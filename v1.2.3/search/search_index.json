{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n\n# Global analog RX block.\nblock = AnalogRX(pi)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 34, '10': 34, '01': 32})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    def _is_feature_param(p: Parameter) -&gt; bool:\n        return not p.trainable and not p.is_number\n\n    if observable is None:\n        self.inputs = list(filter(_is_feature_param, circuit.unique_parameters))\n    else:\n        uparams = unique_parameters(chain(circuit.block, *observable))\n        self.inputs = list(filter(_is_feature_param, uparams))\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/","title":"Advanced Tutorials","text":"<p>In this section, advanced programming concepts and implementations in Qadence are examplified.</p>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-12-22T15:46:04.607723 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence.engines.torch import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"advanced_tutorials/projectors/","title":"Projector blocks","text":"<p>This section introduces the <code>ProjectorBlock</code> as an implementation for the quantum mechanical projection operation onto the subspace spanned by \\(|a\\rangle\\): \\(\\mathbb{\\hat{P}}=|a\\rangle \\langle a|\\). It evaluates the outer product for bras and kets expressed as bitstrings for a given qubit support. They have to possess matching lengths.</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence.operations import Projector  # Projector as an operation.\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# As any block, the matrix representation can be retrieved.\nprojector_matrix = block_to_tensor(projector_block)\n</code></pre> <pre><code>projector matrix = tensor([[[0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\n</code></pre> <p>Other standard operations are expressed as projectors in Qadence. For instance, the number operator is the projector onto the 1-subspace, \\(N=|1\\rangle\\langle 1|\\).</p> <p>In fact, projectors can be used to compose any arbitrary operator. For example, the <code>CNOT</code> can be defined as \\(\\textrm{CNOT}(i,j)=|0\\rangle\\langle 0|_i\\otimes \\mathbb{I}_j+|1\\rangle\\langle 1|_i\\otimes X_j\\) and we can compare its matrix representation with the native one in Qadence:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import kron, I, X, CNOT\n\n# Define a projector for |0&gt; onto the qubit labelled 0.\nprojector0 = Projector(ket=\"0\", bra=\"0\", qubit_support=0)\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector1 = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# Construct the projector controlled CNOT.\nprojector_cnot = kron(projector0, I(1)) + kron(projector1, X(1))\n\n# Get the underlying unitary.\nprojector_cnot_matrix = block_to_tensor(projector_cnot)\n\n# Qadence CNOT unitary.\nqadence_cnot_matrix = block_to_tensor(CNOT(0,1))\n</code></pre> <pre><code>projector cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nqadence cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> <p>Another example is the canonical SWAP unitary that can be defined as \\(SWAP=|00\\rangle\\langle 00|+|01\\rangle\\langle 10|+|10\\rangle\\langle 01|+|11\\rangle\\langle 11|\\). Indeed, it can be shown that their matricial representations are again identical:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import SWAP\n\n# Define all projectors.\nprojector00 = Projector(ket=\"00\", bra=\"00\", qubit_support=(0, 1))\nprojector01 = Projector(ket=\"01\", bra=\"10\", qubit_support=(0, 1))\nprojector10 = Projector(ket=\"10\", bra=\"01\", qubit_support=(0, 1))\nprojector11 = Projector(ket=\"11\", bra=\"11\", qubit_support=(0, 1))\n\n# Construct the SWAP gate.\nprojector_swap = projector00 + projector10 + projector01 + projector11\n\n# Get the underlying unitary.\nprojector_swap_matrix = block_to_tensor(projector_swap)\n\n# Qadence SWAP unitary.\nqadence_swap_matrix = block_to_tensor(SWAP(0,1))\n</code></pre> <pre><code>projector swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]])\nqadence swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]], grad_fn=&lt;UnsafeViewBackward0&gt;)\n</code></pre> <p>Warning</p> <p>Projectors are non-unitary operators, only supported by the PyQTorch backend.</p> <p>To examplify this point, let's run some non-unitary computation involving projectors.</p> <pre><code>from qadence import chain, run\nfrom qadence.operations import H, CNOT\n\n# Define a projector for |1&gt; onto the qubit labelled 1.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=1)\n\n# Some non-unitary computation.\nnon_unitary_block = chain(H(0), CNOT(0,1), projector_block)\n\n# Projected wavefunction becomes unnormalized\nprojected_wf = run(non_unitary_block)  # Run on PyQTorch.\n</code></pre> <pre><code>projected_wf = tensor([[0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>supports_adjoint</code> <p>Does the backend support native adjoint differentation.</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p> <code>native_endianness</code> <p>The native endianness of the backend</p> <p> TYPE: <code>Endianness</code> </p> <code>engine</code> <p>The underlying (native) automatic differentiation engine of the backend.</p> <p> TYPE: <code>Engine</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: ArrayLike | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine TORCH.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.TORCH, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine JAX.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.JAX, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = self.backend.expectation(circuit, observable, param_values, state)\n    else:\n        expectation = DifferentiableExpectation(\n            backend=self.backend,\n            circuit=circuit,\n            observable=observable,\n            param_values=param_values,\n            state=state,\n            measurement=measurement,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        ).psr()\n    return expectation\n</code></pre>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Qadence offers both a PyTorch and Jax differentiation engine.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are applied by implementing a custom <code>torch.autograd.Function</code> class for PyTorch and the <code>custom_vjp</code> in the Jax Engine, respectively.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> under <code>qadence.engines.torch.differentiable_expectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 08f7a8d48917451aa59caf5122487ad8 0 b29bd113f0d94ca38c215f536f164357 X 08f7a8d48917451aa59caf5122487ad8--b29bd113f0d94ca38c215f536f164357 a66f1f26e8b74bbba7c88e959fc2dbe5 1 7eba456eaa8143acbc8c463b086f6c0a b29bd113f0d94ca38c215f536f164357--7eba456eaa8143acbc8c463b086f6c0a 4b2b97fc847f4bbe8f158ecaf5a17349 b7c9108e736c4a1d93adf75d2e12d1ec Y a66f1f26e8b74bbba7c88e959fc2dbe5--b7c9108e736c4a1d93adf75d2e12d1ec b7c9108e736c4a1d93adf75d2e12d1ec--4b2b97fc847f4bbe8f158ecaf5a17349 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 b0fc5cda42c14cb792b987d75f0bf199 0 1c4d33a08ed54d32960091b25ec4315e X b0fc5cda42c14cb792b987d75f0bf199--1c4d33a08ed54d32960091b25ec4315e 8be149d8ec90426fbd754769db22e710 Y 1c4d33a08ed54d32960091b25ec4315e--8be149d8ec90426fbd754769db22e710 3f7cb00bb4f64ed59159bc5bae41dd3f 8be149d8ec90426fbd754769db22e710--3f7cb00bb4f64ed59159bc5bae41dd3f <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 e9d18979d0ee41a9bf671ca38d1de36d 0 5f8c5f7a69e548c4b00f1b01a1e7624b X e9d18979d0ee41a9bf671ca38d1de36d--5f8c5f7a69e548c4b00f1b01a1e7624b 26d3e7ab4779465487c11b8dbd11b4b8 1 91cacf8b2bbe42dd8dd0c975cf381590 5f8c5f7a69e548c4b00f1b01a1e7624b--91cacf8b2bbe42dd8dd0c975cf381590 f76db219879b4972924c1aa8097ae0c8 91cacf8b2bbe42dd8dd0c975cf381590--f76db219879b4972924c1aa8097ae0c8 9bcd1c085d27429aaed052b5907cee12 085d090aa1574168bcd99979f223b9d7 26d3e7ab4779465487c11b8dbd11b4b8--085d090aa1574168bcd99979f223b9d7 3ffadc87f6fe47deb56ac540390f538d Y 085d090aa1574168bcd99979f223b9d7--3ffadc87f6fe47deb56ac540390f538d 3ffadc87f6fe47deb56ac540390f538d--9bcd1c085d27429aaed052b5907cee12 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_98e06b126dd540b79a9fc9ac3af6d6bf e04dc554881444b59911f8b6b17bd5ad 0 c40e669fa0b544bb942081e630666191 e04dc554881444b59911f8b6b17bd5ad--c40e669fa0b544bb942081e630666191 d9052d89939149898f355bb4b0781968 1 48dd7d47a27e43efb4f718df1fec32eb c40e669fa0b544bb942081e630666191--48dd7d47a27e43efb4f718df1fec32eb 0d90a3c86c014c13ac94d594dfde6be7 608a1c88fdee4168ad3a4a1f66dfc600 AddBlock d9052d89939149898f355bb4b0781968--608a1c88fdee4168ad3a4a1f66dfc600 8d81a633cd3e4cb4b5132ee8ad012759 2 608a1c88fdee4168ad3a4a1f66dfc600--0d90a3c86c014c13ac94d594dfde6be7 d8499d78bd6e48768a2d8a187dfcaa5c aa8420da4ecc478c8a6ccd399fe0de5a 8d81a633cd3e4cb4b5132ee8ad012759--aa8420da4ecc478c8a6ccd399fe0de5a aa8420da4ecc478c8a6ccd399fe0de5a--d8499d78bd6e48768a2d8a187dfcaa5c <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_7b90a4cab4d14120848adfe25f592ba7 cluster_7e371b51c19a42f789bb6a28e02c3c21 rx ceda626114114b1ebffca90ad2c7e044 0 eae3bd9c333448a0a8ba00a2fd8c69be X ceda626114114b1ebffca90ad2c7e044--eae3bd9c333448a0a8ba00a2fd8c69be 07aef37d129c4a679ad73c12a6d05056 1 9beecae672d5402495b38a42a6340259 eae3bd9c333448a0a8ba00a2fd8c69be--9beecae672d5402495b38a42a6340259 d91a43c776174022bd3ee19c6aa2cf5d 9beecae672d5402495b38a42a6340259--d91a43c776174022bd3ee19c6aa2cf5d 14ebde9c92e5488197b4abd3068bc2d0 d91a43c776174022bd3ee19c6aa2cf5d--14ebde9c92e5488197b4abd3068bc2d0 7cf5063f9d794d4c8f25708d9f9acfa5 8c96ca5c8d984b26a62cbfea8a2c67df Y 07aef37d129c4a679ad73c12a6d05056--8c96ca5c8d984b26a62cbfea8a2c67df c613d774a64c42179ad100b7fb0f2265 2 19d7f66f990d4242baa9b5c23bc46ec4 8c96ca5c8d984b26a62cbfea8a2c67df--19d7f66f990d4242baa9b5c23bc46ec4 0bf1ded0d90c4c33855c93ad395a7877 HamEvo 19d7f66f990d4242baa9b5c23bc46ec4--0bf1ded0d90c4c33855c93ad395a7877 0bf1ded0d90c4c33855c93ad395a7877--7cf5063f9d794d4c8f25708d9f9acfa5 92d09149151b44759e12f57bd6c7ea25 8fd4fce5820e49c5a6bfb63c1f12bd1a RX(x) c613d774a64c42179ad100b7fb0f2265--8fd4fce5820e49c5a6bfb63c1f12bd1a 77e2918f3f584dd38b62b74365ab7839 3 77e3b8aef82b499c8b946b686d5bd056 8fd4fce5820e49c5a6bfb63c1f12bd1a--77e3b8aef82b499c8b946b686d5bd056 0a32fb99da224bc3969c482c3f571b5d t = 10 77e3b8aef82b499c8b946b686d5bd056--0a32fb99da224bc3969c482c3f571b5d 0a32fb99da224bc3969c482c3f571b5d--92d09149151b44759e12f57bd6c7ea25 ad6060f284064f3e997d4a878be6beff 73e1ea2dd84342e9bc6fb72b3ae93e92 RX(0.5) 77e2918f3f584dd38b62b74365ab7839--73e1ea2dd84342e9bc6fb72b3ae93e92 54a21a8745404eac8cac149b8795d8b9 X 73e1ea2dd84342e9bc6fb72b3ae93e92--54a21a8745404eac8cac149b8795d8b9 54a21a8745404eac8cac149b8795d8b9--77e3b8aef82b499c8b946b686d5bd056 d7c4ec1bbb2b44e78688fe4b18cb4cff 54a21a8745404eac8cac149b8795d8b9--d7c4ec1bbb2b44e78688fe4b18cb4cff d7c4ec1bbb2b44e78688fe4b18cb4cff--ad6060f284064f3e997d4a878be6beff <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_de80dfa209274db1a8225918ca793729 HEA cluster_3e1ade5726e44cb0aaa88cd0a6c55bcb Tower Fourier FM b0af123b0bf94acbbb35b00bd709d9a2 0 a371a7ecd0f4407481dd0bfe65b338c6 RX(1.0*phi) b0af123b0bf94acbbb35b00bd709d9a2--a371a7ecd0f4407481dd0bfe65b338c6 f8bea35d36204fafb42008aa7238d92c 1 bd6ba27e40264a8dbcc1445db7954393 RX(theta\u2080) a371a7ecd0f4407481dd0bfe65b338c6--bd6ba27e40264a8dbcc1445db7954393 0995b94eff6f4f64b142a41a9edd3a8d RY(theta\u2084) bd6ba27e40264a8dbcc1445db7954393--0995b94eff6f4f64b142a41a9edd3a8d a97e3860d3b64295b3bb79078f468c75 RX(theta\u2088) 0995b94eff6f4f64b142a41a9edd3a8d--a97e3860d3b64295b3bb79078f468c75 d6dae32af9754624a1ca7efaa20a9106 a97e3860d3b64295b3bb79078f468c75--d6dae32af9754624a1ca7efaa20a9106 af8c7094fd204721ab9b0c0a9c201abe d6dae32af9754624a1ca7efaa20a9106--af8c7094fd204721ab9b0c0a9c201abe 9b0cf67b26894864a60639a7db6885bb RX(theta\u2081\u2082) af8c7094fd204721ab9b0c0a9c201abe--9b0cf67b26894864a60639a7db6885bb 7439c414ac7a4d74bf60f5ceb12e163c RY(theta\u2081\u2086) 9b0cf67b26894864a60639a7db6885bb--7439c414ac7a4d74bf60f5ceb12e163c 5473de84e8074b91a0bb64d95ef5c0ee RX(theta\u2082\u2080) 7439c414ac7a4d74bf60f5ceb12e163c--5473de84e8074b91a0bb64d95ef5c0ee 2df8460f785648de8ee8b00450128fe8 5473de84e8074b91a0bb64d95ef5c0ee--2df8460f785648de8ee8b00450128fe8 2884bd5b96f249cf82227271310841fd 2df8460f785648de8ee8b00450128fe8--2884bd5b96f249cf82227271310841fd 8e4128ad993448ada08f98b6159fa540 2884bd5b96f249cf82227271310841fd--8e4128ad993448ada08f98b6159fa540 612616864e3f4fe485f9c2353ba2fcb9 c9a1b289d9f04a4f988e8786284515bc RX(2.0*phi) f8bea35d36204fafb42008aa7238d92c--c9a1b289d9f04a4f988e8786284515bc 4bb990f0b9a24f99b87258e8a0bc38c7 2 184fad702b2d414c801fe058d6624c15 RX(theta\u2081) c9a1b289d9f04a4f988e8786284515bc--184fad702b2d414c801fe058d6624c15 0748a6b0733e42f0ada2c3762c2b84bd RY(theta\u2085) 184fad702b2d414c801fe058d6624c15--0748a6b0733e42f0ada2c3762c2b84bd b822b48b536b419abb8ce79cf06bb78e RX(theta\u2089) 0748a6b0733e42f0ada2c3762c2b84bd--b822b48b536b419abb8ce79cf06bb78e fff20490943741549aa55bcfb714577c X b822b48b536b419abb8ce79cf06bb78e--fff20490943741549aa55bcfb714577c fff20490943741549aa55bcfb714577c--d6dae32af9754624a1ca7efaa20a9106 50ff3dcc391041c093739e3aea89508a fff20490943741549aa55bcfb714577c--50ff3dcc391041c093739e3aea89508a fc3d5f7c53ba4481ada795e1caff6581 RX(theta\u2081\u2083) 50ff3dcc391041c093739e3aea89508a--fc3d5f7c53ba4481ada795e1caff6581 012b18367d064bd08a2aea1e06b7da10 RY(theta\u2081\u2087) fc3d5f7c53ba4481ada795e1caff6581--012b18367d064bd08a2aea1e06b7da10 b41459827d854c1cac8734aec940e97f RX(theta\u2082\u2081) 012b18367d064bd08a2aea1e06b7da10--b41459827d854c1cac8734aec940e97f 15972775afde4807b198d5e5aa1b5680 X b41459827d854c1cac8734aec940e97f--15972775afde4807b198d5e5aa1b5680 15972775afde4807b198d5e5aa1b5680--2df8460f785648de8ee8b00450128fe8 0bbb010b10854bf6ac02a43c2c8bf58d 15972775afde4807b198d5e5aa1b5680--0bbb010b10854bf6ac02a43c2c8bf58d 0bbb010b10854bf6ac02a43c2c8bf58d--612616864e3f4fe485f9c2353ba2fcb9 42363e9fb675487a8b09c419a2c4ca46 2868a59ea47c47da93932dd41e158865 RX(3.0*phi) 4bb990f0b9a24f99b87258e8a0bc38c7--2868a59ea47c47da93932dd41e158865 6fb158c12ccb4538aa8c1aaec4f5e1dd 3 3377b346f70a484597beed4835bb6a30 RX(theta\u2082) 2868a59ea47c47da93932dd41e158865--3377b346f70a484597beed4835bb6a30 f90e4940ab604186990f0fccdf761e52 RY(theta\u2086) 3377b346f70a484597beed4835bb6a30--f90e4940ab604186990f0fccdf761e52 6c4affbc01d34356a3c42ccb0b14e0a0 RX(theta\u2081\u2080) f90e4940ab604186990f0fccdf761e52--6c4affbc01d34356a3c42ccb0b14e0a0 2f9a30c2653245d9b35235228f82d872 6c4affbc01d34356a3c42ccb0b14e0a0--2f9a30c2653245d9b35235228f82d872 a4137f84afeb4dfd8933811c3d5f56f5 X 2f9a30c2653245d9b35235228f82d872--a4137f84afeb4dfd8933811c3d5f56f5 a4137f84afeb4dfd8933811c3d5f56f5--50ff3dcc391041c093739e3aea89508a 05369b58c15f4effba5577e8f3511003 RX(theta\u2081\u2084) a4137f84afeb4dfd8933811c3d5f56f5--05369b58c15f4effba5577e8f3511003 842a17def1b047ec8ea83d317baf954e RY(theta\u2081\u2088) 05369b58c15f4effba5577e8f3511003--842a17def1b047ec8ea83d317baf954e 9f6c4a0f90b045cbb7035339a52a360f RX(theta\u2082\u2082) 842a17def1b047ec8ea83d317baf954e--9f6c4a0f90b045cbb7035339a52a360f 245ce4327d714e879dabb4409212d01e 9f6c4a0f90b045cbb7035339a52a360f--245ce4327d714e879dabb4409212d01e f6bf147a9a22478d87b4ff3d2a7f0d4d X 245ce4327d714e879dabb4409212d01e--f6bf147a9a22478d87b4ff3d2a7f0d4d f6bf147a9a22478d87b4ff3d2a7f0d4d--0bbb010b10854bf6ac02a43c2c8bf58d f6bf147a9a22478d87b4ff3d2a7f0d4d--42363e9fb675487a8b09c419a2c4ca46 cb979a9c10b3465d8edd5c30a4ba823d d5394dccbbed428dad1dfb649d4bc9b5 RX(4.0*phi) 6fb158c12ccb4538aa8c1aaec4f5e1dd--d5394dccbbed428dad1dfb649d4bc9b5 3c715c536577458ea48c0b8af5d14320 RX(theta\u2083) d5394dccbbed428dad1dfb649d4bc9b5--3c715c536577458ea48c0b8af5d14320 53058379cd054936a58a06e1613ea13b RY(theta\u2087) 3c715c536577458ea48c0b8af5d14320--53058379cd054936a58a06e1613ea13b 2350ab1cfb0f4aae80a81b1cfaff358e RX(theta\u2081\u2081) 53058379cd054936a58a06e1613ea13b--2350ab1cfb0f4aae80a81b1cfaff358e 4a89a3bfa53f4deab15bf8acbc74f5a4 X 2350ab1cfb0f4aae80a81b1cfaff358e--4a89a3bfa53f4deab15bf8acbc74f5a4 4a89a3bfa53f4deab15bf8acbc74f5a4--2f9a30c2653245d9b35235228f82d872 cf4eeac2553440f4bf04ff8b2f5bd553 4a89a3bfa53f4deab15bf8acbc74f5a4--cf4eeac2553440f4bf04ff8b2f5bd553 7c0927469ec6471fa0523ad643d79cc2 RX(theta\u2081\u2085) cf4eeac2553440f4bf04ff8b2f5bd553--7c0927469ec6471fa0523ad643d79cc2 963d96fa3714438599ff438ada02d7a9 RY(theta\u2081\u2089) 7c0927469ec6471fa0523ad643d79cc2--963d96fa3714438599ff438ada02d7a9 dce2eb798ca24dd99f80162e083a48b8 RX(theta\u2082\u2083) 963d96fa3714438599ff438ada02d7a9--dce2eb798ca24dd99f80162e083a48b8 98076b0bea3d4f49b116db39934c6672 X dce2eb798ca24dd99f80162e083a48b8--98076b0bea3d4f49b116db39934c6672 98076b0bea3d4f49b116db39934c6672--245ce4327d714e879dabb4409212d01e 251638e8d60546489ec34509a53c52cf 98076b0bea3d4f49b116db39934c6672--251638e8d60546489ec34509a53c52cf 251638e8d60546489ec34509a53c52cf--cb979a9c10b3465d8edd5c30a4ba823d <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_df214ee00cae427e98177f00520a5f12 Obs. cluster_3c253d2af27e44d59ac066de590014e5 cluster_043269445e624b45b260e0f18137f313 HEA c6fea4bc810f405496cf508216ead4f9 0 40de705c15f44c09ba4dafb9dc4c1ea8 RX(theta\u2080) c6fea4bc810f405496cf508216ead4f9--40de705c15f44c09ba4dafb9dc4c1ea8 28b25e8bdb774867ae28b1787f592978 1 e86447ebc9ee432fb15bf8a25e605333 RY(theta\u2083) 40de705c15f44c09ba4dafb9dc4c1ea8--e86447ebc9ee432fb15bf8a25e605333 90732327dc7b451a904bbbbb404c9326 RX(theta\u2086) e86447ebc9ee432fb15bf8a25e605333--90732327dc7b451a904bbbbb404c9326 d63d93592b8a48749209a72a9f82b11a 90732327dc7b451a904bbbbb404c9326--d63d93592b8a48749209a72a9f82b11a 83dc09d99c184ab18448336265273d46 d63d93592b8a48749209a72a9f82b11a--83dc09d99c184ab18448336265273d46 86f8b54655a4434aa4874b340c684b26 RX(theta\u2089) 83dc09d99c184ab18448336265273d46--86f8b54655a4434aa4874b340c684b26 e66bd8dbc9264814a2c1d8a47232b2b2 RY(theta\u2081\u2082) 86f8b54655a4434aa4874b340c684b26--e66bd8dbc9264814a2c1d8a47232b2b2 4fa85b54d80b45339c0f0a28b16b5ef9 RX(theta\u2081\u2085) e66bd8dbc9264814a2c1d8a47232b2b2--4fa85b54d80b45339c0f0a28b16b5ef9 469b352b3073419f887dc4dd9d53eb6d 4fa85b54d80b45339c0f0a28b16b5ef9--469b352b3073419f887dc4dd9d53eb6d 66a56929478b49f196917b1f4c6d1c98 469b352b3073419f887dc4dd9d53eb6d--66a56929478b49f196917b1f4c6d1c98 94f2ecd543e740a3874337c5afe9de97 66a56929478b49f196917b1f4c6d1c98--94f2ecd543e740a3874337c5afe9de97 2193f83c1b3946cdb117c1bc594bb40e 94f2ecd543e740a3874337c5afe9de97--2193f83c1b3946cdb117c1bc594bb40e ec447a66910a442284429619fcdef433 38e1231c11c541359e05543660140eef RX(theta\u2081) 28b25e8bdb774867ae28b1787f592978--38e1231c11c541359e05543660140eef 2682f790de9f413ab6f75a6f7c3ec320 2 0dfe201d8011465c9a395415cb21a7d1 RY(theta\u2084) 38e1231c11c541359e05543660140eef--0dfe201d8011465c9a395415cb21a7d1 d30649026be04e6ca289348dcc82b576 RX(theta\u2087) 0dfe201d8011465c9a395415cb21a7d1--d30649026be04e6ca289348dcc82b576 ab25a9116b47404c95227d3f3105353b X d30649026be04e6ca289348dcc82b576--ab25a9116b47404c95227d3f3105353b ab25a9116b47404c95227d3f3105353b--d63d93592b8a48749209a72a9f82b11a ba858f3026c4429da3550594d04b8c4b ab25a9116b47404c95227d3f3105353b--ba858f3026c4429da3550594d04b8c4b 4467cb6cab134c8495849cd5023233bb RX(theta\u2081\u2080) ba858f3026c4429da3550594d04b8c4b--4467cb6cab134c8495849cd5023233bb cbaed39492d04bc5b793c64ac6a2ac81 RY(theta\u2081\u2083) 4467cb6cab134c8495849cd5023233bb--cbaed39492d04bc5b793c64ac6a2ac81 dada4bbd5cdb4dc2902ca27ae0cb4960 RX(theta\u2081\u2086) cbaed39492d04bc5b793c64ac6a2ac81--dada4bbd5cdb4dc2902ca27ae0cb4960 03799b901092412bafd5f9ef9f456e6b X dada4bbd5cdb4dc2902ca27ae0cb4960--03799b901092412bafd5f9ef9f456e6b 03799b901092412bafd5f9ef9f456e6b--469b352b3073419f887dc4dd9d53eb6d 921088fba46948ffb2470a728a00dfaf 03799b901092412bafd5f9ef9f456e6b--921088fba46948ffb2470a728a00dfaf ed200661c87d4e409ea425a92bedb90a AddBlock 921088fba46948ffb2470a728a00dfaf--ed200661c87d4e409ea425a92bedb90a ed200661c87d4e409ea425a92bedb90a--ec447a66910a442284429619fcdef433 219eccb9b0d141b8a56a04a4b7a8b97f 022ea6cf5a804e6b8a97b6cc65642113 RX(theta\u2082) 2682f790de9f413ab6f75a6f7c3ec320--022ea6cf5a804e6b8a97b6cc65642113 12cea888aeea48d6a423845e59d7ca64 RY(theta\u2085) 022ea6cf5a804e6b8a97b6cc65642113--12cea888aeea48d6a423845e59d7ca64 239f4610bf074db8b33283ec281d241d RX(theta\u2088) 12cea888aeea48d6a423845e59d7ca64--239f4610bf074db8b33283ec281d241d d1e10dfe93c646ff84c516a2b4fb6f49 239f4610bf074db8b33283ec281d241d--d1e10dfe93c646ff84c516a2b4fb6f49 303514584ab8492a8ad823458e103b52 X d1e10dfe93c646ff84c516a2b4fb6f49--303514584ab8492a8ad823458e103b52 303514584ab8492a8ad823458e103b52--ba858f3026c4429da3550594d04b8c4b 799e1e793cb84b5dbe3264787e806e2d RX(theta\u2081\u2081) 303514584ab8492a8ad823458e103b52--799e1e793cb84b5dbe3264787e806e2d 7dc49395d5d649228fba6825af776527 RY(theta\u2081\u2084) 799e1e793cb84b5dbe3264787e806e2d--7dc49395d5d649228fba6825af776527 bc54b98ea5ed47c59f1f88f5f7d5bf02 RX(theta\u2081\u2087) 7dc49395d5d649228fba6825af776527--bc54b98ea5ed47c59f1f88f5f7d5bf02 58c7e34a2a404b568e5d17b66f9ae782 bc54b98ea5ed47c59f1f88f5f7d5bf02--58c7e34a2a404b568e5d17b66f9ae782 d95f9ed4c9334d51a49b54992b4c506b X 58c7e34a2a404b568e5d17b66f9ae782--d95f9ed4c9334d51a49b54992b4c506b d95f9ed4c9334d51a49b54992b4c506b--921088fba46948ffb2470a728a00dfaf f76d6875f30241ae89a330ee2adb013f d95f9ed4c9334d51a49b54992b4c506b--f76d6875f30241ae89a330ee2adb013f f76d6875f30241ae89a330ee2adb013f--219eccb9b0d141b8a56a04a4b7a8b97f <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 9e0616a10bf844c28c3a4d4b907e1597 0 4b5d62599dba4bbca90892a274efe387 9e0616a10bf844c28c3a4d4b907e1597--4b5d62599dba4bbca90892a274efe387 76eb331f04f14ae59508ea979696bafc 1 8b11be321350418399c47e92ef2bb227 e78d4409969f4a90acfc5dd8b5ef8742 4b5d62599dba4bbca90892a274efe387--e78d4409969f4a90acfc5dd8b5ef8742 a589059de5a44540a4f8c93e29036ff1 8b11be321350418399c47e92ef2bb227--a589059de5a44540a4f8c93e29036ff1 2fb10f8f6611449d8128a546600f0f51 277a3c36a6984226b4e082b3052cbbe4 a589059de5a44540a4f8c93e29036ff1--277a3c36a6984226b4e082b3052cbbe4 f63781b63101402396d0d17c366e91ab 2fb10f8f6611449d8128a546600f0f51--f63781b63101402396d0d17c366e91ab 8db1d09ebe5340048a71dae243d8ba08 fc93a14eddde4f3c898826ef9f3dc781 76eb331f04f14ae59508ea979696bafc--fc93a14eddde4f3c898826ef9f3dc781 0cafd7dae04b40b9a8b9dee7b593e5c9 2 fc93a14eddde4f3c898826ef9f3dc781--8b11be321350418399c47e92ef2bb227 278f7d61b6274521ad8a2379e029823b e78d4409969f4a90acfc5dd8b5ef8742--278f7d61b6274521ad8a2379e029823b c24dc5eba34d4385abf5ac8a5499b528 278f7d61b6274521ad8a2379e029823b--c24dc5eba34d4385abf5ac8a5499b528 c24dc5eba34d4385abf5ac8a5499b528--8db1d09ebe5340048a71dae243d8ba08 65b049241a204e398a2a77032b753d28 8a74e9a8e2af42988e8f7abca087c7f1 0cafd7dae04b40b9a8b9dee7b593e5c9--8a74e9a8e2af42988e8f7abca087c7f1 52d33b2bf035441a99261fd8d9d2fd97 3 316e3f5dc84043a08669d14858940271 8a74e9a8e2af42988e8f7abca087c7f1--316e3f5dc84043a08669d14858940271 3026b4a21d284abb9970e158b206a7e8 316e3f5dc84043a08669d14858940271--3026b4a21d284abb9970e158b206a7e8 3698d1048f594c42979fb8ba501958a5 3026b4a21d284abb9970e158b206a7e8--3698d1048f594c42979fb8ba501958a5 3698d1048f594c42979fb8ba501958a5--65b049241a204e398a2a77032b753d28 9e0eb6059cc94e2ca0349c58089abb5e f1567da6761041789df7f30a466aea58 52d33b2bf035441a99261fd8d9d2fd97--f1567da6761041789df7f30a466aea58 92d06e52a4de4d2093cd0640c2e7d5ed f1567da6761041789df7f30a466aea58--92d06e52a4de4d2093cd0640c2e7d5ed 323b3fd59d184b27a7c28c39776ef7ae 92d06e52a4de4d2093cd0640c2e7d5ed--323b3fd59d184b27a7c28c39776ef7ae 323b3fd59d184b27a7c28c39776ef7ae--2fb10f8f6611449d8128a546600f0f51 277a3c36a6984226b4e082b3052cbbe4--9e0eb6059cc94e2ca0349c58089abb5e <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 e24de86c3a0944d7af697596b70bb664 0 b75431b6049f45fa9788c8823abcb4db e24de86c3a0944d7af697596b70bb664--b75431b6049f45fa9788c8823abcb4db 53c5f28b7e2b473e82851badfcd0cfec 1 fa2eabeb56724f6f818e0597f23a87cc b75431b6049f45fa9788c8823abcb4db--fa2eabeb56724f6f818e0597f23a87cc 001926dd76bf4271aeaedeb5c3d1133c fa2eabeb56724f6f818e0597f23a87cc--001926dd76bf4271aeaedeb5c3d1133c 291ef5c1dd0f448bad8bce7e2bd69cb7 001926dd76bf4271aeaedeb5c3d1133c--291ef5c1dd0f448bad8bce7e2bd69cb7 27acc55cec8d4a83a8f11d63e0e2cdb6 dc0621c8d8ca4e629499285ea4ad7d8a PHASE(0.5) 53c5f28b7e2b473e82851badfcd0cfec--dc0621c8d8ca4e629499285ea4ad7d8a c905f8d1c62a480bb0581efc0c6c8f2f 2 dc0621c8d8ca4e629499285ea4ad7d8a--b75431b6049f45fa9788c8823abcb4db bd695772b847405ab6607e8883ee77b7 dc0621c8d8ca4e629499285ea4ad7d8a--bd695772b847405ab6607e8883ee77b7 336eaba0b6b340b699f193a58be2ffc3 bd695772b847405ab6607e8883ee77b7--336eaba0b6b340b699f193a58be2ffc3 336eaba0b6b340b699f193a58be2ffc3--27acc55cec8d4a83a8f11d63e0e2cdb6 f186bf82c1944627a27c5005d5c01efc 5cceb655e7a4485bad5f80676cbc962b c905f8d1c62a480bb0581efc0c6c8f2f--5cceb655e7a4485bad5f80676cbc962b 684ceb21074848a9b752aab88f038cf9 3 f61213e467fa4b038d94079b7bbbcbba PHASE(0.5) 5cceb655e7a4485bad5f80676cbc962b--f61213e467fa4b038d94079b7bbbcbba f61213e467fa4b038d94079b7bbbcbba--fa2eabeb56724f6f818e0597f23a87cc a14855f34aad42369a7a69ab3fcf1ed9 f61213e467fa4b038d94079b7bbbcbba--a14855f34aad42369a7a69ab3fcf1ed9 a14855f34aad42369a7a69ab3fcf1ed9--f186bf82c1944627a27c5005d5c01efc 7ca5d8a838e14ed8a4981bb0fd1b83c7 2b59d1f71bcb4fa588fbbc9bcde0ecef 684ceb21074848a9b752aab88f038cf9--2b59d1f71bcb4fa588fbbc9bcde0ecef 47b7f0584ab548c7bce352711b1d0739 2b59d1f71bcb4fa588fbbc9bcde0ecef--47b7f0584ab548c7bce352711b1d0739 25fd06be3dfc47f2b2be8329f4015ec8 PHASE(0.5) 47b7f0584ab548c7bce352711b1d0739--25fd06be3dfc47f2b2be8329f4015ec8 25fd06be3dfc47f2b2be8329f4015ec8--001926dd76bf4271aeaedeb5c3d1133c 25fd06be3dfc47f2b2be8329f4015ec8--7ca5d8a838e14ed8a4981bb0fd1b83c7"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from math import pi\nfrom qadence import AnalogRot\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = pi, # [rad/\u03bcs]\n    delta = pi, # [rad/\u03bcs]\n    phase = pi, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run\nfrom qadence.analog.constants import C6_DICT\nfrom math import pi, cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = pi\ndelta = pi\nphase = pi\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run\nfrom math import pi\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = pi\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>wait</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, wait, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = wait(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction\nfrom math import pi\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * pi * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * pi * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice\nfrom math import pi\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = pi)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all the Analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>wait</code> operation initializes a <code>WaitBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = \"global\"</code>. However, the blocks do support local qubit supports, with some constraints. The main constraint is that using <code>kron</code> on operators with different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, wait\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    wait(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    wait(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    wait(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2023-12-22T15:46:08.356870 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>Warning</p> <p>Tutorial to be updated</p> <p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\nfrom pulser.devices import Chadoq2\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n\n\ndef qubo_register_coords(Q):\n    \"\"\"Compute coordinates for register.\"\"\"\n    bitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\n    costs = []\n    # this takes exponential time with the dimension of the QUBO\n    for b in bitstrings:\n        z = np.array(list(b), dtype=int)\n        cost = z.T @ Q @ z\n        costs.append(cost)\n    zipped = zip(bitstrings, costs)\n    sort_zipped = sorted(zipped, key=lambda x: x[1])\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        new_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    costs = []\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\n\nfrom qadence import chain\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRZ, AnalogRX\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\n    z = np.array(list(bitstring), dtype=int)\n    cost = z.T @ Q @ z\n    return cost\n\n# Cost function.\ndef cost_fn(counter, Q):\n    cost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\n    return cost / sum(counter.values())  # Divide by total samples\n\n\n# Weights.\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in Pulser, and set the device specs with the updated Rydberg level.</p> <pre><code># Register with device specs\ndevice = RydbergDevice(rydberg_level = 70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q),\n    device_specs = device\n)\n\n# Analog circuit\nlayers = 2\n\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\n</code></pre> <pre><code>\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(\n    QuantumCircuit(reg, block),\n    backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 101, '10000': 87, '01000': 75, '00110': 72, '00100': 70, '01010': 64, '01001': 62, '00101': 53, '00010': 51, '00011': 48, '01011': 46, '00001': 45, '10010': 45, '00111': 38, '10001': 34, '11000': 29, '10100': 18, '01100': 14, '01110': 11, '01111': 10, '10110': 7, '11001': 7, '11010': 6, '01101': 4, '10101': 2, '10011': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\n    Q = args[0]\n    param = torch.tensor(param)\n    model.reset_vparams(param)\n    C = model.sample({}, n_shots=1000)[0]\n    return cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\n    res = minimize(\n        loss,\n        args=Q,\n        x0=np.random.uniform(1, 10, size=2 * layers),\n        method=\"COBYLA\",\n        tol=1e-8,\n        options={\"maxiter\": 20},\n    )\n\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 233, '01011': 208, '00000': 104, '01001': 85, '00100': 75, '00110': 71, '01000': 70, '00101': 33, '00010': 27, '00001': 26, '01010': 24, '00011': 15, '10011': 11, '10000': 10, '01100': 3, '10101': 2, '01111': 1, '10100': 1, '10110': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-12-22T15:46:10.262081 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=torch.pi,      # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_a75401db31974620bcfbdb555ac4a8bf cluster_9a9137334b234c9aa6b68b21ceac8864 cluster_e4318ce4994c471bb18dda46e22b30d1 cluster_d3d34691220646acb545a669d5a98939 cluster_e5cffd5dbb1b47f4935e5e0453726183 cluster_243ac2d8e71a492d9c10c7e1e0206a92 cluster_fffa306b2afc4a5ba7fe3fa1af600279 d924c6f92a2d4023b3ce5dfaf9c02a7c 0 f3be571ae71e46ebbfc0994c8306a477 HamEvo d924c6f92a2d4023b3ce5dfaf9c02a7c--f3be571ae71e46ebbfc0994c8306a477 24091013c7934a938880fc256b8fbbb9 1 9994ef93aa234a02abe6a8de842d5b44 HamEvo f3be571ae71e46ebbfc0994c8306a477--9994ef93aa234a02abe6a8de842d5b44 37b9b78582344297873de57384464904 HamEvo 9994ef93aa234a02abe6a8de842d5b44--37b9b78582344297873de57384464904 b5ac4daf2f894102986c968b0a8d709d X 37b9b78582344297873de57384464904--b5ac4daf2f894102986c968b0a8d709d 9edfd1fa4052465690f3a0aabd45fee5 HamEvo b5ac4daf2f894102986c968b0a8d709d--9edfd1fa4052465690f3a0aabd45fee5 3241668fb0f4401092cd228371a87670 HamEvo 9edfd1fa4052465690f3a0aabd45fee5--3241668fb0f4401092cd228371a87670 e5d95fac4d274edf8c6f4a1ea2109b25 X 3241668fb0f4401092cd228371a87670--e5d95fac4d274edf8c6f4a1ea2109b25 37a95baf38564d9b9f8659b2ac616128 e5d95fac4d274edf8c6f4a1ea2109b25--37a95baf38564d9b9f8659b2ac616128 70906854e88a4eddbbc7b09887420a68 HamEvo 37a95baf38564d9b9f8659b2ac616128--70906854e88a4eddbbc7b09887420a68 f7eba2f499104852bbfc42652e04fdad HamEvo 70906854e88a4eddbbc7b09887420a68--f7eba2f499104852bbfc42652e04fdad 489c96b0a42b449e8373c31b8579e217 f7eba2f499104852bbfc42652e04fdad--489c96b0a42b449e8373c31b8579e217 ee05741839e74185b95a0fe0a66cc82f 489c96b0a42b449e8373c31b8579e217--ee05741839e74185b95a0fe0a66cc82f b019c398a589496ab521abce6ad8cb8d a3f4e91f333f48da810cbaf87cd035fa t = -3.142 24091013c7934a938880fc256b8fbbb9--a3f4e91f333f48da810cbaf87cd035fa 3cb327dd9ea547e4a800a9d67fc8a1fa 2 eea0b44634814ce9b72b12847473a431 t = 3.142 a3f4e91f333f48da810cbaf87cd035fa--eea0b44634814ce9b72b12847473a431 88140b8f7ec34c3d827c4dd510d0482b t = -3.142 eea0b44634814ce9b72b12847473a431--88140b8f7ec34c3d827c4dd510d0482b 697711fb10444db493330cbbdc07b81e 88140b8f7ec34c3d827c4dd510d0482b--697711fb10444db493330cbbdc07b81e 0388281dfb1d42aa9a91467dd374b1c5 t = 1.571 697711fb10444db493330cbbdc07b81e--0388281dfb1d42aa9a91467dd374b1c5 d6380ecf61f04f6b920e946a2bdbbef1 t = 1.571 0388281dfb1d42aa9a91467dd374b1c5--d6380ecf61f04f6b920e946a2bdbbef1 50958be4471948029d79b696c7ff911c d6380ecf61f04f6b920e946a2bdbbef1--50958be4471948029d79b696c7ff911c 6e6673fa84364d81b8ef77f025c24029 X 50958be4471948029d79b696c7ff911c--6e6673fa84364d81b8ef77f025c24029 88f45dd544e74fd5ab180ad94f503e27 t = 1.571 6e6673fa84364d81b8ef77f025c24029--88f45dd544e74fd5ab180ad94f503e27 c599f12a9efe4bca8d0d6065982443ab t = 1.571 88f45dd544e74fd5ab180ad94f503e27--c599f12a9efe4bca8d0d6065982443ab b34f636897d3466992973eb2556aaee3 X c599f12a9efe4bca8d0d6065982443ab--b34f636897d3466992973eb2556aaee3 b34f636897d3466992973eb2556aaee3--b019c398a589496ab521abce6ad8cb8d 0f6a81c05fc84092994577e992c5378b 6b662854b6bc4ee0b3e89853b32f53af 3cb327dd9ea547e4a800a9d67fc8a1fa--6b662854b6bc4ee0b3e89853b32f53af a898394b46a741b788e3bb72a3d0f00f 6b662854b6bc4ee0b3e89853b32f53af--a898394b46a741b788e3bb72a3d0f00f bb7a6bf407fa4489acdd4cc3dd2529ed a898394b46a741b788e3bb72a3d0f00f--bb7a6bf407fa4489acdd4cc3dd2529ed 1cbc805b8a9d46e19f8dc90b33bc39ce X bb7a6bf407fa4489acdd4cc3dd2529ed--1cbc805b8a9d46e19f8dc90b33bc39ce 2fcc4d83701f47468cc2876a682adae5 1cbc805b8a9d46e19f8dc90b33bc39ce--2fcc4d83701f47468cc2876a682adae5 a3b34fe09acf4b6094be749cbb4a1bef 2fcc4d83701f47468cc2876a682adae5--a3b34fe09acf4b6094be749cbb4a1bef d4c2c1a8d72043f7a56f57e6f699ca24 X a3b34fe09acf4b6094be749cbb4a1bef--d4c2c1a8d72043f7a56f57e6f699ca24 808e8e1700d44478890e234d2ef2e3ed X d4c2c1a8d72043f7a56f57e6f699ca24--808e8e1700d44478890e234d2ef2e3ed fcc91dc15d554edf9df1528460dd1cb7 808e8e1700d44478890e234d2ef2e3ed--fcc91dc15d554edf9df1528460dd1cb7 f7369e8c641a460088cb596d15a3cf31 fcc91dc15d554edf9df1528460dd1cb7--f7369e8c641a460088cb596d15a3cf31 316b1a88d7da45cf8a476818c76f8026 X f7369e8c641a460088cb596d15a3cf31--316b1a88d7da45cf8a476818c76f8026 316b1a88d7da45cf8a476818c76f8026--0f6a81c05fc84092994577e992c5378b <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_bd2bcca0448d493bb977ce02b9fb4842 cluster_4f755638f30347eb9532972edbbabdfc 8c881aefdc984baea1ea31d6d3976e07 0 1f7c22962d8c4687ac09a04352957f0a X 8c881aefdc984baea1ea31d6d3976e07--1f7c22962d8c4687ac09a04352957f0a b4ae9549659e42bfa5b51a1e2c4c95f8 1 a4689b12adcc4f9ab9ef69f253473743 HamEvo 1f7c22962d8c4687ac09a04352957f0a--a4689b12adcc4f9ab9ef69f253473743 34830cd5786543b9a9bcb6be6b129511 X a4689b12adcc4f9ab9ef69f253473743--34830cd5786543b9a9bcb6be6b129511 ac9691fc6975454d917791ed281a09b3 34830cd5786543b9a9bcb6be6b129511--ac9691fc6975454d917791ed281a09b3 ae9ea1a404a640538f48db8172a41f19 HamEvo ac9691fc6975454d917791ed281a09b3--ae9ea1a404a640538f48db8172a41f19 af82f062779e4fc7a66aeafc6d7c4756 ae9ea1a404a640538f48db8172a41f19--af82f062779e4fc7a66aeafc6d7c4756 e6907ef01f6e410aa9134eb4490a38d3 af82f062779e4fc7a66aeafc6d7c4756--e6907ef01f6e410aa9134eb4490a38d3 0f5a02b7fd8a41cfb0ab142da6ca632e eada3e9bc7734265a701929e585ccdde b4ae9549659e42bfa5b51a1e2c4c95f8--eada3e9bc7734265a701929e585ccdde 01506b4db71d4d28814fc22ec6dc332b 2 77e0ca51dbf347598cba00045c9015e8 t = -0.500 eada3e9bc7734265a701929e585ccdde--77e0ca51dbf347598cba00045c9015e8 872c7aed69e74ec8941f0d0bf0c3dd9a 77e0ca51dbf347598cba00045c9015e8--872c7aed69e74ec8941f0d0bf0c3dd9a 5299c9d78f3548e295e7d9c532e75b5a X 872c7aed69e74ec8941f0d0bf0c3dd9a--5299c9d78f3548e295e7d9c532e75b5a 20cc01b21aa94bb1980f0dd21f57ec28 t = -0.500 5299c9d78f3548e295e7d9c532e75b5a--20cc01b21aa94bb1980f0dd21f57ec28 45fb5981c8c24f1f98ebc34e407fe00a X 20cc01b21aa94bb1980f0dd21f57ec28--45fb5981c8c24f1f98ebc34e407fe00a 45fb5981c8c24f1f98ebc34e407fe00a--0f5a02b7fd8a41cfb0ab142da6ca632e 3d54a2a31e524dffa01fdc37ae18a9e8 139fb60127394289bcb6e4e9fec2f64a X 01506b4db71d4d28814fc22ec6dc332b--139fb60127394289bcb6e4e9fec2f64a c1bda9a4716f4780b79504c1fa364ebb 139fb60127394289bcb6e4e9fec2f64a--c1bda9a4716f4780b79504c1fa364ebb 35fb1109dbdc4762a7beb8d6b18d7422 X c1bda9a4716f4780b79504c1fa364ebb--35fb1109dbdc4762a7beb8d6b18d7422 5b09166935da4da69e398a931044d988 X 35fb1109dbdc4762a7beb8d6b18d7422--5b09166935da4da69e398a931044d988 160c7f86df8e4515963298ef8b726902 5b09166935da4da69e398a931044d988--160c7f86df8e4515963298ef8b726902 c476b488e58043fab11343ebe0c0371f X 160c7f86df8e4515963298ef8b726902--c476b488e58043fab11343ebe0c0371f c476b488e58043fab11343ebe0c0371f--3d54a2a31e524dffa01fdc37ae18a9e8 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_14cff56cad574c10879e626353506441 cluster_e316de09bf05423f98e632301fcf8e01 05b6805da48442699aa148ae81a5ddb0 0 eef0b17598384779ab71a3f193f6787f X 05b6805da48442699aa148ae81a5ddb0--eef0b17598384779ab71a3f193f6787f e17a5d2c4a70463d9a9798d0ca9cb0d7 1 21a7f6fd284b4680b13cd126590c4e45 HamEvo eef0b17598384779ab71a3f193f6787f--21a7f6fd284b4680b13cd126590c4e45 ef5b17d5101a4d7cb7e59776f9b6f94e X 21a7f6fd284b4680b13cd126590c4e45--ef5b17d5101a4d7cb7e59776f9b6f94e 4ef1696b50d84382a6d90090aab4d483 ef5b17d5101a4d7cb7e59776f9b6f94e--4ef1696b50d84382a6d90090aab4d483 57a1f0fc33534fe0b880a129a92d7484 HamEvo 4ef1696b50d84382a6d90090aab4d483--57a1f0fc33534fe0b880a129a92d7484 e85f48aa42f94ef9afc7b35ac228447a 57a1f0fc33534fe0b880a129a92d7484--e85f48aa42f94ef9afc7b35ac228447a 2aa1b1647fc34d8f84e7048c5b5909de e85f48aa42f94ef9afc7b35ac228447a--2aa1b1647fc34d8f84e7048c5b5909de 2a3baf89ce92446180f93e50fe2b0326 03568d45a3ec4a5b9c605a03d91e2479 e17a5d2c4a70463d9a9798d0ca9cb0d7--03568d45a3ec4a5b9c605a03d91e2479 cc7e3aa63445471f91c0e03f9a5c6f28 2 4481d25d3ffc49faa0d14603d7cef3c6 t = -500.000000000000 03568d45a3ec4a5b9c605a03d91e2479--4481d25d3ffc49faa0d14603d7cef3c6 dedba35791fe4392882bcbdfbc3b70f9 4481d25d3ffc49faa0d14603d7cef3c6--dedba35791fe4392882bcbdfbc3b70f9 11912f4d65d045d29320bc5a5b53f1aa X dedba35791fe4392882bcbdfbc3b70f9--11912f4d65d045d29320bc5a5b53f1aa cb9cda844fb146faaabca9eddd9165c1 t = -500.000000000000 11912f4d65d045d29320bc5a5b53f1aa--cb9cda844fb146faaabca9eddd9165c1 01f679ce727b48f5a2f5cad11802e083 X cb9cda844fb146faaabca9eddd9165c1--01f679ce727b48f5a2f5cad11802e083 01f679ce727b48f5a2f5cad11802e083--2a3baf89ce92446180f93e50fe2b0326 9672a0c5801d4809a7ec8f08dabd7b29 e40efc3a7d484573910ea1f86c9180d5 X cc7e3aa63445471f91c0e03f9a5c6f28--e40efc3a7d484573910ea1f86c9180d5 dcbd1cb5b98548f583b2548f486faad2 e40efc3a7d484573910ea1f86c9180d5--dcbd1cb5b98548f583b2548f486faad2 f3c9f79d6e88470f9c75940d59c8ea2a X dcbd1cb5b98548f583b2548f486faad2--f3c9f79d6e88470f9c75940d59c8ea2a 36c223e3d2df450ab7837d83824a57cf X f3c9f79d6e88470f9c75940d59c8ea2a--36c223e3d2df450ab7837d83824a57cf d69bc1460dca4094850ff84ebc363ea7 36c223e3d2df450ab7837d83824a57cf--d69bc1460dca4094850ff84ebc363ea7 9aa7c35660d44b418271691c00c651fa X d69bc1460dca4094850ff84ebc363ea7--9aa7c35660d44b418271691c00c651fa 9aa7c35660d44b418271691c00c651fa--9672a0c5801d4809a7ec8f08dabd7b29 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.847190727211437, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*torch.pi/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 27, '11': 23})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-12-22T15:46:10.756348 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-12-22T15:46:10.886038 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*torch.pi/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 23})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-torch.pi / 2),\n        wait(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([torch.pi / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-12-22T15:46:11.322090 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(torch.pi/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-12-22T15:46:11.714022 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.2723])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.2742])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(torch.pi)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.1391]) The trained function value:  tensor([[0.1391]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\n\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.3978-0.0938j, -0.7308-0.5009j, -0.1796-0.0595j,  0.0092+0.1104j],\n         [ 0.6745-0.4435j,  0.3860+0.1615j, -0.2943-0.2427j, -0.1161-0.1194j],\n         [ 0.0071-0.3775j, -0.0791-0.1563j,  0.7486-0.2045j,  0.0188-0.4734j],\n         [-0.1418-0.1366j,  0.0787-0.0558j, -0.0827-0.4578j,  0.8310+0.2120j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * pi),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None, param_prefix=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | Callable | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data provided comes from. Used to map input data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi). Used to map data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <code>param_prefix</code> <p>string prefix to create trainable parameters multiplying the feature parameter inside the feature-encoding function. Note that currently this does not take into account the domain of the feature-encoding function.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | Callable | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n    param_prefix: str | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data provided comes from. Used to map input data\n            to the correct domain of the feature-encoding function.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).\n            Used to map data to the correct domain of the feature-encoding function.\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n        param_prefix: string prefix to create trainable parameters multiplying the feature parameter\n            inside the feature-encoding function. Note that currently this does not take into\n            account the domain of the feature-encoding function.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    # Backwards compatibility\n    fm_type, reupload_scaling = backwards_compatibility(fm_type, reupload_scaling)\n\n    scaled_fparam = fm_parameter_scaling(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    transform_func = fm_parameter_func(fm_type)\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    fparam = scaled_fparam\n    for i, qubit in enumerate(support):\n        if param_prefix is not None:\n            train_param = VariationalParameter(param_prefix + f\"_{i}\")\n            fparam = train_param * scaled_fparam\n        op_list.append(op(qubit, multiplier * rs_func(i) * transform_func(fparam)))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        int_fn = INTERACTION_DICT.get(interaction, None)\n        if int_fn is None:\n            raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fa571e46a70&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fa571e465f0&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, None)\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    data = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.8553, 0.4821]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.0584, 0.0124, 0.3985, 0.7267, 0.4795]), tensor([0.2762, 0.3432, 0.2289, 0.4323, 0.2156]), tensor([0.1925, 0.1755, 0.1534, 0.1746, 0.5921])]\n[tensor([0.8860, 0.1588, 0.1412, 0.8215, 0.9256]), tensor([0.6628, 0.0107, 0.0522, 0.5735, 0.7052]), tensor([0.0385, 0.0183, 0.7463, 0.0388, 0.6066])]\n[tensor([0.0584, 0.0124, 0.3985, 0.7267, 0.4795]), tensor([0.2762, 0.3432, 0.2289, 0.4323, 0.2156]), tensor([0.1925, 0.1755, 0.1534, 0.1746, 0.5921])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.0448-1.9079e-17j, -0.3027+5.5272e-18j],\n        [ 1.0892-2.7965e-17j, -0.4317+1.1084e-17j]])\ntensor([[1.5334-1.1262j, 0.9423-0.6638j],\n        [1.2765-0.4016j, 0.4069-0.1863j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-np.pi / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = np.pi\n    omega = 0\n    duration = alpha / delta * 1000\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=0.0, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n\n    if omega == 0 and delta == 0:\n        raise ValueError(\"Parameters omega and delta cannot both be 0.\")\n\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    alpha = duration * h_norm / 1000\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; WaitBlock:\n    \"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n\n    Returns:\n        a `WaitBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return WaitBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['9f3fcf97-5da1-4dee-ab8d-6d438ce52269', '93cb19b4-f855-4f70-8d0c-abb82a56ecb9'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.7262773469971591\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.450972795899503\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = make_differentiable(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False, engine=Engine.TORCH)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level.</p> <p>parameters or gate-level parameters. The constructed embedding function has the signature:</p> <pre><code> embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False, engine: Engine = Engine.TORCH\n) -&gt; tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType],]:\n    \"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*.\n\n    parameters or *gate-level* parameters. The constructed embedding function has the signature:\n\n         embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n    concretize_parameter = _concretize_parameter(engine)\n    if engine == Engine.TORCH:\n        cast_dtype = tensor\n    else:\n        from jax.numpy import array\n\n        cast_dtype = array\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, DifferentiableExpression] = {\n        expr: make_differentiable(expr=expr, engine=engine)\n        for expr in unique_expressions\n        if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n        embedded_params: dict[sympy.Expr, ArrayLike] = {}\n        for expr, fn in embeddings.items():\n            angle: ArrayLike\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: ParamDictType = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: ParamDictType\n    params = {\n        p.name: concretize_parameter(value=p.value, trainable=True) for p in trainable_symbols\n    }\n    params.update(\n        {\n            stringify(expr): concretize_parameter(value=evaluate(expr), trainable=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): cast_dtype(nparray(expr.tolist(), dtype=npcdouble))\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('d303b08e-2cf7-4591-81be-22d8daa8c04a', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.3978401946895035'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('2b6c15a2-679a-4b82-9457-01a3f83643ef', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.5107891929577533'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('48c36838-5e22-4cf5-95fc-9d57d1130df2', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.16650538174477025'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('44c19803-b108-4792-b131-a196b35827a6', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.42675966503419094'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('3ede5454-0dc7-4b80-890d-84f390ff6afd', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6686059935634905'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('7092425e-c853-4430-bff3-d2ca0c2262fa', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.2969019264041437'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('579f83b7-4d05-4808-9ee3-71b90a1bbd5b', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.657268166920075'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5272e9a9-12cf-49dc-8273-6c62576408d5', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.9040698059531549'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('97e29c6c-7372-488b-9832-fbb953675378', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.11147726187362894'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('4e18fe0d-55d5-4e03-9904-a60323363031', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.3319225908813115'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('b0f302f2-054f-45b0-b91e-26faa5a2770e', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.732528137502527'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('8b87adaf-4798-45ae-aca7-7caf856e370c', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.6009734758603325'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>01111110\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.0972+0.0300j,  0.7390-0.0408j,  0.2991-0.5066j, -0.2463-0.1876j]])\ntensor([[ 0.9853+0.0000j,  0.0000-0.1688j, -0.0271+0.0000j,  0.0000+0.0046j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 91, '0010': 3, '0001': 2, '0100': 2, '1000': 2})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[0.1102],\n        [0.0714],\n        [0.1501],\n        [0.0039],\n        [0.0344],\n        [0.1196],\n        [0.0958],\n        [0.1658],\n        [0.0453],\n        [0.1395]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 2.8360, -0.3155, -0.3298, -0.1653, -0.2689, -0.3334, -0.3288, -0.3244,\n        -0.2874, -0.3322], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 2.8360, -0.3155, -0.3298, -0.1653, -0.2689, -0.3334, -0.3288, -0.3244,\n        -0.2874, -0.3322], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4482],\n        [0.2437],\n        [0.1200],\n        [0.5725],\n        [0.5203]]), tensor([[0.4334],\n        [0.2413],\n        [0.1197],\n        [0.5417],\n        [0.4971]])], 'y2': [tensor([[0.0801],\n        [0.4220],\n        [0.5646],\n        [0.1147],\n        [0.5553]]), tensor([[0.0800],\n        [0.4096],\n        [0.5351],\n        [0.1144],\n        [0.5272]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2023-12-22T15:46:33.589354 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2023-12-22T15:46:34.164109 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_13957673001d485f94e2981d870995d8 mixing cluster_01a42cb549ff47afbb9d396e0886537e cost cluster_6751b1d3c29046e3855675b9813cf5f4 mixing cluster_3ffde0814a644223b50a22682cd41ba4 cost caa2a7549e8c45a2af33c7ee0d3637a9 0 667f0c4e32814c1982ef0501af5c672c caa2a7549e8c45a2af33c7ee0d3637a9--667f0c4e32814c1982ef0501af5c672c 5b70461cff0c4a4fba5ec98106323e52 1 8a5eb84a68264e0ea27b4d043764c1c0 667f0c4e32814c1982ef0501af5c672c--8a5eb84a68264e0ea27b4d043764c1c0 e91071bc18a04116bb63518de5bcf016 8a5eb84a68264e0ea27b4d043764c1c0--e91071bc18a04116bb63518de5bcf016 75ec9ac4481e4b94a4b2bb3348eb024d e91071bc18a04116bb63518de5bcf016--75ec9ac4481e4b94a4b2bb3348eb024d c8391914980044c6aaa1b0a527a842f1 75ec9ac4481e4b94a4b2bb3348eb024d--c8391914980044c6aaa1b0a527a842f1 43a43eca65af451f856c2945d7fbf9ac c8391914980044c6aaa1b0a527a842f1--43a43eca65af451f856c2945d7fbf9ac 76432c0e9336478e9591e56b2a3b2eff 43a43eca65af451f856c2945d7fbf9ac--76432c0e9336478e9591e56b2a3b2eff 069224b5b6cb40beaefbf643e3e6da0f 76432c0e9336478e9591e56b2a3b2eff--069224b5b6cb40beaefbf643e3e6da0f df1e433081124643b93c80f364eee44b 069224b5b6cb40beaefbf643e3e6da0f--df1e433081124643b93c80f364eee44b 2c501846b864490ba5af25e6c328ae9b df1e433081124643b93c80f364eee44b--2c501846b864490ba5af25e6c328ae9b 5b208bdb27a84a628857f0de1cd49f41 2c501846b864490ba5af25e6c328ae9b--5b208bdb27a84a628857f0de1cd49f41 2b23fa30085445ba9e36035d5d36105e 5b208bdb27a84a628857f0de1cd49f41--2b23fa30085445ba9e36035d5d36105e c53f4798f9a140c7a8fe9a71fe2d4150 2b23fa30085445ba9e36035d5d36105e--c53f4798f9a140c7a8fe9a71fe2d4150 f2c508207e784930ad067bf80b8a1bdc c53f4798f9a140c7a8fe9a71fe2d4150--f2c508207e784930ad067bf80b8a1bdc 8e02b075176743c6a917f242357d5cbb f2c508207e784930ad067bf80b8a1bdc--8e02b075176743c6a917f242357d5cbb 7d4a6adfc0804151b32d7c8dfec4c2b2 8e02b075176743c6a917f242357d5cbb--7d4a6adfc0804151b32d7c8dfec4c2b2 2b9c9aeafac142bc9ac4a3db3044ccd3 7d4a6adfc0804151b32d7c8dfec4c2b2--2b9c9aeafac142bc9ac4a3db3044ccd3 de423814d81c4df79858a81da3089f31 2b9c9aeafac142bc9ac4a3db3044ccd3--de423814d81c4df79858a81da3089f31 0a6d1e52c5b0415da53646930fb9a406 de423814d81c4df79858a81da3089f31--0a6d1e52c5b0415da53646930fb9a406 36dbfeecfdd94f48b659d5c2194a84da 0a6d1e52c5b0415da53646930fb9a406--36dbfeecfdd94f48b659d5c2194a84da 9b45af75de584ec6a3884cac018e72c2 36dbfeecfdd94f48b659d5c2194a84da--9b45af75de584ec6a3884cac018e72c2 630dfddd48d14efb8fe8aabd6066485a 9b45af75de584ec6a3884cac018e72c2--630dfddd48d14efb8fe8aabd6066485a 3fe72af7fe124b359371c0d7b8b30c49 630dfddd48d14efb8fe8aabd6066485a--3fe72af7fe124b359371c0d7b8b30c49 743c47823ccc4dd98a995e3dd38e97de 3fe72af7fe124b359371c0d7b8b30c49--743c47823ccc4dd98a995e3dd38e97de 3eeb9c860f2d44e89b9d8eb19ab24280 743c47823ccc4dd98a995e3dd38e97de--3eeb9c860f2d44e89b9d8eb19ab24280 dcfc3285c9ab4f19a2b4db5d47c4778d 3eeb9c860f2d44e89b9d8eb19ab24280--dcfc3285c9ab4f19a2b4db5d47c4778d f87aa591adfc4d2da85655f010707873 dcfc3285c9ab4f19a2b4db5d47c4778d--f87aa591adfc4d2da85655f010707873 c51dcb45d5c142228c1c236593b5a214 f87aa591adfc4d2da85655f010707873--c51dcb45d5c142228c1c236593b5a214 39b9ab9c95ba44d5bf41717dfeca19c7 c51dcb45d5c142228c1c236593b5a214--39b9ab9c95ba44d5bf41717dfeca19c7 68e2407176c347aab7d14c6a7f343e8c 39b9ab9c95ba44d5bf41717dfeca19c7--68e2407176c347aab7d14c6a7f343e8c 2199e70288074961ada5459abfa238a0 68e2407176c347aab7d14c6a7f343e8c--2199e70288074961ada5459abfa238a0 ed7243ddd9564489937da9a5e0b0dd7f 2199e70288074961ada5459abfa238a0--ed7243ddd9564489937da9a5e0b0dd7f fb9f56df262242ea98c2133c5700b1f2 ed7243ddd9564489937da9a5e0b0dd7f--fb9f56df262242ea98c2133c5700b1f2 3c124828c39741aa9acf139783ebd883 fb9f56df262242ea98c2133c5700b1f2--3c124828c39741aa9acf139783ebd883 0a345d0c8b064eedb901cb5d8ed62272 3c124828c39741aa9acf139783ebd883--0a345d0c8b064eedb901cb5d8ed62272 9f0989b220cf40459e7bcbdfabe6bef8 0a345d0c8b064eedb901cb5d8ed62272--9f0989b220cf40459e7bcbdfabe6bef8 1aa6857fdf9843d1a2eca0f9925d0c62 9f0989b220cf40459e7bcbdfabe6bef8--1aa6857fdf9843d1a2eca0f9925d0c62 5b69743b5f7d47878b4726ef7563d415 1aa6857fdf9843d1a2eca0f9925d0c62--5b69743b5f7d47878b4726ef7563d415 baefe4e21aaf497caf1e218634c35a18 5b69743b5f7d47878b4726ef7563d415--baefe4e21aaf497caf1e218634c35a18 b46000d362ba4acd86a1faa6021e2803 baefe4e21aaf497caf1e218634c35a18--b46000d362ba4acd86a1faa6021e2803 5c662bc0b2dc4497a1f58fa16cfedbfc b46000d362ba4acd86a1faa6021e2803--5c662bc0b2dc4497a1f58fa16cfedbfc 5c10a0abd48a4d54a51c76e272a08a4f 5c662bc0b2dc4497a1f58fa16cfedbfc--5c10a0abd48a4d54a51c76e272a08a4f cf2bd0a6d18d4077a678e3897e0498fa 5c10a0abd48a4d54a51c76e272a08a4f--cf2bd0a6d18d4077a678e3897e0498fa d736abe7f8474b1d96e70e2cd8b3632b cf2bd0a6d18d4077a678e3897e0498fa--d736abe7f8474b1d96e70e2cd8b3632b 6512e671d29447cc95daaf3fb5e7521b d736abe7f8474b1d96e70e2cd8b3632b--6512e671d29447cc95daaf3fb5e7521b 6836cdb6f4264cac8d69ee3d560e57c9 6512e671d29447cc95daaf3fb5e7521b--6836cdb6f4264cac8d69ee3d560e57c9 7723796160b74d0b8fc4177e1216e370 6836cdb6f4264cac8d69ee3d560e57c9--7723796160b74d0b8fc4177e1216e370 ab0fee4e14d34d9ba5a07e1431c1d9a2 7723796160b74d0b8fc4177e1216e370--ab0fee4e14d34d9ba5a07e1431c1d9a2 2b9aa0296fbc4dc494f08306dfd83a1b ab0fee4e14d34d9ba5a07e1431c1d9a2--2b9aa0296fbc4dc494f08306dfd83a1b 3e4236c70ea94822a909f817fe5e084f 2b9aa0296fbc4dc494f08306dfd83a1b--3e4236c70ea94822a909f817fe5e084f 6451a31de7894869a756a6d6bc732658 3e4236c70ea94822a909f817fe5e084f--6451a31de7894869a756a6d6bc732658 5d4bed9b75404a3a97b4995f505cac04 6451a31de7894869a756a6d6bc732658--5d4bed9b75404a3a97b4995f505cac04 eb6af965a48f492d80b69dd39ed390df 5d4bed9b75404a3a97b4995f505cac04--eb6af965a48f492d80b69dd39ed390df d8ee391b0a1b41909b6e06d9b9a6229a eb6af965a48f492d80b69dd39ed390df--d8ee391b0a1b41909b6e06d9b9a6229a d7b2008e06b440deb18d4eb2680f05b2 d8ee391b0a1b41909b6e06d9b9a6229a--d7b2008e06b440deb18d4eb2680f05b2 39ec8f202a144dafb8d43ebd6df7ab2e d7b2008e06b440deb18d4eb2680f05b2--39ec8f202a144dafb8d43ebd6df7ab2e 83fb1f37beca4f7c82e36b2ee6e1009d 39ec8f202a144dafb8d43ebd6df7ab2e--83fb1f37beca4f7c82e36b2ee6e1009d 6fb773ed06394ef2a2e13d6964debf0f 83fb1f37beca4f7c82e36b2ee6e1009d--6fb773ed06394ef2a2e13d6964debf0f d353a092a0af438b8091684565b018a1 6fb773ed06394ef2a2e13d6964debf0f--d353a092a0af438b8091684565b018a1 97b90c10c9654aaca3d60af2f0174094 d353a092a0af438b8091684565b018a1--97b90c10c9654aaca3d60af2f0174094 6f2823f86d2248afb7ab566ef846b36d 97b90c10c9654aaca3d60af2f0174094--6f2823f86d2248afb7ab566ef846b36d ccbdd11da5c943f7b559efcf774fd639 6f2823f86d2248afb7ab566ef846b36d--ccbdd11da5c943f7b559efcf774fd639 74366a193983411683794dd25bb1b70d ccbdd11da5c943f7b559efcf774fd639--74366a193983411683794dd25bb1b70d 8f71de0b14594af685bb76886ad4ca0b 74366a193983411683794dd25bb1b70d--8f71de0b14594af685bb76886ad4ca0b b40eb319336649e1a68dbfbac7083bfc 8f71de0b14594af685bb76886ad4ca0b--b40eb319336649e1a68dbfbac7083bfc 0a489165e07c406cb214270a5d81bdfe b40eb319336649e1a68dbfbac7083bfc--0a489165e07c406cb214270a5d81bdfe 9d7c01869ab24dfba968ecff9dea887f 0a489165e07c406cb214270a5d81bdfe--9d7c01869ab24dfba968ecff9dea887f 9b033353881c44bf9aca31b623bc603b 9d7c01869ab24dfba968ecff9dea887f--9b033353881c44bf9aca31b623bc603b 8effde8d86e0418a85b4b1bd0170cfde 9b033353881c44bf9aca31b623bc603b--8effde8d86e0418a85b4b1bd0170cfde 71c91a284c9e4437a5fab78eed28595d 8effde8d86e0418a85b4b1bd0170cfde--71c91a284c9e4437a5fab78eed28595d c233405e82d34e1f8a6b45b6f26b47c6 71c91a284c9e4437a5fab78eed28595d--c233405e82d34e1f8a6b45b6f26b47c6 04c38b118b9e4328b11325d6575fdd23 c233405e82d34e1f8a6b45b6f26b47c6--04c38b118b9e4328b11325d6575fdd23 ce9f515d1bfd42b6a391d344073d284d 04c38b118b9e4328b11325d6575fdd23--ce9f515d1bfd42b6a391d344073d284d 1bd9273ec6404d36b5547e9569515c1b ce9f515d1bfd42b6a391d344073d284d--1bd9273ec6404d36b5547e9569515c1b e5caaddf06bc4113adf98e570dc6f620 1bd9273ec6404d36b5547e9569515c1b--e5caaddf06bc4113adf98e570dc6f620 a310e1d8bc44452a858fc170fc1376a2 e5caaddf06bc4113adf98e570dc6f620--a310e1d8bc44452a858fc170fc1376a2 09d50c58705a4703839383420a04214a a310e1d8bc44452a858fc170fc1376a2--09d50c58705a4703839383420a04214a 38edc613cff740e8aa011db9c3ece055 09d50c58705a4703839383420a04214a--38edc613cff740e8aa011db9c3ece055 e3c948292e1349adb93cf3ea21a4206f 38edc613cff740e8aa011db9c3ece055--e3c948292e1349adb93cf3ea21a4206f 3b60fbb0d304474a9c421d4668bae40b e3c948292e1349adb93cf3ea21a4206f--3b60fbb0d304474a9c421d4668bae40b 33be196a43d345d68d25b6c859e86839 3b60fbb0d304474a9c421d4668bae40b--33be196a43d345d68d25b6c859e86839 f65f60157c184ec9906d3a81cdd7f603 33be196a43d345d68d25b6c859e86839--f65f60157c184ec9906d3a81cdd7f603 24122761be924074b786f80600c0859a f65f60157c184ec9906d3a81cdd7f603--24122761be924074b786f80600c0859a ad047dc242234d2ea67ea65fb7477ae6 24122761be924074b786f80600c0859a--ad047dc242234d2ea67ea65fb7477ae6 aea3990e7db5411a91a0cfae28839c58 ad047dc242234d2ea67ea65fb7477ae6--aea3990e7db5411a91a0cfae28839c58 0a024fb1ff0c4b27b8013ae726bfa93b aea3990e7db5411a91a0cfae28839c58--0a024fb1ff0c4b27b8013ae726bfa93b 01ebdb12e5a749f990ca673046550281 0a024fb1ff0c4b27b8013ae726bfa93b--01ebdb12e5a749f990ca673046550281 458461d1b18d4072bfcfc1eee47bf365 01ebdb12e5a749f990ca673046550281--458461d1b18d4072bfcfc1eee47bf365 0756fb66824e456eaf3fd06403bf6ac5 458461d1b18d4072bfcfc1eee47bf365--0756fb66824e456eaf3fd06403bf6ac5 c7a8d5fd16c7434cbf4f629c5486bd53 0756fb66824e456eaf3fd06403bf6ac5--c7a8d5fd16c7434cbf4f629c5486bd53 be34ccc6f6664f1e98a2fb8021f458ef c7a8d5fd16c7434cbf4f629c5486bd53--be34ccc6f6664f1e98a2fb8021f458ef 608b47a9ef4944ff9d14df6f4c7f7308 be34ccc6f6664f1e98a2fb8021f458ef--608b47a9ef4944ff9d14df6f4c7f7308 8c527a1a01244910ae7e5542358c0ea6 608b47a9ef4944ff9d14df6f4c7f7308--8c527a1a01244910ae7e5542358c0ea6 47ff345ba5a84750bdf442f2fb501e50 8c527a1a01244910ae7e5542358c0ea6--47ff345ba5a84750bdf442f2fb501e50 09a5e9ad869b4a44bdb027bbd2a1b5a9 47ff345ba5a84750bdf442f2fb501e50--09a5e9ad869b4a44bdb027bbd2a1b5a9 25bdf9b88b4140419fa236b74dcb4db7 09a5e9ad869b4a44bdb027bbd2a1b5a9--25bdf9b88b4140419fa236b74dcb4db7 18b91cacc97942638c2650f4eda59143 25bdf9b88b4140419fa236b74dcb4db7--18b91cacc97942638c2650f4eda59143 23ffc0e89d234821b9f7b3184fa4e969 18b91cacc97942638c2650f4eda59143--23ffc0e89d234821b9f7b3184fa4e969 97ff7f92d86f4951ac29a073a79c728b RX(b00) 23ffc0e89d234821b9f7b3184fa4e969--97ff7f92d86f4951ac29a073a79c728b 290719a408e945f496d91305fbde3a2d 97ff7f92d86f4951ac29a073a79c728b--290719a408e945f496d91305fbde3a2d e7486f314ecf4c4bafb307da951243fa 290719a408e945f496d91305fbde3a2d--e7486f314ecf4c4bafb307da951243fa 683e3b8a0943493aa159a43f20e5c4de e7486f314ecf4c4bafb307da951243fa--683e3b8a0943493aa159a43f20e5c4de b1c1856d81a94f58860e365f73c40ba8 683e3b8a0943493aa159a43f20e5c4de--b1c1856d81a94f58860e365f73c40ba8 eb40ea9e9b9447c4937c7b735789e24f b1c1856d81a94f58860e365f73c40ba8--eb40ea9e9b9447c4937c7b735789e24f f8d88ce2f70345d7b78852ff5cf64923 eb40ea9e9b9447c4937c7b735789e24f--f8d88ce2f70345d7b78852ff5cf64923 9772ad02eb8f4525b761a4dea35e36f0 f8d88ce2f70345d7b78852ff5cf64923--9772ad02eb8f4525b761a4dea35e36f0 a0ee79b46cd5438e89e554c09ff37fad 9772ad02eb8f4525b761a4dea35e36f0--a0ee79b46cd5438e89e554c09ff37fad 0b0c060229d34a3e90450d1e2b1b7b1d a0ee79b46cd5438e89e554c09ff37fad--0b0c060229d34a3e90450d1e2b1b7b1d 76aa224686cd4735a3fee2b136028b2c 0b0c060229d34a3e90450d1e2b1b7b1d--76aa224686cd4735a3fee2b136028b2c ffa0738a1104450f995eb7c9199d9271 76aa224686cd4735a3fee2b136028b2c--ffa0738a1104450f995eb7c9199d9271 5c72da92e27545fa8fa56abbba3ece99 ffa0738a1104450f995eb7c9199d9271--5c72da92e27545fa8fa56abbba3ece99 0a95842d28fd4c80afe41efc0c86fd46 5c72da92e27545fa8fa56abbba3ece99--0a95842d28fd4c80afe41efc0c86fd46 b9ff796f629648ed9e0080eb9b48ce38 0a95842d28fd4c80afe41efc0c86fd46--b9ff796f629648ed9e0080eb9b48ce38 675bbe90acdb497b830f521be72b7ec6 b9ff796f629648ed9e0080eb9b48ce38--675bbe90acdb497b830f521be72b7ec6 bdbcbb53cdb6428db9381add0d05a3b6 675bbe90acdb497b830f521be72b7ec6--bdbcbb53cdb6428db9381add0d05a3b6 f00666fa817c4d2e8b472ea7172f9245 bdbcbb53cdb6428db9381add0d05a3b6--f00666fa817c4d2e8b472ea7172f9245 e0f930b4a2fd4dc49a3781e957afe2dd f00666fa817c4d2e8b472ea7172f9245--e0f930b4a2fd4dc49a3781e957afe2dd 70ec344868604aef8a287d5cf0d644cc e0f930b4a2fd4dc49a3781e957afe2dd--70ec344868604aef8a287d5cf0d644cc 42477a46f3884daf92053705a7fd8a6c 70ec344868604aef8a287d5cf0d644cc--42477a46f3884daf92053705a7fd8a6c 6ca37a5548e143e89829397274ac927a 42477a46f3884daf92053705a7fd8a6c--6ca37a5548e143e89829397274ac927a 6f701a7eeede4ccdbb5b1155b6215704 6ca37a5548e143e89829397274ac927a--6f701a7eeede4ccdbb5b1155b6215704 d7e18d00904848d2b23c0e7d5c247fcd 6f701a7eeede4ccdbb5b1155b6215704--d7e18d00904848d2b23c0e7d5c247fcd 177d7899b3dc4fbb805e5836121a3400 d7e18d00904848d2b23c0e7d5c247fcd--177d7899b3dc4fbb805e5836121a3400 de7ac6a49c5d4671844a283d9511fa04 177d7899b3dc4fbb805e5836121a3400--de7ac6a49c5d4671844a283d9511fa04 4052703fb91541259856363b760afd0a de7ac6a49c5d4671844a283d9511fa04--4052703fb91541259856363b760afd0a 5b60d63285f4422ea73f8a93d91bdf3a 4052703fb91541259856363b760afd0a--5b60d63285f4422ea73f8a93d91bdf3a 63423f1d83304fd59a7a94dfeaaf32ab 5b60d63285f4422ea73f8a93d91bdf3a--63423f1d83304fd59a7a94dfeaaf32ab 53042b77ac6e421ebe8f73864c2d59e7 63423f1d83304fd59a7a94dfeaaf32ab--53042b77ac6e421ebe8f73864c2d59e7 27480dc3e12949b5a25b2acbcb6f7fd9 53042b77ac6e421ebe8f73864c2d59e7--27480dc3e12949b5a25b2acbcb6f7fd9 43f35f213dca4baebe73beccab61e9b0 27480dc3e12949b5a25b2acbcb6f7fd9--43f35f213dca4baebe73beccab61e9b0 a8dd386a0e4d48cabb2bf9e22ba99c3b 43f35f213dca4baebe73beccab61e9b0--a8dd386a0e4d48cabb2bf9e22ba99c3b 109a7eefc84f473697fb4416b1a4af78 a8dd386a0e4d48cabb2bf9e22ba99c3b--109a7eefc84f473697fb4416b1a4af78 46121b726d14454ca6e76edb52fa39a8 109a7eefc84f473697fb4416b1a4af78--46121b726d14454ca6e76edb52fa39a8 a0303e255c8b4a0fa62f51cdb3a4e7a5 46121b726d14454ca6e76edb52fa39a8--a0303e255c8b4a0fa62f51cdb3a4e7a5 8a246dd3156f43799bebbd978276f2a4 a0303e255c8b4a0fa62f51cdb3a4e7a5--8a246dd3156f43799bebbd978276f2a4 4a5aada554514b32a3f2b21fdd834353 8a246dd3156f43799bebbd978276f2a4--4a5aada554514b32a3f2b21fdd834353 0f8befe89f484d16952a0c877005018f 4a5aada554514b32a3f2b21fdd834353--0f8befe89f484d16952a0c877005018f ad39904402d5488e80ea7f99c3483fac 0f8befe89f484d16952a0c877005018f--ad39904402d5488e80ea7f99c3483fac 61e6c0dce4984687b4dbda34f1647e53 ad39904402d5488e80ea7f99c3483fac--61e6c0dce4984687b4dbda34f1647e53 9c41adf8b97043f5b729cca6e7c00b9c 61e6c0dce4984687b4dbda34f1647e53--9c41adf8b97043f5b729cca6e7c00b9c edde8bd70dff42c687ce719ed16eb8aa 9c41adf8b97043f5b729cca6e7c00b9c--edde8bd70dff42c687ce719ed16eb8aa 6acc09d0753044038daf17b6b10fae28 edde8bd70dff42c687ce719ed16eb8aa--6acc09d0753044038daf17b6b10fae28 7349f577b01b4fbd83cb06f32b1bdca2 6acc09d0753044038daf17b6b10fae28--7349f577b01b4fbd83cb06f32b1bdca2 9691bc41ce45438db9eddc4610d51740 7349f577b01b4fbd83cb06f32b1bdca2--9691bc41ce45438db9eddc4610d51740 013ac1e7a8aa49e3a89511a59f952f76 9691bc41ce45438db9eddc4610d51740--013ac1e7a8aa49e3a89511a59f952f76 52d5e46a3c624d2c922752b399ab6923 013ac1e7a8aa49e3a89511a59f952f76--52d5e46a3c624d2c922752b399ab6923 3c49e0cd2e1c4d50b6d84734e6879720 52d5e46a3c624d2c922752b399ab6923--3c49e0cd2e1c4d50b6d84734e6879720 1ae1c556fe0c4281a86d2cebf3503870 3c49e0cd2e1c4d50b6d84734e6879720--1ae1c556fe0c4281a86d2cebf3503870 3e74842eead14308befe3893481298d9 1ae1c556fe0c4281a86d2cebf3503870--3e74842eead14308befe3893481298d9 5a75c26e53d34e44b6247478349abfa9 3e74842eead14308befe3893481298d9--5a75c26e53d34e44b6247478349abfa9 1b5acb9ed4214012b6ab43c862ca37fd 5a75c26e53d34e44b6247478349abfa9--1b5acb9ed4214012b6ab43c862ca37fd f579619f9cb947e7a1b86a5116d68e63 1b5acb9ed4214012b6ab43c862ca37fd--f579619f9cb947e7a1b86a5116d68e63 5bc6c3ce71804cfc9f44418d8869de03 f579619f9cb947e7a1b86a5116d68e63--5bc6c3ce71804cfc9f44418d8869de03 bd54157a29474d9e94dd6fe688b420b0 5bc6c3ce71804cfc9f44418d8869de03--bd54157a29474d9e94dd6fe688b420b0 8da74eac8b7d40879d929e1d75c292b3 bd54157a29474d9e94dd6fe688b420b0--8da74eac8b7d40879d929e1d75c292b3 3dd49b0da19a4161aecb0f5f23069eee 8da74eac8b7d40879d929e1d75c292b3--3dd49b0da19a4161aecb0f5f23069eee 5bac416d71464ab7bbd9966500cc19ff 3dd49b0da19a4161aecb0f5f23069eee--5bac416d71464ab7bbd9966500cc19ff 333fdbb612af4b03ae778b8adc1f1f6d 5bac416d71464ab7bbd9966500cc19ff--333fdbb612af4b03ae778b8adc1f1f6d eb1a20c3d27a4f85a74ce5de79495bd4 333fdbb612af4b03ae778b8adc1f1f6d--eb1a20c3d27a4f85a74ce5de79495bd4 a470d8c30a88482fac76f27e1743a616 eb1a20c3d27a4f85a74ce5de79495bd4--a470d8c30a88482fac76f27e1743a616 843d7f1ea9f14f54a9421f8e4f2e4209 a470d8c30a88482fac76f27e1743a616--843d7f1ea9f14f54a9421f8e4f2e4209 33c110564ace4e01a2c0591071d8d8c2 843d7f1ea9f14f54a9421f8e4f2e4209--33c110564ace4e01a2c0591071d8d8c2 a7e2bda18be3436e99ec7aff55810ba3 33c110564ace4e01a2c0591071d8d8c2--a7e2bda18be3436e99ec7aff55810ba3 c632da5017f84241b69b203c10d9d5a7 a7e2bda18be3436e99ec7aff55810ba3--c632da5017f84241b69b203c10d9d5a7 476de820520a476caae5af725ef059ff c632da5017f84241b69b203c10d9d5a7--476de820520a476caae5af725ef059ff e5b1b2846d5c43a58fc69a6290ec9f38 476de820520a476caae5af725ef059ff--e5b1b2846d5c43a58fc69a6290ec9f38 01efc2149eb94848b83a8b86221ec710 e5b1b2846d5c43a58fc69a6290ec9f38--01efc2149eb94848b83a8b86221ec710 b662847035a349f8a447816c6d1d2204 01efc2149eb94848b83a8b86221ec710--b662847035a349f8a447816c6d1d2204 e7c6534ca4d34f1f90c4afee1a6088c9 b662847035a349f8a447816c6d1d2204--e7c6534ca4d34f1f90c4afee1a6088c9 32f57f7840dd4b1580285fecd6c35ee1 e7c6534ca4d34f1f90c4afee1a6088c9--32f57f7840dd4b1580285fecd6c35ee1 5347d8dad3aa42a3afbec4aa54b25c3c 32f57f7840dd4b1580285fecd6c35ee1--5347d8dad3aa42a3afbec4aa54b25c3c 87a33e0d3cf6455b93f00136851493eb 5347d8dad3aa42a3afbec4aa54b25c3c--87a33e0d3cf6455b93f00136851493eb 2780f241c74c4e0281af2dac4a2f8eec 87a33e0d3cf6455b93f00136851493eb--2780f241c74c4e0281af2dac4a2f8eec 7057e02da73f4341b8e68343d381dda2 2780f241c74c4e0281af2dac4a2f8eec--7057e02da73f4341b8e68343d381dda2 e2685384c6534f1a9aebe599d6f6f6fa 7057e02da73f4341b8e68343d381dda2--e2685384c6534f1a9aebe599d6f6f6fa 4c4afea6ae4648499a66a635131897a8 e2685384c6534f1a9aebe599d6f6f6fa--4c4afea6ae4648499a66a635131897a8 0f6d46e3f06144449f319fe7828c3483 4c4afea6ae4648499a66a635131897a8--0f6d46e3f06144449f319fe7828c3483 f8b850272c5d4d6ba5576569c83398fc 0f6d46e3f06144449f319fe7828c3483--f8b850272c5d4d6ba5576569c83398fc fe52cf78bea6477a9395cfe814ba16c2 f8b850272c5d4d6ba5576569c83398fc--fe52cf78bea6477a9395cfe814ba16c2 646ebba0ac1248d0a19c5232a47f7065 fe52cf78bea6477a9395cfe814ba16c2--646ebba0ac1248d0a19c5232a47f7065 ac9a1685e1ae4588b8e58ded47e2a675 646ebba0ac1248d0a19c5232a47f7065--ac9a1685e1ae4588b8e58ded47e2a675 66d22946a9fe4373be04e41573c14893 ac9a1685e1ae4588b8e58ded47e2a675--66d22946a9fe4373be04e41573c14893 0ba848b763c34b829730eed13d55e04c 66d22946a9fe4373be04e41573c14893--0ba848b763c34b829730eed13d55e04c 22e4b713621849c88b3f470ba52850f2 0ba848b763c34b829730eed13d55e04c--22e4b713621849c88b3f470ba52850f2 051ae96dca0f40d9a768b1b26f389561 22e4b713621849c88b3f470ba52850f2--051ae96dca0f40d9a768b1b26f389561 0ed241c65b734dfd852c3e086073dce9 051ae96dca0f40d9a768b1b26f389561--0ed241c65b734dfd852c3e086073dce9 5786d0a19c4248da849a49410b931981 0ed241c65b734dfd852c3e086073dce9--5786d0a19c4248da849a49410b931981 6ff963dd722145088d197ac1559b609a 5786d0a19c4248da849a49410b931981--6ff963dd722145088d197ac1559b609a f5214d159756470d95e82cf75eafa271 6ff963dd722145088d197ac1559b609a--f5214d159756470d95e82cf75eafa271 10b1add139c6437ea3280d49ce0f20dc f5214d159756470d95e82cf75eafa271--10b1add139c6437ea3280d49ce0f20dc 09214ceb2f904ef183a2513a68463a5e 10b1add139c6437ea3280d49ce0f20dc--09214ceb2f904ef183a2513a68463a5e 53f3b881d5c14868b899d4c9a182cca0 09214ceb2f904ef183a2513a68463a5e--53f3b881d5c14868b899d4c9a182cca0 3125aa1ce844445bb911143be675c022 53f3b881d5c14868b899d4c9a182cca0--3125aa1ce844445bb911143be675c022 7bc342478ed04b22acad7e0e26f39b16 3125aa1ce844445bb911143be675c022--7bc342478ed04b22acad7e0e26f39b16 4cac450b2d5147bdbfa98ec8d8a04c64 7bc342478ed04b22acad7e0e26f39b16--4cac450b2d5147bdbfa98ec8d8a04c64 e9240f87134947eb8fc1909f5e969723 4cac450b2d5147bdbfa98ec8d8a04c64--e9240f87134947eb8fc1909f5e969723 bdd71cb9ceec472490284136bffe8d87 e9240f87134947eb8fc1909f5e969723--bdd71cb9ceec472490284136bffe8d87 38f017cfa5fe458688b137c83a5bd38b RX(b10) bdd71cb9ceec472490284136bffe8d87--38f017cfa5fe458688b137c83a5bd38b aedc1f25c60f43879b910b3c59652918 38f017cfa5fe458688b137c83a5bd38b--aedc1f25c60f43879b910b3c59652918 443533a971f14c89a7880669cb0fc9a5 90161ceaf54e4762875dd1aea38b197e X 5b70461cff0c4a4fba5ec98106323e52--90161ceaf54e4762875dd1aea38b197e 107d119aa734453487cebe46a5dd998c 2 90161ceaf54e4762875dd1aea38b197e--667f0c4e32814c1982ef0501af5c672c 4b80cde7c17d480a888dd16431285768 90161ceaf54e4762875dd1aea38b197e--4b80cde7c17d480a888dd16431285768 78b8cab400af42a189c23d510fd28454 4b80cde7c17d480a888dd16431285768--78b8cab400af42a189c23d510fd28454 01a58cd0051d48ba8a238bcaffe49107 78b8cab400af42a189c23d510fd28454--01a58cd0051d48ba8a238bcaffe49107 54ef7133d33e47a09b8558c5e84d3f4f 01a58cd0051d48ba8a238bcaffe49107--54ef7133d33e47a09b8558c5e84d3f4f 3c29c36c1a124ccc94494a1cfcefb827 54ef7133d33e47a09b8558c5e84d3f4f--3c29c36c1a124ccc94494a1cfcefb827 36b10190fa764bf2a441ff72a2783670 3c29c36c1a124ccc94494a1cfcefb827--36b10190fa764bf2a441ff72a2783670 0a0953f8ca5447f48c13fe35ddb766ea 36b10190fa764bf2a441ff72a2783670--0a0953f8ca5447f48c13fe35ddb766ea 1e8c66080a7a46aa951e180a28134209 0a0953f8ca5447f48c13fe35ddb766ea--1e8c66080a7a46aa951e180a28134209 6332ec8c30454e51a987d31d94c32de1 1e8c66080a7a46aa951e180a28134209--6332ec8c30454e51a987d31d94c32de1 b45f4180bf8841d684b134607dfd7041 6332ec8c30454e51a987d31d94c32de1--b45f4180bf8841d684b134607dfd7041 6e8996307a36406cb71cd32fa5ee0a8e b45f4180bf8841d684b134607dfd7041--6e8996307a36406cb71cd32fa5ee0a8e e3ea457fcef243339f3919232676e982 6e8996307a36406cb71cd32fa5ee0a8e--e3ea457fcef243339f3919232676e982 1d1d455493d242319aed89fbc8050f21 e3ea457fcef243339f3919232676e982--1d1d455493d242319aed89fbc8050f21 d38ea111dcf4434d905c8588b1c17dae X 1d1d455493d242319aed89fbc8050f21--d38ea111dcf4434d905c8588b1c17dae d38ea111dcf4434d905c8588b1c17dae--8e02b075176743c6a917f242357d5cbb e022db37d72247c29502a572dc91410d X d38ea111dcf4434d905c8588b1c17dae--e022db37d72247c29502a572dc91410d e022db37d72247c29502a572dc91410d--7d4a6adfc0804151b32d7c8dfec4c2b2 bbed1152cae342f985382df2580a9dd4 RZ(-1.0*g0) e022db37d72247c29502a572dc91410d--bbed1152cae342f985382df2580a9dd4 5c5a3c92333c4ef5a433bffde421e7b5 X bbed1152cae342f985382df2580a9dd4--5c5a3c92333c4ef5a433bffde421e7b5 5c5a3c92333c4ef5a433bffde421e7b5--de423814d81c4df79858a81da3089f31 5fc7664ccb8b44dabf266d128abc891b X 5c5a3c92333c4ef5a433bffde421e7b5--5fc7664ccb8b44dabf266d128abc891b 5fc7664ccb8b44dabf266d128abc891b--0a6d1e52c5b0415da53646930fb9a406 f8e11a110de8483c9b013f686811937b 5fc7664ccb8b44dabf266d128abc891b--f8e11a110de8483c9b013f686811937b 1e0755b919ed4fa0ad0271d35d3925b4 f8e11a110de8483c9b013f686811937b--1e0755b919ed4fa0ad0271d35d3925b4 1bfa36b154fa46b8ac1010ef77d7b044 1e0755b919ed4fa0ad0271d35d3925b4--1bfa36b154fa46b8ac1010ef77d7b044 197809df789244d8acb9102a534fa8be X 1bfa36b154fa46b8ac1010ef77d7b044--197809df789244d8acb9102a534fa8be 197809df789244d8acb9102a534fa8be--3fe72af7fe124b359371c0d7b8b30c49 481f6011a7a745baa451b1b0bd5329e1 X 197809df789244d8acb9102a534fa8be--481f6011a7a745baa451b1b0bd5329e1 481f6011a7a745baa451b1b0bd5329e1--743c47823ccc4dd98a995e3dd38e97de 5cc86e79adf744e183f28df36a0fcdde 481f6011a7a745baa451b1b0bd5329e1--5cc86e79adf744e183f28df36a0fcdde 9db47ea3d27644b996046e9f0960a007 5cc86e79adf744e183f28df36a0fcdde--9db47ea3d27644b996046e9f0960a007 29c3c5f574154ebf9c99075da43b70bf 9db47ea3d27644b996046e9f0960a007--29c3c5f574154ebf9c99075da43b70bf 90da4dab5ddc42738fc0bf4cd7e45b3f 29c3c5f574154ebf9c99075da43b70bf--90da4dab5ddc42738fc0bf4cd7e45b3f 822e36b037634a80854bef7dba4a1042 90da4dab5ddc42738fc0bf4cd7e45b3f--822e36b037634a80854bef7dba4a1042 100acb43c257435b81f3a1e932a531fd 822e36b037634a80854bef7dba4a1042--100acb43c257435b81f3a1e932a531fd 4211d0026f9e49339625378e019a1e87 100acb43c257435b81f3a1e932a531fd--4211d0026f9e49339625378e019a1e87 1be5014213254726b9dec8a5bad100d0 X 4211d0026f9e49339625378e019a1e87--1be5014213254726b9dec8a5bad100d0 1be5014213254726b9dec8a5bad100d0--ed7243ddd9564489937da9a5e0b0dd7f f2a633dc873a467b94a47e429866b55b X 1be5014213254726b9dec8a5bad100d0--f2a633dc873a467b94a47e429866b55b f2a633dc873a467b94a47e429866b55b--fb9f56df262242ea98c2133c5700b1f2 e642e0224abc42be8ff334fe11768c2f f2a633dc873a467b94a47e429866b55b--e642e0224abc42be8ff334fe11768c2f c8d1802c42af478ba427631f54c18313 e642e0224abc42be8ff334fe11768c2f--c8d1802c42af478ba427631f54c18313 0628156512ee48f3ac5c6f052e9d6e37 c8d1802c42af478ba427631f54c18313--0628156512ee48f3ac5c6f052e9d6e37 a91939aaea1f44488ca2dc26bf44f31a 0628156512ee48f3ac5c6f052e9d6e37--a91939aaea1f44488ca2dc26bf44f31a 88f5703530dd40c79c538fc6d94a97ce a91939aaea1f44488ca2dc26bf44f31a--88f5703530dd40c79c538fc6d94a97ce f937f3964da44c28a5a9d4264bf9553d 88f5703530dd40c79c538fc6d94a97ce--f937f3964da44c28a5a9d4264bf9553d 5d81fba1994e4d558401f3c6e59c1757 f937f3964da44c28a5a9d4264bf9553d--5d81fba1994e4d558401f3c6e59c1757 c36a89ccc12e417eb507dc73ea26b882 5d81fba1994e4d558401f3c6e59c1757--c36a89ccc12e417eb507dc73ea26b882 c5905d8efd1e48afbb4d838a7e86d26d c36a89ccc12e417eb507dc73ea26b882--c5905d8efd1e48afbb4d838a7e86d26d 5b052ad90f2c4e07be0dc4314622ef08 c5905d8efd1e48afbb4d838a7e86d26d--5b052ad90f2c4e07be0dc4314622ef08 cde4f46b1db54b9d852342df83eec0ca 5b052ad90f2c4e07be0dc4314622ef08--cde4f46b1db54b9d852342df83eec0ca 8962373d197e4c8194a1d89b9055427e cde4f46b1db54b9d852342df83eec0ca--8962373d197e4c8194a1d89b9055427e e64886099e9d4a0baac1d32deed026f9 8962373d197e4c8194a1d89b9055427e--e64886099e9d4a0baac1d32deed026f9 859759fbfece46858f4adc7c82118a82 X e64886099e9d4a0baac1d32deed026f9--859759fbfece46858f4adc7c82118a82 859759fbfece46858f4adc7c82118a82--7723796160b74d0b8fc4177e1216e370 948b05fb3f59484198f6ae8ec363bff9 859759fbfece46858f4adc7c82118a82--948b05fb3f59484198f6ae8ec363bff9 b8b3eb6402cf45178b0547f01066125f 948b05fb3f59484198f6ae8ec363bff9--b8b3eb6402cf45178b0547f01066125f 9ff56ece16334df284d659eef23633f4 b8b3eb6402cf45178b0547f01066125f--9ff56ece16334df284d659eef23633f4 3428ef226ab84aaaba7741ad5d294eb0 9ff56ece16334df284d659eef23633f4--3428ef226ab84aaaba7741ad5d294eb0 cdb9523eb61243638d85364f295f339a 3428ef226ab84aaaba7741ad5d294eb0--cdb9523eb61243638d85364f295f339a b83db7aa5ae2484589dc3e6f32803f10 cdb9523eb61243638d85364f295f339a--b83db7aa5ae2484589dc3e6f32803f10 24931346fe0e44ab91f1da47c57e7508 b83db7aa5ae2484589dc3e6f32803f10--24931346fe0e44ab91f1da47c57e7508 9af7e97fb64744fd9d3bfc335256fa85 24931346fe0e44ab91f1da47c57e7508--9af7e97fb64744fd9d3bfc335256fa85 d00535d7c76944358554b83410290a16 9af7e97fb64744fd9d3bfc335256fa85--d00535d7c76944358554b83410290a16 c0da3af9b3944844ba011fe6bca1a9a1 d00535d7c76944358554b83410290a16--c0da3af9b3944844ba011fe6bca1a9a1 638bd44df54e46979665d9199405a3bb c0da3af9b3944844ba011fe6bca1a9a1--638bd44df54e46979665d9199405a3bb 877ab6d6f2ab410b816b162d1d382206 638bd44df54e46979665d9199405a3bb--877ab6d6f2ab410b816b162d1d382206 279f5fbfa497486a8faffdbe0a3f1dc9 877ab6d6f2ab410b816b162d1d382206--279f5fbfa497486a8faffdbe0a3f1dc9 f54c91dc344b4ceaaaa39b704b13d0ed 279f5fbfa497486a8faffdbe0a3f1dc9--f54c91dc344b4ceaaaa39b704b13d0ed b0b287acb5f44a0f8bf72d73b76ccff3 f54c91dc344b4ceaaaa39b704b13d0ed--b0b287acb5f44a0f8bf72d73b76ccff3 4a42ac7019c64e418eab65ec2b6dc5e8 b0b287acb5f44a0f8bf72d73b76ccff3--4a42ac7019c64e418eab65ec2b6dc5e8 253e269c8cf54f56a08a6a5a12ea3c9f 4a42ac7019c64e418eab65ec2b6dc5e8--253e269c8cf54f56a08a6a5a12ea3c9f dff679ebd51f4a9a9d223cdadfc828f3 253e269c8cf54f56a08a6a5a12ea3c9f--dff679ebd51f4a9a9d223cdadfc828f3 57f817bade4948f4bfffae592bc44c84 dff679ebd51f4a9a9d223cdadfc828f3--57f817bade4948f4bfffae592bc44c84 247389799d274977b48e0459d5be2460 57f817bade4948f4bfffae592bc44c84--247389799d274977b48e0459d5be2460 9975a3aaea0d4fc590590b75a95d3fdf 247389799d274977b48e0459d5be2460--9975a3aaea0d4fc590590b75a95d3fdf 0d8dbf905c2c4ebfb7e807d6b858bdff 9975a3aaea0d4fc590590b75a95d3fdf--0d8dbf905c2c4ebfb7e807d6b858bdff 42f301e6b929411099c89ceb187b5f50 0d8dbf905c2c4ebfb7e807d6b858bdff--42f301e6b929411099c89ceb187b5f50 eaf1a5bef84349eaacff2b27353c13cd 42f301e6b929411099c89ceb187b5f50--eaf1a5bef84349eaacff2b27353c13cd b804ed51a5eb4077bbda2d03bf71fdac eaf1a5bef84349eaacff2b27353c13cd--b804ed51a5eb4077bbda2d03bf71fdac 31c82dfc3a0f4d46bc19480cff20cdce b804ed51a5eb4077bbda2d03bf71fdac--31c82dfc3a0f4d46bc19480cff20cdce 00c35800dd524929b39c2a0a45c33b1b 31c82dfc3a0f4d46bc19480cff20cdce--00c35800dd524929b39c2a0a45c33b1b cb34f687335d4e98aa453fb2dccb2e45 00c35800dd524929b39c2a0a45c33b1b--cb34f687335d4e98aa453fb2dccb2e45 4e4e612570bf4fb2b711c17769066596 cb34f687335d4e98aa453fb2dccb2e45--4e4e612570bf4fb2b711c17769066596 0bbaaf0948bf4846b780872afa91f305 4e4e612570bf4fb2b711c17769066596--0bbaaf0948bf4846b780872afa91f305 85022e19c91741d7b0d2272b75c1bda4 0bbaaf0948bf4846b780872afa91f305--85022e19c91741d7b0d2272b75c1bda4 40c89866e3304518a60032eedbda65b6 85022e19c91741d7b0d2272b75c1bda4--40c89866e3304518a60032eedbda65b6 6f7c01b48a464d27979841289b16eb47 40c89866e3304518a60032eedbda65b6--6f7c01b48a464d27979841289b16eb47 a38eb8470cb94e5384bab88656b9a651 6f7c01b48a464d27979841289b16eb47--a38eb8470cb94e5384bab88656b9a651 f207057e591d46b097f0cb5141f02cdc a38eb8470cb94e5384bab88656b9a651--f207057e591d46b097f0cb5141f02cdc e86aa0f680574e82adbcc2d8f5f2aae4 f207057e591d46b097f0cb5141f02cdc--e86aa0f680574e82adbcc2d8f5f2aae4 b747faabf436450a9a1cff59c5eab53e e86aa0f680574e82adbcc2d8f5f2aae4--b747faabf436450a9a1cff59c5eab53e 8719e1efa0d94361b66706b0a4b56172 b747faabf436450a9a1cff59c5eab53e--8719e1efa0d94361b66706b0a4b56172 f03da1a89b8a46888a47c38bd6329e27 8719e1efa0d94361b66706b0a4b56172--f03da1a89b8a46888a47c38bd6329e27 9ee6a5631f024df3a6ab767304a3e96a f03da1a89b8a46888a47c38bd6329e27--9ee6a5631f024df3a6ab767304a3e96a e3f0e1fe3bb64afa9fa9f7b5c047e5cd 9ee6a5631f024df3a6ab767304a3e96a--e3f0e1fe3bb64afa9fa9f7b5c047e5cd e875a9c5bd814e62980bccdb92cc5768 e3f0e1fe3bb64afa9fa9f7b5c047e5cd--e875a9c5bd814e62980bccdb92cc5768 4115ba5902ce467da9a8d0e6be7ded23 e875a9c5bd814e62980bccdb92cc5768--4115ba5902ce467da9a8d0e6be7ded23 f6910654ed944d1d8aed86a2c2437ad6 4115ba5902ce467da9a8d0e6be7ded23--f6910654ed944d1d8aed86a2c2437ad6 69d95cee821b4b089a6ef53625668820 f6910654ed944d1d8aed86a2c2437ad6--69d95cee821b4b089a6ef53625668820 d804971318ca4ec98b69c0685708089c 69d95cee821b4b089a6ef53625668820--d804971318ca4ec98b69c0685708089c 7d5e4de24b0d4f74b4791dd13bfefa98 d804971318ca4ec98b69c0685708089c--7d5e4de24b0d4f74b4791dd13bfefa98 88e327ead6e14f8890c099a1948e8bf1 7d5e4de24b0d4f74b4791dd13bfefa98--88e327ead6e14f8890c099a1948e8bf1 bd1ae5a62bbb45c4aa783dd00240d754 88e327ead6e14f8890c099a1948e8bf1--bd1ae5a62bbb45c4aa783dd00240d754 c4acf4cd7bba4362be7c8e14964c1781 bd1ae5a62bbb45c4aa783dd00240d754--c4acf4cd7bba4362be7c8e14964c1781 348fa124b16e4ed3bf7963afc0957b31 c4acf4cd7bba4362be7c8e14964c1781--348fa124b16e4ed3bf7963afc0957b31 cb8957d7a3a94deeb20472132741dae6 RX(b01) 348fa124b16e4ed3bf7963afc0957b31--cb8957d7a3a94deeb20472132741dae6 3f6363c5e7204e1eb89b9da070a45477 X cb8957d7a3a94deeb20472132741dae6--3f6363c5e7204e1eb89b9da070a45477 3f6363c5e7204e1eb89b9da070a45477--290719a408e945f496d91305fbde3a2d e7044c70385d492081cfcb16a2d8c6c8 3f6363c5e7204e1eb89b9da070a45477--e7044c70385d492081cfcb16a2d8c6c8 51646cee7ad440efaa5a9602b94e30c8 e7044c70385d492081cfcb16a2d8c6c8--51646cee7ad440efaa5a9602b94e30c8 f8c829fcc73d48f981225229f7600d42 51646cee7ad440efaa5a9602b94e30c8--f8c829fcc73d48f981225229f7600d42 69391eec300c4988bbe3c6e0a97efe44 f8c829fcc73d48f981225229f7600d42--69391eec300c4988bbe3c6e0a97efe44 a3ba37a74df14836b9ec7c45fb074224 69391eec300c4988bbe3c6e0a97efe44--a3ba37a74df14836b9ec7c45fb074224 01a28e40ad464c63aef5f88533d951f7 a3ba37a74df14836b9ec7c45fb074224--01a28e40ad464c63aef5f88533d951f7 73b152f6de6d4eb69721cd47d34b9a30 01a28e40ad464c63aef5f88533d951f7--73b152f6de6d4eb69721cd47d34b9a30 4efe58e964fb4b918ed5b51217b8f5d9 73b152f6de6d4eb69721cd47d34b9a30--4efe58e964fb4b918ed5b51217b8f5d9 f4a1316b2713443b9181012e55f500c6 4efe58e964fb4b918ed5b51217b8f5d9--f4a1316b2713443b9181012e55f500c6 930c6cab684b4f578278b64cdb4b2285 f4a1316b2713443b9181012e55f500c6--930c6cab684b4f578278b64cdb4b2285 8d65d30d9c074e96a86a113917add000 930c6cab684b4f578278b64cdb4b2285--8d65d30d9c074e96a86a113917add000 f85c597ff50744d8bc59eb5f2d8208fc 8d65d30d9c074e96a86a113917add000--f85c597ff50744d8bc59eb5f2d8208fc 63d0e95d3d79441687b5bb3bf31f9aba f85c597ff50744d8bc59eb5f2d8208fc--63d0e95d3d79441687b5bb3bf31f9aba e656cbab1f2d4fcdb54c4de9f8796224 X 63d0e95d3d79441687b5bb3bf31f9aba--e656cbab1f2d4fcdb54c4de9f8796224 e656cbab1f2d4fcdb54c4de9f8796224--675bbe90acdb497b830f521be72b7ec6 316d6ef76efc42049d5fdd4e7f38986b X e656cbab1f2d4fcdb54c4de9f8796224--316d6ef76efc42049d5fdd4e7f38986b 316d6ef76efc42049d5fdd4e7f38986b--bdbcbb53cdb6428db9381add0d05a3b6 9b450fe0e390470096de8c2f89cbe564 RZ(-1.0*g1) 316d6ef76efc42049d5fdd4e7f38986b--9b450fe0e390470096de8c2f89cbe564 b136569b8ea24985bc8602c62646b0f5 X 9b450fe0e390470096de8c2f89cbe564--b136569b8ea24985bc8602c62646b0f5 b136569b8ea24985bc8602c62646b0f5--e0f930b4a2fd4dc49a3781e957afe2dd 752f19cc3c7f4960bcea17bf12b933ab X b136569b8ea24985bc8602c62646b0f5--752f19cc3c7f4960bcea17bf12b933ab 752f19cc3c7f4960bcea17bf12b933ab--70ec344868604aef8a287d5cf0d644cc 5d7b56ac838449289204364d9b4788a2 752f19cc3c7f4960bcea17bf12b933ab--5d7b56ac838449289204364d9b4788a2 00f3b993e2304eefbf829e8648376643 5d7b56ac838449289204364d9b4788a2--00f3b993e2304eefbf829e8648376643 b0a9867a5ad7405b830bde44359ee19e 00f3b993e2304eefbf829e8648376643--b0a9867a5ad7405b830bde44359ee19e fd495c33c4b54e5a878d38047f07260d X b0a9867a5ad7405b830bde44359ee19e--fd495c33c4b54e5a878d38047f07260d fd495c33c4b54e5a878d38047f07260d--d7e18d00904848d2b23c0e7d5c247fcd 9182318469834f0b9833f605eceb6981 X fd495c33c4b54e5a878d38047f07260d--9182318469834f0b9833f605eceb6981 9182318469834f0b9833f605eceb6981--177d7899b3dc4fbb805e5836121a3400 2ec344e3de814c2794f099cbd4a1fc53 9182318469834f0b9833f605eceb6981--2ec344e3de814c2794f099cbd4a1fc53 954c61fd765147c5bd189241a1858391 2ec344e3de814c2794f099cbd4a1fc53--954c61fd765147c5bd189241a1858391 7b0a10312cb243f19109496dcd0743e5 954c61fd765147c5bd189241a1858391--7b0a10312cb243f19109496dcd0743e5 d076768481f24582a4f6712746b76fec 7b0a10312cb243f19109496dcd0743e5--d076768481f24582a4f6712746b76fec 7c1a8f62a69141d5beb64652b1ffcb54 d076768481f24582a4f6712746b76fec--7c1a8f62a69141d5beb64652b1ffcb54 8c8d05c19c5c4aba86ffa34561ef52ff 7c1a8f62a69141d5beb64652b1ffcb54--8c8d05c19c5c4aba86ffa34561ef52ff bf33f9c94fc5474ea8c7988bd9c027ba 8c8d05c19c5c4aba86ffa34561ef52ff--bf33f9c94fc5474ea8c7988bd9c027ba 4197f5dd0fee4205be6a15fdb6469569 X bf33f9c94fc5474ea8c7988bd9c027ba--4197f5dd0fee4205be6a15fdb6469569 4197f5dd0fee4205be6a15fdb6469569--a8dd386a0e4d48cabb2bf9e22ba99c3b 234763dfd24a49dbb3c82528aa42b93c X 4197f5dd0fee4205be6a15fdb6469569--234763dfd24a49dbb3c82528aa42b93c 234763dfd24a49dbb3c82528aa42b93c--109a7eefc84f473697fb4416b1a4af78 725b0723f3aa4082abae80bc6b904240 234763dfd24a49dbb3c82528aa42b93c--725b0723f3aa4082abae80bc6b904240 bf44931b4b4a4d5f94f6a776e7c7cde9 725b0723f3aa4082abae80bc6b904240--bf44931b4b4a4d5f94f6a776e7c7cde9 88fb0bff0b09465ea82826a98a45ecfd bf44931b4b4a4d5f94f6a776e7c7cde9--88fb0bff0b09465ea82826a98a45ecfd 3e3dd3d52f8c4a86a662ffb5726d4253 88fb0bff0b09465ea82826a98a45ecfd--3e3dd3d52f8c4a86a662ffb5726d4253 a3486e03705d4ebe8a46d9e4513827bc 3e3dd3d52f8c4a86a662ffb5726d4253--a3486e03705d4ebe8a46d9e4513827bc cb8ac711c2914aabb1417eb0a59de38a a3486e03705d4ebe8a46d9e4513827bc--cb8ac711c2914aabb1417eb0a59de38a 2bb7db286c7a4eb099d68c7072ee9036 cb8ac711c2914aabb1417eb0a59de38a--2bb7db286c7a4eb099d68c7072ee9036 ed30866df7d0488ba7d7f03a1d8baedf 2bb7db286c7a4eb099d68c7072ee9036--ed30866df7d0488ba7d7f03a1d8baedf bf3f9fbf1a9f45b297befff4a289431d ed30866df7d0488ba7d7f03a1d8baedf--bf3f9fbf1a9f45b297befff4a289431d f4aae5d81bac4c8f9cd6207eba7c6b3b bf3f9fbf1a9f45b297befff4a289431d--f4aae5d81bac4c8f9cd6207eba7c6b3b 3aa55d05039d4e3d986840908e935f6b f4aae5d81bac4c8f9cd6207eba7c6b3b--3aa55d05039d4e3d986840908e935f6b 626f24da2bfe45499f5ece85ee986ba4 3aa55d05039d4e3d986840908e935f6b--626f24da2bfe45499f5ece85ee986ba4 2c81d6307c1b423eb59044aad21bc29c 626f24da2bfe45499f5ece85ee986ba4--2c81d6307c1b423eb59044aad21bc29c 6c1f948b1ec1478888306968bc69eeff X 2c81d6307c1b423eb59044aad21bc29c--6c1f948b1ec1478888306968bc69eeff 6c1f948b1ec1478888306968bc69eeff--52d5e46a3c624d2c922752b399ab6923 0ddcb9d98cf447e8addc32ef65157054 6c1f948b1ec1478888306968bc69eeff--0ddcb9d98cf447e8addc32ef65157054 4c993a076ec7459b9d2afb9393b95528 0ddcb9d98cf447e8addc32ef65157054--4c993a076ec7459b9d2afb9393b95528 127948a897054fc9a24e43d9479133f8 4c993a076ec7459b9d2afb9393b95528--127948a897054fc9a24e43d9479133f8 6a5d87449d4948918c5fc9e585b45063 127948a897054fc9a24e43d9479133f8--6a5d87449d4948918c5fc9e585b45063 9d7996e550d14cb590416c81664f281d 6a5d87449d4948918c5fc9e585b45063--9d7996e550d14cb590416c81664f281d 82d62e428e9a4945a1b93655b9121717 9d7996e550d14cb590416c81664f281d--82d62e428e9a4945a1b93655b9121717 aef410787e7b44b3835355e7f576710d 82d62e428e9a4945a1b93655b9121717--aef410787e7b44b3835355e7f576710d 86cd2943db464dc29f25417fae24486f aef410787e7b44b3835355e7f576710d--86cd2943db464dc29f25417fae24486f 1d977a580dd54aada9c26b9ba550a0fd 86cd2943db464dc29f25417fae24486f--1d977a580dd54aada9c26b9ba550a0fd 794c0fd87ddd430190124c98cf97dc7b 1d977a580dd54aada9c26b9ba550a0fd--794c0fd87ddd430190124c98cf97dc7b 32fc3f050a53498185daa05011a7fd3b 794c0fd87ddd430190124c98cf97dc7b--32fc3f050a53498185daa05011a7fd3b a3ede7c619bd40b997f0b0e94d9fdc70 32fc3f050a53498185daa05011a7fd3b--a3ede7c619bd40b997f0b0e94d9fdc70 f31c524e78f4485c9f54b391faca68f9 a3ede7c619bd40b997f0b0e94d9fdc70--f31c524e78f4485c9f54b391faca68f9 86e2346d5e364401b227262196e6ab58 f31c524e78f4485c9f54b391faca68f9--86e2346d5e364401b227262196e6ab58 544f3892c1824a789ffbb09a3c3bbe76 86e2346d5e364401b227262196e6ab58--544f3892c1824a789ffbb09a3c3bbe76 2a1ff34d92de47f0b570e655fd26d692 544f3892c1824a789ffbb09a3c3bbe76--2a1ff34d92de47f0b570e655fd26d692 d8c3978d1b96405084202e0d64720b46 2a1ff34d92de47f0b570e655fd26d692--d8c3978d1b96405084202e0d64720b46 305780f0fcbf42e0b19c820bb4f35fd0 d8c3978d1b96405084202e0d64720b46--305780f0fcbf42e0b19c820bb4f35fd0 e276aadbc66345919036df24b633a802 305780f0fcbf42e0b19c820bb4f35fd0--e276aadbc66345919036df24b633a802 aa136f9af5344c0aa8cbb0af806a89e9 e276aadbc66345919036df24b633a802--aa136f9af5344c0aa8cbb0af806a89e9 9b0551e8279b457db01a0727757ec1b9 aa136f9af5344c0aa8cbb0af806a89e9--9b0551e8279b457db01a0727757ec1b9 da7c108ecd1a4324a0f45de34fcc3403 9b0551e8279b457db01a0727757ec1b9--da7c108ecd1a4324a0f45de34fcc3403 24f8a6680c2340858d41ae02548828fb da7c108ecd1a4324a0f45de34fcc3403--24f8a6680c2340858d41ae02548828fb 2b66f77768a942c6869ac55de80dbf08 24f8a6680c2340858d41ae02548828fb--2b66f77768a942c6869ac55de80dbf08 a85bc68237534d5fb103e091024a215a 2b66f77768a942c6869ac55de80dbf08--a85bc68237534d5fb103e091024a215a 5a1ade1bf33b42818f1095d0800003a6 a85bc68237534d5fb103e091024a215a--5a1ade1bf33b42818f1095d0800003a6 51a072fabc5844749108fcdd3273acf6 5a1ade1bf33b42818f1095d0800003a6--51a072fabc5844749108fcdd3273acf6 f4cefc9ffc72452383e450e7c4507d76 51a072fabc5844749108fcdd3273acf6--f4cefc9ffc72452383e450e7c4507d76 8543267f2da44f09977e4bda222bc839 f4cefc9ffc72452383e450e7c4507d76--8543267f2da44f09977e4bda222bc839 2a95f7135ba340b0a14f52bce6e79b59 8543267f2da44f09977e4bda222bc839--2a95f7135ba340b0a14f52bce6e79b59 db9a0a51e6f84677a64660924212a2c7 2a95f7135ba340b0a14f52bce6e79b59--db9a0a51e6f84677a64660924212a2c7 2749e853fe704fd68b3d173b5442179c db9a0a51e6f84677a64660924212a2c7--2749e853fe704fd68b3d173b5442179c da0ccd91cb0d4bf4afa7cf1809283f6e 2749e853fe704fd68b3d173b5442179c--da0ccd91cb0d4bf4afa7cf1809283f6e e19d02a0fbf74a3fba171534999ca239 da0ccd91cb0d4bf4afa7cf1809283f6e--e19d02a0fbf74a3fba171534999ca239 d7fe163fbfc043639f4fd0ea70464279 e19d02a0fbf74a3fba171534999ca239--d7fe163fbfc043639f4fd0ea70464279 68e905769c0f4186841730ecc2f252a1 d7fe163fbfc043639f4fd0ea70464279--68e905769c0f4186841730ecc2f252a1 53e687e5fd1d4e92a1149b413e4018f3 68e905769c0f4186841730ecc2f252a1--53e687e5fd1d4e92a1149b413e4018f3 16dba5b5f7a9447b840ee228d9e32be6 53e687e5fd1d4e92a1149b413e4018f3--16dba5b5f7a9447b840ee228d9e32be6 2a27c1e3db66499fb5f685d2a42e994e 16dba5b5f7a9447b840ee228d9e32be6--2a27c1e3db66499fb5f685d2a42e994e 4702790368a3474ea44a3442e2b4a699 2a27c1e3db66499fb5f685d2a42e994e--4702790368a3474ea44a3442e2b4a699 ffba06df56c045b68c3fe574aafc92f3 4702790368a3474ea44a3442e2b4a699--ffba06df56c045b68c3fe574aafc92f3 75abaa6adb68451399cb85f0cc887f15 ffba06df56c045b68c3fe574aafc92f3--75abaa6adb68451399cb85f0cc887f15 f1d7134a93514d6aae634ff97cc58086 75abaa6adb68451399cb85f0cc887f15--f1d7134a93514d6aae634ff97cc58086 7e6142a9df454b0dbc36ba65efb1748e f1d7134a93514d6aae634ff97cc58086--7e6142a9df454b0dbc36ba65efb1748e 58d22ce33b3c4ba99870d6adff38f475 7e6142a9df454b0dbc36ba65efb1748e--58d22ce33b3c4ba99870d6adff38f475 1f52ba2f20784b078f759f8aaf1c39d5 58d22ce33b3c4ba99870d6adff38f475--1f52ba2f20784b078f759f8aaf1c39d5 a4f61fbbc42e4b9dbf84e0004b41a327 1f52ba2f20784b078f759f8aaf1c39d5--a4f61fbbc42e4b9dbf84e0004b41a327 f980f8b03e7247089e4ff9b078eeb035 a4f61fbbc42e4b9dbf84e0004b41a327--f980f8b03e7247089e4ff9b078eeb035 a856bf3d48c94530a0116b4a2c3e1acd f980f8b03e7247089e4ff9b078eeb035--a856bf3d48c94530a0116b4a2c3e1acd 42de54e4a7734dfea8a3a5abfcc9c767 a856bf3d48c94530a0116b4a2c3e1acd--42de54e4a7734dfea8a3a5abfcc9c767 7022d3da17fe4508a25db73ee3590159 42de54e4a7734dfea8a3a5abfcc9c767--7022d3da17fe4508a25db73ee3590159 cbf168be060f48aa88b5a826e5703c8c RX(b11) 7022d3da17fe4508a25db73ee3590159--cbf168be060f48aa88b5a826e5703c8c cbf168be060f48aa88b5a826e5703c8c--443533a971f14c89a7880669cb0fc9a5 305e7c87c5844c9ea64edc6b252477bb ee3e9b4558ec49609d595593c8a06565 107d119aa734453487cebe46a5dd998c--ee3e9b4558ec49609d595593c8a06565 30e0a71e41d849c8be54ec28540fd30d 3 6cd0979c62b441af826d863acb0388bd X ee3e9b4558ec49609d595593c8a06565--6cd0979c62b441af826d863acb0388bd 6cd0979c62b441af826d863acb0388bd--4b80cde7c17d480a888dd16431285768 c143f1390d4b4219a9ac838db0e275c1 6cd0979c62b441af826d863acb0388bd--c143f1390d4b4219a9ac838db0e275c1 6ebc7b2556374378a12d3a1eb143750f c143f1390d4b4219a9ac838db0e275c1--6ebc7b2556374378a12d3a1eb143750f d84d0d298f4c43d48345e59646879219 6ebc7b2556374378a12d3a1eb143750f--d84d0d298f4c43d48345e59646879219 27a3dd5fdf51478da28a09a376980213 d84d0d298f4c43d48345e59646879219--27a3dd5fdf51478da28a09a376980213 62ce7d85236e45b8a2a5cc647c337be3 27a3dd5fdf51478da28a09a376980213--62ce7d85236e45b8a2a5cc647c337be3 b66c76229ee0424290eb03c292f12b02 62ce7d85236e45b8a2a5cc647c337be3--b66c76229ee0424290eb03c292f12b02 890eed28859b4b51bdbacc8752c75e8e b66c76229ee0424290eb03c292f12b02--890eed28859b4b51bdbacc8752c75e8e 3eeb56d434e542c6b1659f9337ef0975 890eed28859b4b51bdbacc8752c75e8e--3eeb56d434e542c6b1659f9337ef0975 a54d4b5a92c34345a44b23bf364dd096 3eeb56d434e542c6b1659f9337ef0975--a54d4b5a92c34345a44b23bf364dd096 fa34b1a62f4c4734ae0875eac076ebde a54d4b5a92c34345a44b23bf364dd096--fa34b1a62f4c4734ae0875eac076ebde b48268ba510e4611a24191893e05d5af fa34b1a62f4c4734ae0875eac076ebde--b48268ba510e4611a24191893e05d5af 09d938bc62f040b682eb784fcaa7ccfa X b48268ba510e4611a24191893e05d5af--09d938bc62f040b682eb784fcaa7ccfa 09d938bc62f040b682eb784fcaa7ccfa--1d1d455493d242319aed89fbc8050f21 71573ba092d34badb550e7dbc6815832 09d938bc62f040b682eb784fcaa7ccfa--71573ba092d34badb550e7dbc6815832 71b53099b94946759f3dce2f1128ae40 71573ba092d34badb550e7dbc6815832--71b53099b94946759f3dce2f1128ae40 55d4166068a145a2a247a8b9311f06c5 71b53099b94946759f3dce2f1128ae40--55d4166068a145a2a247a8b9311f06c5 93d0e1f8508b4ae5b795ee839930776b 55d4166068a145a2a247a8b9311f06c5--93d0e1f8508b4ae5b795ee839930776b 4c8c32d9ac7749f0bc326c2b6a4703e8 93d0e1f8508b4ae5b795ee839930776b--4c8c32d9ac7749f0bc326c2b6a4703e8 4aacdbb136bc42e9865a6939d99eada4 X 4c8c32d9ac7749f0bc326c2b6a4703e8--4aacdbb136bc42e9865a6939d99eada4 4aacdbb136bc42e9865a6939d99eada4--f8e11a110de8483c9b013f686811937b 33500d4664eb426aaebbe1e48bcdd1a5 RZ(-1.0*g0) 4aacdbb136bc42e9865a6939d99eada4--33500d4664eb426aaebbe1e48bcdd1a5 2d7ad1b69ee344e78e8a166692b8ce15 X 33500d4664eb426aaebbe1e48bcdd1a5--2d7ad1b69ee344e78e8a166692b8ce15 2d7ad1b69ee344e78e8a166692b8ce15--1bfa36b154fa46b8ac1010ef77d7b044 5d9da70dd1ce4f5ebdf8d59a2b28c9f5 2d7ad1b69ee344e78e8a166692b8ce15--5d9da70dd1ce4f5ebdf8d59a2b28c9f5 46f3fdd0b8f745beaf3b5a8eecf5fbe5 5d9da70dd1ce4f5ebdf8d59a2b28c9f5--46f3fdd0b8f745beaf3b5a8eecf5fbe5 ef4a03572ed14c52b49266440ba0ce9d X 46f3fdd0b8f745beaf3b5a8eecf5fbe5--ef4a03572ed14c52b49266440ba0ce9d ef4a03572ed14c52b49266440ba0ce9d--5cc86e79adf744e183f28df36a0fcdde 8157e936a2024896ab5a217b5e74ce59 ef4a03572ed14c52b49266440ba0ce9d--8157e936a2024896ab5a217b5e74ce59 19b7984bf2b14e81976427db1bebdf2c 8157e936a2024896ab5a217b5e74ce59--19b7984bf2b14e81976427db1bebdf2c 1e075e5dcad94a8d8a32f1860b19e3de 19b7984bf2b14e81976427db1bebdf2c--1e075e5dcad94a8d8a32f1860b19e3de 823039e5f6b643e6affadda6150c3919 1e075e5dcad94a8d8a32f1860b19e3de--823039e5f6b643e6affadda6150c3919 c75fed020e5d481cb3db8dbae47afa7f 823039e5f6b643e6affadda6150c3919--c75fed020e5d481cb3db8dbae47afa7f 9c4438fb3a0e4606913877e72fc603b1 X c75fed020e5d481cb3db8dbae47afa7f--9c4438fb3a0e4606913877e72fc603b1 9c4438fb3a0e4606913877e72fc603b1--4211d0026f9e49339625378e019a1e87 e994f4e30e084ef3857af20d4da8961b 9c4438fb3a0e4606913877e72fc603b1--e994f4e30e084ef3857af20d4da8961b c4011df609b1460781aee338c55d2721 e994f4e30e084ef3857af20d4da8961b--c4011df609b1460781aee338c55d2721 2eab2b1f1b8e409899ec1bacb7d4c342 X c4011df609b1460781aee338c55d2721--2eab2b1f1b8e409899ec1bacb7d4c342 2eab2b1f1b8e409899ec1bacb7d4c342--e642e0224abc42be8ff334fe11768c2f 5e1f879dbb0141c38d09628a5993d3e6 2eab2b1f1b8e409899ec1bacb7d4c342--5e1f879dbb0141c38d09628a5993d3e6 676fc968ff5a4a268b47decf3bddeace 5e1f879dbb0141c38d09628a5993d3e6--676fc968ff5a4a268b47decf3bddeace 6427fea5e5074a1e9bbc2b2ff5b7656e 676fc968ff5a4a268b47decf3bddeace--6427fea5e5074a1e9bbc2b2ff5b7656e f06c973b4db541c39da085db9bc6d075 6427fea5e5074a1e9bbc2b2ff5b7656e--f06c973b4db541c39da085db9bc6d075 39580191eff64e168028a7da81544185 f06c973b4db541c39da085db9bc6d075--39580191eff64e168028a7da81544185 1599700b62c34577996ed7bf3d23c89b 39580191eff64e168028a7da81544185--1599700b62c34577996ed7bf3d23c89b 598b5fc9c3504fd593184f206370217b 1599700b62c34577996ed7bf3d23c89b--598b5fc9c3504fd593184f206370217b da73af69ceb349eba268ff743f5b2384 598b5fc9c3504fd593184f206370217b--da73af69ceb349eba268ff743f5b2384 0f90ba1a63204437bc5dcf43104fff90 da73af69ceb349eba268ff743f5b2384--0f90ba1a63204437bc5dcf43104fff90 302fac39af6b4c6d85bf339a618e3d98 0f90ba1a63204437bc5dcf43104fff90--302fac39af6b4c6d85bf339a618e3d98 013884d894584b79a4e9da3ad8fafbae 302fac39af6b4c6d85bf339a618e3d98--013884d894584b79a4e9da3ad8fafbae 9092ac79fcda4cd595bd415e8dc9894e X 013884d894584b79a4e9da3ad8fafbae--9092ac79fcda4cd595bd415e8dc9894e 9092ac79fcda4cd595bd415e8dc9894e--e64886099e9d4a0baac1d32deed026f9 c742f17320a343a7bfd691e77fd951d7 9092ac79fcda4cd595bd415e8dc9894e--c742f17320a343a7bfd691e77fd951d7 218bbb9867094ca8904605478f7644a8 X c742f17320a343a7bfd691e77fd951d7--218bbb9867094ca8904605478f7644a8 218bbb9867094ca8904605478f7644a8--948b05fb3f59484198f6ae8ec363bff9 6fc5b961720844f3a4a059d539f946fc RZ(-1.0*g0) 218bbb9867094ca8904605478f7644a8--6fc5b961720844f3a4a059d539f946fc a313e753ec76428caf2fffb953ac9174 X 6fc5b961720844f3a4a059d539f946fc--a313e753ec76428caf2fffb953ac9174 a313e753ec76428caf2fffb953ac9174--9ff56ece16334df284d659eef23633f4 546aeb5eda314cfb98147f507f880d59 a313e753ec76428caf2fffb953ac9174--546aeb5eda314cfb98147f507f880d59 31c12a9789b441b59205632a53e6fed6 546aeb5eda314cfb98147f507f880d59--31c12a9789b441b59205632a53e6fed6 88ac6990292247dfbead854909b33b2e 31c12a9789b441b59205632a53e6fed6--88ac6990292247dfbead854909b33b2e a476247ed33f414eab1e3780b9291708 88ac6990292247dfbead854909b33b2e--a476247ed33f414eab1e3780b9291708 443096b80ff34d0c92752ddb21951d88 a476247ed33f414eab1e3780b9291708--443096b80ff34d0c92752ddb21951d88 87fa2acf62434e36bac46fccc28127f1 443096b80ff34d0c92752ddb21951d88--87fa2acf62434e36bac46fccc28127f1 eec4a0c37999482a8aab3e9c236fd554 87fa2acf62434e36bac46fccc28127f1--eec4a0c37999482a8aab3e9c236fd554 5f82284a520e469ba37dc9e3bd1183f4 eec4a0c37999482a8aab3e9c236fd554--5f82284a520e469ba37dc9e3bd1183f4 b125e8a94a9d40fa92267f153ce31259 5f82284a520e469ba37dc9e3bd1183f4--b125e8a94a9d40fa92267f153ce31259 f1c3f97a785d451882779d17f36201b1 b125e8a94a9d40fa92267f153ce31259--f1c3f97a785d451882779d17f36201b1 002783e09eb34a129d11ae8dea06516d f1c3f97a785d451882779d17f36201b1--002783e09eb34a129d11ae8dea06516d dd5c37553b5844a7a3104273789d2d6f 002783e09eb34a129d11ae8dea06516d--dd5c37553b5844a7a3104273789d2d6f e799481c97764f3a9537c8b551f6ef9c dd5c37553b5844a7a3104273789d2d6f--e799481c97764f3a9537c8b551f6ef9c 5dedef6022c643dabebfff02a4d8ddaa e799481c97764f3a9537c8b551f6ef9c--5dedef6022c643dabebfff02a4d8ddaa 84e3bd584787441ab11e2093ecff03e2 5dedef6022c643dabebfff02a4d8ddaa--84e3bd584787441ab11e2093ecff03e2 00d368c31c474e5ab2edebf46dc2ed74 84e3bd584787441ab11e2093ecff03e2--00d368c31c474e5ab2edebf46dc2ed74 b17158d1c234426badc5af906de480be 00d368c31c474e5ab2edebf46dc2ed74--b17158d1c234426badc5af906de480be febd291f6c924de498e23a1f30626261 b17158d1c234426badc5af906de480be--febd291f6c924de498e23a1f30626261 d90a932271be47a0981f589f4a1596dc febd291f6c924de498e23a1f30626261--d90a932271be47a0981f589f4a1596dc a4150185a6804870b105b40e706b43ff d90a932271be47a0981f589f4a1596dc--a4150185a6804870b105b40e706b43ff bd0b3e93cab644f3b4b9f6aec2102002 a4150185a6804870b105b40e706b43ff--bd0b3e93cab644f3b4b9f6aec2102002 feef9c4c72c94c3b9002fd8644871db1 bd0b3e93cab644f3b4b9f6aec2102002--feef9c4c72c94c3b9002fd8644871db1 87039d988c6145018841cb91670e51d2 feef9c4c72c94c3b9002fd8644871db1--87039d988c6145018841cb91670e51d2 bcfd6bd878a14f17be4d5bc9bcaa68f9 87039d988c6145018841cb91670e51d2--bcfd6bd878a14f17be4d5bc9bcaa68f9 4bb2b9553f234a2b978dc8fdcc9c9125 bcfd6bd878a14f17be4d5bc9bcaa68f9--4bb2b9553f234a2b978dc8fdcc9c9125 d17e9e7ff22f409eb1e7948d1cc00bb1 4bb2b9553f234a2b978dc8fdcc9c9125--d17e9e7ff22f409eb1e7948d1cc00bb1 a492a41b6ed8434686a814fa5dec316b d17e9e7ff22f409eb1e7948d1cc00bb1--a492a41b6ed8434686a814fa5dec316b 32d6bcd094bc416d92ede01db0fc35f2 a492a41b6ed8434686a814fa5dec316b--32d6bcd094bc416d92ede01db0fc35f2 447e1a39924c442c9c29dff8d7494609 32d6bcd094bc416d92ede01db0fc35f2--447e1a39924c442c9c29dff8d7494609 dcdbd2067013429981e58199bf8d5c82 447e1a39924c442c9c29dff8d7494609--dcdbd2067013429981e58199bf8d5c82 7b65559a84cb43f3b1da33eb51a2cb27 dcdbd2067013429981e58199bf8d5c82--7b65559a84cb43f3b1da33eb51a2cb27 d97d887bba8f4d319da7d86723461a91 7b65559a84cb43f3b1da33eb51a2cb27--d97d887bba8f4d319da7d86723461a91 9e0c8c8d7a01432fac6a6759d9294d43 d97d887bba8f4d319da7d86723461a91--9e0c8c8d7a01432fac6a6759d9294d43 20b1927655004eec8edd56b4943ddc30 9e0c8c8d7a01432fac6a6759d9294d43--20b1927655004eec8edd56b4943ddc30 2101939c48fa4f43b5603feb2161e542 20b1927655004eec8edd56b4943ddc30--2101939c48fa4f43b5603feb2161e542 166b39af356744d893c4c0ad81f9c8d9 2101939c48fa4f43b5603feb2161e542--166b39af356744d893c4c0ad81f9c8d9 3421d9bbbec04c21baafeeb409df9af3 166b39af356744d893c4c0ad81f9c8d9--3421d9bbbec04c21baafeeb409df9af3 3d0ea7c6c4d44bcaa7c8e8270fba6c97 3421d9bbbec04c21baafeeb409df9af3--3d0ea7c6c4d44bcaa7c8e8270fba6c97 4cc0db24b22b4c39b5441b418ad7863c 3d0ea7c6c4d44bcaa7c8e8270fba6c97--4cc0db24b22b4c39b5441b418ad7863c a83fdd78096440c699ee7b5f27de305e 4cc0db24b22b4c39b5441b418ad7863c--a83fdd78096440c699ee7b5f27de305e 0767185188a84d07934ecc0981d2c9bc a83fdd78096440c699ee7b5f27de305e--0767185188a84d07934ecc0981d2c9bc 5b1f568723724ae7bdd73c53dffb7362 0767185188a84d07934ecc0981d2c9bc--5b1f568723724ae7bdd73c53dffb7362 986bd41927684b97b7036702da82f718 5b1f568723724ae7bdd73c53dffb7362--986bd41927684b97b7036702da82f718 fa37380a963447d79acd48b2472a226c 986bd41927684b97b7036702da82f718--fa37380a963447d79acd48b2472a226c 54452b38c641484ba3c2d8fec4dfa5dc fa37380a963447d79acd48b2472a226c--54452b38c641484ba3c2d8fec4dfa5dc c79c1e72835b4a97b9e469984d3d2dd7 54452b38c641484ba3c2d8fec4dfa5dc--c79c1e72835b4a97b9e469984d3d2dd7 5222829a53b2488985d07c935f635a7a c79c1e72835b4a97b9e469984d3d2dd7--5222829a53b2488985d07c935f635a7a a76cd97dfafb48af95e36f8ce1dddd70 5222829a53b2488985d07c935f635a7a--a76cd97dfafb48af95e36f8ce1dddd70 bc183d36ca8a4a87af3f613b673f3b82 RX(b02) a76cd97dfafb48af95e36f8ce1dddd70--bc183d36ca8a4a87af3f613b673f3b82 e184f05c600640b993d36ea307bcdb5b bc183d36ca8a4a87af3f613b673f3b82--e184f05c600640b993d36ea307bcdb5b 06fe73955303446ca20109c497aad875 X e184f05c600640b993d36ea307bcdb5b--06fe73955303446ca20109c497aad875 06fe73955303446ca20109c497aad875--e7044c70385d492081cfcb16a2d8c6c8 713af4968a2d49869c8cd1e40f38eff8 06fe73955303446ca20109c497aad875--713af4968a2d49869c8cd1e40f38eff8 7088bcf5dba3472f90599bd0a5faf449 713af4968a2d49869c8cd1e40f38eff8--7088bcf5dba3472f90599bd0a5faf449 d5394b89ee634d01b44d56ace0da08ce 7088bcf5dba3472f90599bd0a5faf449--d5394b89ee634d01b44d56ace0da08ce 5d71e72ef9994256b0ac7eb3276245e8 d5394b89ee634d01b44d56ace0da08ce--5d71e72ef9994256b0ac7eb3276245e8 07643fb68c314c51816f0a90d6a232be 5d71e72ef9994256b0ac7eb3276245e8--07643fb68c314c51816f0a90d6a232be 2c4cb9c25a4f492c8a9d0502646bbb46 07643fb68c314c51816f0a90d6a232be--2c4cb9c25a4f492c8a9d0502646bbb46 1c9838e95ab44217a20947bbac84a5de 2c4cb9c25a4f492c8a9d0502646bbb46--1c9838e95ab44217a20947bbac84a5de 1787850cbdec40099b2dc82b818cc3dc 1c9838e95ab44217a20947bbac84a5de--1787850cbdec40099b2dc82b818cc3dc 164ba81a69e44b43aa95b5eadafb00aa 1787850cbdec40099b2dc82b818cc3dc--164ba81a69e44b43aa95b5eadafb00aa 7e4a2600ea294c8bb214109f7585501c 164ba81a69e44b43aa95b5eadafb00aa--7e4a2600ea294c8bb214109f7585501c e0dc8b60ad074f5ca2913fe737966ca8 7e4a2600ea294c8bb214109f7585501c--e0dc8b60ad074f5ca2913fe737966ca8 1e543d10dd734f8a995449d7f0d0aaac X e0dc8b60ad074f5ca2913fe737966ca8--1e543d10dd734f8a995449d7f0d0aaac 1e543d10dd734f8a995449d7f0d0aaac--63d0e95d3d79441687b5bb3bf31f9aba d4ccfd3efc584ed89fe4cb9a0884851d 1e543d10dd734f8a995449d7f0d0aaac--d4ccfd3efc584ed89fe4cb9a0884851d 7a9dac37e913426faf48e1293a0b9b2d d4ccfd3efc584ed89fe4cb9a0884851d--7a9dac37e913426faf48e1293a0b9b2d 15d86b86e75e4a99b0cbb1f00ea12860 7a9dac37e913426faf48e1293a0b9b2d--15d86b86e75e4a99b0cbb1f00ea12860 babac7f6c64444dea30e93b09c2488aa 15d86b86e75e4a99b0cbb1f00ea12860--babac7f6c64444dea30e93b09c2488aa a9edee12e5a543d39a55f2fdfd4471ac babac7f6c64444dea30e93b09c2488aa--a9edee12e5a543d39a55f2fdfd4471ac 8fc77a0cefdc475bac2968cd3c7ee263 X a9edee12e5a543d39a55f2fdfd4471ac--8fc77a0cefdc475bac2968cd3c7ee263 8fc77a0cefdc475bac2968cd3c7ee263--5d7b56ac838449289204364d9b4788a2 ad42dface58f4d3bbec64c0dc720dda7 RZ(-1.0*g1) 8fc77a0cefdc475bac2968cd3c7ee263--ad42dface58f4d3bbec64c0dc720dda7 2edfb3d69f4e4f4b92c59f5575e1a3e3 X ad42dface58f4d3bbec64c0dc720dda7--2edfb3d69f4e4f4b92c59f5575e1a3e3 2edfb3d69f4e4f4b92c59f5575e1a3e3--b0a9867a5ad7405b830bde44359ee19e ff9f1fe58a06487f91264fe4893bbb76 2edfb3d69f4e4f4b92c59f5575e1a3e3--ff9f1fe58a06487f91264fe4893bbb76 55ec16bf5b554045af35b737b66cb50f ff9f1fe58a06487f91264fe4893bbb76--55ec16bf5b554045af35b737b66cb50f 447a089c325246aebbce37d082b3a477 X 55ec16bf5b554045af35b737b66cb50f--447a089c325246aebbce37d082b3a477 447a089c325246aebbce37d082b3a477--2ec344e3de814c2794f099cbd4a1fc53 e7cdf5e398ec40f7a45b61a67524a344 447a089c325246aebbce37d082b3a477--e7cdf5e398ec40f7a45b61a67524a344 f813928e385d47d6a21e18be3756d9a1 e7cdf5e398ec40f7a45b61a67524a344--f813928e385d47d6a21e18be3756d9a1 c101b43c807d42b0a4ded0dd739e84e0 f813928e385d47d6a21e18be3756d9a1--c101b43c807d42b0a4ded0dd739e84e0 9735dfd3c0ec4d4ba403fee7fa5717e5 c101b43c807d42b0a4ded0dd739e84e0--9735dfd3c0ec4d4ba403fee7fa5717e5 f1495b15cb034630901add5866eecaf0 9735dfd3c0ec4d4ba403fee7fa5717e5--f1495b15cb034630901add5866eecaf0 4a6213e5f7ad4320943435859cf7496c X f1495b15cb034630901add5866eecaf0--4a6213e5f7ad4320943435859cf7496c 4a6213e5f7ad4320943435859cf7496c--bf33f9c94fc5474ea8c7988bd9c027ba ee707a30b1b64e00a7aab6696abe5f92 4a6213e5f7ad4320943435859cf7496c--ee707a30b1b64e00a7aab6696abe5f92 e47ff61df0b04e838244eabd12efbb1f ee707a30b1b64e00a7aab6696abe5f92--e47ff61df0b04e838244eabd12efbb1f 27b25265ae5649ab9981f7e95413ec6e X e47ff61df0b04e838244eabd12efbb1f--27b25265ae5649ab9981f7e95413ec6e 27b25265ae5649ab9981f7e95413ec6e--725b0723f3aa4082abae80bc6b904240 68f32765b56c44e89f7924cd8fedc373 27b25265ae5649ab9981f7e95413ec6e--68f32765b56c44e89f7924cd8fedc373 e03627232b91446c86aa11f2853040f6 68f32765b56c44e89f7924cd8fedc373--e03627232b91446c86aa11f2853040f6 24e72af5efaf43e6a91e48d811ff1750 e03627232b91446c86aa11f2853040f6--24e72af5efaf43e6a91e48d811ff1750 f829a5e495cc404aa37a5e055bfcb836 24e72af5efaf43e6a91e48d811ff1750--f829a5e495cc404aa37a5e055bfcb836 db7828baf50e40c19efac3c83cafb2ba f829a5e495cc404aa37a5e055bfcb836--db7828baf50e40c19efac3c83cafb2ba 896a424269994732a3f7653333accb0b db7828baf50e40c19efac3c83cafb2ba--896a424269994732a3f7653333accb0b 8be473b798874072aaef725dc61e5162 896a424269994732a3f7653333accb0b--8be473b798874072aaef725dc61e5162 29cf6bdfb7c5429cbfe7dbe07a3f202f 8be473b798874072aaef725dc61e5162--29cf6bdfb7c5429cbfe7dbe07a3f202f e5960502c3924a9ab15736f86d9ea426 29cf6bdfb7c5429cbfe7dbe07a3f202f--e5960502c3924a9ab15736f86d9ea426 31b0b09ec7894a41afb55d058f281f5d e5960502c3924a9ab15736f86d9ea426--31b0b09ec7894a41afb55d058f281f5d b9ebdf3389744fb38256c00807cbdf91 31b0b09ec7894a41afb55d058f281f5d--b9ebdf3389744fb38256c00807cbdf91 c2d2215cdeeb4d08897e31714060876b X b9ebdf3389744fb38256c00807cbdf91--c2d2215cdeeb4d08897e31714060876b c2d2215cdeeb4d08897e31714060876b--2c81d6307c1b423eb59044aad21bc29c 876b002cd6d84885a7d18968dce322af c2d2215cdeeb4d08897e31714060876b--876b002cd6d84885a7d18968dce322af f3eb0732d00540aaaabc6644e40ec10b X 876b002cd6d84885a7d18968dce322af--f3eb0732d00540aaaabc6644e40ec10b f3eb0732d00540aaaabc6644e40ec10b--0ddcb9d98cf447e8addc32ef65157054 823d08f5eeb346d7babd879c52b0b74d RZ(-1.0*g1) f3eb0732d00540aaaabc6644e40ec10b--823d08f5eeb346d7babd879c52b0b74d 617075cbcba44df59f6131964721b299 X 823d08f5eeb346d7babd879c52b0b74d--617075cbcba44df59f6131964721b299 617075cbcba44df59f6131964721b299--127948a897054fc9a24e43d9479133f8 f90b680f36c949aeba1d0a4f00c9e93b 617075cbcba44df59f6131964721b299--f90b680f36c949aeba1d0a4f00c9e93b a8e6c41f7cad4eb2b63d2d921c3e6e23 f90b680f36c949aeba1d0a4f00c9e93b--a8e6c41f7cad4eb2b63d2d921c3e6e23 17fa40f3843048799f9301aead3fb1db a8e6c41f7cad4eb2b63d2d921c3e6e23--17fa40f3843048799f9301aead3fb1db 2a122f4cc9084f3a99c6bb142f5872a0 17fa40f3843048799f9301aead3fb1db--2a122f4cc9084f3a99c6bb142f5872a0 d76b23c5e9b6424d9743aee568a9659f 2a122f4cc9084f3a99c6bb142f5872a0--d76b23c5e9b6424d9743aee568a9659f a9827c9002c44eae9d0f456cd386bd5d d76b23c5e9b6424d9743aee568a9659f--a9827c9002c44eae9d0f456cd386bd5d ea68121fc8554790886b285151c0c808 a9827c9002c44eae9d0f456cd386bd5d--ea68121fc8554790886b285151c0c808 cbd04859fb6f4724b7abc2a3bb920143 ea68121fc8554790886b285151c0c808--cbd04859fb6f4724b7abc2a3bb920143 4ba3e48eafa942c1b488de523ccd98f6 cbd04859fb6f4724b7abc2a3bb920143--4ba3e48eafa942c1b488de523ccd98f6 aee8f29651a44de899bc677898c2dff7 4ba3e48eafa942c1b488de523ccd98f6--aee8f29651a44de899bc677898c2dff7 ed36902cc3f14d54925cb90f99383047 aee8f29651a44de899bc677898c2dff7--ed36902cc3f14d54925cb90f99383047 73a5468f7d9d4541ac95f30344852e86 ed36902cc3f14d54925cb90f99383047--73a5468f7d9d4541ac95f30344852e86 7939e907720e49e5b7aa7bcadea31164 73a5468f7d9d4541ac95f30344852e86--7939e907720e49e5b7aa7bcadea31164 7102e3a49f324b59b7ca4055a43a0701 7939e907720e49e5b7aa7bcadea31164--7102e3a49f324b59b7ca4055a43a0701 587422249db4484cb5f6f5aeccf137d1 7102e3a49f324b59b7ca4055a43a0701--587422249db4484cb5f6f5aeccf137d1 ed210240085a418f8613f255f0de13e3 587422249db4484cb5f6f5aeccf137d1--ed210240085a418f8613f255f0de13e3 4271aacae58c4d249d3319554d4a2a7c ed210240085a418f8613f255f0de13e3--4271aacae58c4d249d3319554d4a2a7c 12c1f871fe0f498080ee53d66afc08cb 4271aacae58c4d249d3319554d4a2a7c--12c1f871fe0f498080ee53d66afc08cb 2ccacf18cfa64465bf5fb8ecd942e4dc 12c1f871fe0f498080ee53d66afc08cb--2ccacf18cfa64465bf5fb8ecd942e4dc 245e1a13acae42e08a8332bc2c863e3a 2ccacf18cfa64465bf5fb8ecd942e4dc--245e1a13acae42e08a8332bc2c863e3a 8eae49b59bf9403fb9b1a420cf400d04 245e1a13acae42e08a8332bc2c863e3a--8eae49b59bf9403fb9b1a420cf400d04 46dfc1e0a7124e0cbc7e6423a36455c0 8eae49b59bf9403fb9b1a420cf400d04--46dfc1e0a7124e0cbc7e6423a36455c0 0b762ca4b868474888c78fdbca061f14 46dfc1e0a7124e0cbc7e6423a36455c0--0b762ca4b868474888c78fdbca061f14 897e32edd5e14b798955e263924dba56 0b762ca4b868474888c78fdbca061f14--897e32edd5e14b798955e263924dba56 3b184c3ac6c54666bfdda9846145cfcf 897e32edd5e14b798955e263924dba56--3b184c3ac6c54666bfdda9846145cfcf 9563181b299f40a6846c5b9764fe0df7 3b184c3ac6c54666bfdda9846145cfcf--9563181b299f40a6846c5b9764fe0df7 6d1a0c8afefd4f268a13915f9b75095c 9563181b299f40a6846c5b9764fe0df7--6d1a0c8afefd4f268a13915f9b75095c 8c7892eae4d64f0eb2503e0114e93590 6d1a0c8afefd4f268a13915f9b75095c--8c7892eae4d64f0eb2503e0114e93590 33be98201b53434ab4d9e249a238143c 8c7892eae4d64f0eb2503e0114e93590--33be98201b53434ab4d9e249a238143c cd76ae488e9c4ddb9ab4d40deff1e73e 33be98201b53434ab4d9e249a238143c--cd76ae488e9c4ddb9ab4d40deff1e73e 884d0326674948679b018e9ed2a8af20 cd76ae488e9c4ddb9ab4d40deff1e73e--884d0326674948679b018e9ed2a8af20 b28cac4d061b4384aecd2386ba604989 884d0326674948679b018e9ed2a8af20--b28cac4d061b4384aecd2386ba604989 541efeeee5524f35be5b1d4d8c9bad33 b28cac4d061b4384aecd2386ba604989--541efeeee5524f35be5b1d4d8c9bad33 93524e809f6f47ffa76e795c018b8e78 541efeeee5524f35be5b1d4d8c9bad33--93524e809f6f47ffa76e795c018b8e78 e0639053fe0142cba6a2cb725f7cb6e0 93524e809f6f47ffa76e795c018b8e78--e0639053fe0142cba6a2cb725f7cb6e0 52c223b0e8964788b2f43566afd7adda e0639053fe0142cba6a2cb725f7cb6e0--52c223b0e8964788b2f43566afd7adda efb9134d865148049cde54f7dd957516 52c223b0e8964788b2f43566afd7adda--efb9134d865148049cde54f7dd957516 5db6eb9d060240c2ab9fbc66a611ba0d efb9134d865148049cde54f7dd957516--5db6eb9d060240c2ab9fbc66a611ba0d 07810991ef344d4c939878913dd927e3 5db6eb9d060240c2ab9fbc66a611ba0d--07810991ef344d4c939878913dd927e3 06d251fb6eef47668872f60bc1c67d86 07810991ef344d4c939878913dd927e3--06d251fb6eef47668872f60bc1c67d86 367c866fe108478cb436b8173e440963 06d251fb6eef47668872f60bc1c67d86--367c866fe108478cb436b8173e440963 08831254f82143e89335d3ea51a17edb 367c866fe108478cb436b8173e440963--08831254f82143e89335d3ea51a17edb f163213a217948d18d66b360f9628624 08831254f82143e89335d3ea51a17edb--f163213a217948d18d66b360f9628624 538dfa6dd44f4bd59ea13062d973ced3 f163213a217948d18d66b360f9628624--538dfa6dd44f4bd59ea13062d973ced3 47727432bac74879a8c4b3454e1bd899 538dfa6dd44f4bd59ea13062d973ced3--47727432bac74879a8c4b3454e1bd899 d1dc9f9b2fcf4d468252c4fddd9bd99e 47727432bac74879a8c4b3454e1bd899--d1dc9f9b2fcf4d468252c4fddd9bd99e 8091ad66610d4a27905a7a4186b9d492 d1dc9f9b2fcf4d468252c4fddd9bd99e--8091ad66610d4a27905a7a4186b9d492 a9d533bdc4604a83ae998d4a85b0c766 8091ad66610d4a27905a7a4186b9d492--a9d533bdc4604a83ae998d4a85b0c766 4701128b1437475abf02e58768b43ad7 RX(b12) a9d533bdc4604a83ae998d4a85b0c766--4701128b1437475abf02e58768b43ad7 4701128b1437475abf02e58768b43ad7--305e7c87c5844c9ea64edc6b252477bb b66dd9e79ff3439b981a99ced76ac437 4c0a5145662940bd98260656090d0419 30e0a71e41d849c8be54ec28540fd30d--4c0a5145662940bd98260656090d0419 febd850ecb294788954bbbf43df95469 4 5666ca7a14164a85b66d3ad7a8eeec72 4c0a5145662940bd98260656090d0419--5666ca7a14164a85b66d3ad7a8eeec72 f98984e7b1fd40d5b6d8721c515025a2 X 5666ca7a14164a85b66d3ad7a8eeec72--f98984e7b1fd40d5b6d8721c515025a2 f98984e7b1fd40d5b6d8721c515025a2--c143f1390d4b4219a9ac838db0e275c1 282a431eefb94c9291360d999110643a f98984e7b1fd40d5b6d8721c515025a2--282a431eefb94c9291360d999110643a 9060289f5e3441c5b6532fb1ccc983d6 282a431eefb94c9291360d999110643a--9060289f5e3441c5b6532fb1ccc983d6 e9c0ab0c1d05406cb97b65137a09b5cb 9060289f5e3441c5b6532fb1ccc983d6--e9c0ab0c1d05406cb97b65137a09b5cb cf5b09bed46d477889441f69ec871424 e9c0ab0c1d05406cb97b65137a09b5cb--cf5b09bed46d477889441f69ec871424 1680f1cf584241539015e00f2da55c85 cf5b09bed46d477889441f69ec871424--1680f1cf584241539015e00f2da55c85 d7a9bdfe7e3d442f9eb294dbb51e3d4c 1680f1cf584241539015e00f2da55c85--d7a9bdfe7e3d442f9eb294dbb51e3d4c 724087af04794e9e9a27250862984d4c d7a9bdfe7e3d442f9eb294dbb51e3d4c--724087af04794e9e9a27250862984d4c 09ebd3860c6b4f748f93feef3370353f 724087af04794e9e9a27250862984d4c--09ebd3860c6b4f748f93feef3370353f 64c9d301d94c440ab0ecf62c9a34f2cf 09ebd3860c6b4f748f93feef3370353f--64c9d301d94c440ab0ecf62c9a34f2cf 7d8a31998cee46e2bd9ea271810255a9 X 64c9d301d94c440ab0ecf62c9a34f2cf--7d8a31998cee46e2bd9ea271810255a9 7d8a31998cee46e2bd9ea271810255a9--b48268ba510e4611a24191893e05d5af 66494f623ecc4f6ea999b881251f231d 7d8a31998cee46e2bd9ea271810255a9--66494f623ecc4f6ea999b881251f231d cfe3a3ecd48f439fb151058980332882 66494f623ecc4f6ea999b881251f231d--cfe3a3ecd48f439fb151058980332882 97001c0c9b684984832412dc9d1104ae cfe3a3ecd48f439fb151058980332882--97001c0c9b684984832412dc9d1104ae 8146f4f4a2ec4e03b840458fc059d6c2 97001c0c9b684984832412dc9d1104ae--8146f4f4a2ec4e03b840458fc059d6c2 8ad7b81bbf104202bc5368ff9d5f91b6 8146f4f4a2ec4e03b840458fc059d6c2--8ad7b81bbf104202bc5368ff9d5f91b6 1b0546e1edc840e49673116891a81d3e 8ad7b81bbf104202bc5368ff9d5f91b6--1b0546e1edc840e49673116891a81d3e 5bd1a7ec5f1e46338fda8c216d863c2a 1b0546e1edc840e49673116891a81d3e--5bd1a7ec5f1e46338fda8c216d863c2a c65592ce6b324d208fd3cfaecf78a714 5bd1a7ec5f1e46338fda8c216d863c2a--c65592ce6b324d208fd3cfaecf78a714 d21991d3860e4034bd300ca7912e3096 c65592ce6b324d208fd3cfaecf78a714--d21991d3860e4034bd300ca7912e3096 3aa8a669f9e74fb795836c55bd1a5415 d21991d3860e4034bd300ca7912e3096--3aa8a669f9e74fb795836c55bd1a5415 65ca9ece85774ee9b6eb53a693a76f8b 3aa8a669f9e74fb795836c55bd1a5415--65ca9ece85774ee9b6eb53a693a76f8b de19ca55a9fb4929819861942bdbd0c9 65ca9ece85774ee9b6eb53a693a76f8b--de19ca55a9fb4929819861942bdbd0c9 945c52b11fae4765a579babad3a070d3 X de19ca55a9fb4929819861942bdbd0c9--945c52b11fae4765a579babad3a070d3 945c52b11fae4765a579babad3a070d3--8157e936a2024896ab5a217b5e74ce59 40b57080a71c4a10b2405602caea27c7 945c52b11fae4765a579babad3a070d3--40b57080a71c4a10b2405602caea27c7 8e57d844fd9c42b8b387d8d527126d42 40b57080a71c4a10b2405602caea27c7--8e57d844fd9c42b8b387d8d527126d42 2f2129e0aa7e4e2090996cb451c4f1f9 8e57d844fd9c42b8b387d8d527126d42--2f2129e0aa7e4e2090996cb451c4f1f9 44a771614b964f83992ae89fc4d43455 X 2f2129e0aa7e4e2090996cb451c4f1f9--44a771614b964f83992ae89fc4d43455 44a771614b964f83992ae89fc4d43455--c75fed020e5d481cb3db8dbae47afa7f f47949756c7c4d8696a90ebf7b1ed1a1 44a771614b964f83992ae89fc4d43455--f47949756c7c4d8696a90ebf7b1ed1a1 4322e94534374b0d851cf034654c3b14 f47949756c7c4d8696a90ebf7b1ed1a1--4322e94534374b0d851cf034654c3b14 b1b7de535e2c4f1baab5d7d7d5365afd 4322e94534374b0d851cf034654c3b14--b1b7de535e2c4f1baab5d7d7d5365afd b5215da0b78c406c85e82cdd12343d97 b1b7de535e2c4f1baab5d7d7d5365afd--b5215da0b78c406c85e82cdd12343d97 e3c6dace7fce402190d38a69c3cc1388 X b5215da0b78c406c85e82cdd12343d97--e3c6dace7fce402190d38a69c3cc1388 e3c6dace7fce402190d38a69c3cc1388--5e1f879dbb0141c38d09628a5993d3e6 1deff453fba94b89ad9111e1fcf09a4a e3c6dace7fce402190d38a69c3cc1388--1deff453fba94b89ad9111e1fcf09a4a c7bfe7a9e1d341f09af14b0d873d04d8 1deff453fba94b89ad9111e1fcf09a4a--c7bfe7a9e1d341f09af14b0d873d04d8 63528296a8cf4199be2a37368a7aece6 c7bfe7a9e1d341f09af14b0d873d04d8--63528296a8cf4199be2a37368a7aece6 96644851877b43818a1403eca7300e1a 63528296a8cf4199be2a37368a7aece6--96644851877b43818a1403eca7300e1a 09c201b0058b4896a035ca2f6874c6d1 96644851877b43818a1403eca7300e1a--09c201b0058b4896a035ca2f6874c6d1 525f203ec8c14cb088258c6f20dc8d8d 09c201b0058b4896a035ca2f6874c6d1--525f203ec8c14cb088258c6f20dc8d8d 7b6bab8720f04cc29d74a621fd6042d6 525f203ec8c14cb088258c6f20dc8d8d--7b6bab8720f04cc29d74a621fd6042d6 748e55fb779a4cccbfee00a9f5feff72 7b6bab8720f04cc29d74a621fd6042d6--748e55fb779a4cccbfee00a9f5feff72 bbfbca5bb73f4d1a8092aff04d3b131d 748e55fb779a4cccbfee00a9f5feff72--bbfbca5bb73f4d1a8092aff04d3b131d 11ef55e5e29946bc92b125b4d33feb96 X bbfbca5bb73f4d1a8092aff04d3b131d--11ef55e5e29946bc92b125b4d33feb96 11ef55e5e29946bc92b125b4d33feb96--013884d894584b79a4e9da3ad8fafbae 94020e856ccb4a3881727542df3f692c 11ef55e5e29946bc92b125b4d33feb96--94020e856ccb4a3881727542df3f692c c51ff4e16b66424b9dd502d48a553c56 94020e856ccb4a3881727542df3f692c--c51ff4e16b66424b9dd502d48a553c56 7ee545d5722549e6ae96ce31b1e4d8c3 c51ff4e16b66424b9dd502d48a553c56--7ee545d5722549e6ae96ce31b1e4d8c3 2db7cda6c9fa47a69d2403c9a81779e0 7ee545d5722549e6ae96ce31b1e4d8c3--2db7cda6c9fa47a69d2403c9a81779e0 a331883a25b64e239672c8b2bb41ee23 2db7cda6c9fa47a69d2403c9a81779e0--a331883a25b64e239672c8b2bb41ee23 893be1aaddb9488fae9e018084db26a5 X a331883a25b64e239672c8b2bb41ee23--893be1aaddb9488fae9e018084db26a5 893be1aaddb9488fae9e018084db26a5--546aeb5eda314cfb98147f507f880d59 4ec8062d72f543f4a74a5bcc25d1cfdb 893be1aaddb9488fae9e018084db26a5--4ec8062d72f543f4a74a5bcc25d1cfdb 64333e642fbc48cf861a5f0995b23bc9 4ec8062d72f543f4a74a5bcc25d1cfdb--64333e642fbc48cf861a5f0995b23bc9 6b3911b9eae542b5bb6edb905880f340 64333e642fbc48cf861a5f0995b23bc9--6b3911b9eae542b5bb6edb905880f340 7f591e99da56471d98764e6cfde90e60 X 6b3911b9eae542b5bb6edb905880f340--7f591e99da56471d98764e6cfde90e60 7f591e99da56471d98764e6cfde90e60--443096b80ff34d0c92752ddb21951d88 8076e0c8711d472f992999b1c321e128 X 7f591e99da56471d98764e6cfde90e60--8076e0c8711d472f992999b1c321e128 8076e0c8711d472f992999b1c321e128--87fa2acf62434e36bac46fccc28127f1 f46e481dd4ae4b6b9cfe7cd09494a5e1 8076e0c8711d472f992999b1c321e128--f46e481dd4ae4b6b9cfe7cd09494a5e1 833aaa073410447d8e40bc1911a07755 f46e481dd4ae4b6b9cfe7cd09494a5e1--833aaa073410447d8e40bc1911a07755 cdc85eb0aff343638bbfd302d80eab26 833aaa073410447d8e40bc1911a07755--cdc85eb0aff343638bbfd302d80eab26 16cb8ed8866c43ce999ec69b8b7e675e cdc85eb0aff343638bbfd302d80eab26--16cb8ed8866c43ce999ec69b8b7e675e db0236557c55412a9b39b3b326d0eef6 16cb8ed8866c43ce999ec69b8b7e675e--db0236557c55412a9b39b3b326d0eef6 e374ebd809b640a1b804537ae0dd8453 db0236557c55412a9b39b3b326d0eef6--e374ebd809b640a1b804537ae0dd8453 b4c9d7a38e894718952a412101000404 e374ebd809b640a1b804537ae0dd8453--b4c9d7a38e894718952a412101000404 389c1d15f699431cb566543c633dff09 X b4c9d7a38e894718952a412101000404--389c1d15f699431cb566543c633dff09 389c1d15f699431cb566543c633dff09--5dedef6022c643dabebfff02a4d8ddaa 19c465f22e994ab6ae409b574d1a127b X 389c1d15f699431cb566543c633dff09--19c465f22e994ab6ae409b574d1a127b 19c465f22e994ab6ae409b574d1a127b--84e3bd584787441ab11e2093ecff03e2 515f91bfa5b042f98cfc919578c87495 19c465f22e994ab6ae409b574d1a127b--515f91bfa5b042f98cfc919578c87495 a3a7d185850f49818eb50fb3265193b7 515f91bfa5b042f98cfc919578c87495--a3a7d185850f49818eb50fb3265193b7 8829491b62ca467bb000e6f8db5dea88 a3a7d185850f49818eb50fb3265193b7--8829491b62ca467bb000e6f8db5dea88 b4e25a3bc53749df9f40b8346c6c0a3e 8829491b62ca467bb000e6f8db5dea88--b4e25a3bc53749df9f40b8346c6c0a3e 1d8235f8f1bc4f23958a46737760033d b4e25a3bc53749df9f40b8346c6c0a3e--1d8235f8f1bc4f23958a46737760033d dec1b33e6fb14e8fb2181a61bbc353b6 1d8235f8f1bc4f23958a46737760033d--dec1b33e6fb14e8fb2181a61bbc353b6 62d093f088bd4f24b11b6570d95ed586 dec1b33e6fb14e8fb2181a61bbc353b6--62d093f088bd4f24b11b6570d95ed586 5ce466a429a949678bb78e9217f4c80c 62d093f088bd4f24b11b6570d95ed586--5ce466a429a949678bb78e9217f4c80c 3e83217bdee84071bb38e550f3af2b3b 5ce466a429a949678bb78e9217f4c80c--3e83217bdee84071bb38e550f3af2b3b 73a286ff8db842b5bb5e59b133910643 X 3e83217bdee84071bb38e550f3af2b3b--73a286ff8db842b5bb5e59b133910643 73a286ff8db842b5bb5e59b133910643--4bb2b9553f234a2b978dc8fdcc9c9125 43e40ee7419248ae8fb0bb0e2736ac81 73a286ff8db842b5bb5e59b133910643--43e40ee7419248ae8fb0bb0e2736ac81 e6d2ce3702a247d28d52209d4e9ff35c 43e40ee7419248ae8fb0bb0e2736ac81--e6d2ce3702a247d28d52209d4e9ff35c 48f16a8d4ab143cd9a00234b0f6a4068 e6d2ce3702a247d28d52209d4e9ff35c--48f16a8d4ab143cd9a00234b0f6a4068 14f95277c31842dc8668b362e3bb8b84 48f16a8d4ab143cd9a00234b0f6a4068--14f95277c31842dc8668b362e3bb8b84 e4fb3b1e05fa4b509bf266b7fbe584de 14f95277c31842dc8668b362e3bb8b84--e4fb3b1e05fa4b509bf266b7fbe584de 1cd18f8491fd42dfb3ca9e353ce1006a e4fb3b1e05fa4b509bf266b7fbe584de--1cd18f8491fd42dfb3ca9e353ce1006a 30762f7af4484f71ae944a9ccaa0d86d 1cd18f8491fd42dfb3ca9e353ce1006a--30762f7af4484f71ae944a9ccaa0d86d c806a5856e9c498c9e690fc7bd88908b 30762f7af4484f71ae944a9ccaa0d86d--c806a5856e9c498c9e690fc7bd88908b fd103c4c6e414d14817aeb619be0b6ab c806a5856e9c498c9e690fc7bd88908b--fd103c4c6e414d14817aeb619be0b6ab 5ad9ae5496fe40df8038d604d345a511 fd103c4c6e414d14817aeb619be0b6ab--5ad9ae5496fe40df8038d604d345a511 046f388523544895b30f2dffd4d75ed6 5ad9ae5496fe40df8038d604d345a511--046f388523544895b30f2dffd4d75ed6 fbf3ff19bac44ebba3abd3ef3ef3fb89 046f388523544895b30f2dffd4d75ed6--fbf3ff19bac44ebba3abd3ef3ef3fb89 59a7435397374ab5b74ba6ed0c4c3904 fbf3ff19bac44ebba3abd3ef3ef3fb89--59a7435397374ab5b74ba6ed0c4c3904 8461a3a5d39a47cf94d089d3ef533512 59a7435397374ab5b74ba6ed0c4c3904--8461a3a5d39a47cf94d089d3ef533512 693f460b4c6144dfa6b0f395dc9ccc57 8461a3a5d39a47cf94d089d3ef533512--693f460b4c6144dfa6b0f395dc9ccc57 13d031b8646045ac8af2a988d0ad749b 693f460b4c6144dfa6b0f395dc9ccc57--13d031b8646045ac8af2a988d0ad749b 9a9a9826b2304a81a1c1cf99aa18d0c0 13d031b8646045ac8af2a988d0ad749b--9a9a9826b2304a81a1c1cf99aa18d0c0 93a2f75ae1e04aa7b3c933c8fe5ec108 9a9a9826b2304a81a1c1cf99aa18d0c0--93a2f75ae1e04aa7b3c933c8fe5ec108 4b0633547c0e409b98ec2c70033959f2 93a2f75ae1e04aa7b3c933c8fe5ec108--4b0633547c0e409b98ec2c70033959f2 b9df5cb6749f40fa9e542de8440f429b 4b0633547c0e409b98ec2c70033959f2--b9df5cb6749f40fa9e542de8440f429b 640e2f7600074bad830fa3c92358113a b9df5cb6749f40fa9e542de8440f429b--640e2f7600074bad830fa3c92358113a 6dd83aff91d1491e8719feaa3768adbd 640e2f7600074bad830fa3c92358113a--6dd83aff91d1491e8719feaa3768adbd 98520b7d1fb6478bb12ef1de0295a2ba 6dd83aff91d1491e8719feaa3768adbd--98520b7d1fb6478bb12ef1de0295a2ba 97d17ab797ee41fd827668b7cb301137 RX(b03) 98520b7d1fb6478bb12ef1de0295a2ba--97d17ab797ee41fd827668b7cb301137 1cbd4907fc514df1bc5a3d9ec2d09980 97d17ab797ee41fd827668b7cb301137--1cbd4907fc514df1bc5a3d9ec2d09980 8e84d0d0f0d944a8ba5aa81963a59c60 1cbd4907fc514df1bc5a3d9ec2d09980--8e84d0d0f0d944a8ba5aa81963a59c60 7e9b4e1ce4524b0d87075bb3e4199a4c X 8e84d0d0f0d944a8ba5aa81963a59c60--7e9b4e1ce4524b0d87075bb3e4199a4c 7e9b4e1ce4524b0d87075bb3e4199a4c--713af4968a2d49869c8cd1e40f38eff8 d1a4d8b37b974d6d9ab20480d78817c1 7e9b4e1ce4524b0d87075bb3e4199a4c--d1a4d8b37b974d6d9ab20480d78817c1 a1ff533116e348b5b04c33b9ec0daed9 d1a4d8b37b974d6d9ab20480d78817c1--a1ff533116e348b5b04c33b9ec0daed9 52863648402f46f6a450bc370bcf506b a1ff533116e348b5b04c33b9ec0daed9--52863648402f46f6a450bc370bcf506b 3030d8bd095a4239b54a8b906b374f96 52863648402f46f6a450bc370bcf506b--3030d8bd095a4239b54a8b906b374f96 0f5fb3db1bbc41549fe0cfec2e8c0c4e 3030d8bd095a4239b54a8b906b374f96--0f5fb3db1bbc41549fe0cfec2e8c0c4e 11314778e48f4266a70c311f691936a0 0f5fb3db1bbc41549fe0cfec2e8c0c4e--11314778e48f4266a70c311f691936a0 c5c447b389474b9fa64863665e94d05f 11314778e48f4266a70c311f691936a0--c5c447b389474b9fa64863665e94d05f b3d303c3c11a45baaa00078767ea3dc8 c5c447b389474b9fa64863665e94d05f--b3d303c3c11a45baaa00078767ea3dc8 d6713eb7e4c54cfb9863b4081d14859a b3d303c3c11a45baaa00078767ea3dc8--d6713eb7e4c54cfb9863b4081d14859a 453a7634a2a34614b726e3de5242103d X d6713eb7e4c54cfb9863b4081d14859a--453a7634a2a34614b726e3de5242103d 453a7634a2a34614b726e3de5242103d--e0dc8b60ad074f5ca2913fe737966ca8 e887f199c8094732a5c4f8ab0df3004f 453a7634a2a34614b726e3de5242103d--e887f199c8094732a5c4f8ab0df3004f d6ee19d1ec044e2f8e33cf799bb72a67 e887f199c8094732a5c4f8ab0df3004f--d6ee19d1ec044e2f8e33cf799bb72a67 626d0bfb1bdc481ab1afe08011ea8aa4 d6ee19d1ec044e2f8e33cf799bb72a67--626d0bfb1bdc481ab1afe08011ea8aa4 4dc32486ab7b403b99bafa734026def4 626d0bfb1bdc481ab1afe08011ea8aa4--4dc32486ab7b403b99bafa734026def4 d5e541d857494d498498cd9bb496afa8 4dc32486ab7b403b99bafa734026def4--d5e541d857494d498498cd9bb496afa8 2633ff21132840ab97912ebc66ccbbb7 d5e541d857494d498498cd9bb496afa8--2633ff21132840ab97912ebc66ccbbb7 61068406a1f3467cbb11c2cb6b81ede8 2633ff21132840ab97912ebc66ccbbb7--61068406a1f3467cbb11c2cb6b81ede8 d0be2a70250149cda1c8bc06e6e3c99b 61068406a1f3467cbb11c2cb6b81ede8--d0be2a70250149cda1c8bc06e6e3c99b 80b8deed21b240d6b3969f30c1c090f5 d0be2a70250149cda1c8bc06e6e3c99b--80b8deed21b240d6b3969f30c1c090f5 b84f09195b11472aa42362f830e390cc 80b8deed21b240d6b3969f30c1c090f5--b84f09195b11472aa42362f830e390cc e5e22c29ccd54c599855ac575a1c861a b84f09195b11472aa42362f830e390cc--e5e22c29ccd54c599855ac575a1c861a a326119c33994ce4a05b383607db1e3a e5e22c29ccd54c599855ac575a1c861a--a326119c33994ce4a05b383607db1e3a ccbdff348fe242c797390fef9035311b X a326119c33994ce4a05b383607db1e3a--ccbdff348fe242c797390fef9035311b ccbdff348fe242c797390fef9035311b--e7cdf5e398ec40f7a45b61a67524a344 cdf38056dfb44c9e8ce362a6fbc9258a ccbdff348fe242c797390fef9035311b--cdf38056dfb44c9e8ce362a6fbc9258a 806d3a8f4ebf450c9b136fec8f004261 cdf38056dfb44c9e8ce362a6fbc9258a--806d3a8f4ebf450c9b136fec8f004261 cde184e5d57c4bd286e2e9354fced178 806d3a8f4ebf450c9b136fec8f004261--cde184e5d57c4bd286e2e9354fced178 4b5aa4816e934477bdd8ec723b9e1632 X cde184e5d57c4bd286e2e9354fced178--4b5aa4816e934477bdd8ec723b9e1632 4b5aa4816e934477bdd8ec723b9e1632--f1495b15cb034630901add5866eecaf0 7cadd2cc5a4e463c97a8fd942cd24cd6 4b5aa4816e934477bdd8ec723b9e1632--7cadd2cc5a4e463c97a8fd942cd24cd6 865907acb4b44918adbc706b8e539eae 7cadd2cc5a4e463c97a8fd942cd24cd6--865907acb4b44918adbc706b8e539eae 62ad7dad74a74545a8245834f951091f 865907acb4b44918adbc706b8e539eae--62ad7dad74a74545a8245834f951091f 354aa2d1e3e14612afb897f3d6d6c674 62ad7dad74a74545a8245834f951091f--354aa2d1e3e14612afb897f3d6d6c674 8fdcc82482084ec8b008c8ed6665476b X 354aa2d1e3e14612afb897f3d6d6c674--8fdcc82482084ec8b008c8ed6665476b 8fdcc82482084ec8b008c8ed6665476b--68f32765b56c44e89f7924cd8fedc373 9f697a0b3e3e4bba913245a20c0d6a79 8fdcc82482084ec8b008c8ed6665476b--9f697a0b3e3e4bba913245a20c0d6a79 97a3f633b02e423a868dfb2bdf41c14c 9f697a0b3e3e4bba913245a20c0d6a79--97a3f633b02e423a868dfb2bdf41c14c 5e7e56375c94475b9ae6cda2408538df 97a3f633b02e423a868dfb2bdf41c14c--5e7e56375c94475b9ae6cda2408538df 6edca7aac65e4820a9e7b79d96e4101c 5e7e56375c94475b9ae6cda2408538df--6edca7aac65e4820a9e7b79d96e4101c c949568d18774b358fc7a4b837b79aba 6edca7aac65e4820a9e7b79d96e4101c--c949568d18774b358fc7a4b837b79aba 3d338b0fe7724ac799c7c4e42219f5b2 c949568d18774b358fc7a4b837b79aba--3d338b0fe7724ac799c7c4e42219f5b2 075b8fe406ce4c58a059636ea9379975 3d338b0fe7724ac799c7c4e42219f5b2--075b8fe406ce4c58a059636ea9379975 e1a4e6a205684b3fa00430d879bf2fbe 075b8fe406ce4c58a059636ea9379975--e1a4e6a205684b3fa00430d879bf2fbe 144bf0e6ddc14a2da59bcb4687793d7f e1a4e6a205684b3fa00430d879bf2fbe--144bf0e6ddc14a2da59bcb4687793d7f 0cdcc30aad7043b7aa2bceb96ff4dd72 X 144bf0e6ddc14a2da59bcb4687793d7f--0cdcc30aad7043b7aa2bceb96ff4dd72 0cdcc30aad7043b7aa2bceb96ff4dd72--b9ebdf3389744fb38256c00807cbdf91 926c22833d5548d481cc67856178d150 0cdcc30aad7043b7aa2bceb96ff4dd72--926c22833d5548d481cc67856178d150 7b6c2592b51a4930aecc00b62bddde58 926c22833d5548d481cc67856178d150--7b6c2592b51a4930aecc00b62bddde58 15b3ffa44c5a4da4b177cb7c3c6b6faf 7b6c2592b51a4930aecc00b62bddde58--15b3ffa44c5a4da4b177cb7c3c6b6faf 4a7dee2cc9e2463e846df623920269c4 15b3ffa44c5a4da4b177cb7c3c6b6faf--4a7dee2cc9e2463e846df623920269c4 a41901e7a1a34edbb1d3f0716bb3ffda 4a7dee2cc9e2463e846df623920269c4--a41901e7a1a34edbb1d3f0716bb3ffda 1a91beb929aa4ca7b47233efe0db5321 X a41901e7a1a34edbb1d3f0716bb3ffda--1a91beb929aa4ca7b47233efe0db5321 1a91beb929aa4ca7b47233efe0db5321--f90b680f36c949aeba1d0a4f00c9e93b 1232f6a3d2e04eacbeabb25d96d37ea6 1a91beb929aa4ca7b47233efe0db5321--1232f6a3d2e04eacbeabb25d96d37ea6 82981277553740caa9f12336e35b4444 1232f6a3d2e04eacbeabb25d96d37ea6--82981277553740caa9f12336e35b4444 81f3f161c67e4048944277ffe8829d13 82981277553740caa9f12336e35b4444--81f3f161c67e4048944277ffe8829d13 beefdde8f9bd4722beb5b80f2db80d9a X 81f3f161c67e4048944277ffe8829d13--beefdde8f9bd4722beb5b80f2db80d9a beefdde8f9bd4722beb5b80f2db80d9a--d76b23c5e9b6424d9743aee568a9659f 9089cb1e61b64effa4c92844ebfa42f3 X beefdde8f9bd4722beb5b80f2db80d9a--9089cb1e61b64effa4c92844ebfa42f3 9089cb1e61b64effa4c92844ebfa42f3--a9827c9002c44eae9d0f456cd386bd5d 2ead22151bbe4cf381e9e34b73f69eed 9089cb1e61b64effa4c92844ebfa42f3--2ead22151bbe4cf381e9e34b73f69eed 7935571857434f0a8325d4d77d490c50 2ead22151bbe4cf381e9e34b73f69eed--7935571857434f0a8325d4d77d490c50 976235ea4afb42a18cce06b3acbc9406 7935571857434f0a8325d4d77d490c50--976235ea4afb42a18cce06b3acbc9406 e4e2f4ea3fda47bfa6c00a9ff791c3fd 976235ea4afb42a18cce06b3acbc9406--e4e2f4ea3fda47bfa6c00a9ff791c3fd 635095d9ea9d4fa28d001882355ec471 e4e2f4ea3fda47bfa6c00a9ff791c3fd--635095d9ea9d4fa28d001882355ec471 2be77874c45b4ecf9b8e2a3e5e4ae2b7 635095d9ea9d4fa28d001882355ec471--2be77874c45b4ecf9b8e2a3e5e4ae2b7 5af725c4a29f4dd3b633d64b418aad5d 2be77874c45b4ecf9b8e2a3e5e4ae2b7--5af725c4a29f4dd3b633d64b418aad5d 19726adec0c548daa42341637499f208 X 5af725c4a29f4dd3b633d64b418aad5d--19726adec0c548daa42341637499f208 19726adec0c548daa42341637499f208--7102e3a49f324b59b7ca4055a43a0701 2d932172f5ec4f219a7c1b823c85a3b3 X 19726adec0c548daa42341637499f208--2d932172f5ec4f219a7c1b823c85a3b3 2d932172f5ec4f219a7c1b823c85a3b3--587422249db4484cb5f6f5aeccf137d1 7c94ff15db464dd2a2015d089ad75c1d 2d932172f5ec4f219a7c1b823c85a3b3--7c94ff15db464dd2a2015d089ad75c1d 6fd48afdbe154d9889a2e4700ddc5425 7c94ff15db464dd2a2015d089ad75c1d--6fd48afdbe154d9889a2e4700ddc5425 fcc9db7d97844f5db87ae0d045cce224 6fd48afdbe154d9889a2e4700ddc5425--fcc9db7d97844f5db87ae0d045cce224 c544112d8ea4465383e541e53c7ff86e fcc9db7d97844f5db87ae0d045cce224--c544112d8ea4465383e541e53c7ff86e cbe3833655b34db79878a319e165dadf c544112d8ea4465383e541e53c7ff86e--cbe3833655b34db79878a319e165dadf 4e808f0438524a9cb84ad115dc53dfd7 cbe3833655b34db79878a319e165dadf--4e808f0438524a9cb84ad115dc53dfd7 98696e0f6dba4b60b571b7a0ff0b0b66 4e808f0438524a9cb84ad115dc53dfd7--98696e0f6dba4b60b571b7a0ff0b0b66 bdfb9f50835b4dee93a9feb23a37e9d6 98696e0f6dba4b60b571b7a0ff0b0b66--bdfb9f50835b4dee93a9feb23a37e9d6 4e34cecfe9e24710aa6a41ae1bf3676e bdfb9f50835b4dee93a9feb23a37e9d6--4e34cecfe9e24710aa6a41ae1bf3676e 79f0ddd153b44c29be2323b389f64382 X 4e34cecfe9e24710aa6a41ae1bf3676e--79f0ddd153b44c29be2323b389f64382 79f0ddd153b44c29be2323b389f64382--3b184c3ac6c54666bfdda9846145cfcf 6ec6ad8c45c14f6f8ba391b2242e51e7 79f0ddd153b44c29be2323b389f64382--6ec6ad8c45c14f6f8ba391b2242e51e7 76520bef1adb4883bbc1b5dab07eb442 6ec6ad8c45c14f6f8ba391b2242e51e7--76520bef1adb4883bbc1b5dab07eb442 f36d101b863745d588ef514ea5d29f29 76520bef1adb4883bbc1b5dab07eb442--f36d101b863745d588ef514ea5d29f29 a056264a764c4958a8b279587bed9136 f36d101b863745d588ef514ea5d29f29--a056264a764c4958a8b279587bed9136 4f03b55ca6244cfa9115aec4e9dd3e25 a056264a764c4958a8b279587bed9136--4f03b55ca6244cfa9115aec4e9dd3e25 4767f412986c43389782ea4e2365dd36 4f03b55ca6244cfa9115aec4e9dd3e25--4767f412986c43389782ea4e2365dd36 5790b3077e3b4d8fa9da9b3b9f32990f 4767f412986c43389782ea4e2365dd36--5790b3077e3b4d8fa9da9b3b9f32990f 1ca82a1850064366b91cda334bc9c1ae 5790b3077e3b4d8fa9da9b3b9f32990f--1ca82a1850064366b91cda334bc9c1ae 08da059f4f384ece837a1fe0fb6be6d4 1ca82a1850064366b91cda334bc9c1ae--08da059f4f384ece837a1fe0fb6be6d4 e0e8c69e62214eb581d51eba503a193d 08da059f4f384ece837a1fe0fb6be6d4--e0e8c69e62214eb581d51eba503a193d 99b24427f4c84aefb4175f09a3beb5c6 e0e8c69e62214eb581d51eba503a193d--99b24427f4c84aefb4175f09a3beb5c6 67832587786543a0959311a1bc47d489 99b24427f4c84aefb4175f09a3beb5c6--67832587786543a0959311a1bc47d489 c05103df2e7c4590a7a87c15b9ee42a0 67832587786543a0959311a1bc47d489--c05103df2e7c4590a7a87c15b9ee42a0 9f17a7c895c4427d9f3daafe958e148c c05103df2e7c4590a7a87c15b9ee42a0--9f17a7c895c4427d9f3daafe958e148c b9e2dfdb7f9a4cb4a05fbe98bdb61f61 9f17a7c895c4427d9f3daafe958e148c--b9e2dfdb7f9a4cb4a05fbe98bdb61f61 143dca217bce44d58a4ce228eb1433f2 b9e2dfdb7f9a4cb4a05fbe98bdb61f61--143dca217bce44d58a4ce228eb1433f2 5aaeb218324f46d59813161642d46040 143dca217bce44d58a4ce228eb1433f2--5aaeb218324f46d59813161642d46040 fd2fc4cd70a34c0e9283a77d98229f77 5aaeb218324f46d59813161642d46040--fd2fc4cd70a34c0e9283a77d98229f77 92f8951a07314a469e02be22eaa7d4dc fd2fc4cd70a34c0e9283a77d98229f77--92f8951a07314a469e02be22eaa7d4dc 3d79a6c1fd9442998074622a3a0b6d64 92f8951a07314a469e02be22eaa7d4dc--3d79a6c1fd9442998074622a3a0b6d64 55aac7c8336941d6a8ebe085dcc575a1 3d79a6c1fd9442998074622a3a0b6d64--55aac7c8336941d6a8ebe085dcc575a1 eebff759537b47df8fcdbe2df9606cf1 55aac7c8336941d6a8ebe085dcc575a1--eebff759537b47df8fcdbe2df9606cf1 e3b61918bb8f4ecd8a5e2274f39ad196 eebff759537b47df8fcdbe2df9606cf1--e3b61918bb8f4ecd8a5e2274f39ad196 33c125e1e3bb41a38fbe7d04c66c8f27 RX(b13) e3b61918bb8f4ecd8a5e2274f39ad196--33c125e1e3bb41a38fbe7d04c66c8f27 33c125e1e3bb41a38fbe7d04c66c8f27--b66dd9e79ff3439b981a99ced76ac437 5a71ae2d471940518cb742bdcb2f2d17 2be2fb9908a54a43bf2680145b263c0b febd850ecb294788954bbbf43df95469--2be2fb9908a54a43bf2680145b263c0b 4c122fe19db24f259aea1c5ef89807ac 5 bdbe9e7576194b32ad7fc28cbdde8837 2be2fb9908a54a43bf2680145b263c0b--bdbe9e7576194b32ad7fc28cbdde8837 8360da3b756041b198021ab48b90b879 bdbe9e7576194b32ad7fc28cbdde8837--8360da3b756041b198021ab48b90b879 daad039e6ac9455d9d810ee4afc7a78c X 8360da3b756041b198021ab48b90b879--daad039e6ac9455d9d810ee4afc7a78c daad039e6ac9455d9d810ee4afc7a78c--282a431eefb94c9291360d999110643a 92715bc9ced84a7d950325f238021ae2 daad039e6ac9455d9d810ee4afc7a78c--92715bc9ced84a7d950325f238021ae2 a64d33a7070d4c929cfe35557bafe6bd 92715bc9ced84a7d950325f238021ae2--a64d33a7070d4c929cfe35557bafe6bd aa721d061a4f4bda98783d4a96e5ab21 a64d33a7070d4c929cfe35557bafe6bd--aa721d061a4f4bda98783d4a96e5ab21 3c7040a340c3420aae608d6d13989980 aa721d061a4f4bda98783d4a96e5ab21--3c7040a340c3420aae608d6d13989980 d8640f8b08b14da5af8d6e79d21717ad 3c7040a340c3420aae608d6d13989980--d8640f8b08b14da5af8d6e79d21717ad b31955c2dbe2427d8057ad515342e24b d8640f8b08b14da5af8d6e79d21717ad--b31955c2dbe2427d8057ad515342e24b 36dee610763e489ebf42d1de63b71006 b31955c2dbe2427d8057ad515342e24b--36dee610763e489ebf42d1de63b71006 33a1c95ed38e44249e0e139a63029ac5 X 36dee610763e489ebf42d1de63b71006--33a1c95ed38e44249e0e139a63029ac5 33a1c95ed38e44249e0e139a63029ac5--64c9d301d94c440ab0ecf62c9a34f2cf 844aa1da5ac749dd8e7b7a883bed2407 33a1c95ed38e44249e0e139a63029ac5--844aa1da5ac749dd8e7b7a883bed2407 c7bce083331a4f0a9d65b88c57c37e94 844aa1da5ac749dd8e7b7a883bed2407--c7bce083331a4f0a9d65b88c57c37e94 e01ea02991a34c1e8f52d2bc4cd6cab0 c7bce083331a4f0a9d65b88c57c37e94--e01ea02991a34c1e8f52d2bc4cd6cab0 045dc47dc0cc41f58eb367f1e3fbaf38 e01ea02991a34c1e8f52d2bc4cd6cab0--045dc47dc0cc41f58eb367f1e3fbaf38 a87430813113498e9b4adc20860cd9ed 045dc47dc0cc41f58eb367f1e3fbaf38--a87430813113498e9b4adc20860cd9ed 400bb8bfb76a4cddbcd8cdc7893d780d a87430813113498e9b4adc20860cd9ed--400bb8bfb76a4cddbcd8cdc7893d780d 6a73e098e8104c1884c704b100e416cc 400bb8bfb76a4cddbcd8cdc7893d780d--6a73e098e8104c1884c704b100e416cc 1d3d5dcdcb1547319b40ca022d5c949d 6a73e098e8104c1884c704b100e416cc--1d3d5dcdcb1547319b40ca022d5c949d 69fdbb8affb2438aae95b97ef2b5d32c 1d3d5dcdcb1547319b40ca022d5c949d--69fdbb8affb2438aae95b97ef2b5d32c 6e71566e18f24139bc2728dd470bd10a 69fdbb8affb2438aae95b97ef2b5d32c--6e71566e18f24139bc2728dd470bd10a 8b399c397d71477abf60adbdefc75794 6e71566e18f24139bc2728dd470bd10a--8b399c397d71477abf60adbdefc75794 90e3e8ca30f140b888df54c9809644de 8b399c397d71477abf60adbdefc75794--90e3e8ca30f140b888df54c9809644de 3c052b8b0d884a04a09a2a94dcceaa42 90e3e8ca30f140b888df54c9809644de--3c052b8b0d884a04a09a2a94dcceaa42 7ce3a1b3ea5b42cb9d1f0b17c0d34439 3c052b8b0d884a04a09a2a94dcceaa42--7ce3a1b3ea5b42cb9d1f0b17c0d34439 2c53badc0bbf4f91b3b8b82565576ccf X 7ce3a1b3ea5b42cb9d1f0b17c0d34439--2c53badc0bbf4f91b3b8b82565576ccf 2c53badc0bbf4f91b3b8b82565576ccf--40b57080a71c4a10b2405602caea27c7 87ed4c12dcc541549caa28bfa4cc3c60 RZ(-1.0*g0) 2c53badc0bbf4f91b3b8b82565576ccf--87ed4c12dcc541549caa28bfa4cc3c60 dfe6f22c0d214ec9bc2020e887dbb92b X 87ed4c12dcc541549caa28bfa4cc3c60--dfe6f22c0d214ec9bc2020e887dbb92b dfe6f22c0d214ec9bc2020e887dbb92b--2f2129e0aa7e4e2090996cb451c4f1f9 9654f780efe84ef1afcd421eecacdf5f dfe6f22c0d214ec9bc2020e887dbb92b--9654f780efe84ef1afcd421eecacdf5f c69e96519f28478dbdad8808f1aae430 9654f780efe84ef1afcd421eecacdf5f--c69e96519f28478dbdad8808f1aae430 3683248d120c4c4f98ad156608920af5 c69e96519f28478dbdad8808f1aae430--3683248d120c4c4f98ad156608920af5 58845712db614f7e9a7107c30b23a347 3683248d120c4c4f98ad156608920af5--58845712db614f7e9a7107c30b23a347 4bff73cfd8fd42839f7df70ce65dc58e 58845712db614f7e9a7107c30b23a347--4bff73cfd8fd42839f7df70ce65dc58e 703baec3cbe746b7921584b5edce7985 4bff73cfd8fd42839f7df70ce65dc58e--703baec3cbe746b7921584b5edce7985 5ff0efa27ff244199bc42484cd048007 X 703baec3cbe746b7921584b5edce7985--5ff0efa27ff244199bc42484cd048007 5ff0efa27ff244199bc42484cd048007--1deff453fba94b89ad9111e1fcf09a4a f9328d7593014a69bcbe050c11ca3fde 5ff0efa27ff244199bc42484cd048007--f9328d7593014a69bcbe050c11ca3fde 40a99885ff254d54a61056fca852948f f9328d7593014a69bcbe050c11ca3fde--40a99885ff254d54a61056fca852948f ca49226cd0ae43a99644544c0980205a 40a99885ff254d54a61056fca852948f--ca49226cd0ae43a99644544c0980205a c2eaa49057294c24a27a5b90a10db2f5 ca49226cd0ae43a99644544c0980205a--c2eaa49057294c24a27a5b90a10db2f5 f8be072544964fd49d0ad2362d722535 c2eaa49057294c24a27a5b90a10db2f5--f8be072544964fd49d0ad2362d722535 786bea3543164a7fb99af48a27bc300d f8be072544964fd49d0ad2362d722535--786bea3543164a7fb99af48a27bc300d 8f379196b9724c58ace7c5bda3e96b0b 786bea3543164a7fb99af48a27bc300d--8f379196b9724c58ace7c5bda3e96b0b 29c0dbcc4f5e4ce7b993b152572061e2 X 8f379196b9724c58ace7c5bda3e96b0b--29c0dbcc4f5e4ce7b993b152572061e2 29c0dbcc4f5e4ce7b993b152572061e2--bbfbca5bb73f4d1a8092aff04d3b131d 0a08a2b6a28b4a0d8131dd6c9fe2f85b 29c0dbcc4f5e4ce7b993b152572061e2--0a08a2b6a28b4a0d8131dd6c9fe2f85b 3e9a0971826d408ab50ef58e106b4aba 0a08a2b6a28b4a0d8131dd6c9fe2f85b--3e9a0971826d408ab50ef58e106b4aba b7ced3f4fbb849ff87fd16be3cc29d21 3e9a0971826d408ab50ef58e106b4aba--b7ced3f4fbb849ff87fd16be3cc29d21 4c884dab442c4cc784332781cf1dd34a b7ced3f4fbb849ff87fd16be3cc29d21--4c884dab442c4cc784332781cf1dd34a caee99d87bb8440ea801ccfa59f8daad 4c884dab442c4cc784332781cf1dd34a--caee99d87bb8440ea801ccfa59f8daad dfab048a837b434bb826ce003449d913 caee99d87bb8440ea801ccfa59f8daad--dfab048a837b434bb826ce003449d913 fa18e6841ae44786b6d1e8e900595b67 dfab048a837b434bb826ce003449d913--fa18e6841ae44786b6d1e8e900595b67 0e4890216d484300ab4e6356db674d3a X fa18e6841ae44786b6d1e8e900595b67--0e4890216d484300ab4e6356db674d3a 0e4890216d484300ab4e6356db674d3a--4ec8062d72f543f4a74a5bcc25d1cfdb f889da6d52a74640b5afe32796445bd0 RZ(-1.0*g0) 0e4890216d484300ab4e6356db674d3a--f889da6d52a74640b5afe32796445bd0 e434dbccfb0d445e8c8ab16b021e6594 X f889da6d52a74640b5afe32796445bd0--e434dbccfb0d445e8c8ab16b021e6594 e434dbccfb0d445e8c8ab16b021e6594--6b3911b9eae542b5bb6edb905880f340 22ba6a77faef415f8b71876c30a18e17 e434dbccfb0d445e8c8ab16b021e6594--22ba6a77faef415f8b71876c30a18e17 0c7a45f4bb17445bb19d1bea9260c4f4 22ba6a77faef415f8b71876c30a18e17--0c7a45f4bb17445bb19d1bea9260c4f4 179096fe7ae9437ea78318e6d29f2d0e X 0c7a45f4bb17445bb19d1bea9260c4f4--179096fe7ae9437ea78318e6d29f2d0e 179096fe7ae9437ea78318e6d29f2d0e--f46e481dd4ae4b6b9cfe7cd09494a5e1 9f08dfa4240c489492863476c247d599 179096fe7ae9437ea78318e6d29f2d0e--9f08dfa4240c489492863476c247d599 de644c053fa646ea9e6d6d79279e37b0 9f08dfa4240c489492863476c247d599--de644c053fa646ea9e6d6d79279e37b0 77322b3672d84157a0ba1b54a58c0b95 de644c053fa646ea9e6d6d79279e37b0--77322b3672d84157a0ba1b54a58c0b95 2fd7039a8f8e420f802e97bfbec11883 77322b3672d84157a0ba1b54a58c0b95--2fd7039a8f8e420f802e97bfbec11883 8f4fc0add5c94ea6b96dc34da39a24ee 2fd7039a8f8e420f802e97bfbec11883--8f4fc0add5c94ea6b96dc34da39a24ee 7f39058ea459432da88e88f58ea70367 X 8f4fc0add5c94ea6b96dc34da39a24ee--7f39058ea459432da88e88f58ea70367 7f39058ea459432da88e88f58ea70367--b4c9d7a38e894718952a412101000404 43f8338ec8f94b2583f4beab8e5bb413 7f39058ea459432da88e88f58ea70367--43f8338ec8f94b2583f4beab8e5bb413 53a642c1c6144c608da8fb70ed358a7f 43f8338ec8f94b2583f4beab8e5bb413--53a642c1c6144c608da8fb70ed358a7f df1209dc5d0a492095590712a4fde663 X 53a642c1c6144c608da8fb70ed358a7f--df1209dc5d0a492095590712a4fde663 df1209dc5d0a492095590712a4fde663--515f91bfa5b042f98cfc919578c87495 e5187043700941e0a7db97162a7d4619 df1209dc5d0a492095590712a4fde663--e5187043700941e0a7db97162a7d4619 a5f3d691d79f4d70b784277303d9c18f e5187043700941e0a7db97162a7d4619--a5f3d691d79f4d70b784277303d9c18f 534e44459d2e4a6eb06291872717be6a a5f3d691d79f4d70b784277303d9c18f--534e44459d2e4a6eb06291872717be6a 16565f7fbf9d4855969e0896915cba15 534e44459d2e4a6eb06291872717be6a--16565f7fbf9d4855969e0896915cba15 c93e5a9fdd3143568aa8dbf71cf75f8d 16565f7fbf9d4855969e0896915cba15--c93e5a9fdd3143568aa8dbf71cf75f8d 31c6bfdbc2df4f60980dfe66eb6d3956 c93e5a9fdd3143568aa8dbf71cf75f8d--31c6bfdbc2df4f60980dfe66eb6d3956 5770c7449813403f9ad20eda061f4c91 31c6bfdbc2df4f60980dfe66eb6d3956--5770c7449813403f9ad20eda061f4c91 5e722a04c5654f70ac0bee15fdd1e370 X 5770c7449813403f9ad20eda061f4c91--5e722a04c5654f70ac0bee15fdd1e370 5e722a04c5654f70ac0bee15fdd1e370--3e83217bdee84071bb38e550f3af2b3b 7dadb8dd3ad04df993abd7c4afeea5ba 5e722a04c5654f70ac0bee15fdd1e370--7dadb8dd3ad04df993abd7c4afeea5ba 301c24c140b74f77a57ec10a668027b6 X 7dadb8dd3ad04df993abd7c4afeea5ba--301c24c140b74f77a57ec10a668027b6 301c24c140b74f77a57ec10a668027b6--43e40ee7419248ae8fb0bb0e2736ac81 a01814d6db284bb9b7e520873ff61f75 301c24c140b74f77a57ec10a668027b6--a01814d6db284bb9b7e520873ff61f75 805f2e67a0964f21a6d14b4d60e798bd a01814d6db284bb9b7e520873ff61f75--805f2e67a0964f21a6d14b4d60e798bd efae796406e5459ab5d6cad66ffe810f 805f2e67a0964f21a6d14b4d60e798bd--efae796406e5459ab5d6cad66ffe810f 84e01f9c84e94c988a9ae52e0294009b X efae796406e5459ab5d6cad66ffe810f--84e01f9c84e94c988a9ae52e0294009b 84e01f9c84e94c988a9ae52e0294009b--e4fb3b1e05fa4b509bf266b7fbe584de 39ecdd0338b94854bd8f2aadc673e534 X 84e01f9c84e94c988a9ae52e0294009b--39ecdd0338b94854bd8f2aadc673e534 39ecdd0338b94854bd8f2aadc673e534--1cd18f8491fd42dfb3ca9e353ce1006a 662ed1e524994e6fb9d439f79914bfa3 39ecdd0338b94854bd8f2aadc673e534--662ed1e524994e6fb9d439f79914bfa3 63f741cc1e9f4f06b94fc84f7260d674 662ed1e524994e6fb9d439f79914bfa3--63f741cc1e9f4f06b94fc84f7260d674 0fd2f0eab4a34a5789d6887454b3561d 63f741cc1e9f4f06b94fc84f7260d674--0fd2f0eab4a34a5789d6887454b3561d db0aa71664aa4db3988d5514a7b69edc 0fd2f0eab4a34a5789d6887454b3561d--db0aa71664aa4db3988d5514a7b69edc d28952684a124e4782c04a958e369b0a db0aa71664aa4db3988d5514a7b69edc--d28952684a124e4782c04a958e369b0a 97c54691938946c38b6b1a7233541420 X d28952684a124e4782c04a958e369b0a--97c54691938946c38b6b1a7233541420 97c54691938946c38b6b1a7233541420--fbf3ff19bac44ebba3abd3ef3ef3fb89 4f1af1d8c0404896a5593b40b9f59c48 97c54691938946c38b6b1a7233541420--4f1af1d8c0404896a5593b40b9f59c48 5f98fcc9ec704a009ef06d247687ef44 4f1af1d8c0404896a5593b40b9f59c48--5f98fcc9ec704a009ef06d247687ef44 34e3f0e8b07d4711b87d670eb7cfe952 5f98fcc9ec704a009ef06d247687ef44--34e3f0e8b07d4711b87d670eb7cfe952 1ea744a14b9341969d25164087e07d0c 34e3f0e8b07d4711b87d670eb7cfe952--1ea744a14b9341969d25164087e07d0c a9edc67d441549f583928fc2ca26ab42 1ea744a14b9341969d25164087e07d0c--a9edc67d441549f583928fc2ca26ab42 8b95a4457e32437681e2816b224df975 a9edc67d441549f583928fc2ca26ab42--8b95a4457e32437681e2816b224df975 13e016742d0f4cfb81a23073a62cfc64 8b95a4457e32437681e2816b224df975--13e016742d0f4cfb81a23073a62cfc64 7e5861e081b34ae49f12992febf836d3 13e016742d0f4cfb81a23073a62cfc64--7e5861e081b34ae49f12992febf836d3 d2de5646ca75482f879a107c56aa1b22 7e5861e081b34ae49f12992febf836d3--d2de5646ca75482f879a107c56aa1b22 f67e7f5d9488479795123950e25c9c40 d2de5646ca75482f879a107c56aa1b22--f67e7f5d9488479795123950e25c9c40 85f6797e7017409fb83cdb5b14e4d3e9 f67e7f5d9488479795123950e25c9c40--85f6797e7017409fb83cdb5b14e4d3e9 edbe9d377b3f4e2a80c6f202401342d8 RX(b04) 85f6797e7017409fb83cdb5b14e4d3e9--edbe9d377b3f4e2a80c6f202401342d8 ca06f17255bf476da7763ef7ff59e855 edbe9d377b3f4e2a80c6f202401342d8--ca06f17255bf476da7763ef7ff59e855 9ea2394d9be7458ba45395052d18a126 ca06f17255bf476da7763ef7ff59e855--9ea2394d9be7458ba45395052d18a126 dcb62957aae4449aa934a3be58636567 9ea2394d9be7458ba45395052d18a126--dcb62957aae4449aa934a3be58636567 8dcc3f55913141dda22c38dc8b708b8b X dcb62957aae4449aa934a3be58636567--8dcc3f55913141dda22c38dc8b708b8b 8dcc3f55913141dda22c38dc8b708b8b--d1a4d8b37b974d6d9ab20480d78817c1 efcba44c3ef84ad7a1a97d380a1e6ab2 8dcc3f55913141dda22c38dc8b708b8b--efcba44c3ef84ad7a1a97d380a1e6ab2 1d1dbe00c0ae4e84bc5840e8f8ace208 efcba44c3ef84ad7a1a97d380a1e6ab2--1d1dbe00c0ae4e84bc5840e8f8ace208 fbc36926aa6c490eb84b23298fc40b72 1d1dbe00c0ae4e84bc5840e8f8ace208--fbc36926aa6c490eb84b23298fc40b72 fb5b2219181342a3af2649f279fcace9 fbc36926aa6c490eb84b23298fc40b72--fb5b2219181342a3af2649f279fcace9 f147daec1f564889a4af9b58a469e109 fb5b2219181342a3af2649f279fcace9--f147daec1f564889a4af9b58a469e109 dc4732c2b1474086ba9ac0200d810d4a f147daec1f564889a4af9b58a469e109--dc4732c2b1474086ba9ac0200d810d4a 9474e9649ff6493abba6f59c08aed464 dc4732c2b1474086ba9ac0200d810d4a--9474e9649ff6493abba6f59c08aed464 a763f34f283748ce8306279b42feb30d X 9474e9649ff6493abba6f59c08aed464--a763f34f283748ce8306279b42feb30d a763f34f283748ce8306279b42feb30d--d6713eb7e4c54cfb9863b4081d14859a 9ed1ae0c8fff478da54f1b62119640ed a763f34f283748ce8306279b42feb30d--9ed1ae0c8fff478da54f1b62119640ed 19ef327759434f108558315123fe8e26 9ed1ae0c8fff478da54f1b62119640ed--19ef327759434f108558315123fe8e26 3406519bd23b414a8f4cfa25d14c3ff6 19ef327759434f108558315123fe8e26--3406519bd23b414a8f4cfa25d14c3ff6 2d2ea4f46a3541f69f434b34d951a522 3406519bd23b414a8f4cfa25d14c3ff6--2d2ea4f46a3541f69f434b34d951a522 4df10ee665fa49a28bc3dfa4b675cb7a 2d2ea4f46a3541f69f434b34d951a522--4df10ee665fa49a28bc3dfa4b675cb7a 79e4d89a25504633bdf12b9c08b3044a 4df10ee665fa49a28bc3dfa4b675cb7a--79e4d89a25504633bdf12b9c08b3044a 03679d83419a480399af5234bfd68d4c 79e4d89a25504633bdf12b9c08b3044a--03679d83419a480399af5234bfd68d4c 767c0a67c9dd42b5aa8c9e87dc504ffc 03679d83419a480399af5234bfd68d4c--767c0a67c9dd42b5aa8c9e87dc504ffc 37f78c9739c74dc7a64dc85f341cef45 767c0a67c9dd42b5aa8c9e87dc504ffc--37f78c9739c74dc7a64dc85f341cef45 f2343d13d4bd4ff6ba0cbe756459be0c 37f78c9739c74dc7a64dc85f341cef45--f2343d13d4bd4ff6ba0cbe756459be0c dd426193a0a644c5b20ce7ce75c7a850 f2343d13d4bd4ff6ba0cbe756459be0c--dd426193a0a644c5b20ce7ce75c7a850 ff8efd2b83e84a0b846ed6d3e71a68cc dd426193a0a644c5b20ce7ce75c7a850--ff8efd2b83e84a0b846ed6d3e71a68cc 2eb4d7fba7764718b2f03290c3837498 ff8efd2b83e84a0b846ed6d3e71a68cc--2eb4d7fba7764718b2f03290c3837498 9eb0f3cf8284444cbdfba806ea3df6bc 2eb4d7fba7764718b2f03290c3837498--9eb0f3cf8284444cbdfba806ea3df6bc c88d7dddcab946a7a035275d9df6b5e8 X 9eb0f3cf8284444cbdfba806ea3df6bc--c88d7dddcab946a7a035275d9df6b5e8 c88d7dddcab946a7a035275d9df6b5e8--cdf38056dfb44c9e8ce362a6fbc9258a ea8e99819e6b41b6a7e51cbc709bd13f RZ(-1.0*g1) c88d7dddcab946a7a035275d9df6b5e8--ea8e99819e6b41b6a7e51cbc709bd13f d16afb639ca4464391743638ebb63bf2 X ea8e99819e6b41b6a7e51cbc709bd13f--d16afb639ca4464391743638ebb63bf2 d16afb639ca4464391743638ebb63bf2--cde184e5d57c4bd286e2e9354fced178 04b628fcc6cc4fd8b45d19ef84af3c73 d16afb639ca4464391743638ebb63bf2--04b628fcc6cc4fd8b45d19ef84af3c73 dfc5e797f3784504bb9acd27a0e465ea 04b628fcc6cc4fd8b45d19ef84af3c73--dfc5e797f3784504bb9acd27a0e465ea f23bb9f7a2334cefbd0ff9a98952cf0b dfc5e797f3784504bb9acd27a0e465ea--f23bb9f7a2334cefbd0ff9a98952cf0b ca90bd72056a4025989324bb1b7ff4fd f23bb9f7a2334cefbd0ff9a98952cf0b--ca90bd72056a4025989324bb1b7ff4fd 9863710a4cf04b2fb1e8d68c17247028 ca90bd72056a4025989324bb1b7ff4fd--9863710a4cf04b2fb1e8d68c17247028 d8d70287af684f668dc48b5f06c03e7a 9863710a4cf04b2fb1e8d68c17247028--d8d70287af684f668dc48b5f06c03e7a c27646bb01d74b2f935d5bd0f9ec4410 X d8d70287af684f668dc48b5f06c03e7a--c27646bb01d74b2f935d5bd0f9ec4410 c27646bb01d74b2f935d5bd0f9ec4410--9f697a0b3e3e4bba913245a20c0d6a79 4347c43a1ddc40d6bf1dee2aea8b582f c27646bb01d74b2f935d5bd0f9ec4410--4347c43a1ddc40d6bf1dee2aea8b582f 98b7bcfa568f486493ab20fa2d18eed6 4347c43a1ddc40d6bf1dee2aea8b582f--98b7bcfa568f486493ab20fa2d18eed6 8b212c433b92495bb2dd4e4e7542dbac 98b7bcfa568f486493ab20fa2d18eed6--8b212c433b92495bb2dd4e4e7542dbac aab891edef4243e5af1cc553f439b5e3 8b212c433b92495bb2dd4e4e7542dbac--aab891edef4243e5af1cc553f439b5e3 a30c2c902df146f6bd5279f61c4be187 aab891edef4243e5af1cc553f439b5e3--a30c2c902df146f6bd5279f61c4be187 68980409c336498e9d862687bc027f5b a30c2c902df146f6bd5279f61c4be187--68980409c336498e9d862687bc027f5b eb341a81ed2c404f82b4d17b66e84d6f 68980409c336498e9d862687bc027f5b--eb341a81ed2c404f82b4d17b66e84d6f 5e68fef5c07244118a5d539fa2e15bd9 X eb341a81ed2c404f82b4d17b66e84d6f--5e68fef5c07244118a5d539fa2e15bd9 5e68fef5c07244118a5d539fa2e15bd9--144bf0e6ddc14a2da59bcb4687793d7f a5af02e144a344469c2919feb812da5e 5e68fef5c07244118a5d539fa2e15bd9--a5af02e144a344469c2919feb812da5e 0436b71848984b118758bbfa1ae83a8b a5af02e144a344469c2919feb812da5e--0436b71848984b118758bbfa1ae83a8b c24ec6e57a824cd09f33a282ef18f2a9 0436b71848984b118758bbfa1ae83a8b--c24ec6e57a824cd09f33a282ef18f2a9 251bad4f659e4d8aa524185cb43086ba c24ec6e57a824cd09f33a282ef18f2a9--251bad4f659e4d8aa524185cb43086ba 284520a9aaba48d38615df304f5a66b7 251bad4f659e4d8aa524185cb43086ba--284520a9aaba48d38615df304f5a66b7 b94746a0e511407a9ce7af219b9e2c45 284520a9aaba48d38615df304f5a66b7--b94746a0e511407a9ce7af219b9e2c45 88e3d90707954e449cf7d62348a9c318 b94746a0e511407a9ce7af219b9e2c45--88e3d90707954e449cf7d62348a9c318 1931e27c73274e149cc63d4235108e4d X 88e3d90707954e449cf7d62348a9c318--1931e27c73274e149cc63d4235108e4d 1931e27c73274e149cc63d4235108e4d--1232f6a3d2e04eacbeabb25d96d37ea6 b2a87b9fccd2483b823a87c3f34bc413 RZ(-1.0*g1) 1931e27c73274e149cc63d4235108e4d--b2a87b9fccd2483b823a87c3f34bc413 71d89ec9b8ee4efbbedd52ef0ab49236 X b2a87b9fccd2483b823a87c3f34bc413--71d89ec9b8ee4efbbedd52ef0ab49236 71d89ec9b8ee4efbbedd52ef0ab49236--81f3f161c67e4048944277ffe8829d13 5102cb90ea4e4f469a7a8b08d26c2615 71d89ec9b8ee4efbbedd52ef0ab49236--5102cb90ea4e4f469a7a8b08d26c2615 62bbd7b744614a05be73059d6391a9dc 5102cb90ea4e4f469a7a8b08d26c2615--62bbd7b744614a05be73059d6391a9dc e067922e6a0b418492a529a2b211a86a X 62bbd7b744614a05be73059d6391a9dc--e067922e6a0b418492a529a2b211a86a e067922e6a0b418492a529a2b211a86a--2ead22151bbe4cf381e9e34b73f69eed 0925bb663fa44f4890130b312362362b e067922e6a0b418492a529a2b211a86a--0925bb663fa44f4890130b312362362b 93b72d5f50ef4d3a82c0c9d2dec52466 0925bb663fa44f4890130b312362362b--93b72d5f50ef4d3a82c0c9d2dec52466 f9f72d72c29d4659ba5572f00b650a52 93b72d5f50ef4d3a82c0c9d2dec52466--f9f72d72c29d4659ba5572f00b650a52 2b38d137e16a4958b540df9fbe123b75 f9f72d72c29d4659ba5572f00b650a52--2b38d137e16a4958b540df9fbe123b75 5696e96552ca4fea9132b684731518ac 2b38d137e16a4958b540df9fbe123b75--5696e96552ca4fea9132b684731518ac 36a7c5a79fd8469296e8b27ffdea3c69 X 5696e96552ca4fea9132b684731518ac--36a7c5a79fd8469296e8b27ffdea3c69 36a7c5a79fd8469296e8b27ffdea3c69--5af725c4a29f4dd3b633d64b418aad5d 524940113d324f3a8747533c2e765add 36a7c5a79fd8469296e8b27ffdea3c69--524940113d324f3a8747533c2e765add 5e4270c3364a4a349b73c8ad53d6768f 524940113d324f3a8747533c2e765add--5e4270c3364a4a349b73c8ad53d6768f 0510dac99e2e4cc386cfd35fffb2c49d X 5e4270c3364a4a349b73c8ad53d6768f--0510dac99e2e4cc386cfd35fffb2c49d 0510dac99e2e4cc386cfd35fffb2c49d--7c94ff15db464dd2a2015d089ad75c1d 9eae64d045b248d585afd984552d3603 0510dac99e2e4cc386cfd35fffb2c49d--9eae64d045b248d585afd984552d3603 c6da258e31754a789f54129ade71ef44 9eae64d045b248d585afd984552d3603--c6da258e31754a789f54129ade71ef44 e70d20f64e774229b45a9c95061517e7 c6da258e31754a789f54129ade71ef44--e70d20f64e774229b45a9c95061517e7 66e8cf944f6643e4819835c9505a16a0 e70d20f64e774229b45a9c95061517e7--66e8cf944f6643e4819835c9505a16a0 17c7c91ce40d42f1b0f219c6e094a084 66e8cf944f6643e4819835c9505a16a0--17c7c91ce40d42f1b0f219c6e094a084 fc47a4314539413c8108d910fb7e8c67 17c7c91ce40d42f1b0f219c6e094a084--fc47a4314539413c8108d910fb7e8c67 4b2ebf850543427cbf71749b5be57c07 fc47a4314539413c8108d910fb7e8c67--4b2ebf850543427cbf71749b5be57c07 bd4338f9af0f43c0adc7f0f952d9208f X 4b2ebf850543427cbf71749b5be57c07--bd4338f9af0f43c0adc7f0f952d9208f bd4338f9af0f43c0adc7f0f952d9208f--4e34cecfe9e24710aa6a41ae1bf3676e 0979e4ab2f8d4ad796e9c06cb3255660 bd4338f9af0f43c0adc7f0f952d9208f--0979e4ab2f8d4ad796e9c06cb3255660 9562653385a845e0ad5d4d02444fa871 X 0979e4ab2f8d4ad796e9c06cb3255660--9562653385a845e0ad5d4d02444fa871 9562653385a845e0ad5d4d02444fa871--6ec6ad8c45c14f6f8ba391b2242e51e7 08f806ca4fb24d159b4a2306437e1084 9562653385a845e0ad5d4d02444fa871--08f806ca4fb24d159b4a2306437e1084 491c2fd76f5943679affbdc9914090b4 08f806ca4fb24d159b4a2306437e1084--491c2fd76f5943679affbdc9914090b4 858b398fa9c14fb49934304b3406553c 491c2fd76f5943679affbdc9914090b4--858b398fa9c14fb49934304b3406553c 398590d93a5c49bd9db6c2f613570633 X 858b398fa9c14fb49934304b3406553c--398590d93a5c49bd9db6c2f613570633 398590d93a5c49bd9db6c2f613570633--4f03b55ca6244cfa9115aec4e9dd3e25 af8e664840f54115a2e689a2b6eab631 X 398590d93a5c49bd9db6c2f613570633--af8e664840f54115a2e689a2b6eab631 af8e664840f54115a2e689a2b6eab631--4767f412986c43389782ea4e2365dd36 2d21c05268ec4d40a84e1dcd54ffd8a0 af8e664840f54115a2e689a2b6eab631--2d21c05268ec4d40a84e1dcd54ffd8a0 8365adffdece4a039607f7bdd8baa3d4 2d21c05268ec4d40a84e1dcd54ffd8a0--8365adffdece4a039607f7bdd8baa3d4 5ecc76c5db32412394c082b40f48eebb 8365adffdece4a039607f7bdd8baa3d4--5ecc76c5db32412394c082b40f48eebb 08c2354482904d54ac5990e86c0a33ce 5ecc76c5db32412394c082b40f48eebb--08c2354482904d54ac5990e86c0a33ce d9b39919a21541bf8d12f81d41582d37 08c2354482904d54ac5990e86c0a33ce--d9b39919a21541bf8d12f81d41582d37 e3dbfc2c2626442494a948d456992933 X d9b39919a21541bf8d12f81d41582d37--e3dbfc2c2626442494a948d456992933 e3dbfc2c2626442494a948d456992933--67832587786543a0959311a1bc47d489 54e27997362a4a549ef76e0168a8689f e3dbfc2c2626442494a948d456992933--54e27997362a4a549ef76e0168a8689f 80fbf13d67d2405daa448fe792a0a0b4 54e27997362a4a549ef76e0168a8689f--80fbf13d67d2405daa448fe792a0a0b4 f9f6ee621c9d4fcf9d4b35641a5d3e82 80fbf13d67d2405daa448fe792a0a0b4--f9f6ee621c9d4fcf9d4b35641a5d3e82 02a68830359a4a54acad8f9874f419d6 f9f6ee621c9d4fcf9d4b35641a5d3e82--02a68830359a4a54acad8f9874f419d6 621de81a7dc349eaaab482123324a75e 02a68830359a4a54acad8f9874f419d6--621de81a7dc349eaaab482123324a75e 364ca32edbec48449e3804e7a3949cee 621de81a7dc349eaaab482123324a75e--364ca32edbec48449e3804e7a3949cee cfaf8396b973456e8aa5932136d1a398 364ca32edbec48449e3804e7a3949cee--cfaf8396b973456e8aa5932136d1a398 5acac7cdc85f4bf08236ea1434fb52b6 cfaf8396b973456e8aa5932136d1a398--5acac7cdc85f4bf08236ea1434fb52b6 d52328d00065470f97658bb68879f9b1 5acac7cdc85f4bf08236ea1434fb52b6--d52328d00065470f97658bb68879f9b1 c213f5d41ef945a88cd8c521db31ce32 d52328d00065470f97658bb68879f9b1--c213f5d41ef945a88cd8c521db31ce32 48b24122081e47aeaf6462ee34e68ae0 c213f5d41ef945a88cd8c521db31ce32--48b24122081e47aeaf6462ee34e68ae0 a2c708d4d7a642518daccb5d226fbb1e RX(b14) 48b24122081e47aeaf6462ee34e68ae0--a2c708d4d7a642518daccb5d226fbb1e a2c708d4d7a642518daccb5d226fbb1e--5a71ae2d471940518cb742bdcb2f2d17 7ffda3d74c2e42e786a01dbcb65efa69 36818e1f13444b4796a568ac53ccd9f1 4c122fe19db24f259aea1c5ef89807ac--36818e1f13444b4796a568ac53ccd9f1 597e3902f75d43e09f6d1df9dd4f4055 6 1ef1e50b340a407bac7505804c52f04a 36818e1f13444b4796a568ac53ccd9f1--1ef1e50b340a407bac7505804c52f04a 2a4d0714ed1644d7b04bfe698ec02736 1ef1e50b340a407bac7505804c52f04a--2a4d0714ed1644d7b04bfe698ec02736 aed31d3530574d7299851ba039b56731 2a4d0714ed1644d7b04bfe698ec02736--aed31d3530574d7299851ba039b56731 1574435668bf405194ad86c3d8571079 X aed31d3530574d7299851ba039b56731--1574435668bf405194ad86c3d8571079 1574435668bf405194ad86c3d8571079--92715bc9ced84a7d950325f238021ae2 c52aa76b6ec941718fcc0eb84175c393 1574435668bf405194ad86c3d8571079--c52aa76b6ec941718fcc0eb84175c393 dcac32cb24f149639129c504ef2cc7d2 c52aa76b6ec941718fcc0eb84175c393--dcac32cb24f149639129c504ef2cc7d2 218d234d27e1429cb78ae9542252ef3c dcac32cb24f149639129c504ef2cc7d2--218d234d27e1429cb78ae9542252ef3c b96363ad65e04e01937678509a8af6fa 218d234d27e1429cb78ae9542252ef3c--b96363ad65e04e01937678509a8af6fa 566321e6d40c4e5fa98110c0a0475d6c b96363ad65e04e01937678509a8af6fa--566321e6d40c4e5fa98110c0a0475d6c 357e04e8b8a6484586d736db9831bde6 X 566321e6d40c4e5fa98110c0a0475d6c--357e04e8b8a6484586d736db9831bde6 357e04e8b8a6484586d736db9831bde6--36dee610763e489ebf42d1de63b71006 3a3f6c12278b4710a08c015082258f59 357e04e8b8a6484586d736db9831bde6--3a3f6c12278b4710a08c015082258f59 dd86c5781b4347fa82f5bbe72228bdb7 3a3f6c12278b4710a08c015082258f59--dd86c5781b4347fa82f5bbe72228bdb7 812b9d6247854a47988987cc0087b1b2 dd86c5781b4347fa82f5bbe72228bdb7--812b9d6247854a47988987cc0087b1b2 2cc85b42ad1d498c8ff038454e6a1bf3 812b9d6247854a47988987cc0087b1b2--2cc85b42ad1d498c8ff038454e6a1bf3 f171ee82e0d1464dae937c8753c0e7b1 2cc85b42ad1d498c8ff038454e6a1bf3--f171ee82e0d1464dae937c8753c0e7b1 cf61d37091b14b85b02c61ec41197f50 f171ee82e0d1464dae937c8753c0e7b1--cf61d37091b14b85b02c61ec41197f50 b37f4f36126c43bf85db733daa9d6467 cf61d37091b14b85b02c61ec41197f50--b37f4f36126c43bf85db733daa9d6467 640b61d52a9149a0994a85e382d50b0a b37f4f36126c43bf85db733daa9d6467--640b61d52a9149a0994a85e382d50b0a 02393386aa4e4640a312faa3f18ccdec 640b61d52a9149a0994a85e382d50b0a--02393386aa4e4640a312faa3f18ccdec 4a99fa9bcc6d4d4f96042d69567f4a1d 02393386aa4e4640a312faa3f18ccdec--4a99fa9bcc6d4d4f96042d69567f4a1d 3cbe366e455f48319fbe78f127637580 4a99fa9bcc6d4d4f96042d69567f4a1d--3cbe366e455f48319fbe78f127637580 ca8b7f16967d4a11ae312354b49db63f 3cbe366e455f48319fbe78f127637580--ca8b7f16967d4a11ae312354b49db63f 4e1f454a72c44dfa8ba43530dd3fc6ef ca8b7f16967d4a11ae312354b49db63f--4e1f454a72c44dfa8ba43530dd3fc6ef a4f626979df843938f2f0dcc3a07c0c7 4e1f454a72c44dfa8ba43530dd3fc6ef--a4f626979df843938f2f0dcc3a07c0c7 3eff550d82614855a01fe699a6944ef5 a4f626979df843938f2f0dcc3a07c0c7--3eff550d82614855a01fe699a6944ef5 5ff54a2936e1421aa4257d02afd24865 3eff550d82614855a01fe699a6944ef5--5ff54a2936e1421aa4257d02afd24865 015e982ba1874e30847b848bfe545d74 5ff54a2936e1421aa4257d02afd24865--015e982ba1874e30847b848bfe545d74 3aaf731ad45b448eb6f8a8001c339224 015e982ba1874e30847b848bfe545d74--3aaf731ad45b448eb6f8a8001c339224 1394897b3a66420b86114d041ac48961 3aaf731ad45b448eb6f8a8001c339224--1394897b3a66420b86114d041ac48961 ee57da4bf2fe4b6c90bc46d4f7ce83dd 1394897b3a66420b86114d041ac48961--ee57da4bf2fe4b6c90bc46d4f7ce83dd de251d6e8ec44ce483001ef7f6b06131 ee57da4bf2fe4b6c90bc46d4f7ce83dd--de251d6e8ec44ce483001ef7f6b06131 00cca8bd3ccc484fb278f9d600da3a33 de251d6e8ec44ce483001ef7f6b06131--00cca8bd3ccc484fb278f9d600da3a33 cb9700c3dead4b0cac93846eaf7f5c2c 00cca8bd3ccc484fb278f9d600da3a33--cb9700c3dead4b0cac93846eaf7f5c2c ec7b4880d544461ab907d4a2b43d42e0 cb9700c3dead4b0cac93846eaf7f5c2c--ec7b4880d544461ab907d4a2b43d42e0 241a92510c564e19ade6bc0a74bdca2b ec7b4880d544461ab907d4a2b43d42e0--241a92510c564e19ade6bc0a74bdca2b f884a493d941482b896455a54c740d0b X 241a92510c564e19ade6bc0a74bdca2b--f884a493d941482b896455a54c740d0b f884a493d941482b896455a54c740d0b--f9328d7593014a69bcbe050c11ca3fde a88ede5e08b24e3099f22ca4edec97f2 f884a493d941482b896455a54c740d0b--a88ede5e08b24e3099f22ca4edec97f2 533ebff9894444479d1f09b556e9e268 a88ede5e08b24e3099f22ca4edec97f2--533ebff9894444479d1f09b556e9e268 3cf3237884f24d3a8b205ee5377803f1 533ebff9894444479d1f09b556e9e268--3cf3237884f24d3a8b205ee5377803f1 bfb24b33987540f9badd76d0cc5107ae 3cf3237884f24d3a8b205ee5377803f1--bfb24b33987540f9badd76d0cc5107ae 6b3825252a154993a431de4f018b275f bfb24b33987540f9badd76d0cc5107ae--6b3825252a154993a431de4f018b275f 3f13c31d57f145c4a1f814ca6b49cc3d X 6b3825252a154993a431de4f018b275f--3f13c31d57f145c4a1f814ca6b49cc3d 3f13c31d57f145c4a1f814ca6b49cc3d--8f379196b9724c58ace7c5bda3e96b0b e9ce5a9f789940a9aa102dcac577b660 3f13c31d57f145c4a1f814ca6b49cc3d--e9ce5a9f789940a9aa102dcac577b660 298aa8b2e6394987bd2b7587d44721b6 e9ce5a9f789940a9aa102dcac577b660--298aa8b2e6394987bd2b7587d44721b6 97c0d65f9e8747df9aff510999b89b41 298aa8b2e6394987bd2b7587d44721b6--97c0d65f9e8747df9aff510999b89b41 28a4108f88a0484c8078fdd16bdcff82 97c0d65f9e8747df9aff510999b89b41--28a4108f88a0484c8078fdd16bdcff82 36d25180b8ae4965bb25cd46f5299267 28a4108f88a0484c8078fdd16bdcff82--36d25180b8ae4965bb25cd46f5299267 90dd42faffa5411dbfee1f113ca69012 36d25180b8ae4965bb25cd46f5299267--90dd42faffa5411dbfee1f113ca69012 03f08adbe3734112a03c9dbf80e0cda6 90dd42faffa5411dbfee1f113ca69012--03f08adbe3734112a03c9dbf80e0cda6 3849dc2fde6647d2b911095c07a9c1a9 03f08adbe3734112a03c9dbf80e0cda6--3849dc2fde6647d2b911095c07a9c1a9 a9f4fc8fa59346fdb5018af1a8671912 3849dc2fde6647d2b911095c07a9c1a9--a9f4fc8fa59346fdb5018af1a8671912 6039498151224e3988925c6567beb9c5 a9f4fc8fa59346fdb5018af1a8671912--6039498151224e3988925c6567beb9c5 6e0a49a192b3400ebed04597275e2b79 6039498151224e3988925c6567beb9c5--6e0a49a192b3400ebed04597275e2b79 27334087e0994cd9a45279f95d5c4462 6e0a49a192b3400ebed04597275e2b79--27334087e0994cd9a45279f95d5c4462 721d08807fd642259357b52ea78f0b58 27334087e0994cd9a45279f95d5c4462--721d08807fd642259357b52ea78f0b58 e1d0a82a724d4eb3ba738840f182b53c 721d08807fd642259357b52ea78f0b58--e1d0a82a724d4eb3ba738840f182b53c bd10ebacce6547938f982c41debf0015 X e1d0a82a724d4eb3ba738840f182b53c--bd10ebacce6547938f982c41debf0015 bd10ebacce6547938f982c41debf0015--9f08dfa4240c489492863476c247d599 9b58241e601344ca9910cb0836a9a69b bd10ebacce6547938f982c41debf0015--9b58241e601344ca9910cb0836a9a69b 71eba306346b40708e3748afc99a88b4 9b58241e601344ca9910cb0836a9a69b--71eba306346b40708e3748afc99a88b4 ec7a1f7a818c43339b3f19083d427c57 71eba306346b40708e3748afc99a88b4--ec7a1f7a818c43339b3f19083d427c57 47172be938ef4f6c8aef018fe7944740 X ec7a1f7a818c43339b3f19083d427c57--47172be938ef4f6c8aef018fe7944740 47172be938ef4f6c8aef018fe7944740--8f4fc0add5c94ea6b96dc34da39a24ee 873e6bd20e6545588ac1a3e075bf6424 47172be938ef4f6c8aef018fe7944740--873e6bd20e6545588ac1a3e075bf6424 12ba09a730b64effb62e053e74e6dac0 873e6bd20e6545588ac1a3e075bf6424--12ba09a730b64effb62e053e74e6dac0 c9e613b49bcd473b8e6d697dd5e603a6 12ba09a730b64effb62e053e74e6dac0--c9e613b49bcd473b8e6d697dd5e603a6 fb39626f24da49da912a3b686a201c80 c9e613b49bcd473b8e6d697dd5e603a6--fb39626f24da49da912a3b686a201c80 a317d336d8234f8294f166591fcf206d X fb39626f24da49da912a3b686a201c80--a317d336d8234f8294f166591fcf206d a317d336d8234f8294f166591fcf206d--e5187043700941e0a7db97162a7d4619 9cfbe9954b944729aa493c7085245e6f a317d336d8234f8294f166591fcf206d--9cfbe9954b944729aa493c7085245e6f ebae318726a94f839db16896943d3b6f 9cfbe9954b944729aa493c7085245e6f--ebae318726a94f839db16896943d3b6f 34370c670a414547a31d5881973c4993 ebae318726a94f839db16896943d3b6f--34370c670a414547a31d5881973c4993 d7f55ac0c24d43d9b2a27e98ab1c0492 34370c670a414547a31d5881973c4993--d7f55ac0c24d43d9b2a27e98ab1c0492 9ab872c245c647b58aaaf2122e096529 d7f55ac0c24d43d9b2a27e98ab1c0492--9ab872c245c647b58aaaf2122e096529 55a7867895da4b44971e85403761aaa0 X 9ab872c245c647b58aaaf2122e096529--55a7867895da4b44971e85403761aaa0 55a7867895da4b44971e85403761aaa0--5770c7449813403f9ad20eda061f4c91 3659ce4657c04a6f833b332c4d798240 55a7867895da4b44971e85403761aaa0--3659ce4657c04a6f833b332c4d798240 031d91b1913d4b3db9cc13c5574ca3d1 3659ce4657c04a6f833b332c4d798240--031d91b1913d4b3db9cc13c5574ca3d1 33a754a9154241568c5b47eba2c79062 031d91b1913d4b3db9cc13c5574ca3d1--33a754a9154241568c5b47eba2c79062 c8a3795e10a14ebebde03f46a7b69b30 X 33a754a9154241568c5b47eba2c79062--c8a3795e10a14ebebde03f46a7b69b30 c8a3795e10a14ebebde03f46a7b69b30--a01814d6db284bb9b7e520873ff61f75 f6a514bc0f9e4961b438a5e237cd2e12 RZ(-1.0*g0) c8a3795e10a14ebebde03f46a7b69b30--f6a514bc0f9e4961b438a5e237cd2e12 a83ae21dfcaa4e83a721d1673d386519 X f6a514bc0f9e4961b438a5e237cd2e12--a83ae21dfcaa4e83a721d1673d386519 a83ae21dfcaa4e83a721d1673d386519--efae796406e5459ab5d6cad66ffe810f dfa1d0c04304440483c22ba154025599 a83ae21dfcaa4e83a721d1673d386519--dfa1d0c04304440483c22ba154025599 da9d1b1e0fac44dbbd6e21d1d2aea7fe dfa1d0c04304440483c22ba154025599--da9d1b1e0fac44dbbd6e21d1d2aea7fe a44ba8edf25d4f82b9ff9017193f4a51 X da9d1b1e0fac44dbbd6e21d1d2aea7fe--a44ba8edf25d4f82b9ff9017193f4a51 a44ba8edf25d4f82b9ff9017193f4a51--662ed1e524994e6fb9d439f79914bfa3 88226d9f1c15412fbc976bb0157a0287 a44ba8edf25d4f82b9ff9017193f4a51--88226d9f1c15412fbc976bb0157a0287 5fdf909d21ab4f78bb49dc4babd75e5b 88226d9f1c15412fbc976bb0157a0287--5fdf909d21ab4f78bb49dc4babd75e5b fdc015e1dadf4e488afa089ceb72f510 5fdf909d21ab4f78bb49dc4babd75e5b--fdc015e1dadf4e488afa089ceb72f510 5c99f3615a1a4c1f8722f3f811d557d4 X fdc015e1dadf4e488afa089ceb72f510--5c99f3615a1a4c1f8722f3f811d557d4 5c99f3615a1a4c1f8722f3f811d557d4--d28952684a124e4782c04a958e369b0a 2e5778c17c3243fe9952eecea8218e93 5c99f3615a1a4c1f8722f3f811d557d4--2e5778c17c3243fe9952eecea8218e93 6b9ac7733a9a43409e1e1298adc46fa1 X 2e5778c17c3243fe9952eecea8218e93--6b9ac7733a9a43409e1e1298adc46fa1 6b9ac7733a9a43409e1e1298adc46fa1--4f1af1d8c0404896a5593b40b9f59c48 1ac9fd6a9dd84b5fb1f9267a21c1e4dd RZ(-1.0*g0) 6b9ac7733a9a43409e1e1298adc46fa1--1ac9fd6a9dd84b5fb1f9267a21c1e4dd 81d869552beb4313992b48748cc24d83 X 1ac9fd6a9dd84b5fb1f9267a21c1e4dd--81d869552beb4313992b48748cc24d83 81d869552beb4313992b48748cc24d83--34e3f0e8b07d4711b87d670eb7cfe952 0502802cf1de47cd905462e96fe9fdc4 81d869552beb4313992b48748cc24d83--0502802cf1de47cd905462e96fe9fdc4 b739da113e394ac6bbac9e5439e84c9a 0502802cf1de47cd905462e96fe9fdc4--b739da113e394ac6bbac9e5439e84c9a 1c27e1c97dad46c4a2f027ea5a62ffc6 b739da113e394ac6bbac9e5439e84c9a--1c27e1c97dad46c4a2f027ea5a62ffc6 471442443e634133b37144ced90a47cc 1c27e1c97dad46c4a2f027ea5a62ffc6--471442443e634133b37144ced90a47cc dff748f6878b40f5b201dcda4b0a93af 471442443e634133b37144ced90a47cc--dff748f6878b40f5b201dcda4b0a93af 225f66b47ecf4dc5a88e4f8dba20b060 dff748f6878b40f5b201dcda4b0a93af--225f66b47ecf4dc5a88e4f8dba20b060 98607db9ba014998a3c033dce309c698 225f66b47ecf4dc5a88e4f8dba20b060--98607db9ba014998a3c033dce309c698 c4656b84272c451f8373c7c601a7d34d 98607db9ba014998a3c033dce309c698--c4656b84272c451f8373c7c601a7d34d 414df193bd76483ea3df5d01fd1e5616 RX(b05) c4656b84272c451f8373c7c601a7d34d--414df193bd76483ea3df5d01fd1e5616 6313845bc45e4082ab2622f1bbc184b7 414df193bd76483ea3df5d01fd1e5616--6313845bc45e4082ab2622f1bbc184b7 5146fa5ed4a04d4db90950b9da9d3c50 6313845bc45e4082ab2622f1bbc184b7--5146fa5ed4a04d4db90950b9da9d3c50 5b2ad9c6da72496dac6a72040b9b6cc5 5146fa5ed4a04d4db90950b9da9d3c50--5b2ad9c6da72496dac6a72040b9b6cc5 fc0e89f38db3423ebbc913e126afac64 5b2ad9c6da72496dac6a72040b9b6cc5--fc0e89f38db3423ebbc913e126afac64 6efb9ab18e584c74a960a68c2cf1a423 X fc0e89f38db3423ebbc913e126afac64--6efb9ab18e584c74a960a68c2cf1a423 6efb9ab18e584c74a960a68c2cf1a423--efcba44c3ef84ad7a1a97d380a1e6ab2 9a5fa71126f94d4db9115e4a845ce00f 6efb9ab18e584c74a960a68c2cf1a423--9a5fa71126f94d4db9115e4a845ce00f 123f8de43d7d48aeb42eece4f22724ed 9a5fa71126f94d4db9115e4a845ce00f--123f8de43d7d48aeb42eece4f22724ed 9da4c18c649f4ee1afc499b78e439b96 123f8de43d7d48aeb42eece4f22724ed--9da4c18c649f4ee1afc499b78e439b96 74c7a3a3d3dd445ea3d560b068685217 9da4c18c649f4ee1afc499b78e439b96--74c7a3a3d3dd445ea3d560b068685217 980b225fe5d44596ab36a410a4fe8f5a 74c7a3a3d3dd445ea3d560b068685217--980b225fe5d44596ab36a410a4fe8f5a 016b5c036cc24c0c838909e6dd040b72 X 980b225fe5d44596ab36a410a4fe8f5a--016b5c036cc24c0c838909e6dd040b72 016b5c036cc24c0c838909e6dd040b72--9474e9649ff6493abba6f59c08aed464 755acba29e874e19ac682b87a260da91 016b5c036cc24c0c838909e6dd040b72--755acba29e874e19ac682b87a260da91 8cdcaf9e11514673a16dfd171c316423 755acba29e874e19ac682b87a260da91--8cdcaf9e11514673a16dfd171c316423 f26b74938a674adab719c09801fece75 8cdcaf9e11514673a16dfd171c316423--f26b74938a674adab719c09801fece75 8c87ff58958d42f9b7046c24532e1127 f26b74938a674adab719c09801fece75--8c87ff58958d42f9b7046c24532e1127 74350a6ff87444dfae5fb4cb58ca7c6d 8c87ff58958d42f9b7046c24532e1127--74350a6ff87444dfae5fb4cb58ca7c6d b045cea081924ac991d9482ec55508c4 74350a6ff87444dfae5fb4cb58ca7c6d--b045cea081924ac991d9482ec55508c4 1e699ee3dec44b2ca20b0f77cf396f70 b045cea081924ac991d9482ec55508c4--1e699ee3dec44b2ca20b0f77cf396f70 46589cc0a7104982be8886d4a2e9e574 1e699ee3dec44b2ca20b0f77cf396f70--46589cc0a7104982be8886d4a2e9e574 295b35332d684ae09dd09c0385c283c4 46589cc0a7104982be8886d4a2e9e574--295b35332d684ae09dd09c0385c283c4 7912e018269e454e87420f3914cdb859 295b35332d684ae09dd09c0385c283c4--7912e018269e454e87420f3914cdb859 7dcd7e51fc2643ceb17d7ec5c165b90b 7912e018269e454e87420f3914cdb859--7dcd7e51fc2643ceb17d7ec5c165b90b 841a0889616c45cba53bf3f9ed3e6be1 7dcd7e51fc2643ceb17d7ec5c165b90b--841a0889616c45cba53bf3f9ed3e6be1 1d9820538b3f4bc5b8ade8b0cbc6d66a 841a0889616c45cba53bf3f9ed3e6be1--1d9820538b3f4bc5b8ade8b0cbc6d66a 70ff29be676a456a8d03115cda646ae9 1d9820538b3f4bc5b8ade8b0cbc6d66a--70ff29be676a456a8d03115cda646ae9 8e8e3dd1a2f84b4faccc444cdbcd1847 70ff29be676a456a8d03115cda646ae9--8e8e3dd1a2f84b4faccc444cdbcd1847 a2ed5a10186746979223b9e7936aec84 8e8e3dd1a2f84b4faccc444cdbcd1847--a2ed5a10186746979223b9e7936aec84 e779d44172a14ce3a994b4729b8273c4 a2ed5a10186746979223b9e7936aec84--e779d44172a14ce3a994b4729b8273c4 2cc2f9232bc1425a88c3d4ab47303865 e779d44172a14ce3a994b4729b8273c4--2cc2f9232bc1425a88c3d4ab47303865 48d066e457144593809fa3079e6d2c5b 2cc2f9232bc1425a88c3d4ab47303865--48d066e457144593809fa3079e6d2c5b f2c3cdbcc5ec4384bd93ec8a3d10f0db 48d066e457144593809fa3079e6d2c5b--f2c3cdbcc5ec4384bd93ec8a3d10f0db 42b7b17441e641f1a8c773c17943a902 f2c3cdbcc5ec4384bd93ec8a3d10f0db--42b7b17441e641f1a8c773c17943a902 a6f89fa5c330443e855314d079041fd5 42b7b17441e641f1a8c773c17943a902--a6f89fa5c330443e855314d079041fd5 9fe9396bc5024ebba07c72a7bc4fd871 a6f89fa5c330443e855314d079041fd5--9fe9396bc5024ebba07c72a7bc4fd871 285a948d489b4afd9926ea8b9fb98628 9fe9396bc5024ebba07c72a7bc4fd871--285a948d489b4afd9926ea8b9fb98628 e461d8270034448c8c792034c4340946 285a948d489b4afd9926ea8b9fb98628--e461d8270034448c8c792034c4340946 6924f435efe94336b720d05387e5a9f8 X e461d8270034448c8c792034c4340946--6924f435efe94336b720d05387e5a9f8 6924f435efe94336b720d05387e5a9f8--4347c43a1ddc40d6bf1dee2aea8b582f b236afd1ced34e74b38a84d6e49e65d3 6924f435efe94336b720d05387e5a9f8--b236afd1ced34e74b38a84d6e49e65d3 3d7b9c956aea47888aa915ed18f06d95 b236afd1ced34e74b38a84d6e49e65d3--3d7b9c956aea47888aa915ed18f06d95 edf327450f274d0db98d3c2bfe8028fd 3d7b9c956aea47888aa915ed18f06d95--edf327450f274d0db98d3c2bfe8028fd 8eec05daca2f4ecfa52c08e2de7132e6 edf327450f274d0db98d3c2bfe8028fd--8eec05daca2f4ecfa52c08e2de7132e6 6badbca8b7b64f2b9b439447fd61ec12 8eec05daca2f4ecfa52c08e2de7132e6--6badbca8b7b64f2b9b439447fd61ec12 f8bf7ed40e674e95aea0a36d57fc97eb X 6badbca8b7b64f2b9b439447fd61ec12--f8bf7ed40e674e95aea0a36d57fc97eb f8bf7ed40e674e95aea0a36d57fc97eb--eb341a81ed2c404f82b4d17b66e84d6f 9da04cdf46c24e55b8c5f1a1dac10cef f8bf7ed40e674e95aea0a36d57fc97eb--9da04cdf46c24e55b8c5f1a1dac10cef 19f90ef0f50b4af69dce15730e492280 9da04cdf46c24e55b8c5f1a1dac10cef--19f90ef0f50b4af69dce15730e492280 9ab397487b0143e4832572c3040a6336 19f90ef0f50b4af69dce15730e492280--9ab397487b0143e4832572c3040a6336 b4d52ec50d3744f6973949ff2236ecea 9ab397487b0143e4832572c3040a6336--b4d52ec50d3744f6973949ff2236ecea 65e6b89dd8544bcab87790fa72b65c81 b4d52ec50d3744f6973949ff2236ecea--65e6b89dd8544bcab87790fa72b65c81 25ed244972f14c1888869e0ed157699a 65e6b89dd8544bcab87790fa72b65c81--25ed244972f14c1888869e0ed157699a 88c845fec4ad4254bbc48e7e25b97c83 25ed244972f14c1888869e0ed157699a--88c845fec4ad4254bbc48e7e25b97c83 aae927454f604725b07e6fd9078b9005 88c845fec4ad4254bbc48e7e25b97c83--aae927454f604725b07e6fd9078b9005 8a971d6f89df448596f674ea56d139a5 aae927454f604725b07e6fd9078b9005--8a971d6f89df448596f674ea56d139a5 9bd9ecf5b0764534bc9adc4bcc1eaf8a 8a971d6f89df448596f674ea56d139a5--9bd9ecf5b0764534bc9adc4bcc1eaf8a c62072ec295f405c9e380431a64f42dd 9bd9ecf5b0764534bc9adc4bcc1eaf8a--c62072ec295f405c9e380431a64f42dd b5f9e77796c14fb9bd0acfd5cc5b7eb6 c62072ec295f405c9e380431a64f42dd--b5f9e77796c14fb9bd0acfd5cc5b7eb6 2fe9dc4194f84ad49189937a9ee8d3ef b5f9e77796c14fb9bd0acfd5cc5b7eb6--2fe9dc4194f84ad49189937a9ee8d3ef 21138732710547738f84136dbb4db2a1 2fe9dc4194f84ad49189937a9ee8d3ef--21138732710547738f84136dbb4db2a1 ce4c4106735346899e8a010d0c23d662 X 21138732710547738f84136dbb4db2a1--ce4c4106735346899e8a010d0c23d662 ce4c4106735346899e8a010d0c23d662--0925bb663fa44f4890130b312362362b 5647613eee514689bbab620c01e49a10 ce4c4106735346899e8a010d0c23d662--5647613eee514689bbab620c01e49a10 9fe2c13edb0d4e0a9bcb2c9adfec3186 5647613eee514689bbab620c01e49a10--9fe2c13edb0d4e0a9bcb2c9adfec3186 33da9506deb34fbf9611a4a8f771fb9b 9fe2c13edb0d4e0a9bcb2c9adfec3186--33da9506deb34fbf9611a4a8f771fb9b de9282047fae4cebb7017ff3e37a6cb5 X 33da9506deb34fbf9611a4a8f771fb9b--de9282047fae4cebb7017ff3e37a6cb5 de9282047fae4cebb7017ff3e37a6cb5--5696e96552ca4fea9132b684731518ac caf038bbd4c54162a2cbe43e77d7c935 de9282047fae4cebb7017ff3e37a6cb5--caf038bbd4c54162a2cbe43e77d7c935 d208de66fd4c42319e4c6bd69223cda0 caf038bbd4c54162a2cbe43e77d7c935--d208de66fd4c42319e4c6bd69223cda0 cc96c49a39a64b0fa344f7c25cbab510 d208de66fd4c42319e4c6bd69223cda0--cc96c49a39a64b0fa344f7c25cbab510 f698e468e6de430dab82ac6ff7fac578 cc96c49a39a64b0fa344f7c25cbab510--f698e468e6de430dab82ac6ff7fac578 aafc552114e64ac5a87dc96998a90295 X f698e468e6de430dab82ac6ff7fac578--aafc552114e64ac5a87dc96998a90295 aafc552114e64ac5a87dc96998a90295--9eae64d045b248d585afd984552d3603 a19cf8ec18bc48cfa3fda5d1e01767c2 aafc552114e64ac5a87dc96998a90295--a19cf8ec18bc48cfa3fda5d1e01767c2 1fe7d22701df40999aa89c80c76637d9 a19cf8ec18bc48cfa3fda5d1e01767c2--1fe7d22701df40999aa89c80c76637d9 34e8d994678049deab8f8114ea812a9a 1fe7d22701df40999aa89c80c76637d9--34e8d994678049deab8f8114ea812a9a 77428096df3b481494684b86b284a65a 34e8d994678049deab8f8114ea812a9a--77428096df3b481494684b86b284a65a 164a2cb34103424ca83d260bb9d7dd9f 77428096df3b481494684b86b284a65a--164a2cb34103424ca83d260bb9d7dd9f d001cb79f8804ce7b6a5be41c8b4d54c X 164a2cb34103424ca83d260bb9d7dd9f--d001cb79f8804ce7b6a5be41c8b4d54c d001cb79f8804ce7b6a5be41c8b4d54c--4b2ebf850543427cbf71749b5be57c07 1b0e85fdeda94c18864ef33eb355acf7 d001cb79f8804ce7b6a5be41c8b4d54c--1b0e85fdeda94c18864ef33eb355acf7 432ae172b47b407fb073a4662891ad7f 1b0e85fdeda94c18864ef33eb355acf7--432ae172b47b407fb073a4662891ad7f 13cea6a06d064040b32052744f8cf817 432ae172b47b407fb073a4662891ad7f--13cea6a06d064040b32052744f8cf817 ecb39fa3e48c4bbca629eeac98b53ad9 X 13cea6a06d064040b32052744f8cf817--ecb39fa3e48c4bbca629eeac98b53ad9 ecb39fa3e48c4bbca629eeac98b53ad9--08f806ca4fb24d159b4a2306437e1084 297aaac84a744905a8c312731cb0730a RZ(-1.0*g1) ecb39fa3e48c4bbca629eeac98b53ad9--297aaac84a744905a8c312731cb0730a a34c3fb2c2954f6eb47ddf5e4695a281 X 297aaac84a744905a8c312731cb0730a--a34c3fb2c2954f6eb47ddf5e4695a281 a34c3fb2c2954f6eb47ddf5e4695a281--858b398fa9c14fb49934304b3406553c e63b9d867b14428682fd01561f7a6f1c a34c3fb2c2954f6eb47ddf5e4695a281--e63b9d867b14428682fd01561f7a6f1c 2d06b8ef8de5439d91c6eb853c1a8bcf e63b9d867b14428682fd01561f7a6f1c--2d06b8ef8de5439d91c6eb853c1a8bcf 6915c9de67cb49f9902d8d5d1950daf5 X 2d06b8ef8de5439d91c6eb853c1a8bcf--6915c9de67cb49f9902d8d5d1950daf5 6915c9de67cb49f9902d8d5d1950daf5--2d21c05268ec4d40a84e1dcd54ffd8a0 e785d0858a1b49ecba7fc55a33282664 6915c9de67cb49f9902d8d5d1950daf5--e785d0858a1b49ecba7fc55a33282664 02494d778a4f44008e5fcbdb30302f2b e785d0858a1b49ecba7fc55a33282664--02494d778a4f44008e5fcbdb30302f2b 941529bb4b34477cb744e091af13d1da 02494d778a4f44008e5fcbdb30302f2b--941529bb4b34477cb744e091af13d1da ff5a85c40cd14304a0ea46244cb12a84 X 941529bb4b34477cb744e091af13d1da--ff5a85c40cd14304a0ea46244cb12a84 ff5a85c40cd14304a0ea46244cb12a84--d9b39919a21541bf8d12f81d41582d37 bbe971a3a451441b9c7052b8d3a681a8 ff5a85c40cd14304a0ea46244cb12a84--bbe971a3a451441b9c7052b8d3a681a8 462703be8ee7415388f134a1171b5ba1 X bbe971a3a451441b9c7052b8d3a681a8--462703be8ee7415388f134a1171b5ba1 462703be8ee7415388f134a1171b5ba1--54e27997362a4a549ef76e0168a8689f cad41405710047078346f79b22ca06c7 RZ(-1.0*g1) 462703be8ee7415388f134a1171b5ba1--cad41405710047078346f79b22ca06c7 bef87077cd6846989a58ab54d8a7a157 X cad41405710047078346f79b22ca06c7--bef87077cd6846989a58ab54d8a7a157 bef87077cd6846989a58ab54d8a7a157--f9f6ee621c9d4fcf9d4b35641a5d3e82 cd5a106111dc45f9b6f227b598ed0c5c bef87077cd6846989a58ab54d8a7a157--cd5a106111dc45f9b6f227b598ed0c5c f0879c1108d7477182cae6b9e2ff98cc cd5a106111dc45f9b6f227b598ed0c5c--f0879c1108d7477182cae6b9e2ff98cc 2d2f85bc07b94e998f301a1032694bc3 f0879c1108d7477182cae6b9e2ff98cc--2d2f85bc07b94e998f301a1032694bc3 f1522567999a437db6bfe35228dc018e 2d2f85bc07b94e998f301a1032694bc3--f1522567999a437db6bfe35228dc018e 284c3b2ba990423f92f83dbf6c740f8b f1522567999a437db6bfe35228dc018e--284c3b2ba990423f92f83dbf6c740f8b 4f15365dc5334944bf3a8b595e7ff460 284c3b2ba990423f92f83dbf6c740f8b--4f15365dc5334944bf3a8b595e7ff460 8c95ecb618b94ad39886fa50f28c39bc 4f15365dc5334944bf3a8b595e7ff460--8c95ecb618b94ad39886fa50f28c39bc a774c3793f2642efbe0e93eabffc187b 8c95ecb618b94ad39886fa50f28c39bc--a774c3793f2642efbe0e93eabffc187b 894f33c38353418c9cc5d7b898922047 RX(b15) a774c3793f2642efbe0e93eabffc187b--894f33c38353418c9cc5d7b898922047 894f33c38353418c9cc5d7b898922047--7ffda3d74c2e42e786a01dbcb65efa69 0e5f0a4ac1864676a826b6707be15e9f 0da26b989e71451ca8d5e290dcf204a0 597e3902f75d43e09f6d1df9dd4f4055--0da26b989e71451ca8d5e290dcf204a0 d09e6b77893f4735b5a3b83b7425eeeb 7 27ebd0107996480e8ade696fefaa1694 0da26b989e71451ca8d5e290dcf204a0--27ebd0107996480e8ade696fefaa1694 3c90a1639f78482d99b2081e8d4a2e30 27ebd0107996480e8ade696fefaa1694--3c90a1639f78482d99b2081e8d4a2e30 febb2328a2564d04b84801fd5e3106b3 3c90a1639f78482d99b2081e8d4a2e30--febb2328a2564d04b84801fd5e3106b3 d9c83e6801b848a59990e4cd688fe60e febb2328a2564d04b84801fd5e3106b3--d9c83e6801b848a59990e4cd688fe60e 7bb2a24c354a480b90665cfb2c571332 X d9c83e6801b848a59990e4cd688fe60e--7bb2a24c354a480b90665cfb2c571332 7bb2a24c354a480b90665cfb2c571332--c52aa76b6ec941718fcc0eb84175c393 0d61362595f64112a4304556893b2080 7bb2a24c354a480b90665cfb2c571332--0d61362595f64112a4304556893b2080 64e6fe520d6249b9996fc9ed16ad79c6 0d61362595f64112a4304556893b2080--64e6fe520d6249b9996fc9ed16ad79c6 ae0f61287e344d6499e66be9f3d7ae76 64e6fe520d6249b9996fc9ed16ad79c6--ae0f61287e344d6499e66be9f3d7ae76 f5855614fba94e1590070ec95c005c5a X ae0f61287e344d6499e66be9f3d7ae76--f5855614fba94e1590070ec95c005c5a f5855614fba94e1590070ec95c005c5a--566321e6d40c4e5fa98110c0a0475d6c b742d6bc430341e28b62d8c6d104b08a f5855614fba94e1590070ec95c005c5a--b742d6bc430341e28b62d8c6d104b08a 30e812cfd2294b3fb37b79a2a0b3956d b742d6bc430341e28b62d8c6d104b08a--30e812cfd2294b3fb37b79a2a0b3956d 10da491c5f5a4f7e9202ec822afa9775 30e812cfd2294b3fb37b79a2a0b3956d--10da491c5f5a4f7e9202ec822afa9775 237d7e40136e4c5cbeabf9a3e5612ec2 10da491c5f5a4f7e9202ec822afa9775--237d7e40136e4c5cbeabf9a3e5612ec2 4606fcde06d546c1847f9e2540279896 237d7e40136e4c5cbeabf9a3e5612ec2--4606fcde06d546c1847f9e2540279896 c40caa78d1af429b8b5b30e9ec20384e 4606fcde06d546c1847f9e2540279896--c40caa78d1af429b8b5b30e9ec20384e c855a147bb444055a29b9a5a4ccf5d28 c40caa78d1af429b8b5b30e9ec20384e--c855a147bb444055a29b9a5a4ccf5d28 c3d5eb819e4c4fda9eb202af61431352 c855a147bb444055a29b9a5a4ccf5d28--c3d5eb819e4c4fda9eb202af61431352 07d9f97695084073beddf4f224c96d66 c3d5eb819e4c4fda9eb202af61431352--07d9f97695084073beddf4f224c96d66 d415125f63824dae925ec3693f15c244 07d9f97695084073beddf4f224c96d66--d415125f63824dae925ec3693f15c244 8c8b59cf76604fd98339d3892f43d5b8 d415125f63824dae925ec3693f15c244--8c8b59cf76604fd98339d3892f43d5b8 50a824e42bb44e6ea4429a1dfdf24638 8c8b59cf76604fd98339d3892f43d5b8--50a824e42bb44e6ea4429a1dfdf24638 0b4d64e8fc004ca39e8f3e3293194a96 50a824e42bb44e6ea4429a1dfdf24638--0b4d64e8fc004ca39e8f3e3293194a96 c3397b50b8e1466ea878dfba23803263 0b4d64e8fc004ca39e8f3e3293194a96--c3397b50b8e1466ea878dfba23803263 dac55cc332d548dfb84b8e01c54c8ddd c3397b50b8e1466ea878dfba23803263--dac55cc332d548dfb84b8e01c54c8ddd b1cf8eeb45ba425c8b7ce15b84ed4ea1 dac55cc332d548dfb84b8e01c54c8ddd--b1cf8eeb45ba425c8b7ce15b84ed4ea1 e082b2a4171643d8ad054e421d17020f b1cf8eeb45ba425c8b7ce15b84ed4ea1--e082b2a4171643d8ad054e421d17020f 5b0c173753a64108a296fd1b6535d4ab e082b2a4171643d8ad054e421d17020f--5b0c173753a64108a296fd1b6535d4ab 224fb21dd0d64a939be6a00184656bfa 5b0c173753a64108a296fd1b6535d4ab--224fb21dd0d64a939be6a00184656bfa 0a916903ff044617b9c886126457ec52 224fb21dd0d64a939be6a00184656bfa--0a916903ff044617b9c886126457ec52 1649be3edaa1492090a7f4fd7209412f 0a916903ff044617b9c886126457ec52--1649be3edaa1492090a7f4fd7209412f 323fb144f5a54c33a9ac66ad5ed19964 1649be3edaa1492090a7f4fd7209412f--323fb144f5a54c33a9ac66ad5ed19964 06e76e31af8b48c7a73c1be4667d9b62 323fb144f5a54c33a9ac66ad5ed19964--06e76e31af8b48c7a73c1be4667d9b62 cd7b23bb3a674892a30d18eaad1455c1 06e76e31af8b48c7a73c1be4667d9b62--cd7b23bb3a674892a30d18eaad1455c1 a8c7206561e745a0ba503caefd6b050e cd7b23bb3a674892a30d18eaad1455c1--a8c7206561e745a0ba503caefd6b050e 55113ed676b44aa2afa28458552cf67e a8c7206561e745a0ba503caefd6b050e--55113ed676b44aa2afa28458552cf67e 324a2ba3324b44d39944c1e7767820c9 55113ed676b44aa2afa28458552cf67e--324a2ba3324b44d39944c1e7767820c9 91c17985d51c48f9bcc8309ecf9a820f X 324a2ba3324b44d39944c1e7767820c9--91c17985d51c48f9bcc8309ecf9a820f 91c17985d51c48f9bcc8309ecf9a820f--a88ede5e08b24e3099f22ca4edec97f2 360fa90a02044627ab520193f5c6e127 91c17985d51c48f9bcc8309ecf9a820f--360fa90a02044627ab520193f5c6e127 a4deead68ba6445b9be879ed91179804 360fa90a02044627ab520193f5c6e127--a4deead68ba6445b9be879ed91179804 9f677af44c8f4ab9a0b97437bc6e8f86 a4deead68ba6445b9be879ed91179804--9f677af44c8f4ab9a0b97437bc6e8f86 6d4c4a5653bc443c9a08f0a07d328e17 X 9f677af44c8f4ab9a0b97437bc6e8f86--6d4c4a5653bc443c9a08f0a07d328e17 6d4c4a5653bc443c9a08f0a07d328e17--6b3825252a154993a431de4f018b275f 65536ffbfcfd4576b00c5ab8cf871c61 6d4c4a5653bc443c9a08f0a07d328e17--65536ffbfcfd4576b00c5ab8cf871c61 02be2f52914e4587839f2564c327c603 65536ffbfcfd4576b00c5ab8cf871c61--02be2f52914e4587839f2564c327c603 1e18d2b4b07745ea87f636a416df2de4 02be2f52914e4587839f2564c327c603--1e18d2b4b07745ea87f636a416df2de4 3ff5bf7d2ea545caaf20fe76e3c209c8 1e18d2b4b07745ea87f636a416df2de4--3ff5bf7d2ea545caaf20fe76e3c209c8 98f6bbf16c7f4a2a84b6681c22674a6f 3ff5bf7d2ea545caaf20fe76e3c209c8--98f6bbf16c7f4a2a84b6681c22674a6f 826b22e48ad94b308d339065c38ab00b 98f6bbf16c7f4a2a84b6681c22674a6f--826b22e48ad94b308d339065c38ab00b 2b83fe7120244b598d0c3f33045df502 826b22e48ad94b308d339065c38ab00b--2b83fe7120244b598d0c3f33045df502 6e5824fbd4464151bdcbcf9affd71ec0 2b83fe7120244b598d0c3f33045df502--6e5824fbd4464151bdcbcf9affd71ec0 eb81787a1c7648b39c8f3d9f03a7044d 6e5824fbd4464151bdcbcf9affd71ec0--eb81787a1c7648b39c8f3d9f03a7044d d2ad649d643c460a8b0c2419a3cddd57 eb81787a1c7648b39c8f3d9f03a7044d--d2ad649d643c460a8b0c2419a3cddd57 ad531e0aacf44ebc9715adc75e745d4c d2ad649d643c460a8b0c2419a3cddd57--ad531e0aacf44ebc9715adc75e745d4c 905520104a5a4bb0b4738193ac87dac7 ad531e0aacf44ebc9715adc75e745d4c--905520104a5a4bb0b4738193ac87dac7 c0da4c173d8940cdbb1336e6a4157980 905520104a5a4bb0b4738193ac87dac7--c0da4c173d8940cdbb1336e6a4157980 946890c774624a07ae508b2ecd25bb1f c0da4c173d8940cdbb1336e6a4157980--946890c774624a07ae508b2ecd25bb1f f0557c177273432bb1eceb7eb6c43653 946890c774624a07ae508b2ecd25bb1f--f0557c177273432bb1eceb7eb6c43653 42396f7a4b584d879d2f70e644b013e6 f0557c177273432bb1eceb7eb6c43653--42396f7a4b584d879d2f70e644b013e6 2486708db2bf4b79acc64bf2bcddfe71 X 42396f7a4b584d879d2f70e644b013e6--2486708db2bf4b79acc64bf2bcddfe71 2486708db2bf4b79acc64bf2bcddfe71--9b58241e601344ca9910cb0836a9a69b cbd3b0c3b0d047378942b316eafb3ad4 RZ(-1.0*g0) 2486708db2bf4b79acc64bf2bcddfe71--cbd3b0c3b0d047378942b316eafb3ad4 6e148a20c4f94f288d1ae7e8b9126606 X cbd3b0c3b0d047378942b316eafb3ad4--6e148a20c4f94f288d1ae7e8b9126606 6e148a20c4f94f288d1ae7e8b9126606--ec7a1f7a818c43339b3f19083d427c57 2523f4ed26674b269ad9f0bf1acaf490 6e148a20c4f94f288d1ae7e8b9126606--2523f4ed26674b269ad9f0bf1acaf490 e410bc78e9774c458e4a2e36c5c03c81 2523f4ed26674b269ad9f0bf1acaf490--e410bc78e9774c458e4a2e36c5c03c81 cdaf53559a744d8b9b88c080dc51d918 e410bc78e9774c458e4a2e36c5c03c81--cdaf53559a744d8b9b88c080dc51d918 61e47cae23f64b17b1265078415389ca cdaf53559a744d8b9b88c080dc51d918--61e47cae23f64b17b1265078415389ca 66044af351c34f2f81bd61517ea83e8d 61e47cae23f64b17b1265078415389ca--66044af351c34f2f81bd61517ea83e8d d0b6bfe6ce0e436782a95590a74668d5 66044af351c34f2f81bd61517ea83e8d--d0b6bfe6ce0e436782a95590a74668d5 811f9b322f2b4141a1bcebe50339074f X d0b6bfe6ce0e436782a95590a74668d5--811f9b322f2b4141a1bcebe50339074f 811f9b322f2b4141a1bcebe50339074f--9cfbe9954b944729aa493c7085245e6f 0ac4389612e64895a7be68d1b6fa6367 811f9b322f2b4141a1bcebe50339074f--0ac4389612e64895a7be68d1b6fa6367 7bdedbe5f8b44f9489526441f01a6f74 0ac4389612e64895a7be68d1b6fa6367--7bdedbe5f8b44f9489526441f01a6f74 1d1992fd8ef3489cb7f847c5e4566e5a 7bdedbe5f8b44f9489526441f01a6f74--1d1992fd8ef3489cb7f847c5e4566e5a a9dcebb8d70e434c9807b87137941ff7 X 1d1992fd8ef3489cb7f847c5e4566e5a--a9dcebb8d70e434c9807b87137941ff7 a9dcebb8d70e434c9807b87137941ff7--9ab872c245c647b58aaaf2122e096529 b1d3a08086954d0f99fa002ac572ec3e a9dcebb8d70e434c9807b87137941ff7--b1d3a08086954d0f99fa002ac572ec3e 631b5c42094c45bb9d0714a008d58a2d b1d3a08086954d0f99fa002ac572ec3e--631b5c42094c45bb9d0714a008d58a2d fa855cc6a13447eaa48e51761c5b8e32 631b5c42094c45bb9d0714a008d58a2d--fa855cc6a13447eaa48e51761c5b8e32 5864fe7115684a788b08fe42a930a308 fa855cc6a13447eaa48e51761c5b8e32--5864fe7115684a788b08fe42a930a308 2bf90cb668494e0eaa920699ceb55c8f 5864fe7115684a788b08fe42a930a308--2bf90cb668494e0eaa920699ceb55c8f 19ef991621014c328133a41d05fe2501 2bf90cb668494e0eaa920699ceb55c8f--19ef991621014c328133a41d05fe2501 b2e78a49c904466cbc3de7075f59f15c 19ef991621014c328133a41d05fe2501--b2e78a49c904466cbc3de7075f59f15c e4dfee3df8c947c5a9dcf0ccdeb6f967 b2e78a49c904466cbc3de7075f59f15c--e4dfee3df8c947c5a9dcf0ccdeb6f967 446fbda3a76845c8b9ee8dd366b00e9c e4dfee3df8c947c5a9dcf0ccdeb6f967--446fbda3a76845c8b9ee8dd366b00e9c 257987ebd52046088b81e4cc5ef979fe 446fbda3a76845c8b9ee8dd366b00e9c--257987ebd52046088b81e4cc5ef979fe b131f2293ad8457f8239be33bafb53a2 X 257987ebd52046088b81e4cc5ef979fe--b131f2293ad8457f8239be33bafb53a2 b131f2293ad8457f8239be33bafb53a2--88226d9f1c15412fbc976bb0157a0287 4d4839e1fea542ac997df8cb8c1c8d55 RZ(-1.0*g0) b131f2293ad8457f8239be33bafb53a2--4d4839e1fea542ac997df8cb8c1c8d55 3d769c6348544bf5a235ec98dfdd6597 X 4d4839e1fea542ac997df8cb8c1c8d55--3d769c6348544bf5a235ec98dfdd6597 3d769c6348544bf5a235ec98dfdd6597--fdc015e1dadf4e488afa089ceb72f510 2442230d148a4522b1bd73db94d1b31d 3d769c6348544bf5a235ec98dfdd6597--2442230d148a4522b1bd73db94d1b31d 05e5ca510ce746da84bada98d1105ed1 2442230d148a4522b1bd73db94d1b31d--05e5ca510ce746da84bada98d1105ed1 39e51847026644c49f1ce71da995b445 05e5ca510ce746da84bada98d1105ed1--39e51847026644c49f1ce71da995b445 7ad766680a09416e9666cbcf68e3f6f3 39e51847026644c49f1ce71da995b445--7ad766680a09416e9666cbcf68e3f6f3 6aa205ddf60848eea0b434e2f304ed65 7ad766680a09416e9666cbcf68e3f6f3--6aa205ddf60848eea0b434e2f304ed65 fcb2d0a3dc3245e78e55fc4dbbee0c26 X 6aa205ddf60848eea0b434e2f304ed65--fcb2d0a3dc3245e78e55fc4dbbee0c26 fcb2d0a3dc3245e78e55fc4dbbee0c26--0502802cf1de47cd905462e96fe9fdc4 74783e2d47b94ff08961b80a61e3492f fcb2d0a3dc3245e78e55fc4dbbee0c26--74783e2d47b94ff08961b80a61e3492f a80fff19bb134f189258b0c2dda0f82f 74783e2d47b94ff08961b80a61e3492f--a80fff19bb134f189258b0c2dda0f82f 3ae8ee14b07f4b6b94fdadbc521c6938 a80fff19bb134f189258b0c2dda0f82f--3ae8ee14b07f4b6b94fdadbc521c6938 bf62a09320574dde9b0d8d3b2783d17f X 3ae8ee14b07f4b6b94fdadbc521c6938--bf62a09320574dde9b0d8d3b2783d17f bf62a09320574dde9b0d8d3b2783d17f--dff748f6878b40f5b201dcda4b0a93af 41eedec774ff4801a9bf8483707aee4c bf62a09320574dde9b0d8d3b2783d17f--41eedec774ff4801a9bf8483707aee4c 8eacd2045fc84a39aac17aaeffa8ab2c 41eedec774ff4801a9bf8483707aee4c--8eacd2045fc84a39aac17aaeffa8ab2c 5541c9fa79e4406cab44ad84321bb361 8eacd2045fc84a39aac17aaeffa8ab2c--5541c9fa79e4406cab44ad84321bb361 5dc4dd95bd8b4f1996607bb77bdfa6fc RX(b06) 5541c9fa79e4406cab44ad84321bb361--5dc4dd95bd8b4f1996607bb77bdfa6fc 13b8360435ae4e20a3f9738fad64d628 5dc4dd95bd8b4f1996607bb77bdfa6fc--13b8360435ae4e20a3f9738fad64d628 22428db2b535466ba14c111f4a86d14d 13b8360435ae4e20a3f9738fad64d628--22428db2b535466ba14c111f4a86d14d 816f8cb8ac094724b846793d6b1f708a 22428db2b535466ba14c111f4a86d14d--816f8cb8ac094724b846793d6b1f708a cc44892f40694608b7f9bff41ae84cf0 816f8cb8ac094724b846793d6b1f708a--cc44892f40694608b7f9bff41ae84cf0 56b03b68be5746d2b808d5c10d11672b cc44892f40694608b7f9bff41ae84cf0--56b03b68be5746d2b808d5c10d11672b 29bfd6205cb64eca9b22a9ba3ef3a684 X 56b03b68be5746d2b808d5c10d11672b--29bfd6205cb64eca9b22a9ba3ef3a684 29bfd6205cb64eca9b22a9ba3ef3a684--9a5fa71126f94d4db9115e4a845ce00f 0ced779c524948c7a206b25b7034efa3 29bfd6205cb64eca9b22a9ba3ef3a684--0ced779c524948c7a206b25b7034efa3 2c007ed2910647a3ae477e48f263d79b 0ced779c524948c7a206b25b7034efa3--2c007ed2910647a3ae477e48f263d79b f3e2bea9ca4a4535b58954946bd03763 2c007ed2910647a3ae477e48f263d79b--f3e2bea9ca4a4535b58954946bd03763 fd82e5732d62470ca3d1fed201eba050 X f3e2bea9ca4a4535b58954946bd03763--fd82e5732d62470ca3d1fed201eba050 fd82e5732d62470ca3d1fed201eba050--980b225fe5d44596ab36a410a4fe8f5a 7f5471c91cf64a1dbb7fa71e6a1880e8 fd82e5732d62470ca3d1fed201eba050--7f5471c91cf64a1dbb7fa71e6a1880e8 f7465ca0394b46d5a009749ac7b7ddee 7f5471c91cf64a1dbb7fa71e6a1880e8--f7465ca0394b46d5a009749ac7b7ddee 4b20524f82644921a05a11d0317841ea f7465ca0394b46d5a009749ac7b7ddee--4b20524f82644921a05a11d0317841ea 0a10b0efbc3d4d93aa6818c7a2c6fb78 4b20524f82644921a05a11d0317841ea--0a10b0efbc3d4d93aa6818c7a2c6fb78 ab83cd03781342959d35f7d58039baf9 0a10b0efbc3d4d93aa6818c7a2c6fb78--ab83cd03781342959d35f7d58039baf9 43e98c4670cf4b7f9986c2937e0bf0fc ab83cd03781342959d35f7d58039baf9--43e98c4670cf4b7f9986c2937e0bf0fc d3ae600e76c44ddab49fdddf164c0c1b 43e98c4670cf4b7f9986c2937e0bf0fc--d3ae600e76c44ddab49fdddf164c0c1b f294dcfbc06640678485bae9c80e2e6f d3ae600e76c44ddab49fdddf164c0c1b--f294dcfbc06640678485bae9c80e2e6f 92eb1ec6eaa2425eb78a159943071126 f294dcfbc06640678485bae9c80e2e6f--92eb1ec6eaa2425eb78a159943071126 a682d3ba1c2e43919672345e070058b4 92eb1ec6eaa2425eb78a159943071126--a682d3ba1c2e43919672345e070058b4 7c108c6cd13a4f9a8b1090f0a3258177 a682d3ba1c2e43919672345e070058b4--7c108c6cd13a4f9a8b1090f0a3258177 6376b9d14ead43438a03eb9147a99ff3 7c108c6cd13a4f9a8b1090f0a3258177--6376b9d14ead43438a03eb9147a99ff3 b90e2e5111e34282b983b92d5675ee88 6376b9d14ead43438a03eb9147a99ff3--b90e2e5111e34282b983b92d5675ee88 0d149d58c58741ef9f984276fb883f98 b90e2e5111e34282b983b92d5675ee88--0d149d58c58741ef9f984276fb883f98 caeba2981cfb4561b40df74ece3a7b31 0d149d58c58741ef9f984276fb883f98--caeba2981cfb4561b40df74ece3a7b31 4b8ba85d0b314194b676c19f1595ef56 caeba2981cfb4561b40df74ece3a7b31--4b8ba85d0b314194b676c19f1595ef56 c70859a8af814ba7bf53b92221d10074 4b8ba85d0b314194b676c19f1595ef56--c70859a8af814ba7bf53b92221d10074 957c36623d4d4028854f195622807695 c70859a8af814ba7bf53b92221d10074--957c36623d4d4028854f195622807695 d0b373d6b62b49078c729d9dd024ffb1 957c36623d4d4028854f195622807695--d0b373d6b62b49078c729d9dd024ffb1 263cfcb9eff64e08b9dbb69e6030649e d0b373d6b62b49078c729d9dd024ffb1--263cfcb9eff64e08b9dbb69e6030649e cdf52999112341ccad75c6ed24ab7d19 263cfcb9eff64e08b9dbb69e6030649e--cdf52999112341ccad75c6ed24ab7d19 6a4e716dea50476f9c5f87bb9d636ce6 cdf52999112341ccad75c6ed24ab7d19--6a4e716dea50476f9c5f87bb9d636ce6 d76bedd096094258a5b54c01824de34f 6a4e716dea50476f9c5f87bb9d636ce6--d76bedd096094258a5b54c01824de34f cb7528f1bd00405c9a0e52cc23549881 d76bedd096094258a5b54c01824de34f--cb7528f1bd00405c9a0e52cc23549881 67e1ea84f33c488792c720b3fde0f508 cb7528f1bd00405c9a0e52cc23549881--67e1ea84f33c488792c720b3fde0f508 00ccdbfe0fdb497889b64dfa4afdceec 67e1ea84f33c488792c720b3fde0f508--00ccdbfe0fdb497889b64dfa4afdceec 8c6b3fbee3f54bf0ac08b1227d1d98a1 00ccdbfe0fdb497889b64dfa4afdceec--8c6b3fbee3f54bf0ac08b1227d1d98a1 fcdb920ecb0b438a9709f7879a9c35a9 X 8c6b3fbee3f54bf0ac08b1227d1d98a1--fcdb920ecb0b438a9709f7879a9c35a9 fcdb920ecb0b438a9709f7879a9c35a9--b236afd1ced34e74b38a84d6e49e65d3 eb6df96790cb432da0657c0888021f10 fcdb920ecb0b438a9709f7879a9c35a9--eb6df96790cb432da0657c0888021f10 ce71f695a088437991ee4ef41921b4f0 eb6df96790cb432da0657c0888021f10--ce71f695a088437991ee4ef41921b4f0 85e7967a2a954bd29105d823de84afc7 ce71f695a088437991ee4ef41921b4f0--85e7967a2a954bd29105d823de84afc7 0c3c92e0d45543078f54e1a0d8a7f4a9 X 85e7967a2a954bd29105d823de84afc7--0c3c92e0d45543078f54e1a0d8a7f4a9 0c3c92e0d45543078f54e1a0d8a7f4a9--6badbca8b7b64f2b9b439447fd61ec12 785d764d5fa542d3ac69c9596dc4c5f5 0c3c92e0d45543078f54e1a0d8a7f4a9--785d764d5fa542d3ac69c9596dc4c5f5 90cbf53758844c759c5721d64fb5de91 785d764d5fa542d3ac69c9596dc4c5f5--90cbf53758844c759c5721d64fb5de91 0b5b9cc5365740c1bcee66287dd317ad 90cbf53758844c759c5721d64fb5de91--0b5b9cc5365740c1bcee66287dd317ad d58f4e89f3ea4c409cd62f188c717c02 0b5b9cc5365740c1bcee66287dd317ad--d58f4e89f3ea4c409cd62f188c717c02 c51cfd24cbb34c459f69ee5ea7c824f0 d58f4e89f3ea4c409cd62f188c717c02--c51cfd24cbb34c459f69ee5ea7c824f0 179bc6eb6ab34f9b998c7c6f02bdaccf c51cfd24cbb34c459f69ee5ea7c824f0--179bc6eb6ab34f9b998c7c6f02bdaccf d9db867de8124c3382819993c27db9ef 179bc6eb6ab34f9b998c7c6f02bdaccf--d9db867de8124c3382819993c27db9ef c370c4bdb97840d4aff3391151fda1aa d9db867de8124c3382819993c27db9ef--c370c4bdb97840d4aff3391151fda1aa ee46f64e7e5a4a01a97bd58227a7603f c370c4bdb97840d4aff3391151fda1aa--ee46f64e7e5a4a01a97bd58227a7603f ac404224adb947aa936404d9d172fd2e ee46f64e7e5a4a01a97bd58227a7603f--ac404224adb947aa936404d9d172fd2e 9628f5793f274e578401b66fd44ebeed ac404224adb947aa936404d9d172fd2e--9628f5793f274e578401b66fd44ebeed d86abebab1f64c61985e6271d54959b0 9628f5793f274e578401b66fd44ebeed--d86abebab1f64c61985e6271d54959b0 4132d22550b5401190bbbd772458980d d86abebab1f64c61985e6271d54959b0--4132d22550b5401190bbbd772458980d 4184414563cd49d8a6f914d54d0e6b15 4132d22550b5401190bbbd772458980d--4184414563cd49d8a6f914d54d0e6b15 b470ddc10e104a24b693b7a00f5736d6 4184414563cd49d8a6f914d54d0e6b15--b470ddc10e104a24b693b7a00f5736d6 a72eeca352f1493b8abb6036737842f9 b470ddc10e104a24b693b7a00f5736d6--a72eeca352f1493b8abb6036737842f9 09c616770430482d83a931a34aa53b8c X a72eeca352f1493b8abb6036737842f9--09c616770430482d83a931a34aa53b8c 09c616770430482d83a931a34aa53b8c--5647613eee514689bbab620c01e49a10 508fe7ae91844699bab59126d78d312d RZ(-1.0*g1) 09c616770430482d83a931a34aa53b8c--508fe7ae91844699bab59126d78d312d 368f55e6bbd3474284a5a1c6c3ee5220 X 508fe7ae91844699bab59126d78d312d--368f55e6bbd3474284a5a1c6c3ee5220 368f55e6bbd3474284a5a1c6c3ee5220--33da9506deb34fbf9611a4a8f771fb9b 1472e44df8c74c61b954a97d466d4d5d 368f55e6bbd3474284a5a1c6c3ee5220--1472e44df8c74c61b954a97d466d4d5d 1b2436c7dcf54ebaa52e528ec6cf7b74 1472e44df8c74c61b954a97d466d4d5d--1b2436c7dcf54ebaa52e528ec6cf7b74 546d5123b79649a4863a0cea676a103b 1b2436c7dcf54ebaa52e528ec6cf7b74--546d5123b79649a4863a0cea676a103b ba5ec194045945f4b56bb62b80fee0cd 546d5123b79649a4863a0cea676a103b--ba5ec194045945f4b56bb62b80fee0cd cb824bb7be9e49488f92957809a0af5e ba5ec194045945f4b56bb62b80fee0cd--cb824bb7be9e49488f92957809a0af5e c0c09f36d50e4278ac4f07d203e66ccf cb824bb7be9e49488f92957809a0af5e--c0c09f36d50e4278ac4f07d203e66ccf 5dc7165fba6a4d919017e9615e38424b X c0c09f36d50e4278ac4f07d203e66ccf--5dc7165fba6a4d919017e9615e38424b 5dc7165fba6a4d919017e9615e38424b--a19cf8ec18bc48cfa3fda5d1e01767c2 0ead0cd72768497bb9e4d934997e39aa 5dc7165fba6a4d919017e9615e38424b--0ead0cd72768497bb9e4d934997e39aa f9f1fee3e0854f089abc198a69313c81 0ead0cd72768497bb9e4d934997e39aa--f9f1fee3e0854f089abc198a69313c81 b749fc252b3044d8a31c937ae17598d5 f9f1fee3e0854f089abc198a69313c81--b749fc252b3044d8a31c937ae17598d5 be6344deb6b7497fbc0dfdad5f48e3ac X b749fc252b3044d8a31c937ae17598d5--be6344deb6b7497fbc0dfdad5f48e3ac be6344deb6b7497fbc0dfdad5f48e3ac--164a2cb34103424ca83d260bb9d7dd9f 236405e9dd094965bfcbbef5a477c021 be6344deb6b7497fbc0dfdad5f48e3ac--236405e9dd094965bfcbbef5a477c021 62452191aa94490a9ffddfa7add609a3 236405e9dd094965bfcbbef5a477c021--62452191aa94490a9ffddfa7add609a3 eaa3be170940440582f09cdd926e7a00 62452191aa94490a9ffddfa7add609a3--eaa3be170940440582f09cdd926e7a00 4cb0b6b0949c445ca84d94e855b4a170 eaa3be170940440582f09cdd926e7a00--4cb0b6b0949c445ca84d94e855b4a170 57c54319e3eb41da8c058f7f7ded6bc7 4cb0b6b0949c445ca84d94e855b4a170--57c54319e3eb41da8c058f7f7ded6bc7 c03db16921a54907873089c6c602661f 57c54319e3eb41da8c058f7f7ded6bc7--c03db16921a54907873089c6c602661f 01cce660c3264a129d41999f58aa71ff c03db16921a54907873089c6c602661f--01cce660c3264a129d41999f58aa71ff 70ed1a279504417096af6252ea6c5a79 01cce660c3264a129d41999f58aa71ff--70ed1a279504417096af6252ea6c5a79 2d4f4f6a883f4539a33745f7a1cda811 70ed1a279504417096af6252ea6c5a79--2d4f4f6a883f4539a33745f7a1cda811 9aca412ec6b740f9a887ade196b262f2 2d4f4f6a883f4539a33745f7a1cda811--9aca412ec6b740f9a887ade196b262f2 821180e0682847c2a117bf7a9e7c79d6 X 9aca412ec6b740f9a887ade196b262f2--821180e0682847c2a117bf7a9e7c79d6 821180e0682847c2a117bf7a9e7c79d6--e785d0858a1b49ecba7fc55a33282664 3bb238ee2dbf4c0fa475bde17a2e7627 RZ(-1.0*g1) 821180e0682847c2a117bf7a9e7c79d6--3bb238ee2dbf4c0fa475bde17a2e7627 e27ac74380984ccc954715be3202a95f X 3bb238ee2dbf4c0fa475bde17a2e7627--e27ac74380984ccc954715be3202a95f e27ac74380984ccc954715be3202a95f--941529bb4b34477cb744e091af13d1da 80338ba514d34dc4945bf0d77295f564 e27ac74380984ccc954715be3202a95f--80338ba514d34dc4945bf0d77295f564 7fdc97e635bd49419bc1a8b20d28d42f 80338ba514d34dc4945bf0d77295f564--7fdc97e635bd49419bc1a8b20d28d42f bf40c9ea4fa6489ba64b12063a00e5d7 7fdc97e635bd49419bc1a8b20d28d42f--bf40c9ea4fa6489ba64b12063a00e5d7 caa54f00c90740f6bfce40a5adea9a27 bf40c9ea4fa6489ba64b12063a00e5d7--caa54f00c90740f6bfce40a5adea9a27 b28c3a0cb64e4e1d974889183669d676 caa54f00c90740f6bfce40a5adea9a27--b28c3a0cb64e4e1d974889183669d676 d3c9ec6b733848059a7c2914da2f6f00 X b28c3a0cb64e4e1d974889183669d676--d3c9ec6b733848059a7c2914da2f6f00 d3c9ec6b733848059a7c2914da2f6f00--cd5a106111dc45f9b6f227b598ed0c5c 6e365c4cbc3d483995c9594916b24a67 d3c9ec6b733848059a7c2914da2f6f00--6e365c4cbc3d483995c9594916b24a67 1a743f33d0fd46e9bf8d573f47e0480b 6e365c4cbc3d483995c9594916b24a67--1a743f33d0fd46e9bf8d573f47e0480b 8a2c0a93b65947ce909aa370e2e27821 1a743f33d0fd46e9bf8d573f47e0480b--8a2c0a93b65947ce909aa370e2e27821 d3899d12fd714350856d9b3d9e0f845a X 8a2c0a93b65947ce909aa370e2e27821--d3899d12fd714350856d9b3d9e0f845a d3899d12fd714350856d9b3d9e0f845a--284c3b2ba990423f92f83dbf6c740f8b 8316efbd8f2e4c1aa3bc7fae0c1413fc d3899d12fd714350856d9b3d9e0f845a--8316efbd8f2e4c1aa3bc7fae0c1413fc 733dea12ed014088b831f2cb662b2886 8316efbd8f2e4c1aa3bc7fae0c1413fc--733dea12ed014088b831f2cb662b2886 bb46faad6ebd47f38907b4a5c87d32a8 733dea12ed014088b831f2cb662b2886--bb46faad6ebd47f38907b4a5c87d32a8 08aa3f3a1b6b43629a8ffa45de5561ef RX(b16) bb46faad6ebd47f38907b4a5c87d32a8--08aa3f3a1b6b43629a8ffa45de5561ef 08aa3f3a1b6b43629a8ffa45de5561ef--0e5f0a4ac1864676a826b6707be15e9f 4fe9de1f93774234a4eb50af0ffce51d bcc98b4737f24c5b88efed0f0ebed926 d09e6b77893f4735b5a3b83b7425eeeb--bcc98b4737f24c5b88efed0f0ebed926 71f9d62b378148a0be375eb0d8acbe8b bcc98b4737f24c5b88efed0f0ebed926--71f9d62b378148a0be375eb0d8acbe8b aae9584a33c041d0837e43de1cf29582 71f9d62b378148a0be375eb0d8acbe8b--aae9584a33c041d0837e43de1cf29582 780044c3a4dc4915b70822de01a64b9b aae9584a33c041d0837e43de1cf29582--780044c3a4dc4915b70822de01a64b9b 59638150a9ac46da89e2a943eb54bbec 780044c3a4dc4915b70822de01a64b9b--59638150a9ac46da89e2a943eb54bbec 69d0801121ea49a5affc11e800d177b7 59638150a9ac46da89e2a943eb54bbec--69d0801121ea49a5affc11e800d177b7 bd8d79ff1e5f48b39b15e17150d387e6 X 69d0801121ea49a5affc11e800d177b7--bd8d79ff1e5f48b39b15e17150d387e6 bd8d79ff1e5f48b39b15e17150d387e6--0d61362595f64112a4304556893b2080 f2cd26a319114e82b40619bddb2d5cea RZ(1.0*g0) bd8d79ff1e5f48b39b15e17150d387e6--f2cd26a319114e82b40619bddb2d5cea 1408b6b2687d4eda90e7682d810731fa X f2cd26a319114e82b40619bddb2d5cea--1408b6b2687d4eda90e7682d810731fa 1408b6b2687d4eda90e7682d810731fa--ae0f61287e344d6499e66be9f3d7ae76 0094fb6aa31549ad8f1bcb7d18b64f3a 1408b6b2687d4eda90e7682d810731fa--0094fb6aa31549ad8f1bcb7d18b64f3a 1310f0081acb4045af98eb79baca316c 0094fb6aa31549ad8f1bcb7d18b64f3a--1310f0081acb4045af98eb79baca316c 6844c53ce63c4dae9db99b265ef33a95 1310f0081acb4045af98eb79baca316c--6844c53ce63c4dae9db99b265ef33a95 36d49d6dee6b46baae56ebe3cf85bd8e 6844c53ce63c4dae9db99b265ef33a95--36d49d6dee6b46baae56ebe3cf85bd8e c2056dc7d0714c089c2b7c43ef3bb5b5 36d49d6dee6b46baae56ebe3cf85bd8e--c2056dc7d0714c089c2b7c43ef3bb5b5 f35ac1b21fb14922b58f89c03455619a c2056dc7d0714c089c2b7c43ef3bb5b5--f35ac1b21fb14922b58f89c03455619a a2dbabf1b76a4de1a5388c6f0c94e0db f35ac1b21fb14922b58f89c03455619a--a2dbabf1b76a4de1a5388c6f0c94e0db 2746a7b89b974873a6b5660c780a5209 a2dbabf1b76a4de1a5388c6f0c94e0db--2746a7b89b974873a6b5660c780a5209 433c6bceacd947d0bba27416f3c9e625 2746a7b89b974873a6b5660c780a5209--433c6bceacd947d0bba27416f3c9e625 63282656179a429f836641a529a51c4e 433c6bceacd947d0bba27416f3c9e625--63282656179a429f836641a529a51c4e ef907dabef364f06ae52d5b7f2b58e56 63282656179a429f836641a529a51c4e--ef907dabef364f06ae52d5b7f2b58e56 7952f48b911744c988316901ca4eb7b5 ef907dabef364f06ae52d5b7f2b58e56--7952f48b911744c988316901ca4eb7b5 3e7c7795ab004bbfb592ac06612a6ecb 7952f48b911744c988316901ca4eb7b5--3e7c7795ab004bbfb592ac06612a6ecb ae4e6fa2a21840bc9b59fbacdc3015e3 3e7c7795ab004bbfb592ac06612a6ecb--ae4e6fa2a21840bc9b59fbacdc3015e3 bf4a2c86003b421bbdf2777e3c0458c6 ae4e6fa2a21840bc9b59fbacdc3015e3--bf4a2c86003b421bbdf2777e3c0458c6 0fc06919470140d2bddde08af9391280 bf4a2c86003b421bbdf2777e3c0458c6--0fc06919470140d2bddde08af9391280 d9babd69cc6848fb9ab46c0ebdd485ef 0fc06919470140d2bddde08af9391280--d9babd69cc6848fb9ab46c0ebdd485ef 0174b7e74fc1420e91646248b27d3c40 d9babd69cc6848fb9ab46c0ebdd485ef--0174b7e74fc1420e91646248b27d3c40 c591b3f3d8be48dc9114d36329078ae8 0174b7e74fc1420e91646248b27d3c40--c591b3f3d8be48dc9114d36329078ae8 86a6c38ac773450db6000429ffe93025 c591b3f3d8be48dc9114d36329078ae8--86a6c38ac773450db6000429ffe93025 4ca10043082a4921b87df6e07d17fa80 86a6c38ac773450db6000429ffe93025--4ca10043082a4921b87df6e07d17fa80 0c1aebb348c04bc5822f4c0ec91050f0 4ca10043082a4921b87df6e07d17fa80--0c1aebb348c04bc5822f4c0ec91050f0 e52c54a1169344a7a933e158c74a0c22 0c1aebb348c04bc5822f4c0ec91050f0--e52c54a1169344a7a933e158c74a0c22 ebbf8e0eba694fcd8b66ef278d9c4dbb e52c54a1169344a7a933e158c74a0c22--ebbf8e0eba694fcd8b66ef278d9c4dbb 86f5cbe04ff14073b0c694d9ce77cbe3 ebbf8e0eba694fcd8b66ef278d9c4dbb--86f5cbe04ff14073b0c694d9ce77cbe3 aa9906e80c6c436ab1a45cb7916a3029 86f5cbe04ff14073b0c694d9ce77cbe3--aa9906e80c6c436ab1a45cb7916a3029 b26f6ae7192a4e3d9206206cd98e208b aa9906e80c6c436ab1a45cb7916a3029--b26f6ae7192a4e3d9206206cd98e208b 869b663ccda145918118a1b1612028bc b26f6ae7192a4e3d9206206cd98e208b--869b663ccda145918118a1b1612028bc 806ef65ec3dd43008d69109b64128e38 869b663ccda145918118a1b1612028bc--806ef65ec3dd43008d69109b64128e38 ed6e2fc7f8ce45609e7401b8337e609e X 806ef65ec3dd43008d69109b64128e38--ed6e2fc7f8ce45609e7401b8337e609e ed6e2fc7f8ce45609e7401b8337e609e--360fa90a02044627ab520193f5c6e127 e976ad16f7984f70b501c6aa54e04765 RZ(-1.0*g0) ed6e2fc7f8ce45609e7401b8337e609e--e976ad16f7984f70b501c6aa54e04765 b390076b715c44a1a57cb852c4fa6a28 X e976ad16f7984f70b501c6aa54e04765--b390076b715c44a1a57cb852c4fa6a28 b390076b715c44a1a57cb852c4fa6a28--9f677af44c8f4ab9a0b97437bc6e8f86 0254ec2083b145579767f46024349042 b390076b715c44a1a57cb852c4fa6a28--0254ec2083b145579767f46024349042 4456ba8993094c2cb1a5067230c05b9e 0254ec2083b145579767f46024349042--4456ba8993094c2cb1a5067230c05b9e 20ba13ae598c4840972bb839776c523f 4456ba8993094c2cb1a5067230c05b9e--20ba13ae598c4840972bb839776c523f 26933b785b924ba496faf3bdf22edf7d 20ba13ae598c4840972bb839776c523f--26933b785b924ba496faf3bdf22edf7d 788295f42b264a078d5a4faad628b424 26933b785b924ba496faf3bdf22edf7d--788295f42b264a078d5a4faad628b424 ab3b0030cb904b2485f9345b743d1553 788295f42b264a078d5a4faad628b424--ab3b0030cb904b2485f9345b743d1553 922801bcfdda46448796c8e61170b4b2 ab3b0030cb904b2485f9345b743d1553--922801bcfdda46448796c8e61170b4b2 06aeaa01ccec49bea137ded9bcb8de34 922801bcfdda46448796c8e61170b4b2--06aeaa01ccec49bea137ded9bcb8de34 d942d4891260441a9aebca32195ebe8f 06aeaa01ccec49bea137ded9bcb8de34--d942d4891260441a9aebca32195ebe8f b6c3782060134106a18ac7d2955d5786 d942d4891260441a9aebca32195ebe8f--b6c3782060134106a18ac7d2955d5786 4f4872de924f4c759473577941a7df7e b6c3782060134106a18ac7d2955d5786--4f4872de924f4c759473577941a7df7e 582626ce01a048e6b672f4a2e1837fc4 4f4872de924f4c759473577941a7df7e--582626ce01a048e6b672f4a2e1837fc4 ba80a859993b47cb9644076955b3b977 582626ce01a048e6b672f4a2e1837fc4--ba80a859993b47cb9644076955b3b977 bed6de67adef4278bbe0d47e2928ab40 ba80a859993b47cb9644076955b3b977--bed6de67adef4278bbe0d47e2928ab40 a84ebc5be6254783a45897ab601a9ee5 bed6de67adef4278bbe0d47e2928ab40--a84ebc5be6254783a45897ab601a9ee5 eac835d7550c4eb19e711b04c5728979 a84ebc5be6254783a45897ab601a9ee5--eac835d7550c4eb19e711b04c5728979 aa419a2569c8469d8a706eb3d57bef81 eac835d7550c4eb19e711b04c5728979--aa419a2569c8469d8a706eb3d57bef81 64a496e385514ddc86eb6f96af10b03d aa419a2569c8469d8a706eb3d57bef81--64a496e385514ddc86eb6f96af10b03d 032a03679ed54ab7bb9b7fa0d55292cf 64a496e385514ddc86eb6f96af10b03d--032a03679ed54ab7bb9b7fa0d55292cf 340fd6ecfbda4d81b2d15b1a1fad81da 032a03679ed54ab7bb9b7fa0d55292cf--340fd6ecfbda4d81b2d15b1a1fad81da dc520a4d34b04ab3a62311b7ed4f56d7 340fd6ecfbda4d81b2d15b1a1fad81da--dc520a4d34b04ab3a62311b7ed4f56d7 4722e62f2fac4d5aaaa3dd9b261fd3d2 dc520a4d34b04ab3a62311b7ed4f56d7--4722e62f2fac4d5aaaa3dd9b261fd3d2 36785327ea2d4397a6c01e71143943ec 4722e62f2fac4d5aaaa3dd9b261fd3d2--36785327ea2d4397a6c01e71143943ec 5cb4758d89c247378a98dff3ac5c78e8 36785327ea2d4397a6c01e71143943ec--5cb4758d89c247378a98dff3ac5c78e8 4f0358881e374b93ab2a9f329e623932 5cb4758d89c247378a98dff3ac5c78e8--4f0358881e374b93ab2a9f329e623932 2b41ec7508d34f48ba196a36ebfb1aa4 4f0358881e374b93ab2a9f329e623932--2b41ec7508d34f48ba196a36ebfb1aa4 a3ac6d895b2d429f99900e395d5438fc 2b41ec7508d34f48ba196a36ebfb1aa4--a3ac6d895b2d429f99900e395d5438fc e492a06119954768b29c18557c06c0a9 X a3ac6d895b2d429f99900e395d5438fc--e492a06119954768b29c18557c06c0a9 e492a06119954768b29c18557c06c0a9--0ac4389612e64895a7be68d1b6fa6367 32489080a8d840bb97c5d7ebc5d09200 RZ(-1.0*g0) e492a06119954768b29c18557c06c0a9--32489080a8d840bb97c5d7ebc5d09200 fbb70802948e4a1ea5c1c9648f23f5f4 X 32489080a8d840bb97c5d7ebc5d09200--fbb70802948e4a1ea5c1c9648f23f5f4 fbb70802948e4a1ea5c1c9648f23f5f4--1d1992fd8ef3489cb7f847c5e4566e5a 8d53de17e8fd466eb0727f814eef2627 fbb70802948e4a1ea5c1c9648f23f5f4--8d53de17e8fd466eb0727f814eef2627 2d17dd55cbc04d43b614c5278863297e 8d53de17e8fd466eb0727f814eef2627--2d17dd55cbc04d43b614c5278863297e e1fdb0c5424f4c5babc20f8628df2217 2d17dd55cbc04d43b614c5278863297e--e1fdb0c5424f4c5babc20f8628df2217 7ad8fac65ee847d7ae05878d63141b5a e1fdb0c5424f4c5babc20f8628df2217--7ad8fac65ee847d7ae05878d63141b5a ff52f3f3bc4a442182efc119e87b67e1 7ad8fac65ee847d7ae05878d63141b5a--ff52f3f3bc4a442182efc119e87b67e1 fc73b4830ee548deaefe5da54ff395f1 ff52f3f3bc4a442182efc119e87b67e1--fc73b4830ee548deaefe5da54ff395f1 55e10d5bf4fd4240a306afa659a25217 fc73b4830ee548deaefe5da54ff395f1--55e10d5bf4fd4240a306afa659a25217 444f40dec95d4c5f96dcd50ac736e8bb 55e10d5bf4fd4240a306afa659a25217--444f40dec95d4c5f96dcd50ac736e8bb 23c470324d0a4e2481d0ae0b4728595d 444f40dec95d4c5f96dcd50ac736e8bb--23c470324d0a4e2481d0ae0b4728595d 5b0677fa212f45c7adfd8f7fed76f883 23c470324d0a4e2481d0ae0b4728595d--5b0677fa212f45c7adfd8f7fed76f883 3e451becca8c4fc295e6c585ea0eb11e 5b0677fa212f45c7adfd8f7fed76f883--3e451becca8c4fc295e6c585ea0eb11e 3c9359170b894842902587b54523f944 3e451becca8c4fc295e6c585ea0eb11e--3c9359170b894842902587b54523f944 6733f51b0288436aab74d42e1ec7353f 3c9359170b894842902587b54523f944--6733f51b0288436aab74d42e1ec7353f efe867cc483a4bd8a49ff8a88f3ef699 6733f51b0288436aab74d42e1ec7353f--efe867cc483a4bd8a49ff8a88f3ef699 4f67f7af48a340d6bc9ed7bd6c5acfff efe867cc483a4bd8a49ff8a88f3ef699--4f67f7af48a340d6bc9ed7bd6c5acfff 80ad183c3ed6455ea9ca198cb9368d0d 4f67f7af48a340d6bc9ed7bd6c5acfff--80ad183c3ed6455ea9ca198cb9368d0d f381139e04874d5bb474e57419d56ce4 80ad183c3ed6455ea9ca198cb9368d0d--f381139e04874d5bb474e57419d56ce4 0f52617b44284edbb9d78091c9c3cc11 f381139e04874d5bb474e57419d56ce4--0f52617b44284edbb9d78091c9c3cc11 97ed81195c1b41b397f79cf2733b4e28 0f52617b44284edbb9d78091c9c3cc11--97ed81195c1b41b397f79cf2733b4e28 a5b3552e8a0e43e4a3c1e8e342eabbe2 97ed81195c1b41b397f79cf2733b4e28--a5b3552e8a0e43e4a3c1e8e342eabbe2 3be538eded38470b8e0fd297547b3816 X a5b3552e8a0e43e4a3c1e8e342eabbe2--3be538eded38470b8e0fd297547b3816 3be538eded38470b8e0fd297547b3816--74783e2d47b94ff08961b80a61e3492f d07094b03917445db80b7f4d69c3af31 RZ(-1.0*g0) 3be538eded38470b8e0fd297547b3816--d07094b03917445db80b7f4d69c3af31 c43ce67c37ec4dae9af4cc361191bc9e X d07094b03917445db80b7f4d69c3af31--c43ce67c37ec4dae9af4cc361191bc9e c43ce67c37ec4dae9af4cc361191bc9e--3ae8ee14b07f4b6b94fdadbc521c6938 410e4c196cbe4264b69a0f0ff5f9acde c43ce67c37ec4dae9af4cc361191bc9e--410e4c196cbe4264b69a0f0ff5f9acde 93e3dfc9943d49e9beb8aea92c1e7bec X 410e4c196cbe4264b69a0f0ff5f9acde--93e3dfc9943d49e9beb8aea92c1e7bec 93e3dfc9943d49e9beb8aea92c1e7bec--41eedec774ff4801a9bf8483707aee4c 859107d004bd4f0c9e2ca6e65be2d546 RZ(-1.0*g0) 93e3dfc9943d49e9beb8aea92c1e7bec--859107d004bd4f0c9e2ca6e65be2d546 784f4091547b4498b1fe724c9470d6b0 X 859107d004bd4f0c9e2ca6e65be2d546--784f4091547b4498b1fe724c9470d6b0 784f4091547b4498b1fe724c9470d6b0--5541c9fa79e4406cab44ad84321bb361 e161a6c2003c42e8ba1d5bb0449cd4ae RX(b07) 784f4091547b4498b1fe724c9470d6b0--e161a6c2003c42e8ba1d5bb0449cd4ae 3ed5c6140d9441d9b01f05b831fda08f e161a6c2003c42e8ba1d5bb0449cd4ae--3ed5c6140d9441d9b01f05b831fda08f dbcb4051d8154e6cadeb1ffa45534906 3ed5c6140d9441d9b01f05b831fda08f--dbcb4051d8154e6cadeb1ffa45534906 924733899a864f918fa8e994d523f50b dbcb4051d8154e6cadeb1ffa45534906--924733899a864f918fa8e994d523f50b fc909184c2464345bf3a6160b51e8eb9 924733899a864f918fa8e994d523f50b--fc909184c2464345bf3a6160b51e8eb9 0ae02481b776487da7a8d1bb1dc3e85d fc909184c2464345bf3a6160b51e8eb9--0ae02481b776487da7a8d1bb1dc3e85d b16566bbcfe14a38a31b21a85c0b424a 0ae02481b776487da7a8d1bb1dc3e85d--b16566bbcfe14a38a31b21a85c0b424a 516d2772aafb450f9999f1305ae38d60 X b16566bbcfe14a38a31b21a85c0b424a--516d2772aafb450f9999f1305ae38d60 516d2772aafb450f9999f1305ae38d60--0ced779c524948c7a206b25b7034efa3 97f9b9fdd9a148a58cb725836aa47dc7 RZ(1.0*g1) 516d2772aafb450f9999f1305ae38d60--97f9b9fdd9a148a58cb725836aa47dc7 7a81fb0c1fe144ab8b058d9daeb44284 X 97f9b9fdd9a148a58cb725836aa47dc7--7a81fb0c1fe144ab8b058d9daeb44284 7a81fb0c1fe144ab8b058d9daeb44284--f3e2bea9ca4a4535b58954946bd03763 dab05fa776014a8c9b543f2016b3b7e6 7a81fb0c1fe144ab8b058d9daeb44284--dab05fa776014a8c9b543f2016b3b7e6 a08d8c10b5da4c439b12bb3fe72c27f2 dab05fa776014a8c9b543f2016b3b7e6--a08d8c10b5da4c439b12bb3fe72c27f2 e2ce4e72518b4ec8926152e14f204652 a08d8c10b5da4c439b12bb3fe72c27f2--e2ce4e72518b4ec8926152e14f204652 587b5064a9b449f088c49bf15079cf95 e2ce4e72518b4ec8926152e14f204652--587b5064a9b449f088c49bf15079cf95 2d43c5f1048b4ef9916337e092a9870d 587b5064a9b449f088c49bf15079cf95--2d43c5f1048b4ef9916337e092a9870d 7aede7620e0444c98dd974c9c55de8f1 2d43c5f1048b4ef9916337e092a9870d--7aede7620e0444c98dd974c9c55de8f1 758c9efd51bb479e8ef9f6af7fae1d3b 7aede7620e0444c98dd974c9c55de8f1--758c9efd51bb479e8ef9f6af7fae1d3b e76cd4a5bf7242c1912380a3296b7173 758c9efd51bb479e8ef9f6af7fae1d3b--e76cd4a5bf7242c1912380a3296b7173 fc75ae4930104a8fb97f488e4c712b4f e76cd4a5bf7242c1912380a3296b7173--fc75ae4930104a8fb97f488e4c712b4f 0ba54b303661445fad9c56a61caadba3 fc75ae4930104a8fb97f488e4c712b4f--0ba54b303661445fad9c56a61caadba3 94aa182771ff4893b482dcc107d091d7 0ba54b303661445fad9c56a61caadba3--94aa182771ff4893b482dcc107d091d7 36862cb0667e4d4dbb66780e3c61c1b9 94aa182771ff4893b482dcc107d091d7--36862cb0667e4d4dbb66780e3c61c1b9 f892f03f24ed42b8a33b1bc62e19b4b0 36862cb0667e4d4dbb66780e3c61c1b9--f892f03f24ed42b8a33b1bc62e19b4b0 8839f2ec28e847c188e655a3d44b4b52 f892f03f24ed42b8a33b1bc62e19b4b0--8839f2ec28e847c188e655a3d44b4b52 722d86ef42f24923ad5ff74180fa56f8 8839f2ec28e847c188e655a3d44b4b52--722d86ef42f24923ad5ff74180fa56f8 f02181fcbd1d4abb820dbd4658b802e6 722d86ef42f24923ad5ff74180fa56f8--f02181fcbd1d4abb820dbd4658b802e6 e8228c2ff85448fb8d66f42f488566cc f02181fcbd1d4abb820dbd4658b802e6--e8228c2ff85448fb8d66f42f488566cc d01cd3c6f1844ede91fa451bce925b49 e8228c2ff85448fb8d66f42f488566cc--d01cd3c6f1844ede91fa451bce925b49 9302e5a664a44ef190173ab12a043708 d01cd3c6f1844ede91fa451bce925b49--9302e5a664a44ef190173ab12a043708 aa47d97c6a7e44d095f0d895d35fe6da 9302e5a664a44ef190173ab12a043708--aa47d97c6a7e44d095f0d895d35fe6da b5b2d5c0f350473daea641798da5c840 aa47d97c6a7e44d095f0d895d35fe6da--b5b2d5c0f350473daea641798da5c840 95d5d68ce47a468d9d0d2816fa536691 b5b2d5c0f350473daea641798da5c840--95d5d68ce47a468d9d0d2816fa536691 0af2dd200e8e47e7bec86f6527d05d11 95d5d68ce47a468d9d0d2816fa536691--0af2dd200e8e47e7bec86f6527d05d11 7407f701ea8e47ca97e26608bfbff896 0af2dd200e8e47e7bec86f6527d05d11--7407f701ea8e47ca97e26608bfbff896 1f65f11535404cd08acb5353712b3edd 7407f701ea8e47ca97e26608bfbff896--1f65f11535404cd08acb5353712b3edd 2eb2672679344924b67ebc06896be8af 1f65f11535404cd08acb5353712b3edd--2eb2672679344924b67ebc06896be8af bebbd93e2484478aa8818295c494ab59 2eb2672679344924b67ebc06896be8af--bebbd93e2484478aa8818295c494ab59 f3e116819ae649e88b308b6ea3663b0c bebbd93e2484478aa8818295c494ab59--f3e116819ae649e88b308b6ea3663b0c 5cea53ed199c433694a0aba733254162 f3e116819ae649e88b308b6ea3663b0c--5cea53ed199c433694a0aba733254162 39170575fee04a63bcc02b68fa35cdbc X 5cea53ed199c433694a0aba733254162--39170575fee04a63bcc02b68fa35cdbc 39170575fee04a63bcc02b68fa35cdbc--eb6df96790cb432da0657c0888021f10 c80f51e465264ef29dd0f0ec088e78a6 RZ(-1.0*g1) 39170575fee04a63bcc02b68fa35cdbc--c80f51e465264ef29dd0f0ec088e78a6 89f1cdcc32fd4521ac0311f120dec5fa X c80f51e465264ef29dd0f0ec088e78a6--89f1cdcc32fd4521ac0311f120dec5fa 89f1cdcc32fd4521ac0311f120dec5fa--85e7967a2a954bd29105d823de84afc7 fe5e36e0d0bb474bba2563f6a7e9b042 89f1cdcc32fd4521ac0311f120dec5fa--fe5e36e0d0bb474bba2563f6a7e9b042 020f29ae19e54ea5b4e9e806162602ec fe5e36e0d0bb474bba2563f6a7e9b042--020f29ae19e54ea5b4e9e806162602ec 48a3c5d907254ffa8fc05100f1b4f224 020f29ae19e54ea5b4e9e806162602ec--48a3c5d907254ffa8fc05100f1b4f224 b5fe45106f30428ea12eb2414b9d0641 48a3c5d907254ffa8fc05100f1b4f224--b5fe45106f30428ea12eb2414b9d0641 038d621b770b4effaf191e03a0c31ea6 b5fe45106f30428ea12eb2414b9d0641--038d621b770b4effaf191e03a0c31ea6 29a51c73678a499ebd7e1e7d7822a014 038d621b770b4effaf191e03a0c31ea6--29a51c73678a499ebd7e1e7d7822a014 28b78b0006184042a1489babb0510c1a 29a51c73678a499ebd7e1e7d7822a014--28b78b0006184042a1489babb0510c1a c50cd074269e413bb16798e6d81fe9d3 28b78b0006184042a1489babb0510c1a--c50cd074269e413bb16798e6d81fe9d3 b7826e0254f74cf3bd074dec42d7a77d c50cd074269e413bb16798e6d81fe9d3--b7826e0254f74cf3bd074dec42d7a77d 0ac04422a0dd4412bcd2ad8383403639 b7826e0254f74cf3bd074dec42d7a77d--0ac04422a0dd4412bcd2ad8383403639 944b9a9482f04675bddc06864676640b 0ac04422a0dd4412bcd2ad8383403639--944b9a9482f04675bddc06864676640b 8909c462f70e412fa426b9b7a5abe2d3 944b9a9482f04675bddc06864676640b--8909c462f70e412fa426b9b7a5abe2d3 b9db851d5f884e4e8059cb67249db405 8909c462f70e412fa426b9b7a5abe2d3--b9db851d5f884e4e8059cb67249db405 c178b03782af49ddb18891d824aec9cd b9db851d5f884e4e8059cb67249db405--c178b03782af49ddb18891d824aec9cd b3df7d630ef946a9aff0a6797c9d6ce3 c178b03782af49ddb18891d824aec9cd--b3df7d630ef946a9aff0a6797c9d6ce3 0d4c746357f04cc5a83282e621b9f890 b3df7d630ef946a9aff0a6797c9d6ce3--0d4c746357f04cc5a83282e621b9f890 5db7100caaac453aaa6c9292c3961e7a 0d4c746357f04cc5a83282e621b9f890--5db7100caaac453aaa6c9292c3961e7a e46d82e5e49f4a9aabd78f3ba4a1d9fe 5db7100caaac453aaa6c9292c3961e7a--e46d82e5e49f4a9aabd78f3ba4a1d9fe 25b3e30175d640d4b0149f9c8c68e094 e46d82e5e49f4a9aabd78f3ba4a1d9fe--25b3e30175d640d4b0149f9c8c68e094 0af460bc0a6a44b2b67f236bafba0162 25b3e30175d640d4b0149f9c8c68e094--0af460bc0a6a44b2b67f236bafba0162 b24a1369f3b948288d5e32301a5f9adb 0af460bc0a6a44b2b67f236bafba0162--b24a1369f3b948288d5e32301a5f9adb 66458f0fc5514d549770ddb56e4cfb26 b24a1369f3b948288d5e32301a5f9adb--66458f0fc5514d549770ddb56e4cfb26 8e02d037c9f54828a25537f26fb6743f 66458f0fc5514d549770ddb56e4cfb26--8e02d037c9f54828a25537f26fb6743f 1c661b1fe99447f9840a876bf7806b36 8e02d037c9f54828a25537f26fb6743f--1c661b1fe99447f9840a876bf7806b36 b0081bfb6f9e41ec9614e2614ecd6ee5 1c661b1fe99447f9840a876bf7806b36--b0081bfb6f9e41ec9614e2614ecd6ee5 4fe6bc5b1b3e46fa82b4a030a7a5cdd7 b0081bfb6f9e41ec9614e2614ecd6ee5--4fe6bc5b1b3e46fa82b4a030a7a5cdd7 2ba7040beac440f1a121dfe61d6110a3 4fe6bc5b1b3e46fa82b4a030a7a5cdd7--2ba7040beac440f1a121dfe61d6110a3 8957405168da4653926de552e3678bb1 X 2ba7040beac440f1a121dfe61d6110a3--8957405168da4653926de552e3678bb1 8957405168da4653926de552e3678bb1--0ead0cd72768497bb9e4d934997e39aa 95ee351e02574e738a12ca8ac7703e31 RZ(-1.0*g1) 8957405168da4653926de552e3678bb1--95ee351e02574e738a12ca8ac7703e31 9f8e2bb5dc4447a49d77903d52152112 X 95ee351e02574e738a12ca8ac7703e31--9f8e2bb5dc4447a49d77903d52152112 9f8e2bb5dc4447a49d77903d52152112--b749fc252b3044d8a31c937ae17598d5 4bf135e95cbc406ab12e93a25fd876a2 9f8e2bb5dc4447a49d77903d52152112--4bf135e95cbc406ab12e93a25fd876a2 bf3787bcb4d240f391f7088c5624b6ff 4bf135e95cbc406ab12e93a25fd876a2--bf3787bcb4d240f391f7088c5624b6ff e19d5303ec904974872cc413712c2816 bf3787bcb4d240f391f7088c5624b6ff--e19d5303ec904974872cc413712c2816 5d923546a0b54d4ab2e8dd5266bd59b8 e19d5303ec904974872cc413712c2816--5d923546a0b54d4ab2e8dd5266bd59b8 4a9d78fc3db64cebbcee969212cf6265 5d923546a0b54d4ab2e8dd5266bd59b8--4a9d78fc3db64cebbcee969212cf6265 e4d4a8ff10bd4cf098b90b674e701b15 4a9d78fc3db64cebbcee969212cf6265--e4d4a8ff10bd4cf098b90b674e701b15 d15682fc1bc644f4a7226c9be6ab85e2 e4d4a8ff10bd4cf098b90b674e701b15--d15682fc1bc644f4a7226c9be6ab85e2 c5289805e322494ca1a622ff877e5ad8 d15682fc1bc644f4a7226c9be6ab85e2--c5289805e322494ca1a622ff877e5ad8 34e645caf4b94879962e98276b7ebb71 c5289805e322494ca1a622ff877e5ad8--34e645caf4b94879962e98276b7ebb71 d41af3961a4c411e9f470a94ef747dfa 34e645caf4b94879962e98276b7ebb71--d41af3961a4c411e9f470a94ef747dfa 50a2beb6c432461289aae9a6d0213060 d41af3961a4c411e9f470a94ef747dfa--50a2beb6c432461289aae9a6d0213060 89047d0ce9234924a6f990c19568b711 50a2beb6c432461289aae9a6d0213060--89047d0ce9234924a6f990c19568b711 4bc30a9a86204082b884864629449333 89047d0ce9234924a6f990c19568b711--4bc30a9a86204082b884864629449333 2b11f02539b340e285ffce5939e7e227 4bc30a9a86204082b884864629449333--2b11f02539b340e285ffce5939e7e227 4e475ef70d2b417faaf44ec4c96cc97b 2b11f02539b340e285ffce5939e7e227--4e475ef70d2b417faaf44ec4c96cc97b 6ba7aeaacaa645548d2b994575ab2338 4e475ef70d2b417faaf44ec4c96cc97b--6ba7aeaacaa645548d2b994575ab2338 48fa31b2cb4042bfbfa42ededb3b6a56 6ba7aeaacaa645548d2b994575ab2338--48fa31b2cb4042bfbfa42ededb3b6a56 d3f150d0009c4693abf3930d15fdb59a 48fa31b2cb4042bfbfa42ededb3b6a56--d3f150d0009c4693abf3930d15fdb59a 1cc6068e780b4bd585d33b8e9b4123b3 d3f150d0009c4693abf3930d15fdb59a--1cc6068e780b4bd585d33b8e9b4123b3 7ed891f8a2664df4bf96101e0ed49141 1cc6068e780b4bd585d33b8e9b4123b3--7ed891f8a2664df4bf96101e0ed49141 8b58de5deb2b464d875a798bb1efa75a X 7ed891f8a2664df4bf96101e0ed49141--8b58de5deb2b464d875a798bb1efa75a 8b58de5deb2b464d875a798bb1efa75a--6e365c4cbc3d483995c9594916b24a67 26e7009f462748019083ae89e1194463 RZ(-1.0*g1) 8b58de5deb2b464d875a798bb1efa75a--26e7009f462748019083ae89e1194463 07d5ec8952954686b3792ab0202740f0 X 26e7009f462748019083ae89e1194463--07d5ec8952954686b3792ab0202740f0 07d5ec8952954686b3792ab0202740f0--8a2c0a93b65947ce909aa370e2e27821 58a5dfef3a0e448aad7cd66e87ab11f9 07d5ec8952954686b3792ab0202740f0--58a5dfef3a0e448aad7cd66e87ab11f9 9eafd6e735264683b70b8f79c8d27a5e X 58a5dfef3a0e448aad7cd66e87ab11f9--9eafd6e735264683b70b8f79c8d27a5e 9eafd6e735264683b70b8f79c8d27a5e--8316efbd8f2e4c1aa3bc7fae0c1413fc 957c7ca5977c4031b038caccb8f9bef1 RZ(-1.0*g1) 9eafd6e735264683b70b8f79c8d27a5e--957c7ca5977c4031b038caccb8f9bef1 97018174941c46d8ad817231b2311500 X 957c7ca5977c4031b038caccb8f9bef1--97018174941c46d8ad817231b2311500 97018174941c46d8ad817231b2311500--bb46faad6ebd47f38907b4a5c87d32a8 d4a5b2146cf045e190ff16f5283c43e7 RX(b17) 97018174941c46d8ad817231b2311500--d4a5b2146cf045e190ff16f5283c43e7 d4a5b2146cf045e190ff16f5283c43e7--4fe9de1f93774234a4eb50af0ffce51d"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -3.0661654627558486\nMaxCut cost at iteration 10: 10.26055241400507\nMaxCut cost at iteration 20: 10.984241028038948\nMaxCut cost at iteration 30: 10.996763936265438\nMaxCut cost at iteration 40: 10.994525571185937\nMaxCut cost at iteration 50: 10.998991054983358\nMaxCut cost at iteration 60: 10.999935999010567\nMaxCut cost at iteration 70: 10.999996266101927\nMaxCut cost at iteration 80: 10.999999782649441\nMaxCut cost at iteration 90: 10.99999998728447\nMaxCut cost at iteration 100: 10.99999999924708\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 01011001  2023-12-22T15:46:40.319992 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-12-22T15:46:44.527179 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_14f6b590ff2941298f42c67ae7470cb3 Constant Chebyshev FM cluster_92328fac64dd46e0bb6c207a29224d5c Constant Fourier FM 1791de53183b4821b8e07890e4640a56 0 30eb1b663fcf47ff8745a4028fdc4ee5 RX(phi) 1791de53183b4821b8e07890e4640a56--30eb1b663fcf47ff8745a4028fdc4ee5 e78c9af10591440ab78fc3e80a9db80b 1 dbfb2d90ef714f9eb1faf1e24fc5e93f RX(acos(phi)) 30eb1b663fcf47ff8745a4028fdc4ee5--dbfb2d90ef714f9eb1faf1e24fc5e93f aaf04984be464dda8c64690dcd858456 dbfb2d90ef714f9eb1faf1e24fc5e93f--aaf04984be464dda8c64690dcd858456 d9324f1607a94cc8af066f10027146b5 5d6cdae01f0f48e3ac78b229fae67d57 RX(phi) e78c9af10591440ab78fc3e80a9db80b--5d6cdae01f0f48e3ac78b229fae67d57 09dd27abac4948ca9f60d65cdab872a5 2 ab011143ca2749acae92974b83747509 RX(acos(phi)) 5d6cdae01f0f48e3ac78b229fae67d57--ab011143ca2749acae92974b83747509 ab011143ca2749acae92974b83747509--d9324f1607a94cc8af066f10027146b5 acddc9befe894b18a78441e2b6c40a65 c4e7d241dd1145f5830d79abf21f01e7 RX(phi) 09dd27abac4948ca9f60d65cdab872a5--c4e7d241dd1145f5830d79abf21f01e7 a5e713494a594c6c903cfca3738a65c0 RX(acos(phi)) c4e7d241dd1145f5830d79abf21f01e7--a5e713494a594c6c903cfca3738a65c0 a5e713494a594c6c903cfca3738a65c0--acddc9befe894b18a78441e2b6c40a65 <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom function\ndef custom_fn(x):\n    return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_fn)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_02f18673560f470892035672cf41a6fb Constant &lt;function custom_fn at 0x7fa5712ec9d0&gt; FM cluster_a4d3ef299dc4429ba78dbde80cf95a4b Constant asin FM b1b3e22958d540978d0bd4f2251c0d80 0 3568413b94054a7da4aa4b6dd19389f8 RX(asin(phi)) b1b3e22958d540978d0bd4f2251c0d80--3568413b94054a7da4aa4b6dd19389f8 1d1b120001ec4958b43660c0f667ec08 1 1087d6f1a7984a90b34d894e5876d931 RX(phi**2 + asin(phi)) 3568413b94054a7da4aa4b6dd19389f8--1087d6f1a7984a90b34d894e5876d931 e41c2e7d867e4248bb7dd7a82bcc3275 1087d6f1a7984a90b34d894e5876d931--e41c2e7d867e4248bb7dd7a82bcc3275 a840b8917d9c4bb58908e024b02142b1 985e70fa5b0d497999a8cf82ac3dac5c RX(asin(phi)) 1d1b120001ec4958b43660c0f667ec08--985e70fa5b0d497999a8cf82ac3dac5c ed0814620f234315bfde9d64b64a4f92 2 08230fa2caad4d7caf3b8883914642f2 RX(phi**2 + asin(phi)) 985e70fa5b0d497999a8cf82ac3dac5c--08230fa2caad4d7caf3b8883914642f2 08230fa2caad4d7caf3b8883914642f2--a840b8917d9c4bb58908e024b02142b1 e5186f50bae0410d862fabd67407c543 f1181c34758e49c79ccc2896ff9f6f01 RX(asin(phi)) ed0814620f234315bfde9d64b64a4f92--f1181c34758e49c79ccc2896ff9f6f01 7ef9dafd5b574389a30ccf8945443b81 RX(phi**2 + asin(phi)) f1181c34758e49c79ccc2896ff9f6f01--7ef9dafd5b574389a30ccf8945443b81 7ef9dafd5b574389a30ccf8945443b81--e5186f50bae0410d862fabd67407c543 <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_ad68f74fb56f400e906a6e712e149946 Exponential Fourier FM cluster_4a8c4807e4d44716afc61a3fad854ba3 Constant Fourier FM cluster_5e0baef3681d483dbdc7b2d4c425ba51 Tower Fourier FM 8812a663954a4fbf85aa452765334591 0 f4c4621976744608a6e7877ab7f98050 RX(phi) 8812a663954a4fbf85aa452765334591--f4c4621976744608a6e7877ab7f98050 edaf5d331fc340eb8326aec769f8e139 1 ece1058ba56c41f7a90d03a0744f7319 RX(1.0*phi) f4c4621976744608a6e7877ab7f98050--ece1058ba56c41f7a90d03a0744f7319 05ea6cf58b5e4b04be41e62d3f7120a5 RX(1.0*phi) ece1058ba56c41f7a90d03a0744f7319--05ea6cf58b5e4b04be41e62d3f7120a5 4130d03dcd8a4cb99c1c427f5077e5da 05ea6cf58b5e4b04be41e62d3f7120a5--4130d03dcd8a4cb99c1c427f5077e5da 2f3290701e4745f0b83be9c0f567083f c32d66558e3a4cef8886332164385069 RX(phi) edaf5d331fc340eb8326aec769f8e139--c32d66558e3a4cef8886332164385069 7098de06045a48a5bcec27a66636e493 2 f7fb6b0dea914e429d7e0dc25bdfd632 RX(2.0*phi) c32d66558e3a4cef8886332164385069--f7fb6b0dea914e429d7e0dc25bdfd632 d95c6dcb37284b22996e56a52de61376 RX(2.0*phi) f7fb6b0dea914e429d7e0dc25bdfd632--d95c6dcb37284b22996e56a52de61376 d95c6dcb37284b22996e56a52de61376--2f3290701e4745f0b83be9c0f567083f 3044aca9788243abb5fe13cea0437afc 6212542378d3402fae5b7169bba09f70 RX(phi) 7098de06045a48a5bcec27a66636e493--6212542378d3402fae5b7169bba09f70 db63c9eaad9b4fefb6a8e166ec4dd678 3 ddc46f604d2a499bad90a13bf8e1a89b RX(3.0*phi) 6212542378d3402fae5b7169bba09f70--ddc46f604d2a499bad90a13bf8e1a89b 1163b0d01866499dbfe2a4602e8b5788 RX(4.0*phi) ddc46f604d2a499bad90a13bf8e1a89b--1163b0d01866499dbfe2a4602e8b5788 1163b0d01866499dbfe2a4602e8b5788--3044aca9788243abb5fe13cea0437afc b54b7e772d7c4dfb920a2a724c9e0b1d 134ad906dee446cba5859812634717d6 RX(phi) db63c9eaad9b4fefb6a8e166ec4dd678--134ad906dee446cba5859812634717d6 7db35cd8a27f488194d1380b9161cb1f 4 092fa2a110da4df696b0518dae62b519 RX(4.0*phi) 134ad906dee446cba5859812634717d6--092fa2a110da4df696b0518dae62b519 6d9f21eb0f5a43dfba53c3175fc33de1 RX(8.0*phi) 092fa2a110da4df696b0518dae62b519--6d9f21eb0f5a43dfba53c3175fc33de1 6d9f21eb0f5a43dfba53c3175fc33de1--b54b7e772d7c4dfb920a2a724c9e0b1d bbef7c3f8a40433885309ed66ab54dea 9c5a7bb067f141d5b961f435bb919395 RX(phi) 7db35cd8a27f488194d1380b9161cb1f--9c5a7bb067f141d5b961f435bb919395 25df2266392a4f94a978d0b16769b513 RX(5.0*phi) 9c5a7bb067f141d5b961f435bb919395--25df2266392a4f94a978d0b16769b513 0f7720302e0c400983068373c9dc1ba6 RX(16.0*phi) 25df2266392a4f94a978d0b16769b513--0f7720302e0c400983068373c9dc1ba6 0f7720302e0c400983068373c9dc1ba6--bbef7c3f8a40433885309ed66ab54dea <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 d1a9df5dec344f599daae14b4cafd725 0 efd7176ecec34eb4a0e53e9b2924f41f RX(1.0*acos(phi)) d1a9df5dec344f599daae14b4cafd725--efd7176ecec34eb4a0e53e9b2924f41f fef5dbbebabb4490835a48f7dbe9302c 1 c3a2ffa22b844cf59180f3538150c8df efd7176ecec34eb4a0e53e9b2924f41f--c3a2ffa22b844cf59180f3538150c8df 19ebce16f6bc4ab1abb160dcf90c0333 b4677a40d5734efca25028cd0b2e420c RX(1.414*acos(phi)) fef5dbbebabb4490835a48f7dbe9302c--b4677a40d5734efca25028cd0b2e420c 7e9a7f49ca334984ab1bd2343db669e8 2 b4677a40d5734efca25028cd0b2e420c--19ebce16f6bc4ab1abb160dcf90c0333 8ee7b706c8f046dbab46c9ac8dfa6ad8 1145a18a19b7473a92e9b59051ed8874 RX(1.732*acos(phi)) 7e9a7f49ca334984ab1bd2343db669e8--1145a18a19b7473a92e9b59051ed8874 7df517b2a4d642e4b2c43a2cf85e667d 3 1145a18a19b7473a92e9b59051ed8874--8ee7b706c8f046dbab46c9ac8dfa6ad8 a0d0ac4ab0854779a5a05bc58f671bea c3fee1fb850d4dbeb5097f1103a70222 RX(2.0*acos(phi)) 7df517b2a4d642e4b2c43a2cf85e667d--c3fee1fb850d4dbeb5097f1103a70222 cdc20fa7ee034d498ac4f7996cd96f0a 4 c3fee1fb850d4dbeb5097f1103a70222--a0d0ac4ab0854779a5a05bc58f671bea 943d834e714b49c4a114986231270abf 87ab2c7b93324e27bbbccf1237f90e52 RX(2.236*acos(phi)) cdc20fa7ee034d498ac4f7996cd96f0a--87ab2c7b93324e27bbbccf1237f90e52 87ab2c7b93324e27bbbccf1237f90e52--943d834e714b49c4a114986231270abf <p>To add a trainable parameter that multiplies the feature parameter inside the encoding function, simply pass a <code>param_prefix</code> string:</p> <pre><code>n_qubits = 5\n\nfm_trainable = feature_map(\n    n_qubits,\n    fm_type=BasisSet.FOURIER,\n    reupload_scaling=ReuploadScaling.EXP,\n    param_prefix = \"w\",\n)\n</code></pre> %3 4cf758099c3a427d945a455541aadb92 0 d3640a9fa5a646e9ba2c4755c0e2d955 RX(1.0*phi*w\u2080) 4cf758099c3a427d945a455541aadb92--d3640a9fa5a646e9ba2c4755c0e2d955 6dc75369468d426994472fc01414d9a9 1 3d5cc239c46b4d6fb346da0a1ffb8b8a d3640a9fa5a646e9ba2c4755c0e2d955--3d5cc239c46b4d6fb346da0a1ffb8b8a bb666ed8e2484aa0964c554a1fe30569 61184cea43cc4c37a9b0c6f111cfad49 RX(2.0*phi*w\u2081) 6dc75369468d426994472fc01414d9a9--61184cea43cc4c37a9b0c6f111cfad49 1b4b285041474daeafbb4f69b61667d5 2 61184cea43cc4c37a9b0c6f111cfad49--bb666ed8e2484aa0964c554a1fe30569 8ba3af7761614c169ce6c4971b326547 c2b422cd652f41b68b0d62c6647ff5b6 RX(4.0*phi*w\u2082) 1b4b285041474daeafbb4f69b61667d5--c2b422cd652f41b68b0d62c6647ff5b6 a322eb4289534adcbcd364e2799f965e 3 c2b422cd652f41b68b0d62c6647ff5b6--8ba3af7761614c169ce6c4971b326547 bcca91bb806a42e3a47ebc3f010472fa d29404ed12034e358d9c4ad0215843ce RX(8.0*phi*w\u2083) a322eb4289534adcbcd364e2799f965e--d29404ed12034e358d9c4ad0215843ce 74e7fefb2d484b9a8842e91e2b99f64f 4 d29404ed12034e358d9c4ad0215843ce--bcca91bb806a42e3a47ebc3f010472fa 8d621c01551c4ec5a589af3fec43e2a1 a96baecabe2841ee9377d6c73e65e4ea RX(16.0*phi*w\u2084) 74e7fefb2d484b9a8842e91e2b99f64f--a96baecabe2841ee9377d6c73e65e4ea a96baecabe2841ee9377d6c73e65e4ea--8d621c01551c4ec5a589af3fec43e2a1 <p>Note that for the Fourier feature map, the encoding function is simply \\(f(x)=x\\). For other cases, like the Chebyshev <code>acos()</code> encoding, the trainable parameter may cause the feature value to be outside the domain of the encoding function. This will eventually be fixed by adding range constraints to trainable parameters in Qadence.</p> <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0, # Extra multiplier, which can also be a Parameter\n    param_prefix = \"w\", # Add trainable parameters\n)\n</code></pre> %3 48819c1a380d4b5e863581c78b707a54 0 ff61bb1eb1444642a3a5bbabbc6720a2 RY(80.0*acos(w\u2084*(0.667*x + 1.667))) 48819c1a380d4b5e863581c78b707a54--ff61bb1eb1444642a3a5bbabbc6720a2 6776c481372f4c368abc6603d03a162a 1 b693914d72964bd68e7c5ee2041638de ff61bb1eb1444642a3a5bbabbc6720a2--b693914d72964bd68e7c5ee2041638de 62878bdc37f94a6e9178dd7b46c58e9a 22c6fc54a91d42f49bb3106cb3dd41c2 RY(40.0*acos(w\u2083*(0.667*x + 1.667))) 6776c481372f4c368abc6603d03a162a--22c6fc54a91d42f49bb3106cb3dd41c2 39a7bf361b1b42d4abdde501f68dcf04 2 22c6fc54a91d42f49bb3106cb3dd41c2--62878bdc37f94a6e9178dd7b46c58e9a 1c615d8151314ddc91b296012c6a03e2 88bbc38c3d9741808d33d58df244b00d RY(20.0*acos(w\u2082*(0.667*x + 1.667))) 39a7bf361b1b42d4abdde501f68dcf04--88bbc38c3d9741808d33d58df244b00d 8dcc2fad38db403eafcaae306d9c952b 3 88bbc38c3d9741808d33d58df244b00d--1c615d8151314ddc91b296012c6a03e2 ffbbb8f6d512486aa8a45b02187f0f54 0414175d84ee44beabf67b0a892858cc RY(10.0*acos(w\u2081*(0.667*x + 1.667))) 8dcc2fad38db403eafcaae306d9c952b--0414175d84ee44beabf67b0a892858cc a695d48ba9e34804bec720dc18d0dc07 4 0414175d84ee44beabf67b0a892858cc--ffbbb8f6d512486aa8a45b02187f0f54 d51ad2254e114fef83840c1ffa62cbfe f0a95e8852104d389426eda009e05a30 RY(5.0*acos(w\u2080*(0.667*x + 1.667))) a695d48ba9e34804bec720dc18d0dc07--f0a95e8852104d389426eda009e05a30 f0a95e8852104d389426eda009e05a30--d51ad2254e114fef83840c1ffa62cbfe"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 e4684996b20d4d2abf425c758df9ad5a 0 8dc6543fa98743dc997d7065a4f397a0 RX(theta\u2080) e4684996b20d4d2abf425c758df9ad5a--8dc6543fa98743dc997d7065a4f397a0 b755fef93e6540ad969e085134aa4343 1 1c3fcdce43ea45449f25eb595f63d20d RY(theta\u2083) 8dc6543fa98743dc997d7065a4f397a0--1c3fcdce43ea45449f25eb595f63d20d ea9c99e2b7df4272b2cc372517d97461 RX(theta\u2086) 1c3fcdce43ea45449f25eb595f63d20d--ea9c99e2b7df4272b2cc372517d97461 30d538ade96040bfbc3859d467370900 ea9c99e2b7df4272b2cc372517d97461--30d538ade96040bfbc3859d467370900 149fb4ce46ac43d1b4aaf70b8bb8b29a 30d538ade96040bfbc3859d467370900--149fb4ce46ac43d1b4aaf70b8bb8b29a c7deb27fe45641039892ee037fc70533 RX(theta\u2089) 149fb4ce46ac43d1b4aaf70b8bb8b29a--c7deb27fe45641039892ee037fc70533 7d62bcf5901744b5a621a2b07c2b94e5 RY(theta\u2081\u2082) c7deb27fe45641039892ee037fc70533--7d62bcf5901744b5a621a2b07c2b94e5 2870db7fcd49433d8d72b86d172db1a8 RX(theta\u2081\u2085) 7d62bcf5901744b5a621a2b07c2b94e5--2870db7fcd49433d8d72b86d172db1a8 d16510111e714e11acfa6d195e6f896d 2870db7fcd49433d8d72b86d172db1a8--d16510111e714e11acfa6d195e6f896d 1a3337de182e49c0a592d937a25826d8 d16510111e714e11acfa6d195e6f896d--1a3337de182e49c0a592d937a25826d8 c111e1636e2745f1bc1a96a5bd31da36 1a3337de182e49c0a592d937a25826d8--c111e1636e2745f1bc1a96a5bd31da36 84bc4193a2194950a2413a384e424129 dcc47898f8dd4110b81e5ab4e591a714 RX(theta\u2081) b755fef93e6540ad969e085134aa4343--dcc47898f8dd4110b81e5ab4e591a714 961504bb4bd44c8da5bf5f727887fc64 2 d543fdf5ad9349abb536d9fef12d5121 RY(theta\u2084) dcc47898f8dd4110b81e5ab4e591a714--d543fdf5ad9349abb536d9fef12d5121 5faf71fc2572462887ca8451800dd999 RX(theta\u2087) d543fdf5ad9349abb536d9fef12d5121--5faf71fc2572462887ca8451800dd999 00b983363ea74ec28c796bf3af0a0a9b X 5faf71fc2572462887ca8451800dd999--00b983363ea74ec28c796bf3af0a0a9b 00b983363ea74ec28c796bf3af0a0a9b--30d538ade96040bfbc3859d467370900 42fd71eb07fe4f349b426a96fd92695e 00b983363ea74ec28c796bf3af0a0a9b--42fd71eb07fe4f349b426a96fd92695e afb7307676004302a5ecfce734cb2b36 RX(theta\u2081\u2080) 42fd71eb07fe4f349b426a96fd92695e--afb7307676004302a5ecfce734cb2b36 594141048ae9453890a078f9556e1627 RY(theta\u2081\u2083) afb7307676004302a5ecfce734cb2b36--594141048ae9453890a078f9556e1627 0d257cd5551c42edab3c3b70c1aaca41 RX(theta\u2081\u2086) 594141048ae9453890a078f9556e1627--0d257cd5551c42edab3c3b70c1aaca41 c1e03c19e9fe459a881b0cbcb7c4ad6d X 0d257cd5551c42edab3c3b70c1aaca41--c1e03c19e9fe459a881b0cbcb7c4ad6d c1e03c19e9fe459a881b0cbcb7c4ad6d--d16510111e714e11acfa6d195e6f896d 5a265036ba364c01a26f04777c61c5bf c1e03c19e9fe459a881b0cbcb7c4ad6d--5a265036ba364c01a26f04777c61c5bf 5a265036ba364c01a26f04777c61c5bf--84bc4193a2194950a2413a384e424129 7c30279e805d43a6900c3ce55fc7ce99 777ea7b5107443aa9d87d60dddef6bb1 RX(theta\u2082) 961504bb4bd44c8da5bf5f727887fc64--777ea7b5107443aa9d87d60dddef6bb1 32309645b6b24f7c9c66654980e09647 RY(theta\u2085) 777ea7b5107443aa9d87d60dddef6bb1--32309645b6b24f7c9c66654980e09647 dce6a7468c9a44cf8ccabe58ada5e52a RX(theta\u2088) 32309645b6b24f7c9c66654980e09647--dce6a7468c9a44cf8ccabe58ada5e52a 4d7a2bfcb3c04aeaa4fed282e4085818 dce6a7468c9a44cf8ccabe58ada5e52a--4d7a2bfcb3c04aeaa4fed282e4085818 cb62e80ffbfe4f1e98d3d46812fe230e X 4d7a2bfcb3c04aeaa4fed282e4085818--cb62e80ffbfe4f1e98d3d46812fe230e cb62e80ffbfe4f1e98d3d46812fe230e--42fd71eb07fe4f349b426a96fd92695e a232f1d8a6174982aa4ca20a18c1d747 RX(theta\u2081\u2081) cb62e80ffbfe4f1e98d3d46812fe230e--a232f1d8a6174982aa4ca20a18c1d747 df1b1cebd8fe42c1984d38b53bec3350 RY(theta\u2081\u2084) a232f1d8a6174982aa4ca20a18c1d747--df1b1cebd8fe42c1984d38b53bec3350 5a4c4b84882c456189521ede7ce943d7 RX(theta\u2081\u2087) df1b1cebd8fe42c1984d38b53bec3350--5a4c4b84882c456189521ede7ce943d7 5796afc5a6c14f85be54fd6a1374e4ad 5a4c4b84882c456189521ede7ce943d7--5796afc5a6c14f85be54fd6a1374e4ad 22208059565e4a829da9349a104f1e51 X 5796afc5a6c14f85be54fd6a1374e4ad--22208059565e4a829da9349a104f1e51 22208059565e4a829da9349a104f1e51--5a265036ba364c01a26f04777c61c5bf 22208059565e4a829da9349a104f1e51--7c30279e805d43a6900c3ce55fc7ce99 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 eceb2b1c11ce4f579aea7dfb488f93e4 0 7c81b9d330a747799afed2695c8549f9 RX(phi\u2080) eceb2b1c11ce4f579aea7dfb488f93e4--7c81b9d330a747799afed2695c8549f9 f0b350144df64d3c93c19487ce76f50a 1 4f3373e6203a45999de11ffaaf6dee25 RY(phi\u2083) 7c81b9d330a747799afed2695c8549f9--4f3373e6203a45999de11ffaaf6dee25 2ffcd7c843964ab2b54c950b3845b9a6 RX(phi\u2086) 4f3373e6203a45999de11ffaaf6dee25--2ffcd7c843964ab2b54c950b3845b9a6 6b275b2acaab4560a3304ba6d16e1ddf 2ffcd7c843964ab2b54c950b3845b9a6--6b275b2acaab4560a3304ba6d16e1ddf bb5dc28a5e7f4c98adc09d2089744b1a 6b275b2acaab4560a3304ba6d16e1ddf--bb5dc28a5e7f4c98adc09d2089744b1a 4de000cace084f59b190751135c60e89 RX(phi\u2089) bb5dc28a5e7f4c98adc09d2089744b1a--4de000cace084f59b190751135c60e89 cd46e12c64754b24948d3b7c265d0dbc RY(phi\u2081\u2082) 4de000cace084f59b190751135c60e89--cd46e12c64754b24948d3b7c265d0dbc 7104b82892e04805aa0020dbc436c56f RX(phi\u2081\u2085) cd46e12c64754b24948d3b7c265d0dbc--7104b82892e04805aa0020dbc436c56f a37cd502920f40d3b540e55a4dbb2f47 7104b82892e04805aa0020dbc436c56f--a37cd502920f40d3b540e55a4dbb2f47 d7d8246b4c5444fc82e8bd852de609bd a37cd502920f40d3b540e55a4dbb2f47--d7d8246b4c5444fc82e8bd852de609bd 1b50e523b0a044af8d0bf8dfa1e79ee5 d7d8246b4c5444fc82e8bd852de609bd--1b50e523b0a044af8d0bf8dfa1e79ee5 7ac3742e7e754dd49c253e206a482b18 23db7ddca8e34e4e8766b38d496905ee RX(phi\u2081) f0b350144df64d3c93c19487ce76f50a--23db7ddca8e34e4e8766b38d496905ee 9e52236fb02f4c5cbef835990c7a3054 2 3070af6b3bd64c85aabb7e1fadc31432 RY(phi\u2084) 23db7ddca8e34e4e8766b38d496905ee--3070af6b3bd64c85aabb7e1fadc31432 c2c0f31e00694ab0b244a89a405271d1 RX(phi\u2087) 3070af6b3bd64c85aabb7e1fadc31432--c2c0f31e00694ab0b244a89a405271d1 2c9f8027c10a4a32ae712854ab0dfdab PHASE(phi_ent\u2080) c2c0f31e00694ab0b244a89a405271d1--2c9f8027c10a4a32ae712854ab0dfdab 2c9f8027c10a4a32ae712854ab0dfdab--6b275b2acaab4560a3304ba6d16e1ddf 07db74a553df41a99da737f322ed6a6d 2c9f8027c10a4a32ae712854ab0dfdab--07db74a553df41a99da737f322ed6a6d bb47bddc2a9b43d1b638b26430a53801 RX(phi\u2081\u2080) 07db74a553df41a99da737f322ed6a6d--bb47bddc2a9b43d1b638b26430a53801 7a995406c2ff4d5c9626f7f19f181ed1 RY(phi\u2081\u2083) bb47bddc2a9b43d1b638b26430a53801--7a995406c2ff4d5c9626f7f19f181ed1 1ceca3860652426681007f66a432fa32 RX(phi\u2081\u2086) 7a995406c2ff4d5c9626f7f19f181ed1--1ceca3860652426681007f66a432fa32 3d8ce914bb9549248ac4d3261f65e027 PHASE(phi_ent\u2082) 1ceca3860652426681007f66a432fa32--3d8ce914bb9549248ac4d3261f65e027 3d8ce914bb9549248ac4d3261f65e027--a37cd502920f40d3b540e55a4dbb2f47 12bc1effd3ca4f39a0571dff0707cd03 3d8ce914bb9549248ac4d3261f65e027--12bc1effd3ca4f39a0571dff0707cd03 12bc1effd3ca4f39a0571dff0707cd03--7ac3742e7e754dd49c253e206a482b18 2b22d317f84e4f87b84007bc5a699872 26b56f2fee2a48a2b4c7f57b6e76d965 RX(phi\u2082) 9e52236fb02f4c5cbef835990c7a3054--26b56f2fee2a48a2b4c7f57b6e76d965 f785281f0ce34535b407ef4dab33f6b9 RY(phi\u2085) 26b56f2fee2a48a2b4c7f57b6e76d965--f785281f0ce34535b407ef4dab33f6b9 857f7031200f499cbfa9f1855d8eec67 RX(phi\u2088) f785281f0ce34535b407ef4dab33f6b9--857f7031200f499cbfa9f1855d8eec67 ebb3224ac8c54052a1bcddde156f0651 857f7031200f499cbfa9f1855d8eec67--ebb3224ac8c54052a1bcddde156f0651 9ce272a2a7214da0b1a4111718cd79ae PHASE(phi_ent\u2081) ebb3224ac8c54052a1bcddde156f0651--9ce272a2a7214da0b1a4111718cd79ae 9ce272a2a7214da0b1a4111718cd79ae--07db74a553df41a99da737f322ed6a6d 5f4145ee48c64829874809223516750e RX(phi\u2081\u2081) 9ce272a2a7214da0b1a4111718cd79ae--5f4145ee48c64829874809223516750e c22e140a78824cc08bfd31d5835273a7 RY(phi\u2081\u2084) 5f4145ee48c64829874809223516750e--c22e140a78824cc08bfd31d5835273a7 4fa9cdbe133c45b7bf806308f5160066 RX(phi\u2081\u2087) c22e140a78824cc08bfd31d5835273a7--4fa9cdbe133c45b7bf806308f5160066 0b6fdc877dae4623afd150a340f77f16 4fa9cdbe133c45b7bf806308f5160066--0b6fdc877dae4623afd150a340f77f16 19fa989fb77440389ce541cd6cad0b32 PHASE(phi_ent\u2083) 0b6fdc877dae4623afd150a340f77f16--19fa989fb77440389ce541cd6cad0b32 19fa989fb77440389ce541cd6cad0b32--12bc1effd3ca4f39a0571dff0707cd03 19fa989fb77440389ce541cd6cad0b32--2b22d317f84e4f87b84007bc5a699872 <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_371b71362f11481e9ad17c96a15b2b1c cluster_6c796a4f60f945819bd93535451cb37b c117cde2e5d447debd4e4f8c61a6cb97 0 57968abb2cc743dd8898900d9b09635f RX(theta\u2080) c117cde2e5d447debd4e4f8c61a6cb97--57968abb2cc743dd8898900d9b09635f dab1bffbe8024934b85c0439fc4b6480 1 173bd6c2c868447886ad5eee830f8de7 RY(theta\u2083) 57968abb2cc743dd8898900d9b09635f--173bd6c2c868447886ad5eee830f8de7 5716b2ffc9a34d87ac4779d5a5071a8d RX(theta\u2086) 173bd6c2c868447886ad5eee830f8de7--5716b2ffc9a34d87ac4779d5a5071a8d ed7deae7071446be9bf5197d5e780065 HamEvo 5716b2ffc9a34d87ac4779d5a5071a8d--ed7deae7071446be9bf5197d5e780065 ce3c99d78ae946aa82bd6b4d1b2732e8 RX(theta\u2089) ed7deae7071446be9bf5197d5e780065--ce3c99d78ae946aa82bd6b4d1b2732e8 5aa84c2412d24d4589386ad054f03015 RY(theta\u2081\u2082) ce3c99d78ae946aa82bd6b4d1b2732e8--5aa84c2412d24d4589386ad054f03015 447b0703163342b0b153c6e12854c144 RX(theta\u2081\u2085) 5aa84c2412d24d4589386ad054f03015--447b0703163342b0b153c6e12854c144 7bfea05847474850b9114efb41bd926f HamEvo 447b0703163342b0b153c6e12854c144--7bfea05847474850b9114efb41bd926f f6ddd30517fd4d33a5dfab93500dbf4a 7bfea05847474850b9114efb41bd926f--f6ddd30517fd4d33a5dfab93500dbf4a d286259044604febaa20f0f9ed3359c0 67593f3593614e2abc796f711984fea4 RX(theta\u2081) dab1bffbe8024934b85c0439fc4b6480--67593f3593614e2abc796f711984fea4 67da8e72c5254f8bbe5be6c568f9f01f 2 159b24fffab74ea7b76b3c47cc45bddd RY(theta\u2084) 67593f3593614e2abc796f711984fea4--159b24fffab74ea7b76b3c47cc45bddd 2d2dd3bcf36b404b9226e4d9ba8a79b3 RX(theta\u2087) 159b24fffab74ea7b76b3c47cc45bddd--2d2dd3bcf36b404b9226e4d9ba8a79b3 5fb9d3cfd70c4a16a88cac2e0c5650a8 t = theta_t\u2080 2d2dd3bcf36b404b9226e4d9ba8a79b3--5fb9d3cfd70c4a16a88cac2e0c5650a8 79d4db16b08d425195447af0c92f07d8 RX(theta\u2081\u2080) 5fb9d3cfd70c4a16a88cac2e0c5650a8--79d4db16b08d425195447af0c92f07d8 19bcb89b6d834b13958f2f9332c3e988 RY(theta\u2081\u2083) 79d4db16b08d425195447af0c92f07d8--19bcb89b6d834b13958f2f9332c3e988 ea89da8948754b2a8c0453e17e9a2157 RX(theta\u2081\u2086) 19bcb89b6d834b13958f2f9332c3e988--ea89da8948754b2a8c0453e17e9a2157 9ec0a7bf566c44f5bb885546f7960e3a t = theta_t\u2081 ea89da8948754b2a8c0453e17e9a2157--9ec0a7bf566c44f5bb885546f7960e3a 9ec0a7bf566c44f5bb885546f7960e3a--d286259044604febaa20f0f9ed3359c0 097860a9459347cc8e5442eec9353e54 a41b936d3d0a4862b26cb16c8e54f88f RX(theta\u2082) 67da8e72c5254f8bbe5be6c568f9f01f--a41b936d3d0a4862b26cb16c8e54f88f 81c5d9618c154358936cb392cd7303b2 RY(theta\u2085) a41b936d3d0a4862b26cb16c8e54f88f--81c5d9618c154358936cb392cd7303b2 2d1ad737abd646e289984c0db50da98c RX(theta\u2088) 81c5d9618c154358936cb392cd7303b2--2d1ad737abd646e289984c0db50da98c aed2c04ad86044fba5631112adbfbba7 2d1ad737abd646e289984c0db50da98c--aed2c04ad86044fba5631112adbfbba7 934a5e3e5e494156a4a7966df3b18585 RX(theta\u2081\u2081) aed2c04ad86044fba5631112adbfbba7--934a5e3e5e494156a4a7966df3b18585 c2113a6d899b496ba019f03781f2e4f0 RY(theta\u2081\u2084) 934a5e3e5e494156a4a7966df3b18585--c2113a6d899b496ba019f03781f2e4f0 b59756dd393548d78368f5c578bb1d3b RX(theta\u2081\u2087) c2113a6d899b496ba019f03781f2e4f0--b59756dd393548d78368f5c578bb1d3b 4f1946f897cd4fc78cd9ce25b7d4c11d b59756dd393548d78368f5c578bb1d3b--4f1946f897cd4fc78cd9ce25b7d4c11d 4f1946f897cd4fc78cd9ce25b7d4c11d--097860a9459347cc8e5442eec9353e54 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_7616f914257b48159056574041775389 cluster_6705cb3328074f498d7a4ff0aac91c6b b1cd1a61f24a4b849037e45772e2e2a7 0 1aa8adc8e9174e288ed869368ce3d57e RX(theta\u2080) b1cd1a61f24a4b849037e45772e2e2a7--1aa8adc8e9174e288ed869368ce3d57e 522bfb996b794e319f9798f7474ada03 1 5ffe8b08922241bb8a82ad8e821f75c2 RY(theta\u2086) 1aa8adc8e9174e288ed869368ce3d57e--5ffe8b08922241bb8a82ad8e821f75c2 c592b23779b3459fb9d8e59d2861900e RX(theta\u2081\u2082) 5ffe8b08922241bb8a82ad8e821f75c2--c592b23779b3459fb9d8e59d2861900e 4b52785863634f199aa315c0dfb63a99 c592b23779b3459fb9d8e59d2861900e--4b52785863634f199aa315c0dfb63a99 02c8bfe45fc44d35a2bf0a912eb7a9e1 RX(theta\u2081\u2088) 4b52785863634f199aa315c0dfb63a99--02c8bfe45fc44d35a2bf0a912eb7a9e1 0f1df06637e44f78b1f7be59bd645cea RY(theta\u2082\u2084) 02c8bfe45fc44d35a2bf0a912eb7a9e1--0f1df06637e44f78b1f7be59bd645cea a1ddb91a85804cd394e448ac324cfe60 RX(theta\u2083\u2080) 0f1df06637e44f78b1f7be59bd645cea--a1ddb91a85804cd394e448ac324cfe60 f00f0d13258f4fe3899951f635dfd279 a1ddb91a85804cd394e448ac324cfe60--f00f0d13258f4fe3899951f635dfd279 d1c849c110054df5ad848dadeac6046d f00f0d13258f4fe3899951f635dfd279--d1c849c110054df5ad848dadeac6046d 48d9cb656a124bb5a77a5a351c112288 64a3bf80cabb49b483eef700d4d5bc0c RX(theta\u2081) 522bfb996b794e319f9798f7474ada03--64a3bf80cabb49b483eef700d4d5bc0c f81716a371e14fbaa0c95e92e484390d 2 35ed5f5929cd4559a5371473559cacd3 RY(theta\u2087) 64a3bf80cabb49b483eef700d4d5bc0c--35ed5f5929cd4559a5371473559cacd3 98907aab734a48c3956b7f450f1df352 RX(theta\u2081\u2083) 35ed5f5929cd4559a5371473559cacd3--98907aab734a48c3956b7f450f1df352 3d13c3c4b279437aba1eb4d2ea783d2b 98907aab734a48c3956b7f450f1df352--3d13c3c4b279437aba1eb4d2ea783d2b c9e9a322017d431cab23f2eb2b33d53f RX(theta\u2081\u2089) 3d13c3c4b279437aba1eb4d2ea783d2b--c9e9a322017d431cab23f2eb2b33d53f 5ffa26b71e2d4cbfb2a77f2f4e55f14c RY(theta\u2082\u2085) c9e9a322017d431cab23f2eb2b33d53f--5ffa26b71e2d4cbfb2a77f2f4e55f14c 76b5a0be7f66408c9b118e973ea8f3de RX(theta\u2083\u2081) 5ffa26b71e2d4cbfb2a77f2f4e55f14c--76b5a0be7f66408c9b118e973ea8f3de cccbcdb94c5144d0813f06857d0bf459 76b5a0be7f66408c9b118e973ea8f3de--cccbcdb94c5144d0813f06857d0bf459 cccbcdb94c5144d0813f06857d0bf459--48d9cb656a124bb5a77a5a351c112288 5b463fbee3d646b2b90b15e70caf4b4d f85ec54d7cd14fefb508f6c9bdcde773 RX(theta\u2082) f81716a371e14fbaa0c95e92e484390d--f85ec54d7cd14fefb508f6c9bdcde773 5df50d0a82914622917491c4dede5026 3 beb5b370a8404336bc38bf0bd19545aa RY(theta\u2088) f85ec54d7cd14fefb508f6c9bdcde773--beb5b370a8404336bc38bf0bd19545aa 28b5df3c87a94802beeaa9883ce29aaf RX(theta\u2081\u2084) beb5b370a8404336bc38bf0bd19545aa--28b5df3c87a94802beeaa9883ce29aaf e84d72da191644719e4324002ee8bfe7 HamEvo 28b5df3c87a94802beeaa9883ce29aaf--e84d72da191644719e4324002ee8bfe7 f88e02ba44874053a64bfaeb6b65f47d RX(theta\u2082\u2080) e84d72da191644719e4324002ee8bfe7--f88e02ba44874053a64bfaeb6b65f47d be9e9407e6d8454da88787848815416c RY(theta\u2082\u2086) f88e02ba44874053a64bfaeb6b65f47d--be9e9407e6d8454da88787848815416c f2de745dde2d4a08aae69e72d82dedc4 RX(theta\u2083\u2082) be9e9407e6d8454da88787848815416c--f2de745dde2d4a08aae69e72d82dedc4 cf9fc625f8fc4e3ea4eeff81d763ad5b HamEvo f2de745dde2d4a08aae69e72d82dedc4--cf9fc625f8fc4e3ea4eeff81d763ad5b cf9fc625f8fc4e3ea4eeff81d763ad5b--5b463fbee3d646b2b90b15e70caf4b4d f660eff36f6e4380b31c973231ac85ab be2540ef1b6744c39d0c6f886b4f7ab7 RX(theta\u2083) 5df50d0a82914622917491c4dede5026--be2540ef1b6744c39d0c6f886b4f7ab7 5d3f6d90a5d242deba574de430a65d19 4 af3b76f5cfae465ca619fbe45fad2189 RY(theta\u2089) be2540ef1b6744c39d0c6f886b4f7ab7--af3b76f5cfae465ca619fbe45fad2189 4aa8d17d43044bd4840eba8f7e70430b RX(theta\u2081\u2085) af3b76f5cfae465ca619fbe45fad2189--4aa8d17d43044bd4840eba8f7e70430b fcc8f21e207f4257b47f66c21e630e28 t = theta_t\u2080 4aa8d17d43044bd4840eba8f7e70430b--fcc8f21e207f4257b47f66c21e630e28 fbf0cf752a334bea9dcda893fcfc29e6 RX(theta\u2082\u2081) fcc8f21e207f4257b47f66c21e630e28--fbf0cf752a334bea9dcda893fcfc29e6 3a56f52832194cddbe7fe7b91ad1151f RY(theta\u2082\u2087) fbf0cf752a334bea9dcda893fcfc29e6--3a56f52832194cddbe7fe7b91ad1151f 3a14a92105f84684bd2593e4e7b403d9 RX(theta\u2083\u2083) 3a56f52832194cddbe7fe7b91ad1151f--3a14a92105f84684bd2593e4e7b403d9 06bd9aa04f6c450dafd7f790e6248841 t = theta_t\u2081 3a14a92105f84684bd2593e4e7b403d9--06bd9aa04f6c450dafd7f790e6248841 06bd9aa04f6c450dafd7f790e6248841--f660eff36f6e4380b31c973231ac85ab 2273275da153464e8beb6320eaa1b266 72edea4d34f24b35848d053da2325c89 RX(theta\u2084) 5d3f6d90a5d242deba574de430a65d19--72edea4d34f24b35848d053da2325c89 2fe02a6f87844da4aec0e311b20cd959 5 46667b75366347ebb98e7a22bd7c0e0f RY(theta\u2081\u2080) 72edea4d34f24b35848d053da2325c89--46667b75366347ebb98e7a22bd7c0e0f 47cddf0752e945919527cbd8902d538d RX(theta\u2081\u2086) 46667b75366347ebb98e7a22bd7c0e0f--47cddf0752e945919527cbd8902d538d 6368f0fe30b34aa7b5400b77dc7f017a 47cddf0752e945919527cbd8902d538d--6368f0fe30b34aa7b5400b77dc7f017a 31ffb99ef58648dcbf207c8bdf23cf67 RX(theta\u2082\u2082) 6368f0fe30b34aa7b5400b77dc7f017a--31ffb99ef58648dcbf207c8bdf23cf67 af2d285fa4494f07880944c695b55e61 RY(theta\u2082\u2088) 31ffb99ef58648dcbf207c8bdf23cf67--af2d285fa4494f07880944c695b55e61 a792719a111c4137b8a755fd8eec0696 RX(theta\u2083\u2084) af2d285fa4494f07880944c695b55e61--a792719a111c4137b8a755fd8eec0696 c75a33ace86e4de1972d9fc3c1f565ed a792719a111c4137b8a755fd8eec0696--c75a33ace86e4de1972d9fc3c1f565ed c75a33ace86e4de1972d9fc3c1f565ed--2273275da153464e8beb6320eaa1b266 267baf8fef47483aa0e8d083cb3f5892 43312f68a7964664a053b18aa3c5dffa RX(theta\u2085) 2fe02a6f87844da4aec0e311b20cd959--43312f68a7964664a053b18aa3c5dffa 9ccac246d2ec4f688fae7a91d016a891 RY(theta\u2081\u2081) 43312f68a7964664a053b18aa3c5dffa--9ccac246d2ec4f688fae7a91d016a891 182c990cedd44aaea8907fe521087a05 RX(theta\u2081\u2087) 9ccac246d2ec4f688fae7a91d016a891--182c990cedd44aaea8907fe521087a05 bc3611c0774c4c68b87563c9aea04f0c 182c990cedd44aaea8907fe521087a05--bc3611c0774c4c68b87563c9aea04f0c 527a8811fd8340659dad0f777c5b03de RX(theta\u2082\u2083) bc3611c0774c4c68b87563c9aea04f0c--527a8811fd8340659dad0f777c5b03de 3eaa391402d94eb6af3bf83e846de96f RY(theta\u2082\u2089) 527a8811fd8340659dad0f777c5b03de--3eaa391402d94eb6af3bf83e846de96f 0b21b24010444a6185fcf7cb8cc71d63 RX(theta\u2083\u2085) 3eaa391402d94eb6af3bf83e846de96f--0b21b24010444a6185fcf7cb8cc71d63 09d6b18e16fd4e6f82c6a1905c0285e2 0b21b24010444a6185fcf7cb8cc71d63--09d6b18e16fd4e6f82c6a1905c0285e2 09d6b18e16fd4e6f82c6a1905c0285e2--267baf8fef47483aa0e8d083cb3f5892"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_2eb594990e64418dbe9549ca2e307c47 BPMA-1 cluster_0b4df50244634e21bf5cfc393ebdc4ca BPMA-0 8fddd4dfae77470fae5351c405d8dc64 0 91105245f050487e8467af8d9fdf51ea RX(iia_\u03b1\u2080\u2080) 8fddd4dfae77470fae5351c405d8dc64--91105245f050487e8467af8d9fdf51ea 3b347b5e6b8c4a1e8b01c382a61b5a24 1 9b73dd7a996b4f098da4549646f3f63d RY(iia_\u03b1\u2080\u2083) 91105245f050487e8467af8d9fdf51ea--9b73dd7a996b4f098da4549646f3f63d bfd344449abb45bdbb2d012627ab016a 9b73dd7a996b4f098da4549646f3f63d--bfd344449abb45bdbb2d012627ab016a aa377404996c477c8641b90fd1fa23be bfd344449abb45bdbb2d012627ab016a--aa377404996c477c8641b90fd1fa23be 52e7bee9de7749539543ce7771eee3be RX(iia_\u03b3\u2080\u2080) aa377404996c477c8641b90fd1fa23be--52e7bee9de7749539543ce7771eee3be c6301c08f70d4dde883cea46550e5a7b 52e7bee9de7749539543ce7771eee3be--c6301c08f70d4dde883cea46550e5a7b 69f06bafc7cb4d3a9ab0715460a1f33f c6301c08f70d4dde883cea46550e5a7b--69f06bafc7cb4d3a9ab0715460a1f33f b8025a2f964c4dc8a9e51369435e06e8 RY(iia_\u03b2\u2080\u2083) 69f06bafc7cb4d3a9ab0715460a1f33f--b8025a2f964c4dc8a9e51369435e06e8 0edcf49313314cf5a7281384e88c978e RX(iia_\u03b2\u2080\u2080) b8025a2f964c4dc8a9e51369435e06e8--0edcf49313314cf5a7281384e88c978e 6ee00497f6c542f08a057021b5caf9e1 RX(iia_\u03b1\u2081\u2080) 0edcf49313314cf5a7281384e88c978e--6ee00497f6c542f08a057021b5caf9e1 7423609bcc184cc5944dea4d39fac94f RY(iia_\u03b1\u2081\u2083) 6ee00497f6c542f08a057021b5caf9e1--7423609bcc184cc5944dea4d39fac94f 2e00237830d44810b54522b29c869433 7423609bcc184cc5944dea4d39fac94f--2e00237830d44810b54522b29c869433 ac9b7b1166484795ad31e6843c003960 2e00237830d44810b54522b29c869433--ac9b7b1166484795ad31e6843c003960 5a6993c355e84b1d9ab2fa4aa51060a2 RX(iia_\u03b3\u2081\u2080) ac9b7b1166484795ad31e6843c003960--5a6993c355e84b1d9ab2fa4aa51060a2 54acaa44c4d94f878a9ddc7bad3b0862 5a6993c355e84b1d9ab2fa4aa51060a2--54acaa44c4d94f878a9ddc7bad3b0862 4eff23f016fa42e99a1b2d3accac2849 54acaa44c4d94f878a9ddc7bad3b0862--4eff23f016fa42e99a1b2d3accac2849 54a6f68e15fe424a822a3c22f0232088 RY(iia_\u03b2\u2081\u2083) 4eff23f016fa42e99a1b2d3accac2849--54a6f68e15fe424a822a3c22f0232088 1c451622a7c04461839dc8d838dd129b RX(iia_\u03b2\u2081\u2080) 54a6f68e15fe424a822a3c22f0232088--1c451622a7c04461839dc8d838dd129b 8ff6e617f9d846ecb42b249a4d5fe37b 1c451622a7c04461839dc8d838dd129b--8ff6e617f9d846ecb42b249a4d5fe37b bcfb2aaa65814935b524a8c73af33acc dbc2d4c3c20245538032302a594d35ec RX(iia_\u03b1\u2080\u2081) 3b347b5e6b8c4a1e8b01c382a61b5a24--dbc2d4c3c20245538032302a594d35ec ca0ca6a8708348aea1b0d62ee7642c8a 2 155c9bae6a704bafb0a70b2e739229dc RY(iia_\u03b1\u2080\u2084) dbc2d4c3c20245538032302a594d35ec--155c9bae6a704bafb0a70b2e739229dc 26db92fc5f5141afaefd9d7a982f0a75 X 155c9bae6a704bafb0a70b2e739229dc--26db92fc5f5141afaefd9d7a982f0a75 26db92fc5f5141afaefd9d7a982f0a75--bfd344449abb45bdbb2d012627ab016a 02cab97ea5d04b208a5c7dcbf42eb6bf 26db92fc5f5141afaefd9d7a982f0a75--02cab97ea5d04b208a5c7dcbf42eb6bf a50b1fbdc6ee487ebe1aebd6280c51c2 RX(iia_\u03b3\u2080\u2081) 02cab97ea5d04b208a5c7dcbf42eb6bf--a50b1fbdc6ee487ebe1aebd6280c51c2 00beadbd3a6a40a0b7d8a3c68a0cfc20 a50b1fbdc6ee487ebe1aebd6280c51c2--00beadbd3a6a40a0b7d8a3c68a0cfc20 c059b73feb094436bcde75cc111715ba X 00beadbd3a6a40a0b7d8a3c68a0cfc20--c059b73feb094436bcde75cc111715ba c059b73feb094436bcde75cc111715ba--69f06bafc7cb4d3a9ab0715460a1f33f 160c80cc613343809518f3533d411b6c RY(iia_\u03b2\u2080\u2084) c059b73feb094436bcde75cc111715ba--160c80cc613343809518f3533d411b6c 178c4ff49e2a4722aa661ba365428be9 RX(iia_\u03b2\u2080\u2081) 160c80cc613343809518f3533d411b6c--178c4ff49e2a4722aa661ba365428be9 f9e675308ee049cd866f04a7b692d051 RX(iia_\u03b1\u2081\u2081) 178c4ff49e2a4722aa661ba365428be9--f9e675308ee049cd866f04a7b692d051 9bc296bf0718493c8beea6d8c933ed4e RY(iia_\u03b1\u2081\u2084) f9e675308ee049cd866f04a7b692d051--9bc296bf0718493c8beea6d8c933ed4e 35898f65fba84d3aa1ce523a0dbd8409 X 9bc296bf0718493c8beea6d8c933ed4e--35898f65fba84d3aa1ce523a0dbd8409 35898f65fba84d3aa1ce523a0dbd8409--2e00237830d44810b54522b29c869433 69a87f0fa53d4deb86050161254f6948 35898f65fba84d3aa1ce523a0dbd8409--69a87f0fa53d4deb86050161254f6948 23e0c30fa2494a7987d8c0dd45ce6c30 RX(iia_\u03b3\u2081\u2081) 69a87f0fa53d4deb86050161254f6948--23e0c30fa2494a7987d8c0dd45ce6c30 1e1e2ec765714ee58cb3cb14938d7d39 23e0c30fa2494a7987d8c0dd45ce6c30--1e1e2ec765714ee58cb3cb14938d7d39 ecf766cbcfb146afab7df31ce2da7cf9 X 1e1e2ec765714ee58cb3cb14938d7d39--ecf766cbcfb146afab7df31ce2da7cf9 ecf766cbcfb146afab7df31ce2da7cf9--4eff23f016fa42e99a1b2d3accac2849 03df270d6b4e4611a5275e1943d5b5ce RY(iia_\u03b2\u2081\u2084) ecf766cbcfb146afab7df31ce2da7cf9--03df270d6b4e4611a5275e1943d5b5ce 28f184ace3a34a1b8eea2dca82dc6aa9 RX(iia_\u03b2\u2081\u2081) 03df270d6b4e4611a5275e1943d5b5ce--28f184ace3a34a1b8eea2dca82dc6aa9 28f184ace3a34a1b8eea2dca82dc6aa9--bcfb2aaa65814935b524a8c73af33acc f601b951e1704259bd5081b26c61f97a 1720f2af268542b3a934816aa4952ac7 RX(iia_\u03b1\u2080\u2082) ca0ca6a8708348aea1b0d62ee7642c8a--1720f2af268542b3a934816aa4952ac7 4ba14463b9cf4cb3bfe80ee13d8e81c9 RY(iia_\u03b1\u2080\u2085) 1720f2af268542b3a934816aa4952ac7--4ba14463b9cf4cb3bfe80ee13d8e81c9 b7fdf0ff540b4f6bad8a68416c36675e 4ba14463b9cf4cb3bfe80ee13d8e81c9--b7fdf0ff540b4f6bad8a68416c36675e 22e211985298439eb6280d1b81208f28 X b7fdf0ff540b4f6bad8a68416c36675e--22e211985298439eb6280d1b81208f28 22e211985298439eb6280d1b81208f28--02cab97ea5d04b208a5c7dcbf42eb6bf c048972c66694e11ae07902c285c7cd2 RX(iia_\u03b3\u2080\u2082) 22e211985298439eb6280d1b81208f28--c048972c66694e11ae07902c285c7cd2 8d382e3ad9c343d084a9fba702fb9485 X c048972c66694e11ae07902c285c7cd2--8d382e3ad9c343d084a9fba702fb9485 8d382e3ad9c343d084a9fba702fb9485--00beadbd3a6a40a0b7d8a3c68a0cfc20 3b102feea59e41e99f95fb038e73307c 8d382e3ad9c343d084a9fba702fb9485--3b102feea59e41e99f95fb038e73307c facdef90283d4978adb17befe1b06f9a RY(iia_\u03b2\u2080\u2085) 3b102feea59e41e99f95fb038e73307c--facdef90283d4978adb17befe1b06f9a 713ed92ab96f40319f12e7f24a8d33d7 RX(iia_\u03b2\u2080\u2082) facdef90283d4978adb17befe1b06f9a--713ed92ab96f40319f12e7f24a8d33d7 646138fd3b3a433a95080a3c4ad5511c RX(iia_\u03b1\u2081\u2082) 713ed92ab96f40319f12e7f24a8d33d7--646138fd3b3a433a95080a3c4ad5511c 19b517bb22f9423892ca2b32765e2adb RY(iia_\u03b1\u2081\u2085) 646138fd3b3a433a95080a3c4ad5511c--19b517bb22f9423892ca2b32765e2adb 1897165a52d24f02a2d166b39178727b 19b517bb22f9423892ca2b32765e2adb--1897165a52d24f02a2d166b39178727b 68ed58c257a94d96b5f96a208da3d03b X 1897165a52d24f02a2d166b39178727b--68ed58c257a94d96b5f96a208da3d03b 68ed58c257a94d96b5f96a208da3d03b--69a87f0fa53d4deb86050161254f6948 ef2ac27785124f97a0e56ec06cdfba0d RX(iia_\u03b3\u2081\u2082) 68ed58c257a94d96b5f96a208da3d03b--ef2ac27785124f97a0e56ec06cdfba0d a3972deb936d49f2b1724d871b4209ad X ef2ac27785124f97a0e56ec06cdfba0d--a3972deb936d49f2b1724d871b4209ad a3972deb936d49f2b1724d871b4209ad--1e1e2ec765714ee58cb3cb14938d7d39 cfb50eb242314d0691aedbe59c7b5fc7 a3972deb936d49f2b1724d871b4209ad--cfb50eb242314d0691aedbe59c7b5fc7 a39dacfb29b1448fac7434421c7b59d0 RY(iia_\u03b2\u2081\u2085) cfb50eb242314d0691aedbe59c7b5fc7--a39dacfb29b1448fac7434421c7b59d0 7987d484ed504d8da2bff271d8e92b56 RX(iia_\u03b2\u2081\u2082) a39dacfb29b1448fac7434421c7b59d0--7987d484ed504d8da2bff271d8e92b56 7987d484ed504d8da2bff271d8e92b56--f601b951e1704259bd5081b26c61f97a"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>Sample-based measurement protocols are fundamental tools for the prediction and estimation of a quantum state as the result of NISQ programs executions. Their resource efficient implementation is a current and active research field. Qadence offers two main measurement protocols: quantum state tomography and classical shadows.</p>"},{"location":"realistic_sims/measurements/#quantum-state-tomography","title":"Quantum state tomography","text":"<p>The fundamental task of quantum state tomography is to learn an approximate classical description of an output quantum state described by a density matrix \\(\\rho\\), from repeated measurements of copies on a chosen basis. To do so, \\(\\rho\\) is expanded in a basis of observables (the tomography step) and for a given observable \\(\\hat{\\mathcal{O}}\\), the expectation value is calculated with \\(\\langle \\hat{\\mathcal{O}} \\rangle=\\textrm{Tr}(\\hat{\\mathcal{O}}\\rho)\\). A number of measurement repetitions in a suitable basis is then required to estimate \\(\\langle \\hat{\\mathcal{O}} \\rangle\\).</p> <p>The main drawback is the scaling in measurements for the retrieval of the classical expression for a \\(n\\)-qubit quantum state as \\(2^n \\times 2^n\\), together with a large amount of classical post-processing.</p> <p>For an observable expressed as a Pauli string \\(\\hat{\\mathcal{P}}\\), the expectation value for a state \\(|\\psi \\rangle\\) can be derived as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\langle \\psi | \\hat{\\mathcal{P}} |\\psi \\rangle=\\langle \\psi | \\hat{\\mathcal{R}}^\\dagger \\hat{\\mathcal{D}} \\hat{\\mathcal{R}} |\\psi \\rangle \\] <p>The operator \\(\\hat{\\mathcal{R}}\\) diagonalizes \\(\\hat{\\mathcal{P}}\\) and rotates the state into an eigenstate in the computational basis. Therefore, \\(\\hat{\\mathcal{R}}|\\psi \\rangle=\\sum\\limits_{z}a_z|z\\rangle\\) and the expectation value can finally be expressed as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\sum_{z,z'}\\langle z |\\bar{a}_z\\hat{\\mathcal{D}}a_{z'}|z'\\rangle = \\sum_{z}|a_z|^2(-1)^{\\phi_z(\\hat{\\mathcal{P}})} \\] <p>In Qadence, running a tomographical experiment is made simple by defining a <code>Measurements</code> object that captures all options for execution:</p> <pre><code>from torch import tensor\nfrom qadence import hamiltonian_factory, BackendName, DiffMode\nfrom qadence import Parameter, chain, kron, RX, RY, Z, QuantumCircuit, QuantumModel\nfrom qadence.measurements import Measurements\n\n# Define parameters for a circuit.\ntheta1 = Parameter(\"theta1\", trainable=False)\ntheta2 = Parameter(\"theta2\", trainable=False)\ntheta3 = Parameter(\"theta3\", trainable=False)\ntheta4 = Parameter(\"theta4\", trainable=False)\n\nblocks = chain(\n    kron(RX(0, theta1), RY(1, theta2)),\n    kron(RX(0, theta3), RY(1, theta4)),\n)\n\nvalues = {\n    \"theta1\": tensor([0.5]),\n    \"theta2\": tensor([1.5]),\n    \"theta3\": tensor([2.0]),\n    \"theta4\": tensor([2.5]),\n}\n\n# Create a circuit and an observable.\ncircuit = QuantumCircuit(2, blocks)\nobservable = hamiltonian_factory(2, detuning=Z)\n\n# Create a model.\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n)\n\n# Define a measurement protocol by passing the shot budget as an option.\ntomo_options = {\"n_shots\": 100000}\ntomo_measurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=tomo_options)\n\n# Get the exact expectation value.\nexact_values = model.expectation(\n    values=values,\n)\n\n# Run the tomography experiment.\nestimated_values_tomo = model.expectation(\n    values=values,\n    measurement=tomo_measurement,\n)\n</code></pre> <pre><code>Exact expectation value = tensor([[-1.4548]])\nEstimated expectation value tomo = tensor([[-1.4503]])\n</code></pre>"},{"location":"realistic_sims/measurements/#classical-shadows","title":"Classical shadows","text":"<p>Recently, a much less resource demanding protocol based on classical shadows has been proposed<sup>1</sup>. It combines ideas from shadow tomography<sup>2</sup> and randomized measurement protocols capable of learning a classical shadow of an unknown quantum state \\(\\rho\\). It relies on deliberately discarding the full classical characterization of the quantum state, and instead focuses on accurately predicting a restricted set of properties that provide efficient protocols for the study of the system.</p> <p>A random measurement consists of applying random unitary rotations before a fixed measurement on each copy of a state. Appropriately averaging over these measurements produces an efficient estimator for the expectation value of an observable. This protocol therefore creates a robust classical representation of the quantum state or classical shadow. The captured measurement information is then reuseable for multiple purposes, i.e. any observable expected value and available for noise mitigation postprocessing.</p> <p>A classical shadow is therefore an unbiased estimator of a quantum state \\(\\rho\\). Such an estimator is obtained with the following procedure<sup>1</sup>: first, apply a random unitary gate \\(U\\) to rotate the state: \\(\\rho \\rightarrow U \\rho U^\\dagger\\) and then perform a basis measurement to obtain a \\(n\\)-bit measurement \\(|\\hat{b}\\rangle \\in \\{0, 1\\}^n\\). Both unitary gates \\(U\\) and the measurement outcomes \\(|\\hat{b}\\rangle\\) are stored on a classical computer for postprocessing v \\(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U\\), a classical snapshot of the state \\(\\rho\\). The whole procedure can be seen as a quantum channel \\(\\mathcal{M}\\) that maps the initial unknown quantum state \\(\\rho\\) to the average result of the measurement protocol:</p> \\[ \\mathbb{E}[U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U] = \\mathcal{M}(\\rho) \\Rightarrow \\rho = \\mathbb{E}[\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)] \\] <p>It is worth noting that the single classical snapshot \\(\\hat{\\rho}=\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)\\) equals \\(\\rho\\) in expectation: \\(\\mathbb{E}[\\hat{\\rho}]=\\rho\\) despite \\(\\mathcal{M}^{-1}\\) not being a completely positive map. Repeating this procedure \\(N\\) times results in an array of \\(N\\) independent, classical snapshots of \\(\\rho\\) called the classical shadow:</p> \\[ S(\\rho, N) = \\{ \\hat{\\rho}_1=\\mathcal{M}^{-1}(U_1^\\dagger |\\hat{b}_1\\rangle\\langle \\hat{b}_1|U_1),\\cdots,\\hat{\\rho}_N=\\mathcal{M}^{-1}(U_N^\\dagger |\\hat{b}_N\\rangle\\langle \\hat{b}_N|U_N)\\} \\] <p>Along the same lines as the example before, estimating the expectation value using classical shadows in Qadence only requires to pass the right set of parameters to the <code>Measurements</code> object:</p> <pre><code># Classical shadows are defined up to some accuracy and confidence.\nshadow_options = {\"accuracy\": 0.1, \"confidence\": 0.1}  # Shadow size N=54400.\nshadow_measurement = Measurements(protocol=Measurements.SHADOW, options=shadow_options)\n\n# Run the experiment with classical shadows.\nestimated_values_shadow = model.expectation(\n    values=values,\n    measurement=shadow_measurement,\n)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-1.5018]])\n</code></pre>"},{"location":"realistic_sims/measurements/#references","title":"References","text":"<ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9\u21a9</p> </li> <li> <p>S. Aaronson. Shadow tomography of quantum states. In Proceedings of the 50th Annual A ACM SIGACT Symposium on Theory of Computing, STOC 2018, pages 325\u2013338, New York, NY, USA, 2018. ACM\u00a0\u21a9</p> </li> </ol>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>Beyond running noisy simulations, Qadence offers a number of noise mitigation techniques to achieve better accuracy of simulation outputs. Currently, mitigation addresses readout errors and depolarizing and dephasing noise for analog blocks.</p>"},{"location":"realistic_sims/mitigation/#readout-error-mitigation","title":"Readout error mitigation","text":"<p>The complete implementation of the mitigation technique is to measure \\(T\\) and classically apply \\(T^{\u22121}\\) to measured probability distributions. However there are several limitations of this approach:</p> <ul> <li>The complete implementation requires \\(2^n\\) characterization experiments (probability measurements), which is not scalable. The classical processing of the calibration data is also inefficient.</li> <li>The matrix \\(T\\) may become singular for large \\(n\\), preventing direct inversion.</li> <li>The inverse \\(T^{\u22121}\\) might not be a stochastic matrix, meaning that it can produce negative corrected probabilities.</li> <li>The correction is not rigorously justified, so we cannot be sure that we are only removing SPAM errors and not otherwise corrupting an estimated probability distribution.</li> </ul> <p>Qadence relies on the assumption of uncorrelated readout errors:</p> \\[ T=T_1\\otimes T_2\\otimes \\dots \\otimes T_n \\] <p>for which the inversion is straightforward:</p> \\[ T^{-1}=T_1^{-1}\\otimes T_2^{-1}\\otimes \\dots \\otimes T_n^{-1} \\] <p>However, even for a reduced \\(n\\) the third limitation holds. This can be avoided by reformulating into a minimization problem<sup>1</sup>:</p> \\[ \\lVert Tp_{\\textrm{corr}}-p_{\\textrm{raw}}\\rVert_{2}^{2} \\] <p>subjected to physicality constraints \\(0 \\leq p_{corr}(x) \\leq 1\\) and \\(\\lVert p_{corr} \\rVert = 1\\). At this point, two methods are implemented to solve this problem. The first one relies on solving using standard optimization tools, the second on Maximum-Likelihood Estimation<sup>2</sup>. In Qadence, this can be user defined using the mitigation protocol:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\nfrom qadence.mitigations import Mitigations\nfrom qadence.types import ReadOutOptimization\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use:\nnoise = Noise(protocol=Noise.READOUT)\n# Define the mitigation method solving the minimization problem:\noptions={\"optimization_type\": ReadOutOptimization.CONSTRAINED}  # ReadOutOptimization.MLE for the alternative method.\nmitigation = Mitigations(protocol=Mitigations.READOUT, options=options)\n\n# Run noiseless, noisy and mitigated simulations.\nn_shots = 100\nnoiseless_samples = model.sample(n_shots=n_shots)\nnoisy_samples = model.sample(noise=noise, n_shots=n_shots)\nmitigated_samples = model.sample(\n    noise=noise, mitigation=mitigation, n_shots=n_shots\n)\n\nprint(f\"noiseless {noiseless_samples}\")\nprint(f\"noisy {noisy_samples}\")\nprint(f\"mitigated {mitigated_samples}\")\n</code></pre> <pre><code>noiseless [Counter({'10': 54, '00': 46})]\nnoisy [Counter({'10': 52, '00': 39, '01': 6, '11': 3})]\nmitigated [Counter({'10': 44, '00': 43, '11': 7, '01': 6})]\n</code></pre>"},{"location":"realistic_sims/mitigation/#wip-zero-noise-extrapolation-for-analog-blocks","title":"[WIP] Zero-noise extrapolation for analog blocks","text":"<p>Zero-noise extrapolation (ZNE) is an error mitigation technique in which an expectation value is computed at different noise levels and, as a second step, the ideal expectation value is inferred by extrapolating the measured results to the zero-noise limit. In digital computing, this is typically implemented by \"folding\" the circuit and its dagger to artificially increase the noise through sequences of identities<sup>3</sup>. In the analog ZNE variation, analog blocks are time stretched to again artificially increase noise<sup>3</sup>.</p>"},{"location":"realistic_sims/mitigation/#references","title":"References","text":"<ol> <li> <p>Michael R. Geller and Mingyu Sun, Efficient correction of multiqubit measurement errors, (2020) \u21a9</p> </li> <li> <p>Smolin et al., Maximum Likelihood, Minimum Effort, (2011) \u21a9</p> </li> <li> <p>Mitiq: What's the theory behind ZNE? \u21a9\u21a9</p> </li> </ol>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. They are typically described using confusion matrices of the form:</p> \\[ T(x|x')=\\delta_{xx'} \\] <p>Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'10': 55, '00': 45})]\nnoisy = [Counter({'00': 49, '10': 46, '11': 4, '01': 1})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[1.0126]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9760]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': ec9d236f-36f2-4df7-9905-09f9bf6ec151, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 5ed68be0-4f57-48db-9162-6cbb3e4998af, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': c06a54f6-43bc-49db-8aff-01ef915ddebd, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': bf56e5b9-1228-41ed-950b-6a3777afd198, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 9bbbbf5a-7672-429a-8f6f-665cd86fddfa, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': ebaea68c-3f4e-4196-9dac-89b4a7444f55, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': fa93f4d0-582f-4153-851c-0ed9cf6d3d03, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': eab29812-0e63-4b48-b088-02f56b6928ea, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': c9d133d0-a289-42d5-8b5e-99599da5dbb4, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 68a94033-bc52-4f9d-a273-b5066c363075, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': f6488ee9-13f0-419a-bc9b-02806d50b079, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_7: tensor([0.5714], requires_grad=True)\n  theta_2: tensor([0.0286], requires_grad=True)\n  theta_4: tensor([0.4681], requires_grad=True)\n  theta_3: tensor([0.9100], requires_grad=True)\n  theta_5: tensor([0.1901], requires_grad=True)\n  theta_6: tensor([0.3384], requires_grad=True)\n  theta_8: tensor([0.4730], requires_grad=True)\n  theta_1: tensor([0.0567], requires_grad=True)\n  theta_0: tensor([0.2443], requires_grad=True)\n}\nembedded = {\n  ec9d236f-36f2-4df7-9905-09f9bf6ec151: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  5ed68be0-4f57-48db-9162-6cbb3e4998af: tensor([2., 2.])\n  c06a54f6-43bc-49db-8aff-01ef915ddebd: tensor([0.2443], grad_fn=&lt;ViewBackward0&gt;)\n  bf56e5b9-1228-41ed-950b-6a3777afd198: tensor([0.0567], grad_fn=&lt;ViewBackward0&gt;)\n  9bbbbf5a-7672-429a-8f6f-665cd86fddfa: tensor([0.0286], grad_fn=&lt;ViewBackward0&gt;)\n  ebaea68c-3f4e-4196-9dac-89b4a7444f55: tensor([0.9100], grad_fn=&lt;ViewBackward0&gt;)\n  fa93f4d0-582f-4153-851c-0ed9cf6d3d03: tensor([0.4681], grad_fn=&lt;ViewBackward0&gt;)\n  eab29812-0e63-4b48-b088-02f56b6928ea: tensor([0.1901], grad_fn=&lt;ViewBackward0&gt;)\n  c9d133d0-a289-42d5-8b5e-99599da5dbb4: tensor([0.3384], grad_fn=&lt;ViewBackward0&gt;)\n  68a94033-bc52-4f9d-a273-b5066c363075: tensor([0.5714], grad_fn=&lt;ViewBackward0&gt;)\n  f6488ee9-13f0-419a-bc9b-02806d50b079: tensor([0.4730], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  theta_7: tensor([0.5714], grad_fn=&lt;ViewBackward0&gt;)\n  theta_4: tensor([0.4681], grad_fn=&lt;ViewBackward0&gt;)\n  theta_2: tensor([0.0286], grad_fn=&lt;ViewBackward0&gt;)\n  y: tensor([2., 2.])\n  theta_3: tensor([0.9100], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.1901], grad_fn=&lt;ViewBackward0&gt;)\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  theta_6: tensor([0.3384], grad_fn=&lt;ViewBackward0&gt;)\n  theta_8: tensor([0.4730], grad_fn=&lt;ViewBackward0&gt;)\n  theta_1: tensor([0.0567], grad_fn=&lt;ViewBackward0&gt;)\n  theta_0: tensor([0.2443], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.1024-0.2150j, -0.0442-0.0478j,  0.1181-0.0056j,  0.1793+0.3932j,\n         -0.6275-0.4645j, -0.1817+0.1123j,  0.0725+0.0232j,  0.0196+0.2776j],\n        [ 0.1024-0.2150j, -0.0442-0.0478j,  0.1181-0.0056j,  0.1793+0.3932j,\n         -0.6275-0.4645j, -0.1817+0.1123j,  0.0725+0.0232j,  0.0196+0.2776j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 250, '100': 190, '011': 145, '111': 140, '001': 88, '110': 67, '101': 62, '010': 58})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(ec9d236f-36f2-4df7-9905-09f9bf6ec151)-C----------------------------------------Rx(c06a54f6-43bc-49db-8aff-01ef915ddebd)-Ry(ebaea68c-3f4e-4196-9dac-89b4a7444f55)-Rx(c9d133d0-a289-42d5-8b5e-99599da5dbb4)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(5ed68be0-4f57-48db-9162-6cbb3e4998af)-X----------------------------------------Rx(bf56e5b9-1228-41ed-950b-6a3777afd198)-Ry(fa93f4d0-582f-4153-851c-0ed9cf6d3d03)-Rx(68a94033-bc52-4f9d-a273-b5066c363075)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(9bbbbf5a-7672-429a-8f6f-665cd86fddfa)-Ry(eab29812-0e63-4b48-b088-02f56b6928ea)-Rx(f6488ee9-13f0-419a-bc9b-02806d50b079)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [5ed68be0-4f57-48db-9162-6cbb3e4998af, 68a94033-bc52-4f9d-a273-b5066c363075, 9bbbbf5a-7672-429a-8f6f-665cd86fddfa, bf56e5b9-1228-41ed-950b-6a3777afd198, c06a54f6-43bc-49db-8aff-01ef915ddebd, c9d133d0-a289-42d5-8b5e-99599da5dbb4, eab29812-0e63-4b48-b088-02f56b6928ea, ebaea68c-3f4e-4196-9dac-89b4a7444f55, ec9d236f-36f2-4df7-9905-09f9bf6ec151, f6488ee9-13f0-419a-bc9b-02806d50b079, fa93f4d0-582f-4153-851c-0ed9cf6d3d03].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(1.23)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.24)-DEPO(0.1)-Ry(0.91)-DEPO(0.1)-Rx(0.34)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.83)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.06)-DEPO(0.1)-Ry(0.47)-DEPO(0.1)-Rx(0.57)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.03)-DEPO(0.1)-Ry(0.19)-DEPO(0.1)-Rx(0.47)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 fbdd8ac31fec480a9e6f024d1b1b043a 0 bcbcffe29d484bc0a3fbab2e8ce07521 X fbdd8ac31fec480a9e6f024d1b1b043a--bcbcffe29d484bc0a3fbab2e8ce07521 a9f0a76efafd496685575d1e25acad05 1 9058ac3fd7c74442b35d65bfa7968fca bcbcffe29d484bc0a3fbab2e8ce07521--9058ac3fd7c74442b35d65bfa7968fca 213f0be8bd6241fa90ab28e7bddc20d3 ffb337fb55734f01b52512a6d95c0317 Y a9f0a76efafd496685575d1e25acad05--ffb337fb55734f01b52512a6d95c0317 ffb337fb55734f01b52512a6d95c0317--213f0be8bd6241fa90ab28e7bddc20d3 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 3bf6cb1f44f74eee8a6244d224a7bc8b 0 9639381565bb4d0fb687d5144b32f881 RX(0.5) 3bf6cb1f44f74eee8a6244d224a7bc8b--9639381565bb4d0fb687d5144b32f881 c38c13975fa045868bfb40c462b77013 9639381565bb4d0fb687d5144b32f881--c38c13975fa045868bfb40c462b77013 <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 24477c006ba8482c984ecd67f377c63b 0 590988cbeb0b4bf58e5737215a749a6e 24477c006ba8482c984ecd67f377c63b--590988cbeb0b4bf58e5737215a749a6e f3060f6fe5654f76b3c059a2533131b8 1 b55acad5291444e68fec9811b557a8eb 590988cbeb0b4bf58e5737215a749a6e--b55acad5291444e68fec9811b557a8eb d0b0b8dfe40844569cd26b853fded392 7eeadf29f54f4cd48fa300b80fcd74b5 X f3060f6fe5654f76b3c059a2533131b8--7eeadf29f54f4cd48fa300b80fcd74b5 7eeadf29f54f4cd48fa300b80fcd74b5--590988cbeb0b4bf58e5737215a749a6e 7eeadf29f54f4cd48fa300b80fcd74b5--d0b0b8dfe40844569cd26b853fded392 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 9bbd4161bb6b4276998a6938aa3e7b08 0 5614ed8eb342450dab65bc57623e466e X 9bbd4161bb6b4276998a6938aa3e7b08--5614ed8eb342450dab65bc57623e466e 80722e8c52314bc4b412c96b0fc41fba X 5614ed8eb342450dab65bc57623e466e--80722e8c52314bc4b412c96b0fc41fba 6831db49e8cb4f68862b06ca12c3c704 80722e8c52314bc4b412c96b0fc41fba--6831db49e8cb4f68862b06ca12c3c704 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 8d6381499049469884150ff25f5297c7 0 f6cac03efb4b41e3b16d54c359d15867 X 8d6381499049469884150ff25f5297c7--f6cac03efb4b41e3b16d54c359d15867 0f37f06b523a4b3fa441f5fd823ae26b 1 23863978837b42d7b765c8f5f4e85380 f6cac03efb4b41e3b16d54c359d15867--23863978837b42d7b765c8f5f4e85380 e5d3eb7cb2204967ac9e1b593aa0546b 23863978837b42d7b765c8f5f4e85380--e5d3eb7cb2204967ac9e1b593aa0546b 5960ff312d0a403fabe2554f7a5d6b77 791acae75cc44c4490348c0e1f10b1cf 0f37f06b523a4b3fa441f5fd823ae26b--791acae75cc44c4490348c0e1f10b1cf 9264b62252df4f118a8d3af59e0d76f6 X 791acae75cc44c4490348c0e1f10b1cf--9264b62252df4f118a8d3af59e0d76f6 9264b62252df4f118a8d3af59e0d76f6--5960ff312d0a403fabe2554f7a5d6b77 </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 69f14cf2f94848ce85d9c0cb08e78131 0 b2ada67e6a794c1488471e9ade9b7598 X 69f14cf2f94848ce85d9c0cb08e78131--b2ada67e6a794c1488471e9ade9b7598 adf859bd4f12483f984e27c739aae091 1 8259c8f155384fdfbc12de4bd763d5ee b2ada67e6a794c1488471e9ade9b7598--8259c8f155384fdfbc12de4bd763d5ee 92d654ec222341848c05b4bf31b2007b 280d8935c19643129060feaca431293d X adf859bd4f12483f984e27c739aae091--280d8935c19643129060feaca431293d 280d8935c19643129060feaca431293d--92d654ec222341848c05b4bf31b2007b <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_65cc6199c54d4bfb92c6b4c65dc7189b subblock cluster_12239fa6fa3c49eab8ad4059545de9d4 subblock d5bf650eb10c4248a6186c84e03b703d 0 79d0e0c02201494fa848e63ff885677f X d5bf650eb10c4248a6186c84e03b703d--79d0e0c02201494fa848e63ff885677f 09247c2558fb4356b7369c6d57bb38e5 1 957b7fd980a34dd289b07a9a89170e79 X 79d0e0c02201494fa848e63ff885677f--957b7fd980a34dd289b07a9a89170e79 9e9635c86b274207a22c559b25c84901 957b7fd980a34dd289b07a9a89170e79--9e9635c86b274207a22c559b25c84901 fbe2e61178834e1d8de891a0046f5ff9 0c3b71f5fadf49b094b709ba23d24758 Y 09247c2558fb4356b7369c6d57bb38e5--0c3b71f5fadf49b094b709ba23d24758 5584c97ad89f4492b98e9e7c7f8064bd 2 b97ea31d26704e7caf816eaaf5cb4569 Y 0c3b71f5fadf49b094b709ba23d24758--b97ea31d26704e7caf816eaaf5cb4569 b97ea31d26704e7caf816eaaf5cb4569--fbe2e61178834e1d8de891a0046f5ff9 d46965ef06c44cb5b9e1b6a2c0e6b87d 0d49d572f59e4098ae05ed493f52613c 5584c97ad89f4492b98e9e7c7f8064bd--0d49d572f59e4098ae05ed493f52613c 16ea4221e9ab46559a68058b24d4ccc9 3 6e8d75744e6f42ee9f000f0b51c76075 0d49d572f59e4098ae05ed493f52613c--6e8d75744e6f42ee9f000f0b51c76075 6e8d75744e6f42ee9f000f0b51c76075--d46965ef06c44cb5b9e1b6a2c0e6b87d 6fb3cf1ac3f54efb95145cb09304aec1 a96bb5fb142e46d29bac4a190b6a21fa 16ea4221e9ab46559a68058b24d4ccc9--a96bb5fb142e46d29bac4a190b6a21fa 83c863a9475249988e7b139df75017cd 4 67c24fc9429344ed997d80651addad67 a96bb5fb142e46d29bac4a190b6a21fa--67c24fc9429344ed997d80651addad67 67c24fc9429344ed997d80651addad67--6fb3cf1ac3f54efb95145cb09304aec1 ec0bbc0c91904a6da02e6d60ca106475 c6b67ecc94b0403191d4dfb5a52f9287 X 83c863a9475249988e7b139df75017cd--c6b67ecc94b0403191d4dfb5a52f9287 c6b67ecc94b0403191d4dfb5a52f9287--a96bb5fb142e46d29bac4a190b6a21fa e663aeae3f48470499b1d60f5ab40ba6 X c6b67ecc94b0403191d4dfb5a52f9287--e663aeae3f48470499b1d60f5ab40ba6 e663aeae3f48470499b1d60f5ab40ba6--67c24fc9429344ed997d80651addad67 e663aeae3f48470499b1d60f5ab40ba6--ec0bbc0c91904a6da02e6d60ca106475"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'11': 262, '00': 249, '10': 248, '01': 241})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'100': 30, '010': 27, '000': 24, '110': 19})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[0.2568, 0.0030],\n        [0.0140, 0.0074]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9048+0.0000j, 0.0000-0.4258j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.9633+0.0000j, 0.0000-0.2685j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.8746+0.0000j, 0.3181+0.0000j, 0.0000-0.3439j, 0.0000-0.1251j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_98e4c4520b5447d09b5d2676ce64d45a [* 2] cluster_a98a9100fb0847fc93f2bf1e733e141f Rotations f62fb64c08824dc29c5d603513d92c03 0 0b63b9364597486a8f3d383787476459 RX(phi/theta) f62fb64c08824dc29c5d603513d92c03--0b63b9364597486a8f3d383787476459 7698c44136ee46bca53390add9020032 1 eaf0f64f520b42cfb64d153b43ccec4c RX(phi) 0b63b9364597486a8f3d383787476459--eaf0f64f520b42cfb64d153b43ccec4c b389fefdebea43199331909865b0b345 RX(phi) eaf0f64f520b42cfb64d153b43ccec4c--b389fefdebea43199331909865b0b345 ad759cb33dfd41538d40b1ca7ee6b1d1 RX(phi + theta) b389fefdebea43199331909865b0b345--ad759cb33dfd41538d40b1ca7ee6b1d1 275bc930d5d1468bab7affbdac8173ae ad759cb33dfd41538d40b1ca7ee6b1d1--275bc930d5d1468bab7affbdac8173ae 18f29e55a80f4c34ab2a3225f8ea82b7 275bc930d5d1468bab7affbdac8173ae--18f29e55a80f4c34ab2a3225f8ea82b7 9df69c881840446b88e3a0f12a683def Z 18f29e55a80f4c34ab2a3225f8ea82b7--9df69c881840446b88e3a0f12a683def df125cab3b2c44c589c1fc080731e531 9df69c881840446b88e3a0f12a683def--df125cab3b2c44c589c1fc080731e531 ff7c3de9c2b94ca2a1b91ec3ec3f7f22 01be6fa21fe040a8ba3d5c6c31af8bee RY(2*theta) 7698c44136ee46bca53390add9020032--01be6fa21fe040a8ba3d5c6c31af8bee 3324657f556e481d8deed1584960c883 2 508be02a521d4d26a476ba0e6f68d4ff RY(theta) 01be6fa21fe040a8ba3d5c6c31af8bee--508be02a521d4d26a476ba0e6f68d4ff ddbabac12ec94677b413a3db19abaaf5 RY(theta) 508be02a521d4d26a476ba0e6f68d4ff--ddbabac12ec94677b413a3db19abaaf5 f2886a8773dc46c7b3d1dfcbe758d568 RY(theta**2) ddbabac12ec94677b413a3db19abaaf5--f2886a8773dc46c7b3d1dfcbe758d568 0addac31f8ba4adb94d2a88e2daa5120 X f2886a8773dc46c7b3d1dfcbe758d568--0addac31f8ba4adb94d2a88e2daa5120 0addac31f8ba4adb94d2a88e2daa5120--275bc930d5d1468bab7affbdac8173ae d540981345a6470aae77070807f1adc1 0addac31f8ba4adb94d2a88e2daa5120--d540981345a6470aae77070807f1adc1 1302b29ad5494aa496832fd6017bfedc Z d540981345a6470aae77070807f1adc1--1302b29ad5494aa496832fd6017bfedc 1302b29ad5494aa496832fd6017bfedc--ff7c3de9c2b94ca2a1b91ec3ec3f7f22 2ffb78ab4d3f42588a200a35ec4fecab 3d858675b48742cd9dfc5ddbee910dd7 RZ(cos(phi)) 3324657f556e481d8deed1584960c883--3d858675b48742cd9dfc5ddbee910dd7 0bcf5a1b247848348eaee08117912aee RZ(phi) 3d858675b48742cd9dfc5ddbee910dd7--0bcf5a1b247848348eaee08117912aee 5b709451cdc44cf99b97eff3d027c9c4 RZ(phi) 0bcf5a1b247848348eaee08117912aee--5b709451cdc44cf99b97eff3d027c9c4 a22ef5444b9646be8842bfc6082698cb RZ(cos(phi)) 5b709451cdc44cf99b97eff3d027c9c4--a22ef5444b9646be8842bfc6082698cb f6e0f26aeb2a4ead904f82626ede3ef4 a22ef5444b9646be8842bfc6082698cb--f6e0f26aeb2a4ead904f82626ede3ef4 6d807f5d99644dc7bad9991ac9f811e3 X f6e0f26aeb2a4ead904f82626ede3ef4--6d807f5d99644dc7bad9991ac9f811e3 6d807f5d99644dc7bad9991ac9f811e3--d540981345a6470aae77070807f1adc1 2d595c687a02463f9297983d9870acf4 Z 6d807f5d99644dc7bad9991ac9f811e3--2d595c687a02463f9297983d9870acf4 2d595c687a02463f9297983d9870acf4--2ffb78ab4d3f42588a200a35ec4fecab <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.6122]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.8583+0.0000j, 0.3487+0.0000j, 0.0000-0.3487j, 0.0000-0.1417j],\n        [0.9034+0.0000j, 0.2954+0.0000j, 0.0000-0.2954j, 0.0000-0.0966j],\n        [0.6968+0.0000j, 0.4597+0.0000j, 0.0000-0.4597j, 0.0000-0.3032j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 ddd4289519894cee9e8dd749d35de386 0 418bff578dd54ab6a823bb71b8eee4ae RX(theta\u2080) ddd4289519894cee9e8dd749d35de386--418bff578dd54ab6a823bb71b8eee4ae 3357ca8ae83c4da5a71641ac3357bcc5 1 674cd61f05e4445fa6440a9254a36f3d RY(theta\u2084) 418bff578dd54ab6a823bb71b8eee4ae--674cd61f05e4445fa6440a9254a36f3d 577026fafa5e40ad97d67794c38d4fef RX(theta\u2088) 674cd61f05e4445fa6440a9254a36f3d--577026fafa5e40ad97d67794c38d4fef cd2a48a7810549cd82a54c63def85b06 577026fafa5e40ad97d67794c38d4fef--cd2a48a7810549cd82a54c63def85b06 d704c7306f644a89ab3f019a7838beb9 cd2a48a7810549cd82a54c63def85b06--d704c7306f644a89ab3f019a7838beb9 34f42f0411694a749fb2cc61f10a1253 RX(theta\u2081\u2082) d704c7306f644a89ab3f019a7838beb9--34f42f0411694a749fb2cc61f10a1253 8aee06a85ab54e18b098224122190201 RY(theta\u2081\u2086) 34f42f0411694a749fb2cc61f10a1253--8aee06a85ab54e18b098224122190201 b262132757d949c087a2577f0e952494 RX(theta\u2082\u2080) 8aee06a85ab54e18b098224122190201--b262132757d949c087a2577f0e952494 5877440b9bf54733a32a6269b42291fb b262132757d949c087a2577f0e952494--5877440b9bf54733a32a6269b42291fb d752925e4cb4475ba38ca9529554d677 5877440b9bf54733a32a6269b42291fb--d752925e4cb4475ba38ca9529554d677 79059a8ccc8448289aa4a84ab315b2d2 d752925e4cb4475ba38ca9529554d677--79059a8ccc8448289aa4a84ab315b2d2 3f505daad9dc4a7993cf2b1945867b51 da90ffb1da1c4c3bbca98325caf9ce70 RX(theta\u2081) 3357ca8ae83c4da5a71641ac3357bcc5--da90ffb1da1c4c3bbca98325caf9ce70 74afd42b01a14604b6bbcf7d6332f429 2 f4a34e7088fc435bb32006c959af34d0 RY(theta\u2085) da90ffb1da1c4c3bbca98325caf9ce70--f4a34e7088fc435bb32006c959af34d0 e969825f62d04ecaa467833d72816db9 RX(theta\u2089) f4a34e7088fc435bb32006c959af34d0--e969825f62d04ecaa467833d72816db9 e8680879bc7e4ce8a8893dfa4df76c3c X e969825f62d04ecaa467833d72816db9--e8680879bc7e4ce8a8893dfa4df76c3c e8680879bc7e4ce8a8893dfa4df76c3c--cd2a48a7810549cd82a54c63def85b06 3205ea0708a546309c98deb094315dfb e8680879bc7e4ce8a8893dfa4df76c3c--3205ea0708a546309c98deb094315dfb 55bea6e0c5f24e2982bad704baf232c2 RX(theta\u2081\u2083) 3205ea0708a546309c98deb094315dfb--55bea6e0c5f24e2982bad704baf232c2 b33f4dd602444d63a911a8bd0211a423 RY(theta\u2081\u2087) 55bea6e0c5f24e2982bad704baf232c2--b33f4dd602444d63a911a8bd0211a423 086a3179d794424abed0254726ac9b7d RX(theta\u2082\u2081) b33f4dd602444d63a911a8bd0211a423--086a3179d794424abed0254726ac9b7d 3e6cc5c5511047c0abe84b7112504938 X 086a3179d794424abed0254726ac9b7d--3e6cc5c5511047c0abe84b7112504938 3e6cc5c5511047c0abe84b7112504938--5877440b9bf54733a32a6269b42291fb 8ae0adad1f514c629518dba3a89dd2e4 3e6cc5c5511047c0abe84b7112504938--8ae0adad1f514c629518dba3a89dd2e4 8ae0adad1f514c629518dba3a89dd2e4--3f505daad9dc4a7993cf2b1945867b51 01a94fc6a48c4b1bb0e37834077aaf15 11dcbdb87c1d4d1a931269bf1b65954c RX(theta\u2082) 74afd42b01a14604b6bbcf7d6332f429--11dcbdb87c1d4d1a931269bf1b65954c 5d9b08f329014c4bbc09b4914b6320c7 3 39b42c5bd1a748dfa85011c7d547e39c RY(theta\u2086) 11dcbdb87c1d4d1a931269bf1b65954c--39b42c5bd1a748dfa85011c7d547e39c 40d9ed02ef9546dba95da1a51cf10e21 RX(theta\u2081\u2080) 39b42c5bd1a748dfa85011c7d547e39c--40d9ed02ef9546dba95da1a51cf10e21 94c67d3520624d4eabf4d61270faf92f 40d9ed02ef9546dba95da1a51cf10e21--94c67d3520624d4eabf4d61270faf92f ab37ff7b52d94576aa1cba18abe9c78f X 94c67d3520624d4eabf4d61270faf92f--ab37ff7b52d94576aa1cba18abe9c78f ab37ff7b52d94576aa1cba18abe9c78f--3205ea0708a546309c98deb094315dfb 74527da4f7034bfbb4d50259bc174732 RX(theta\u2081\u2084) ab37ff7b52d94576aa1cba18abe9c78f--74527da4f7034bfbb4d50259bc174732 27c5b9e903194662b85bd526291fff5f RY(theta\u2081\u2088) 74527da4f7034bfbb4d50259bc174732--27c5b9e903194662b85bd526291fff5f 4560c06931d74568b6192d0cbae728d1 RX(theta\u2082\u2082) 27c5b9e903194662b85bd526291fff5f--4560c06931d74568b6192d0cbae728d1 458b3db303bd4931a2437122ac8d3607 4560c06931d74568b6192d0cbae728d1--458b3db303bd4931a2437122ac8d3607 bf2d0e88cc0341128e7b6bc902103795 X 458b3db303bd4931a2437122ac8d3607--bf2d0e88cc0341128e7b6bc902103795 bf2d0e88cc0341128e7b6bc902103795--8ae0adad1f514c629518dba3a89dd2e4 bf2d0e88cc0341128e7b6bc902103795--01a94fc6a48c4b1bb0e37834077aaf15 fd7a760bde7d418bb1ea2c3d3b9be843 18db448e39d4432e934ff38e7170d8fc RX(theta\u2083) 5d9b08f329014c4bbc09b4914b6320c7--18db448e39d4432e934ff38e7170d8fc 483899303d3e424689d7da8ce7167d1f RY(theta\u2087) 18db448e39d4432e934ff38e7170d8fc--483899303d3e424689d7da8ce7167d1f f43a7cb4061f46fdb3b0db63cd5df5fa RX(theta\u2081\u2081) 483899303d3e424689d7da8ce7167d1f--f43a7cb4061f46fdb3b0db63cd5df5fa 805016d7ca194b438fd8437ff16f3e0e X f43a7cb4061f46fdb3b0db63cd5df5fa--805016d7ca194b438fd8437ff16f3e0e 805016d7ca194b438fd8437ff16f3e0e--94c67d3520624d4eabf4d61270faf92f 80d331c9260d456a923823f6623eaeea 805016d7ca194b438fd8437ff16f3e0e--80d331c9260d456a923823f6623eaeea 073803ab085647e7b0580f17a46ef619 RX(theta\u2081\u2085) 80d331c9260d456a923823f6623eaeea--073803ab085647e7b0580f17a46ef619 049ad9725e324194844e7ecd18bd94ed RY(theta\u2081\u2089) 073803ab085647e7b0580f17a46ef619--049ad9725e324194844e7ecd18bd94ed 8a56967f95a9481e88f1afa21c1e7c04 RX(theta\u2082\u2083) 049ad9725e324194844e7ecd18bd94ed--8a56967f95a9481e88f1afa21c1e7c04 d39fc4ad363744f99ccbf7ff23fa1084 X 8a56967f95a9481e88f1afa21c1e7c04--d39fc4ad363744f99ccbf7ff23fa1084 d39fc4ad363744f99ccbf7ff23fa1084--458b3db303bd4931a2437122ac8d3607 594b46eb03a1405eb538f0b0a9fc5646 d39fc4ad363744f99ccbf7ff23fa1084--594b46eb03a1405eb538f0b0a9fc5646 594b46eb03a1405eb538f0b0a9fc5646--fd7a760bde7d418bb1ea2c3d3b9be843 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_de4536714c7e48cfa98f006f7f061345 HEA cluster_100b443537d548c48b6d25ee96c6398f HEA 85c94ceec13b4b01ac1204dabd1980ef 0 7a916c92c6b148729ec0779714d1586f RX(theta\u2080) 85c94ceec13b4b01ac1204dabd1980ef--7a916c92c6b148729ec0779714d1586f 4bb6c2fbcfaa4d2086ba492b2f7e13be 1 2d1bf2076e964d11b94b9ea885be990d RY(theta\u2084) 7a916c92c6b148729ec0779714d1586f--2d1bf2076e964d11b94b9ea885be990d f050478e69da4b29abce6a98cd346e1b RX(theta\u2088) 2d1bf2076e964d11b94b9ea885be990d--f050478e69da4b29abce6a98cd346e1b 256bfc78f0a54c0ab727450755387519 f050478e69da4b29abce6a98cd346e1b--256bfc78f0a54c0ab727450755387519 d5e0e368626c4a7eb7a7f2cf21050870 256bfc78f0a54c0ab727450755387519--d5e0e368626c4a7eb7a7f2cf21050870 f4a6b31e381b4319a8d9fb411129068a RX(theta\u2081\u2082) d5e0e368626c4a7eb7a7f2cf21050870--f4a6b31e381b4319a8d9fb411129068a 0753ce5197b74c46865ff872e65bdda5 RY(theta\u2081\u2086) f4a6b31e381b4319a8d9fb411129068a--0753ce5197b74c46865ff872e65bdda5 ac86d803345f4a8b90efb90ccc1fe4e8 RX(theta\u2082\u2080) 0753ce5197b74c46865ff872e65bdda5--ac86d803345f4a8b90efb90ccc1fe4e8 1e9d1ce71c164b10864840c5152c9eb8 ac86d803345f4a8b90efb90ccc1fe4e8--1e9d1ce71c164b10864840c5152c9eb8 6bf3aac8185046f98d513ca04baa1223 1e9d1ce71c164b10864840c5152c9eb8--6bf3aac8185046f98d513ca04baa1223 726e0d52de4843b39301c3027fcc4932 RX(theta\u2080) 6bf3aac8185046f98d513ca04baa1223--726e0d52de4843b39301c3027fcc4932 82eb1dfd469b4022ada24af2fb02e012 RY(theta\u2084) 726e0d52de4843b39301c3027fcc4932--82eb1dfd469b4022ada24af2fb02e012 2beb92cd64f84962be2a35d903fba9ae RX(theta\u2088) 82eb1dfd469b4022ada24af2fb02e012--2beb92cd64f84962be2a35d903fba9ae 4e848ee16f7d45c88f1a9f650fd1eef3 2beb92cd64f84962be2a35d903fba9ae--4e848ee16f7d45c88f1a9f650fd1eef3 132b6cb77ab94cc8a5fbdab2083e59d3 4e848ee16f7d45c88f1a9f650fd1eef3--132b6cb77ab94cc8a5fbdab2083e59d3 09cc58aa5e9d4f8080afbad2f17ef0c8 RX(theta\u2081\u2082) 132b6cb77ab94cc8a5fbdab2083e59d3--09cc58aa5e9d4f8080afbad2f17ef0c8 94d4fee1ebf24c94a5d8bf8dcb0393b7 RY(theta\u2081\u2086) 09cc58aa5e9d4f8080afbad2f17ef0c8--94d4fee1ebf24c94a5d8bf8dcb0393b7 ecaf451b32bf49c2b1c9304ed0b8438e RX(theta\u2082\u2080) 94d4fee1ebf24c94a5d8bf8dcb0393b7--ecaf451b32bf49c2b1c9304ed0b8438e 05bb2c9f8a65496a8b6ee1acaa438e6b ecaf451b32bf49c2b1c9304ed0b8438e--05bb2c9f8a65496a8b6ee1acaa438e6b 79666b978a2a4a0c99df0657df9ae71e 05bb2c9f8a65496a8b6ee1acaa438e6b--79666b978a2a4a0c99df0657df9ae71e 5374948214d24a0991adee4be3ab1319 79666b978a2a4a0c99df0657df9ae71e--5374948214d24a0991adee4be3ab1319 830396d826f14448a3e41a43df373ccb 42cddec7dadf448094378bdc667749ee RX(theta\u2081) 4bb6c2fbcfaa4d2086ba492b2f7e13be--42cddec7dadf448094378bdc667749ee 461ccefecc6f434196ac00359a17fd9c 2 533669443f164bb4ac2a95b399bcf209 RY(theta\u2085) 42cddec7dadf448094378bdc667749ee--533669443f164bb4ac2a95b399bcf209 2a4e54b73d7f4693a44b0ce6e04f9912 RX(theta\u2089) 533669443f164bb4ac2a95b399bcf209--2a4e54b73d7f4693a44b0ce6e04f9912 b7dc3d2b0f0748c3bed82ce1e6727012 X 2a4e54b73d7f4693a44b0ce6e04f9912--b7dc3d2b0f0748c3bed82ce1e6727012 b7dc3d2b0f0748c3bed82ce1e6727012--256bfc78f0a54c0ab727450755387519 8a81bd9cab90460880bc42acfe0caaec b7dc3d2b0f0748c3bed82ce1e6727012--8a81bd9cab90460880bc42acfe0caaec 376154f6042e4bf69451e13b525ac4ae RX(theta\u2081\u2083) 8a81bd9cab90460880bc42acfe0caaec--376154f6042e4bf69451e13b525ac4ae 6a75e9420c02409ca65f04d4e10913ad RY(theta\u2081\u2087) 376154f6042e4bf69451e13b525ac4ae--6a75e9420c02409ca65f04d4e10913ad df9557c5a43d40b998e4f4880af17d62 RX(theta\u2082\u2081) 6a75e9420c02409ca65f04d4e10913ad--df9557c5a43d40b998e4f4880af17d62 70c48c4a1be74a2cb5cbfd4c70942936 X df9557c5a43d40b998e4f4880af17d62--70c48c4a1be74a2cb5cbfd4c70942936 70c48c4a1be74a2cb5cbfd4c70942936--1e9d1ce71c164b10864840c5152c9eb8 58be7c55c12d47089df4846b1ec0fe4c 70c48c4a1be74a2cb5cbfd4c70942936--58be7c55c12d47089df4846b1ec0fe4c f454d0bf7f974ca1831cb92585a3fa24 RX(theta\u2081) 58be7c55c12d47089df4846b1ec0fe4c--f454d0bf7f974ca1831cb92585a3fa24 d3d07770edd548b3b93d5025e7a0fdeb RY(theta\u2085) f454d0bf7f974ca1831cb92585a3fa24--d3d07770edd548b3b93d5025e7a0fdeb b3826ed3b3764ec18e2eae58521d3039 RX(theta\u2089) d3d07770edd548b3b93d5025e7a0fdeb--b3826ed3b3764ec18e2eae58521d3039 74b9f8f59c2a4cca8676f37eabc74d65 X b3826ed3b3764ec18e2eae58521d3039--74b9f8f59c2a4cca8676f37eabc74d65 74b9f8f59c2a4cca8676f37eabc74d65--4e848ee16f7d45c88f1a9f650fd1eef3 284870795f1a4ca787fc36ef92c78cf4 74b9f8f59c2a4cca8676f37eabc74d65--284870795f1a4ca787fc36ef92c78cf4 c5c615adb1a24e5baabfb9dd66f09dd1 RX(theta\u2081\u2083) 284870795f1a4ca787fc36ef92c78cf4--c5c615adb1a24e5baabfb9dd66f09dd1 194b510163294a39905788c794206445 RY(theta\u2081\u2087) c5c615adb1a24e5baabfb9dd66f09dd1--194b510163294a39905788c794206445 b535aae6766648c08d83ccc2203e06f7 RX(theta\u2082\u2081) 194b510163294a39905788c794206445--b535aae6766648c08d83ccc2203e06f7 e5f616394239408cbbe2674e516a5431 X b535aae6766648c08d83ccc2203e06f7--e5f616394239408cbbe2674e516a5431 e5f616394239408cbbe2674e516a5431--05bb2c9f8a65496a8b6ee1acaa438e6b afbcdee80dc045d5b1b27cec3772493f e5f616394239408cbbe2674e516a5431--afbcdee80dc045d5b1b27cec3772493f afbcdee80dc045d5b1b27cec3772493f--830396d826f14448a3e41a43df373ccb 02bf015066164c78866c97c3342b4a18 213c21d86b034a26a66e18865e7c105b RX(theta\u2082) 461ccefecc6f434196ac00359a17fd9c--213c21d86b034a26a66e18865e7c105b b61159332a234e01b7e4cca1bb2e5487 3 2ed15cfa12aa4dd681fc54ee14f5c6c8 RY(theta\u2086) 213c21d86b034a26a66e18865e7c105b--2ed15cfa12aa4dd681fc54ee14f5c6c8 9354adae048f497b8d46a33b74eb3513 RX(theta\u2081\u2080) 2ed15cfa12aa4dd681fc54ee14f5c6c8--9354adae048f497b8d46a33b74eb3513 d56cd195a6064904bdd47deddbec3257 9354adae048f497b8d46a33b74eb3513--d56cd195a6064904bdd47deddbec3257 11b23e3ce7f04fca90b56861c17b5d1a X d56cd195a6064904bdd47deddbec3257--11b23e3ce7f04fca90b56861c17b5d1a 11b23e3ce7f04fca90b56861c17b5d1a--8a81bd9cab90460880bc42acfe0caaec 8953b27e7e2d48a9a6fbe2391c477f95 RX(theta\u2081\u2084) 11b23e3ce7f04fca90b56861c17b5d1a--8953b27e7e2d48a9a6fbe2391c477f95 b7ebc7999392492aa303b34730e01c2f RY(theta\u2081\u2088) 8953b27e7e2d48a9a6fbe2391c477f95--b7ebc7999392492aa303b34730e01c2f 0d9be2e42dcb4fb49ee9d667988602cf RX(theta\u2082\u2082) b7ebc7999392492aa303b34730e01c2f--0d9be2e42dcb4fb49ee9d667988602cf 8c4dd38fe8b842e7a5a38098346a596b 0d9be2e42dcb4fb49ee9d667988602cf--8c4dd38fe8b842e7a5a38098346a596b eeb0f4f081864c8a89c538ab2573d4a5 X 8c4dd38fe8b842e7a5a38098346a596b--eeb0f4f081864c8a89c538ab2573d4a5 eeb0f4f081864c8a89c538ab2573d4a5--58be7c55c12d47089df4846b1ec0fe4c 25a44396cc9e4c41a02a3e4c657ebd53 RX(theta\u2082) eeb0f4f081864c8a89c538ab2573d4a5--25a44396cc9e4c41a02a3e4c657ebd53 230ea43f65fe4395bd9a53d95816c5d1 RY(theta\u2086) 25a44396cc9e4c41a02a3e4c657ebd53--230ea43f65fe4395bd9a53d95816c5d1 705acf68e03449b19247cf1f02e29da1 RX(theta\u2081\u2080) 230ea43f65fe4395bd9a53d95816c5d1--705acf68e03449b19247cf1f02e29da1 7149959237de4be696e199e3dfa1f567 705acf68e03449b19247cf1f02e29da1--7149959237de4be696e199e3dfa1f567 17660eec0c754e66a33ffa7c04ab2dd9 X 7149959237de4be696e199e3dfa1f567--17660eec0c754e66a33ffa7c04ab2dd9 17660eec0c754e66a33ffa7c04ab2dd9--284870795f1a4ca787fc36ef92c78cf4 61cbb324c1c84ad4bc5cf24096dbe267 RX(theta\u2081\u2084) 17660eec0c754e66a33ffa7c04ab2dd9--61cbb324c1c84ad4bc5cf24096dbe267 ece876f6fa4b4b38af49bb016999b27d RY(theta\u2081\u2088) 61cbb324c1c84ad4bc5cf24096dbe267--ece876f6fa4b4b38af49bb016999b27d a174ad1b88c54b42aa490f07f25b7f9e RX(theta\u2082\u2082) ece876f6fa4b4b38af49bb016999b27d--a174ad1b88c54b42aa490f07f25b7f9e 9398ad0a53e5496bad33a21fc7df5035 a174ad1b88c54b42aa490f07f25b7f9e--9398ad0a53e5496bad33a21fc7df5035 9e11adf0943d4d87af4363f04be5d61c X 9398ad0a53e5496bad33a21fc7df5035--9e11adf0943d4d87af4363f04be5d61c 9e11adf0943d4d87af4363f04be5d61c--afbcdee80dc045d5b1b27cec3772493f 9e11adf0943d4d87af4363f04be5d61c--02bf015066164c78866c97c3342b4a18 ddda53e2f8944942b0f77800452ae90a 16389e4f45934027bb6f4f495340e122 RX(theta\u2083) b61159332a234e01b7e4cca1bb2e5487--16389e4f45934027bb6f4f495340e122 6652b018553946bebd5297b6d0093222 RY(theta\u2087) 16389e4f45934027bb6f4f495340e122--6652b018553946bebd5297b6d0093222 ae979ca444fe424692ceba8f8852b50d RX(theta\u2081\u2081) 6652b018553946bebd5297b6d0093222--ae979ca444fe424692ceba8f8852b50d d0a9f0bbc45c4fac965ed5b041757c80 X ae979ca444fe424692ceba8f8852b50d--d0a9f0bbc45c4fac965ed5b041757c80 d0a9f0bbc45c4fac965ed5b041757c80--d56cd195a6064904bdd47deddbec3257 6b298c9a088c4e9c8c2b7fb87a61e40e d0a9f0bbc45c4fac965ed5b041757c80--6b298c9a088c4e9c8c2b7fb87a61e40e ac42a47bf21b4132a3e73a5e142b550e RX(theta\u2081\u2085) 6b298c9a088c4e9c8c2b7fb87a61e40e--ac42a47bf21b4132a3e73a5e142b550e a08c2bc3f4954be4b8d619617ba35862 RY(theta\u2081\u2089) ac42a47bf21b4132a3e73a5e142b550e--a08c2bc3f4954be4b8d619617ba35862 0f331fd4a2c9401bbd509ad3da41b214 RX(theta\u2082\u2083) a08c2bc3f4954be4b8d619617ba35862--0f331fd4a2c9401bbd509ad3da41b214 104e112aba1d4510b4df9de40824bfea X 0f331fd4a2c9401bbd509ad3da41b214--104e112aba1d4510b4df9de40824bfea 104e112aba1d4510b4df9de40824bfea--8c4dd38fe8b842e7a5a38098346a596b 5121a0501d20455cb02127efa745ac88 104e112aba1d4510b4df9de40824bfea--5121a0501d20455cb02127efa745ac88 0b9f92c960234eb79daa119b427db539 RX(theta\u2083) 5121a0501d20455cb02127efa745ac88--0b9f92c960234eb79daa119b427db539 1137ebb77bdc42238c281b1ff7e7f954 RY(theta\u2087) 0b9f92c960234eb79daa119b427db539--1137ebb77bdc42238c281b1ff7e7f954 4edf5ca2518e4d9c91b1442a577f9770 RX(theta\u2081\u2081) 1137ebb77bdc42238c281b1ff7e7f954--4edf5ca2518e4d9c91b1442a577f9770 5c099541a36e4acf9e4e73ae989863e5 X 4edf5ca2518e4d9c91b1442a577f9770--5c099541a36e4acf9e4e73ae989863e5 5c099541a36e4acf9e4e73ae989863e5--7149959237de4be696e199e3dfa1f567 bf55175f57674e0b95e1c96750613f22 5c099541a36e4acf9e4e73ae989863e5--bf55175f57674e0b95e1c96750613f22 8c4f2d6af6ac4b399a3a26f48369ba53 RX(theta\u2081\u2085) bf55175f57674e0b95e1c96750613f22--8c4f2d6af6ac4b399a3a26f48369ba53 d93fab496ad34044ac8fa31350130e5d RY(theta\u2081\u2089) 8c4f2d6af6ac4b399a3a26f48369ba53--d93fab496ad34044ac8fa31350130e5d fe0f4320c07a49f7abaf0b42439a2541 RX(theta\u2082\u2083) d93fab496ad34044ac8fa31350130e5d--fe0f4320c07a49f7abaf0b42439a2541 55be8dae684c476bb27e2aed4c271a5f X fe0f4320c07a49f7abaf0b42439a2541--55be8dae684c476bb27e2aed4c271a5f 55be8dae684c476bb27e2aed4c271a5f--9398ad0a53e5496bad33a21fc7df5035 257aa5e10ed54ceebb22febe474842fd 55be8dae684c476bb27e2aed4c271a5f--257aa5e10ed54ceebb22febe474842fd 257aa5e10ed54ceebb22febe474842fd--ddda53e2f8944942b0f77800452ae90a </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_8eb9a1035f7b476c99b903bbb5568413 HEA cluster_38b13d9955604a65bc2bbc69ee9a0ab7 HEA b5a789caed7f40e0ace5ea79f48938a2 0 3bc31cc2b29b44b6849cd6f1c1d4400e RX(p1\u2080) b5a789caed7f40e0ace5ea79f48938a2--3bc31cc2b29b44b6849cd6f1c1d4400e d5cd9c54b2204a2da5211bcdb63df9d2 1 59d3112afb7546069146e773d38265ea RY(p1\u2084) 3bc31cc2b29b44b6849cd6f1c1d4400e--59d3112afb7546069146e773d38265ea 991cf5534385450ca8d484df6f021086 RX(p1\u2088) 59d3112afb7546069146e773d38265ea--991cf5534385450ca8d484df6f021086 4c3dfd3595b64c4686548a31e84e1ea3 991cf5534385450ca8d484df6f021086--4c3dfd3595b64c4686548a31e84e1ea3 e30af62f13e44c298a7e1465f86c89df 4c3dfd3595b64c4686548a31e84e1ea3--e30af62f13e44c298a7e1465f86c89df f3e8e9cbdd7f456abc0d665f3a576f7f RX(p1\u2081\u2082) e30af62f13e44c298a7e1465f86c89df--f3e8e9cbdd7f456abc0d665f3a576f7f d8dd8285ddd74a2196fada2788150434 RY(p1\u2081\u2086) f3e8e9cbdd7f456abc0d665f3a576f7f--d8dd8285ddd74a2196fada2788150434 ce857fbfb3c247b7aeec72c48d77c8c9 RX(p1\u2082\u2080) d8dd8285ddd74a2196fada2788150434--ce857fbfb3c247b7aeec72c48d77c8c9 5e03f0ada9c2496c8f09e9650b4eae9d ce857fbfb3c247b7aeec72c48d77c8c9--5e03f0ada9c2496c8f09e9650b4eae9d be484f84b5b747bc84139fdf8e3de452 5e03f0ada9c2496c8f09e9650b4eae9d--be484f84b5b747bc84139fdf8e3de452 3967d02cc00f48ab85f6da6c8a01ec84 RX(p2\u2080) be484f84b5b747bc84139fdf8e3de452--3967d02cc00f48ab85f6da6c8a01ec84 0ef9f3874e434419a1ad90f3f5c6044e RY(p2\u2084) 3967d02cc00f48ab85f6da6c8a01ec84--0ef9f3874e434419a1ad90f3f5c6044e 938aa6bc1d384191afce39ef6a63ce5c RX(p2\u2088) 0ef9f3874e434419a1ad90f3f5c6044e--938aa6bc1d384191afce39ef6a63ce5c 060523327fbb431282d8bdaac481d826 938aa6bc1d384191afce39ef6a63ce5c--060523327fbb431282d8bdaac481d826 aeccf1e26a5a40169d8d3c052e9248d0 060523327fbb431282d8bdaac481d826--aeccf1e26a5a40169d8d3c052e9248d0 18e3f8584f21422b89261fe230860abf RX(p2\u2081\u2082) aeccf1e26a5a40169d8d3c052e9248d0--18e3f8584f21422b89261fe230860abf 348f784bcb984e21994023ce82c97940 RY(p2\u2081\u2086) 18e3f8584f21422b89261fe230860abf--348f784bcb984e21994023ce82c97940 4bdceed7b8bb4bc19d8349a18640a2ce RX(p2\u2082\u2080) 348f784bcb984e21994023ce82c97940--4bdceed7b8bb4bc19d8349a18640a2ce 264b14b8f9c8435ca5f3f48668d48d3c 4bdceed7b8bb4bc19d8349a18640a2ce--264b14b8f9c8435ca5f3f48668d48d3c 1ed287ec2ac745aabc677c29122d5c2c 264b14b8f9c8435ca5f3f48668d48d3c--1ed287ec2ac745aabc677c29122d5c2c e80a856408944479bec0815a5066e4e8 1ed287ec2ac745aabc677c29122d5c2c--e80a856408944479bec0815a5066e4e8 f6ff66e27cdc4419a47393480c777007 57f1b69efea841b699c39228136fcc41 RX(p1\u2081) d5cd9c54b2204a2da5211bcdb63df9d2--57f1b69efea841b699c39228136fcc41 06249adecebd4367ad21c09df8125617 2 a8928b7c11f144528386961d61fbcb4a RY(p1\u2085) 57f1b69efea841b699c39228136fcc41--a8928b7c11f144528386961d61fbcb4a d767b40381ea4c2f923049024af2b85d RX(p1\u2089) a8928b7c11f144528386961d61fbcb4a--d767b40381ea4c2f923049024af2b85d 5331a977dfd544dc94f326cc40c8f8b9 X d767b40381ea4c2f923049024af2b85d--5331a977dfd544dc94f326cc40c8f8b9 5331a977dfd544dc94f326cc40c8f8b9--4c3dfd3595b64c4686548a31e84e1ea3 4fb76a59f9664ebb858bba78ab6d1ea5 5331a977dfd544dc94f326cc40c8f8b9--4fb76a59f9664ebb858bba78ab6d1ea5 a5d5ce6a2c2d47f7b36e082a6463a867 RX(p1\u2081\u2083) 4fb76a59f9664ebb858bba78ab6d1ea5--a5d5ce6a2c2d47f7b36e082a6463a867 307a16eb69054774946d69a51080a99b RY(p1\u2081\u2087) a5d5ce6a2c2d47f7b36e082a6463a867--307a16eb69054774946d69a51080a99b 4fdeccfc90134c68b241c50e76d3df82 RX(p1\u2082\u2081) 307a16eb69054774946d69a51080a99b--4fdeccfc90134c68b241c50e76d3df82 4e222f496cb545f3af6837b8672c1557 X 4fdeccfc90134c68b241c50e76d3df82--4e222f496cb545f3af6837b8672c1557 4e222f496cb545f3af6837b8672c1557--5e03f0ada9c2496c8f09e9650b4eae9d e3721931c1d943d0b9e0ab4e10eac87e 4e222f496cb545f3af6837b8672c1557--e3721931c1d943d0b9e0ab4e10eac87e ffaf885da6364a5e88da20c2f445057d RX(p2\u2081) e3721931c1d943d0b9e0ab4e10eac87e--ffaf885da6364a5e88da20c2f445057d d966f83db5cd467e917e6e635d2f3880 RY(p2\u2085) ffaf885da6364a5e88da20c2f445057d--d966f83db5cd467e917e6e635d2f3880 155688270f57412bb8ada54471ebb617 RX(p2\u2089) d966f83db5cd467e917e6e635d2f3880--155688270f57412bb8ada54471ebb617 562329692b5849de92c8b0c35bd441f1 X 155688270f57412bb8ada54471ebb617--562329692b5849de92c8b0c35bd441f1 562329692b5849de92c8b0c35bd441f1--060523327fbb431282d8bdaac481d826 9822c5f7d2304ec0b80f9054aba53f0f 562329692b5849de92c8b0c35bd441f1--9822c5f7d2304ec0b80f9054aba53f0f 058ffe160c8b420599c65d9dc4f82545 RX(p2\u2081\u2083) 9822c5f7d2304ec0b80f9054aba53f0f--058ffe160c8b420599c65d9dc4f82545 4802b618552a4d34b373e9a68ba7f204 RY(p2\u2081\u2087) 058ffe160c8b420599c65d9dc4f82545--4802b618552a4d34b373e9a68ba7f204 367a9d3ba1914aed8a9677b44bbb4bc8 RX(p2\u2082\u2081) 4802b618552a4d34b373e9a68ba7f204--367a9d3ba1914aed8a9677b44bbb4bc8 f979e787755a4f93848cae9034551d7d X 367a9d3ba1914aed8a9677b44bbb4bc8--f979e787755a4f93848cae9034551d7d f979e787755a4f93848cae9034551d7d--264b14b8f9c8435ca5f3f48668d48d3c b11103f17bc944148f610f229b020591 f979e787755a4f93848cae9034551d7d--b11103f17bc944148f610f229b020591 b11103f17bc944148f610f229b020591--f6ff66e27cdc4419a47393480c777007 b841dbfbe3964a9b9686baf3eafffc86 168a99ca0b994a969dad78d0e31b3ee7 RX(p1\u2082) 06249adecebd4367ad21c09df8125617--168a99ca0b994a969dad78d0e31b3ee7 3fa0ff67739b4f4387b91e3fbab10d3f 3 363f779aaf90402b9aebe892f83957d4 RY(p1\u2086) 168a99ca0b994a969dad78d0e31b3ee7--363f779aaf90402b9aebe892f83957d4 74af1264545447eea39d001ebccf66a1 RX(p1\u2081\u2080) 363f779aaf90402b9aebe892f83957d4--74af1264545447eea39d001ebccf66a1 be774b88e3704eaab5ba8d9a0fd8b567 74af1264545447eea39d001ebccf66a1--be774b88e3704eaab5ba8d9a0fd8b567 7dea546841c54c4196d070e6d1cc3a92 X be774b88e3704eaab5ba8d9a0fd8b567--7dea546841c54c4196d070e6d1cc3a92 7dea546841c54c4196d070e6d1cc3a92--4fb76a59f9664ebb858bba78ab6d1ea5 0f85f01cec604ef7a9f5f2db6bf19e22 RX(p1\u2081\u2084) 7dea546841c54c4196d070e6d1cc3a92--0f85f01cec604ef7a9f5f2db6bf19e22 8d0b3eb070b94a3380801f95141fd96f RY(p1\u2081\u2088) 0f85f01cec604ef7a9f5f2db6bf19e22--8d0b3eb070b94a3380801f95141fd96f 128f415347b0438ca15ded7ead64d013 RX(p1\u2082\u2082) 8d0b3eb070b94a3380801f95141fd96f--128f415347b0438ca15ded7ead64d013 80f989db846945c6ad8b18d1541dd63f 128f415347b0438ca15ded7ead64d013--80f989db846945c6ad8b18d1541dd63f 9ef428284e25419b9c5535915df599fe X 80f989db846945c6ad8b18d1541dd63f--9ef428284e25419b9c5535915df599fe 9ef428284e25419b9c5535915df599fe--e3721931c1d943d0b9e0ab4e10eac87e c0bc2bd0b7fe4f5caa685b60def3c4d3 RX(p2\u2082) 9ef428284e25419b9c5535915df599fe--c0bc2bd0b7fe4f5caa685b60def3c4d3 d3e071f7ff4b4661abbebf6020c9a63c RY(p2\u2086) c0bc2bd0b7fe4f5caa685b60def3c4d3--d3e071f7ff4b4661abbebf6020c9a63c 3313f4d69ea2448fbbfbae5a4330c7d0 RX(p2\u2081\u2080) d3e071f7ff4b4661abbebf6020c9a63c--3313f4d69ea2448fbbfbae5a4330c7d0 afb12c8e8ace4b04a50f8426c783d10e 3313f4d69ea2448fbbfbae5a4330c7d0--afb12c8e8ace4b04a50f8426c783d10e a87612acbdcd48e9ac805830a076480c X afb12c8e8ace4b04a50f8426c783d10e--a87612acbdcd48e9ac805830a076480c a87612acbdcd48e9ac805830a076480c--9822c5f7d2304ec0b80f9054aba53f0f e11f39c104934284b07c175c6dbb40d8 RX(p2\u2081\u2084) a87612acbdcd48e9ac805830a076480c--e11f39c104934284b07c175c6dbb40d8 01fc580a557c45e6afdd8a593a33b20c RY(p2\u2081\u2088) e11f39c104934284b07c175c6dbb40d8--01fc580a557c45e6afdd8a593a33b20c f2961705eda440ddad6cf8e062478ffd RX(p2\u2082\u2082) 01fc580a557c45e6afdd8a593a33b20c--f2961705eda440ddad6cf8e062478ffd 1b5d2f64b8ca401699d2020b386b2f5d f2961705eda440ddad6cf8e062478ffd--1b5d2f64b8ca401699d2020b386b2f5d 0ce87cd0af7c4cb9a09164d04117fa57 X 1b5d2f64b8ca401699d2020b386b2f5d--0ce87cd0af7c4cb9a09164d04117fa57 0ce87cd0af7c4cb9a09164d04117fa57--b11103f17bc944148f610f229b020591 0ce87cd0af7c4cb9a09164d04117fa57--b841dbfbe3964a9b9686baf3eafffc86 fa74b54608624b47bf9c5cf41df796d1 636b8da2cfef4f408e41a2b0d510465d RX(p1\u2083) 3fa0ff67739b4f4387b91e3fbab10d3f--636b8da2cfef4f408e41a2b0d510465d f805dd41f38547fb97286e06412bd6c9 RY(p1\u2087) 636b8da2cfef4f408e41a2b0d510465d--f805dd41f38547fb97286e06412bd6c9 d6947bf2ba9044f0b24af1e06d6627a1 RX(p1\u2081\u2081) f805dd41f38547fb97286e06412bd6c9--d6947bf2ba9044f0b24af1e06d6627a1 7f2c22542b2c4e768769aed65c08ad1e X d6947bf2ba9044f0b24af1e06d6627a1--7f2c22542b2c4e768769aed65c08ad1e 7f2c22542b2c4e768769aed65c08ad1e--be774b88e3704eaab5ba8d9a0fd8b567 80421832369e46dcbd08b59d366dcfd1 7f2c22542b2c4e768769aed65c08ad1e--80421832369e46dcbd08b59d366dcfd1 5e4fb7d625f145fcaee8d084a1ebd141 RX(p1\u2081\u2085) 80421832369e46dcbd08b59d366dcfd1--5e4fb7d625f145fcaee8d084a1ebd141 5150a581299f4bf886f60f39cfe4ea0c RY(p1\u2081\u2089) 5e4fb7d625f145fcaee8d084a1ebd141--5150a581299f4bf886f60f39cfe4ea0c 4c51f67853934356bb531328a12a0a18 RX(p1\u2082\u2083) 5150a581299f4bf886f60f39cfe4ea0c--4c51f67853934356bb531328a12a0a18 2f81b4b2e9eb4407bbafb1769f354701 X 4c51f67853934356bb531328a12a0a18--2f81b4b2e9eb4407bbafb1769f354701 2f81b4b2e9eb4407bbafb1769f354701--80f989db846945c6ad8b18d1541dd63f 5a679d16e3e5426ea6d4eb3722b6dc5f 2f81b4b2e9eb4407bbafb1769f354701--5a679d16e3e5426ea6d4eb3722b6dc5f fcb85d88ee634823af6c18cd11ed6642 RX(p2\u2083) 5a679d16e3e5426ea6d4eb3722b6dc5f--fcb85d88ee634823af6c18cd11ed6642 36cfcb3fbd69416980409652d00d9917 RY(p2\u2087) fcb85d88ee634823af6c18cd11ed6642--36cfcb3fbd69416980409652d00d9917 2dfb3825e96844fda9ab668f01ac24bf RX(p2\u2081\u2081) 36cfcb3fbd69416980409652d00d9917--2dfb3825e96844fda9ab668f01ac24bf 3df43613593d433fa58238c9237fb22f X 2dfb3825e96844fda9ab668f01ac24bf--3df43613593d433fa58238c9237fb22f 3df43613593d433fa58238c9237fb22f--afb12c8e8ace4b04a50f8426c783d10e 5a30f9ccd3454e239fb4cd024019e2d7 3df43613593d433fa58238c9237fb22f--5a30f9ccd3454e239fb4cd024019e2d7 f5a8b39e48e743839bc3d1baa06d1d20 RX(p2\u2081\u2085) 5a30f9ccd3454e239fb4cd024019e2d7--f5a8b39e48e743839bc3d1baa06d1d20 65d32f741f9049c0b4c4d03c0dad4233 RY(p2\u2081\u2089) f5a8b39e48e743839bc3d1baa06d1d20--65d32f741f9049c0b4c4d03c0dad4233 84a086d2c4c44a3b8d63b78fef6b54aa RX(p2\u2082\u2083) 65d32f741f9049c0b4c4d03c0dad4233--84a086d2c4c44a3b8d63b78fef6b54aa af420f1a755d4c0e81cba115112ebe52 X 84a086d2c4c44a3b8d63b78fef6b54aa--af420f1a755d4c0e81cba115112ebe52 af420f1a755d4c0e81cba115112ebe52--1b5d2f64b8ca401699d2020b386b2f5d ac8437af5f394127a392d6dc92220d0f af420f1a755d4c0e81cba115112ebe52--ac8437af5f394127a392d6dc92220d0f ac8437af5f394127a392d6dc92220d0f--fa74b54608624b47bf9c5cf41df796d1 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.0855])), ('theta_0', tensor([0.5155])), ('theta_1', tensor([0.9281])), ('theta_10', tensor([0.9866])), ('theta_11', tensor([0.2450])), ('theta_12', tensor([0.4834])), ('theta_13', tensor([0.1215])), ('theta_14', tensor([0.0793])), ('theta_15', tensor([0.7420])), ('theta_16', tensor([0.6813])), ('theta_17', tensor([0.5558])), ('theta_18', tensor([0.9943])), ('theta_19', tensor([0.4941])), ('theta_2', tensor([0.8950])), ('theta_20', tensor([0.5997])), ('theta_21', tensor([0.0895])), ('theta_22', tensor([0.9110])), ('theta_23', tensor([0.1405])), ('theta_3', tensor([0.2954])), ('theta_4', tensor([0.5823])), ('theta_5', tensor([0.5412])), ('theta_6', tensor([0.5837])), ('theta_7', tensor([0.3800])), ('theta_8', tensor([0.2195])), ('theta_9', tensor([0.9872]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.0845])), ('theta_0', tensor([0.5145])), ('theta_1', tensor([0.9291])), ('theta_10', tensor([0.9876])), ('theta_11', tensor([0.2440])), ('theta_12', tensor([0.4844])), ('theta_13', tensor([0.1225])), ('theta_14', tensor([0.0803])), ('theta_15', tensor([0.7410])), ('theta_16', tensor([0.6803])), ('theta_17', tensor([0.5568])), ('theta_18', tensor([0.9933])), ('theta_19', tensor([0.4951])), ('theta_2', tensor([0.8960])), ('theta_20', tensor([0.6007])), ('theta_21', tensor([0.0905])), ('theta_22', tensor([0.9120])), ('theta_23', tensor([0.1395])), ('theta_3', tensor([0.2944])), ('theta_4', tensor([0.5833])), ('theta_5', tensor([0.5422])), ('theta_6', tensor([0.5827])), ('theta_7', tensor([0.3790])), ('theta_8', tensor([0.2205])), ('theta_9', tensor([0.9882]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 9.9885e-01+0.0000j,  0.0000e+00-0.0338j,  0.0000e+00-0.0338j,\n         -1.1468e-03+0.0000j],\n        [ 9.9919e-01+0.0000j,  0.0000e+00-0.0284j,  0.0000e+00-0.0284j,\n         -8.0882e-04+0.0000j],\n        [ 9.8061e-01+0.0000j,  0.0000e+00-0.1379j,  0.0000e+00-0.1379j,\n         -1.9395e-02+0.0000j]])\nxs = [Counter({'00': 100}), Counter({'00': 100}), Counter({'00': 97, '01': 2, '10': 1})]\nex = tensor([[0.9977],\n        [0.9984],\n        [0.9612]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9977, 0.9977],\n        [0.9984, 0.9984],\n        [0.9612, 0.9612]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-12-22T15:47:24.804504 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2023-12-22T15:47:25.130701 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'00': 55, '01': 45})]\nSample in little endian = [Counter({'00': 52, '10': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'00': 55, '10': 45})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 84, '01': 16})]\nOn Braket = [Counter({'00': 84, '01': 16})]\nOn Pulser = [Counter({'00': 82, '01': 18})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [ 0.95905179+0.07257001j -0.27299549-0.02065716j  0.        +0.j\n  0.        +0.j        ]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_0615399263254fd0bf594511bb28d775 Circuit block cluster_b11e0bda350a476eb40f65dd0a7adf83 Prep block 1ae58760d0364f13928e5d318ee1f349 0 ea597de6f2b640e9a26589a52086339d 1ae58760d0364f13928e5d318ee1f349--ea597de6f2b640e9a26589a52086339d f186f7dbca3948cc8172b9dd0809c2b7 1 e28a6fdf47904623b21072d1cd991278 RX(theta\u2080) ea597de6f2b640e9a26589a52086339d--e28a6fdf47904623b21072d1cd991278 8b457b8b7c504dff81bb91ce49737911 RY(theta\u2084) e28a6fdf47904623b21072d1cd991278--8b457b8b7c504dff81bb91ce49737911 50f2807f7d844c879400d6706c788dd0 RX(theta\u2088) 8b457b8b7c504dff81bb91ce49737911--50f2807f7d844c879400d6706c788dd0 919b4f92024b4a9ba23aa3702cb1d679 50f2807f7d844c879400d6706c788dd0--919b4f92024b4a9ba23aa3702cb1d679 028fecffd9a048fe91c560c1d978adcb 919b4f92024b4a9ba23aa3702cb1d679--028fecffd9a048fe91c560c1d978adcb 0e5acd3b8722437c9a09601e348bbcb8 RX(theta\u2081\u2082) 028fecffd9a048fe91c560c1d978adcb--0e5acd3b8722437c9a09601e348bbcb8 b0c1f13644494922b12a494f9c1f6b2c RY(theta\u2081\u2086) 0e5acd3b8722437c9a09601e348bbcb8--b0c1f13644494922b12a494f9c1f6b2c d0ee0ca39a9a4fa0a0066ff8fbd9f5d7 RX(theta\u2082\u2080) b0c1f13644494922b12a494f9c1f6b2c--d0ee0ca39a9a4fa0a0066ff8fbd9f5d7 d8a764b718e2433ca2c48b506dc3ac4e d0ee0ca39a9a4fa0a0066ff8fbd9f5d7--d8a764b718e2433ca2c48b506dc3ac4e 0ef5f2b7338d4aeea2dbc3ceaf800446 d8a764b718e2433ca2c48b506dc3ac4e--0ef5f2b7338d4aeea2dbc3ceaf800446 9266657de044454d86f85907a1cbfdc5 0ef5f2b7338d4aeea2dbc3ceaf800446--9266657de044454d86f85907a1cbfdc5 ea818eba22e34c7d9ce505d91e701f93 68f4c7c5d06a4aba90f1297f0df31d57 f186f7dbca3948cc8172b9dd0809c2b7--68f4c7c5d06a4aba90f1297f0df31d57 e826cdd4a8d54b77a1140311c1a384c5 2 408aecedcecb44d1851ea5ebeac39aee RX(theta\u2081) 68f4c7c5d06a4aba90f1297f0df31d57--408aecedcecb44d1851ea5ebeac39aee 440baeed7e9349939745144836d1cf7a RY(theta\u2085) 408aecedcecb44d1851ea5ebeac39aee--440baeed7e9349939745144836d1cf7a e928bb401205488b912845e67dfe7cf5 RX(theta\u2089) 440baeed7e9349939745144836d1cf7a--e928bb401205488b912845e67dfe7cf5 0684a1d8cd424bfc903f6b8fa55fb05b X e928bb401205488b912845e67dfe7cf5--0684a1d8cd424bfc903f6b8fa55fb05b 0684a1d8cd424bfc903f6b8fa55fb05b--919b4f92024b4a9ba23aa3702cb1d679 921ccbf6a04c4064a7fa56c95f03943e 0684a1d8cd424bfc903f6b8fa55fb05b--921ccbf6a04c4064a7fa56c95f03943e be3f174334a545ecacada5535904e5c1 RX(theta\u2081\u2083) 921ccbf6a04c4064a7fa56c95f03943e--be3f174334a545ecacada5535904e5c1 47e8ca249ab9429fa43a9c91c71078a3 RY(theta\u2081\u2087) be3f174334a545ecacada5535904e5c1--47e8ca249ab9429fa43a9c91c71078a3 c8d8efe6e8834e80b5e50337b517f04f RX(theta\u2082\u2081) 47e8ca249ab9429fa43a9c91c71078a3--c8d8efe6e8834e80b5e50337b517f04f b2097f5ff8e6483b88b65aaa9217f354 X c8d8efe6e8834e80b5e50337b517f04f--b2097f5ff8e6483b88b65aaa9217f354 b2097f5ff8e6483b88b65aaa9217f354--d8a764b718e2433ca2c48b506dc3ac4e af825a338c0c437d8d12de7ecfb3fd80 b2097f5ff8e6483b88b65aaa9217f354--af825a338c0c437d8d12de7ecfb3fd80 af825a338c0c437d8d12de7ecfb3fd80--ea818eba22e34c7d9ce505d91e701f93 e02ddccdef9a4faba3eb8e211c2f6296 f090a31aaab24f37a7ac11fb2e928264 e826cdd4a8d54b77a1140311c1a384c5--f090a31aaab24f37a7ac11fb2e928264 0f99cc5ce99c4a6ab8f8795fd078c1e7 3 08ba275a5f554b46aa92778e96747b4f RX(theta\u2082) f090a31aaab24f37a7ac11fb2e928264--08ba275a5f554b46aa92778e96747b4f eb853549e72143dfac18f0b64f71f321 RY(theta\u2086) 08ba275a5f554b46aa92778e96747b4f--eb853549e72143dfac18f0b64f71f321 0134dec0cc41486b90eb489ace35bd1c RX(theta\u2081\u2080) eb853549e72143dfac18f0b64f71f321--0134dec0cc41486b90eb489ace35bd1c 364ae636655e420588ee2d4f94c72a30 0134dec0cc41486b90eb489ace35bd1c--364ae636655e420588ee2d4f94c72a30 550d9e969f994a8dba7cbe5a561bfc19 X 364ae636655e420588ee2d4f94c72a30--550d9e969f994a8dba7cbe5a561bfc19 550d9e969f994a8dba7cbe5a561bfc19--921ccbf6a04c4064a7fa56c95f03943e 4a2c5fce062d4504823ba64725255bb8 RX(theta\u2081\u2084) 550d9e969f994a8dba7cbe5a561bfc19--4a2c5fce062d4504823ba64725255bb8 6f21efd1cea1403eb44d7b5b5a5a2e21 RY(theta\u2081\u2088) 4a2c5fce062d4504823ba64725255bb8--6f21efd1cea1403eb44d7b5b5a5a2e21 2dd68537f40b4d9c9802666cf6b929c7 RX(theta\u2082\u2082) 6f21efd1cea1403eb44d7b5b5a5a2e21--2dd68537f40b4d9c9802666cf6b929c7 4e2a1cd8744946e196113f93aa7f006b 2dd68537f40b4d9c9802666cf6b929c7--4e2a1cd8744946e196113f93aa7f006b 1a73a48f68734774a1ca8e2cc17cd3d3 X 4e2a1cd8744946e196113f93aa7f006b--1a73a48f68734774a1ca8e2cc17cd3d3 1a73a48f68734774a1ca8e2cc17cd3d3--af825a338c0c437d8d12de7ecfb3fd80 1a73a48f68734774a1ca8e2cc17cd3d3--e02ddccdef9a4faba3eb8e211c2f6296 866e7fbc25b1492d88e5744f620797b2 bc93b688325b4ba6be8cd11439f619f7 X 0f99cc5ce99c4a6ab8f8795fd078c1e7--bc93b688325b4ba6be8cd11439f619f7 892c675e4b6a401ab275eed57414b482 RX(theta\u2083) bc93b688325b4ba6be8cd11439f619f7--892c675e4b6a401ab275eed57414b482 fb9f87320eac4e51b886d3881dec82eb RY(theta\u2087) 892c675e4b6a401ab275eed57414b482--fb9f87320eac4e51b886d3881dec82eb bdbd982335d44194b71847c63535c2be RX(theta\u2081\u2081) fb9f87320eac4e51b886d3881dec82eb--bdbd982335d44194b71847c63535c2be 3f348c15435d413995b3d7cb30d1b62b X bdbd982335d44194b71847c63535c2be--3f348c15435d413995b3d7cb30d1b62b 3f348c15435d413995b3d7cb30d1b62b--364ae636655e420588ee2d4f94c72a30 6ea47e76e93f4d4a9d12e8488b3dad02 3f348c15435d413995b3d7cb30d1b62b--6ea47e76e93f4d4a9d12e8488b3dad02 fe1c99727d75445d91bf777e5859e5b3 RX(theta\u2081\u2085) 6ea47e76e93f4d4a9d12e8488b3dad02--fe1c99727d75445d91bf777e5859e5b3 5d5d0a611f374f17974696098dbd7a23 RY(theta\u2081\u2089) fe1c99727d75445d91bf777e5859e5b3--5d5d0a611f374f17974696098dbd7a23 0192f760e7744a7184e3aaf5a053a922 RX(theta\u2082\u2083) 5d5d0a611f374f17974696098dbd7a23--0192f760e7744a7184e3aaf5a053a922 a820c08ae09e46c8b002858b46dc043f X 0192f760e7744a7184e3aaf5a053a922--a820c08ae09e46c8b002858b46dc043f a820c08ae09e46c8b002858b46dc043f--4e2a1cd8744946e196113f93aa7f006b 5b5d4add046e4f929af6b63e988c3c03 a820c08ae09e46c8b002858b46dc043f--5b5d4add046e4f929af6b63e988c3c03 5b5d4add046e4f929af6b63e988c3c03--866e7fbc25b1492d88e5744f620797b2  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[ 0.4778-0.3032j, -0.2188+0.0063j, -0.5854+0.1054j, -0.0209+0.1171j,\n         -0.1233+0.1146j,  0.2949-0.1529j,  0.2178+0.2514j,  0.0053+0.1206j],\n        [ 0.0060+0.1147j,  0.1033+0.1432j, -0.2309+0.3088j, -0.2681+0.2402j,\n         -0.2283-0.2065j, -0.4066+0.1532j, -0.5098-0.1379j,  0.2512-0.2275j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}