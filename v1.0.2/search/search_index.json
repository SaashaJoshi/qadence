{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interation until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\nreturn 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n# Global analog RX block.\nblock = AnalogRX(pi)\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])  # Dimensionless.\nsamples = sample(register, block)\n# Interacting qubits as close together.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 45, '01': 27, '10': 27, '11': 1})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock | None = None,\nbackend: BackendName | str = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize a generic QuantumModel instance.\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        protocol: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\nsuper().__init__()\nif not isinstance(circuit, QuantumCircuit):\nTypeError(\nf\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n)\nself.inputs = [p for p in circuit.unique_parameters if not p.trainable and not p.is_number]\nif diff_mode is None:\nraise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\nself.backend = backend_factory(\nbackend=backend, diff_mode=diff_mode, configuration=configuration\n)\nif isinstance(observable, list) or observable is None:\nobservable = observable\nelse:\nobservable = [observable]\nconv = self.backend.convert(circuit, observable)\nself.embedding_fn = conv.embedding_fn\nself._circuit = conv.circuit\nself._observable = conv.observable\nself._backend_name = backend\nself._diff_mode = diff_mode\nself._protocol = protocol\nself._params = nn.ParameterDict(\n{\nstr(key): nn.Parameter(val, requires_grad=val.requires_grad)\nfor key, val in conv.params.items()\n}\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code></p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n\"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`\"\"\"\nparams = self.embedding_fn(self._params, values)\nreturn self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\nself,\nvalues: dict[str, Tensor] = {},\nobservable: list[ConvertedObservable] | ConvertedObservable | None = None,\nstate: Optional[Tensor] = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute expectation using the given backend.\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\nif observable is None:\nif self._observable is None:\nraise ValueError(\n\"Provide an AbstractBlock as the observable to compute expectation.\"\n\"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n\"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n)\nobservable = self._observable\nparams = self.embedding_fn(self._params, values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.backend.expectation(\ncircuit=self._circuit,\nobservable=observable,\nparam_values=params,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n\"\"\"Reset all the variational parameters with a given list of values\"\"\"\ncurrent_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\nassert (\nlen(values) == self.num_vparams\n), \"Pass an iterable with the values of all variational parameters\"\nfor i, k in enumerate(current_vparams.keys()):\ncurrent_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN\nfrom qadence import hea, feature_map, hamiltonian_factory, Z\n# create the circuit\nn_qubits, depth = 2, 4\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning = Z)\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n# initialize and use the model\nqnn = QNN(circuit, obs, diff_mode=\"ad\", backend=\"pyqtorch\")\ny = qnn.expectation({\"phi\": torch.rand(3)})\n</code></pre> <pre><code>tensor([[0.7110, 1.4221],\n[1.6172, 3.2344],\n[1.1616, 2.3231]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock,\ntransform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize the QNN\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        protocol: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        configuration: optional configuration for the backend\n    \"\"\"\nsuper().__init__(\ncircuit=circuit,\nobservable=observable,\nbackend=backend,\ndiff_mode=diff_mode,\nprotocol=protocol,\nconfiguration=configuration,\n)\nif self.out_features is None:\nraise ValueError(\"You need to provide at least one observable in the QNN constructor\")\nself.transform = transform if transform else lambda x: x\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\nself,\nvalues: dict[str, Tensor] | Tensor = None,\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Forward pass of the model\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n    Args:\n        values (dict[str, Tensor] | Tensor): the values of the feature parameters\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\nif values is None:\nvalues = {}\nif not isinstance(values, dict):\nvalues = self._format_to_dict(values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.transform(\nself.expectation(values=values, state=state, protocol=protocol, endianness=endianness)\n)\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\nclass CustomQuantumModel(QuantumModel):\ndef __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\nsuper().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\nself.n_qubits = circuit.n_qubits\n# define some additional parameters which will scale and shift (variationally) the\n# output of the QuantumModel\n# you can use all torch machinery for building those\nself.scale_out = torch.nn.Parameter(torch.ones(1))\nself.shift_out = torch.nn.Parameter(torch.ones(1))\n# override the forward pass of the model\n# the forward pass is the output of your QuantumModel and in this case\n# it's the (scaled) expectation value of the total magnetization with\n# a variable coefficient in front\ndef forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n# scale the observable\nres = self.expectation(values)\n# scale and shift the result before returning\nreturn self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\ndef quantum_circuit(n_qubits):\nx = Parameter(\"x\", trainable=False)\nfm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\nansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\nansatz = chain(ansatz, CNOT(0, n_qubits-1))\nblock = chain(fm, ansatz)\nblock.tag = \"circuit\"\nreturn QuantumCircuit(n_qubits, block)\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 1.0910],\n[-0.3106],\n[-0.0326],\n[-0.2145],\n[-0.1543],\n[-0.5374],\n[-0.5529],\n[-0.0691],\n[-0.0888],\n[-0.4947]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\ndef __init__(\nself,\ntrain_circuit: QuantumCircuit,\ntarget_circuit: QuantumCircuit,\nbackend=\"pyqtorch\",\n):\nsuper().__init__(circuit=train_circuit, backend=backend)\nself.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\ndef forward(self):\nreturn self.overlap_fn()\n# compute the wavefunction of the associated train circuit\ndef wavefunction(self):\nreturn model.overlap_fn.run({})\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\nmodel = LearnHadamard(train_circuit, target_circuit)\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.5337]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\nloss = criterion(torch.tensor([[1.0]]), model())\nreturn loss, {}\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\nmodel, None, optimizer, config, loss_fn=loss_fn\n)\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\nhamiltonian_factory, QuantumCircuit,\nQuantumModel, BackendName, DiffMode)\nimport torch\nn_qubits = 2\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.GPSR)\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\nexp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\nexp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\nexp_val_ad.detach().numpy(),\nlabel=\"f(x)\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_ad.detach().numpy(),\nlabel=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_gpsr.detach().numpy(),\ns=5,\nlabel=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-10-17T16:39:31.486267 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n\"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n\"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend\n    representation.\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting samples.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run a circuit and return the resulting wave function.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting samples.\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1000,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bit strings.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n\"\"\"Return as a string the available fields with types of the configuration\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\nconf_msg = \"\"\nfor field in fields(self):\nif not field.name.startswith(\"_\"):\nconf_msg += (\nf\"Name: {field.name} - Type: {field.type} - Default value: {field.default}\\n\"\n)\nreturn conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend. Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n\"\"\"Return parameter names for the current backend. Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\"\"\"\nparam_ids: Tuple\n# FIXME: better type hiearchy?\ntypes = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\nif not isinstance(blk, types):\nraise TypeError(f\"Can not infer param name from {type(blk)}\")\nelse:\nif self._use_gate_params:\nparam_ids = tuple(blk.parameters.uuids())\nelse:\nparam_ids = tuple(map(stringify, blk.parameters.expressions()))\nreturn param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\nself, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n\"\"\"Assign numerical values to the circuit parameters\"\"\"\nif param_values is None:\nreturn circuit.native()\nparams_copy = param_values.copy()\npnames = [p.name for p in circuit.native.parameters]\n# account for fixed parameters\nfor name in param_values.keys():\nif name not in pnames:\nparams_copy.pop(name)\n# make sure that all the parameters are single floats\n# otherwise it won't be accepted by Braket\nnative_params = promote_parameters(params_copy)\n# assign the parameters to the circuit\nassigned_circuit = circuit.native(**native_params)\nreturn assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return a wavefunction in form of a statevector.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Parameters of the circuit (after calling the embedding function on the user-facing parameters).</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The endianness of the wave function.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"\n    Execute the circuit and return a wavefunction in form of a statevector.\n    Arguments:\n        circuit: The circuit that is executed.\n        param_values: Parameters of the circuit (after calling the embedding\n            function on the user-facing parameters).\n        state: Initial state.\n        endianness: The endianness of the wave function.\n    \"\"\"\nif state is not None:\nraise NotImplementedError\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nresults = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\nfinal_circuit.state_vector()  # set simulation type\ntask = self._device.run(final_circuit, 0)\nresults.append(task.result().values[0])\nstates = torch.tensor(np.array(results))\nn_qubits = circuit.abstract.n_qubits\nif endianness != self.native_endianness and n_qubits &gt; 1:\nfrom qadence.transpile import invert_endianness\nstates = invert_endianness(states)\nreturn states\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\nif state is not None:\nraise NotImplementedError(\"Braket cannot handle a custom initial state.\")\nif n_shots &lt; 1:\nraise ValueError(\"You can only call sample with n_shots&gt;0.\")\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nsamples = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\ntask = self._device.run(final_circuit, n_shots)\nsamples.append(task.result().measurement_counts)\nif endianness != self.native_endianness:\nfrom qadence.transpile import invert_endianness\nsamples = invert_endianness(samples)\nreturn samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>Module</code></p> <p>A class to abstract the operations done by the autodiff engine</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def __init__(\nself,\nbackend: QuantumBackend,\ndiff_mode: DiffMode = DiffMode.AD,\n**psr_args: int | float | None,\n) -&gt; None:\nsuper().__init__()\nself.backend = backend\nself.diff_mode = diff_mode\nself.psr_args = psr_args\n# TODO: Add differentiable overlap calculation\nself._overlap: Callable = None  # type: ignore [assignment]\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of a given observable.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A backend native observable to compute the expectation value from.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>A dict of values for symbolic substitution.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>An initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>protocol</code> <p>A shot-based measurement protocol.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the state.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of expectation values.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of a given observable.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        observable: A backend native observable to compute the expectation value from.\n        param_values: A dict of values for symbolic substitution.\n        state: An initial state.\n        protocol: A shot-based measurement protocol.\n        endianness: Endianness of the state.\n    Returns:\n        A tensor of expectation values.\n    \"\"\"\nobservable = observable if isinstance(observable, list) else [observable]\ndifferentiable_expectation = DifferentiableExpectation(\nbackend=self.backend,\ncircuit=circuit,\nobservable=observable,\nparam_values=param_values,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\nif self.diff_mode == DiffMode.AD:\nexpectation = differentiable_expectation.ad\nelse:\ntry:\nfns = get_gpsr_fns()\npsr_fn = fns[self.diff_mode]\nexcept KeyError:\nraise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\nexpectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\nreturn expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Run on the underlying backend.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run on the underlying backend.\"\"\"\nreturn self.backend.run(\ncircuit=circuit, param_values=param_values, state=state, endianness=endianness\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.sample","title":"<code>sample(circuit, param_values, state=None, n_shots=1, endianness=Endianness.BIG)</code>","text":"<p>Sample bitstring from the registered circuit.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>The values of the parameters after embedding</p> <p> TYPE: <code>dict[str, Tensor]</code> </p> <code>n_shots</code> <p>The number of shots. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>An iterable with all the sampled bitstrings</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor],\nstate: Tensor | None = None,\nn_shots: int = 1,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bitstring from the registered circuit.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        param_values: The values of the parameters after embedding\n        n_shots: The number of shots. Defaults to 1.\n    Returns:\n        An iterable with all the sampled bitstrings\n    \"\"\"\nwith torch.no_grad():\nreturn self.backend.sample(\ncircuit=circuit,\nparam_values=param_values,\nstate=state,\nn_shots=n_shots,\nendianness=endianness,\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation","title":"<code>DifferentiableExpectation</code>  <code>dataclass</code>","text":"<p>A handler for differentiating expectation estimation using various engines.</p>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation.construct_rules","title":"<code>construct_rules(circuit, observable, psr_fn, **psr_args)</code>  <code>staticmethod</code>","text":"<p>Create a mapping between parameters and PSR functions.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>@staticmethod\ndef construct_rules(\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock],\npsr_fn: Callable,\n**psr_args: int | float | None,\n) -&gt; dict[str, Callable]:\n\"\"\"Create a mapping between parameters and PSR functions.\"\"\"\nuuid_to_eigs = uuid_to_eigen(circuit.block)\n# We currently rely on implicit ordering to match the PSR to the parameter,\n# because we want to cache PSRs.\nparam_to_psr = OrderedDict()\nfor param_id, eigenvalues in uuid_to_eigs.items():\nif eigenvalues is None:\nraise ValueError(\nf\"Eigenvalues are not defined for param_id {param_id}\\n\"\n# f\"of type {type(block)}.\\n\"\n\"PSR cannot be defined in that case.\"\n)\nparam_to_psr[param_id] = psr_fn(eigenvalues, **psr_args)\nfor obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\n# We need the embedded fixed params of the observable in the param_values dict\n# to be able to call expectation. Since torch backward requires\n# a list of param_ids and values of equal length, we need to pass them to PSR too.\n# Since they are constants their gradients are 0.\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\nreturn param_to_psr\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.PSRExpectation","title":"<code>PSRExpectation</code>","text":"<p>             Bases: <code>Function</code></p> <p>Overloads the PyTorch AD system to perform parameter shift rule on quantum circuits.</p>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register, spacing=DEFAULT_SPACING)</code>","text":"<p>Create Pulser register instance.</p> PARAMETER  DESCRIPTION <code>register</code> <p>graph representing a register with accompanying coordinate data</p> <p> TYPE: <code>Register</code> </p> <code>spacing</code> <p>distance between qubits in micrometers</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_SPACING</code> </p> RETURNS DESCRIPTION <code>Register</code> <p>Pulser register</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register, spacing: float = DEFAULT_SPACING) -&gt; PulserRegister:\n\"\"\"Create Pulser register instance.\n    Args:\n        register (Register): graph representing a register with accompanying coordinate data\n        spacing (float): distance between qubits in micrometers\n    Returns:\n        Register: Pulser register\n    \"\"\"\n# create register from coordinates\ncoords = np.array(list(register.coords.values()))\nreturn PulserRegister.from_coordinates(coords * spacing)\n</code></pre>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.IDEALIZED","title":"<code>IDEALIZED = IdealDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>idealized device, least realistic</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.REALISTIC","title":"<code>REALISTIC = RealisticDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>device with realistic specs</p>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.interaction","title":"<code>interaction: Callable | Interaction | str = Interaction.NN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Digital-analog emulation interaction that is used for <code>AnalogBlock</code>s.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction and loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing. Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates. Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\nself,\nops: list[Module],\nqubits: list[int] | tuple,\nn_qubits: int,\nconfig: Configuration = None,\n):\n\"\"\"Compose a chain of single qubit operations on the same qubit into a single\n    call to _apply_batch_gate.\"\"\"\nsuper().__init__()\nself.operations = ops\nself.qubits = qubits\nself.n_qubits = n_qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.ScalePyQOperation","title":"<code>ScalePyQOperation(n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Computes:</p> <pre><code>M = matrix(op, theta)\nscale * matmul(M, state)\n</code></pre> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(self, n_qubits: int, block: ScaleBlock, config: Configuration):\nsuper().__init__()\n(self.param_name,) = config.get_param_name(block)\nif not isinstance(block.block, PrimitiveBlock):\nraise NotImplementedError(\n\"The pyqtorch backend can currently only scale `PrimitiveBlock` types.\\\n            Please use the following transpile function on your circuit first:\\\n            from qadence.transpile import scale_primitive_blocks_only\"\n)\nself.operation = convert_block(block.block, n_qubits, config)[0]\ndef _fwd(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn values[self.param_name] * self.operation(state, values)\nif config.use_gradient_checkpointing:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn checkpoint(_fwd, state, values, use_reentrant=False)\nelse:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn _fwd(state, values)\nself._forward = _forward\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Currently, the only implemented differentiation engine is PyTorch but it is easy to add support to another one like Jax.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are implemented by extending the PyTorch autograd engine using custom <code>Function</code> objects. The implementation is based on this PyTorch guide.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\nclass CustomFunction(Function):\n# forward pass implementation giving the output of the module\n@staticmethod\ndef forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\nctx.save_for_backward(inputs, params)\n...\n# backward pass implementation giving the derivative of the module\n# with respect to the parameters. This must return the whole vector-jacobian\n# product to integrate within the autograd engine\n@staticmethod\ndef backward(ctx, grad_output: torch.Tensor):\ninputs, params = ctx.saved_tensors\n...\n</code></pre> <p>The class <code>PSRExpectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\nreturn PSRExpectation.apply(\nctx.expectation_fn,\nctx.param_psrs,\nparams.keys(),\n*params.values(),\n)\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\n</code></pre> %3 6a2838f5a1d14d62b814fcd533231a78 0 56c42de851584330bb86b5255d37b2dd X 6a2838f5a1d14d62b814fcd533231a78--56c42de851584330bb86b5255d37b2dd 76a43a32978241ec864aa6b540d99cfb 1 0fa22c5c606042e8acdc9c7eb0d1cced 56c42de851584330bb86b5255d37b2dd--0fa22c5c606042e8acdc9c7eb0d1cced d13386ce324242d282e6a48a854becd0 a458ccafbb9d4e8686538b8d8ea72a4a Y 76a43a32978241ec864aa6b540d99cfb--a458ccafbb9d4e8686538b8d8ea72a4a a458ccafbb9d4e8686538b8d8ea72a4a--d13386ce324242d282e6a48a854becd0 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(0))\n</code></pre> %3 bd2cd870144547fc971162f8b6925d1d 0 2add641e109e4cc8b0853e96c8b2a87b X bd2cd870144547fc971162f8b6925d1d--2add641e109e4cc8b0853e96c8b2a87b d87950eaee2e4fa5a5c1eaa8d9b247c8 Y 2add641e109e4cc8b0853e96c8b2a87b--d87950eaee2e4fa5a5c1eaa8d9b247c8 30bfe95a0ebe45f3b58e7a0b9630e5f0 d87950eaee2e4fa5a5c1eaa8d9b247c8--30bfe95a0ebe45f3b58e7a0b9630e5f0 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(1))\n</code></pre> %3 54d1deed837b4bed9046e9bd8fa8c662 0 51167a5fc64c41f09837c432c902564b X 54d1deed837b4bed9046e9bd8fa8c662--51167a5fc64c41f09837c432c902564b a716a3af191344dd80c86b22d6cb765a 1 f11b62937fc94a91afa35b89deb40270 51167a5fc64c41f09837c432c902564b--f11b62937fc94a91afa35b89deb40270 6f1e027a9e5942ef8516011e65d2c49b f11b62937fc94a91afa35b89deb40270--6f1e027a9e5942ef8516011e65d2c49b c42ecd2c5c014bd58f872ba5ec07f0d0 9aaf7b0ba2584d3b80bcac106b003236 a716a3af191344dd80c86b22d6cb765a--9aaf7b0ba2584d3b80bcac106b003236 ff0c485519b0475097a0f2bbe169f4b1 Y 9aaf7b0ba2584d3b80bcac106b003236--ff0c485519b0475097a0f2bbe169f4b1 ff0c485519b0475097a0f2bbe169f4b1--c42ecd2c5c014bd58f872ba5ec07f0d0 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_5fc975517f674c5089aa2fb850f6403c d40b203edb344a44b5dc27de77534ece 0 952c980824c4481690c955b359d933b2 d40b203edb344a44b5dc27de77534ece--952c980824c4481690c955b359d933b2 6abc5e3e9e514dc8810b9acbce558312 1 ac63f120e08c4175b0dcf985645a8538 952c980824c4481690c955b359d933b2--ac63f120e08c4175b0dcf985645a8538 7d96f8f4fc0d47418d430d5cf046ac2b 697993a250c745f29bedebd63bfcd70f AddBlock 6abc5e3e9e514dc8810b9acbce558312--697993a250c745f29bedebd63bfcd70f 6f4b24aac49e47ba901735035acd328a 2 697993a250c745f29bedebd63bfcd70f--7d96f8f4fc0d47418d430d5cf046ac2b e45419849e514a44926b8c96795ffd4a f556a892fc744576aab0721ee86f7618 6f4b24aac49e47ba901735035acd328a--f556a892fc744576aab0721ee86f7618 f556a892fc744576aab0721ee86f7618--e45419849e514a44926b8c96795ffd4a <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n# `chain` puts things in sequence\nblock = chain(\nkron(X(0), Y(1), rx),\nCNOT(2,3),\nHamEvo(gen, 10)\n)\n</code></pre> %3 cluster_9953768a094145d2a3626123c5a84583 cluster_999937c195dd498788b0ce25f333c0e7 rx 8460b2e044d241adb7979c8031b0ba96 0 7efff87dedc1483dbe7aea37ae5107fc X 8460b2e044d241adb7979c8031b0ba96--7efff87dedc1483dbe7aea37ae5107fc 78e6c0c23e7a40f6bacef538e33aedbb 1 6e43e02165324b5eadee72c49760e86a 7efff87dedc1483dbe7aea37ae5107fc--6e43e02165324b5eadee72c49760e86a bd3123cd86444a4ea1b594fe7541cc31 6e43e02165324b5eadee72c49760e86a--bd3123cd86444a4ea1b594fe7541cc31 180c723aa0e4445995a9279b5be27c59 bd3123cd86444a4ea1b594fe7541cc31--180c723aa0e4445995a9279b5be27c59 f9e3c27cd76e4c8581c3148f3b9dbaa2 83966574841547fb83649eb286dfb658 Y 78e6c0c23e7a40f6bacef538e33aedbb--83966574841547fb83649eb286dfb658 f5987254700149118fb32d39a2820c08 2 5a10e31d3be544b4a2fbb0061120d7fc 83966574841547fb83649eb286dfb658--5a10e31d3be544b4a2fbb0061120d7fc 0a71c19b84ec46e4b9d7fd0d3b4d7c59 HamEvo 5a10e31d3be544b4a2fbb0061120d7fc--0a71c19b84ec46e4b9d7fd0d3b4d7c59 0a71c19b84ec46e4b9d7fd0d3b4d7c59--f9e3c27cd76e4c8581c3148f3b9dbaa2 220d91cd8f17493f92345c887cbae078 d07a66ed6d884bb08e507e97ef906f90 RX(x) f5987254700149118fb32d39a2820c08--d07a66ed6d884bb08e507e97ef906f90 eba0c56313fb42d69e5e1f0da48ca5a2 3 7488f5e109e647ce8c4fd0051b5b3ff8 d07a66ed6d884bb08e507e97ef906f90--7488f5e109e647ce8c4fd0051b5b3ff8 c5f6d0eff192425591e9ba8db0ce06f9 t = 10 7488f5e109e647ce8c4fd0051b5b3ff8--c5f6d0eff192425591e9ba8db0ce06f9 c5f6d0eff192425591e9ba8db0ce06f9--220d91cd8f17493f92345c887cbae078 abff094a0daa482593b5ace242bf6ae3 06e97f77111242aaab292348c7e1c135 RX(0.5) eba0c56313fb42d69e5e1f0da48ca5a2--06e97f77111242aaab292348c7e1c135 f73c8ffbef3a494e9ca88171d6e58813 X 06e97f77111242aaab292348c7e1c135--f73c8ffbef3a494e9ca88171d6e58813 f73c8ffbef3a494e9ca88171d6e58813--7488f5e109e647ce8c4fd0051b5b3ff8 c9ca6d40e1514d89b7b8edf96050c05f f73c8ffbef3a494e9ca88171d6e58813--c9ca6d40e1514d89b7b8edf96050c05f c9ca6d40e1514d89b7b8edf96050c05f--abff094a0daa482593b5ace242bf6ae3 <pre><code>from qadence import feature_map, hea, chain\nblock = chain(feature_map(4, fm_type=\"tower\"), hea(4,2))\n</code></pre> %3 cluster_8bb11fe4695c465f87fdc00b79c4c3a5 HEA cluster_5ea0f34746304801b6455766e43951a7 Tower Chebyshev FM 8b6304cf01454238a04fa718e2e7f2d5 0 ac92a94a8abe41a7886b0ff0814fa7ff RX(1.0*acos(phi)) 8b6304cf01454238a04fa718e2e7f2d5--ac92a94a8abe41a7886b0ff0814fa7ff 86a92d4a5ffa46d2868225a78f37894e 1 f69e09141b5d44a5a0b939f97cc095ed RX(theta\u2080) ac92a94a8abe41a7886b0ff0814fa7ff--f69e09141b5d44a5a0b939f97cc095ed 0ae9cb340be24747833fc728db36bcad RY(theta\u2084) f69e09141b5d44a5a0b939f97cc095ed--0ae9cb340be24747833fc728db36bcad d589a80404444aa2b5af4ae8c3862252 RX(theta\u2088) 0ae9cb340be24747833fc728db36bcad--d589a80404444aa2b5af4ae8c3862252 c97f6e22b4d84b59b153f005950bf4af d589a80404444aa2b5af4ae8c3862252--c97f6e22b4d84b59b153f005950bf4af 792123e634ad4c2e9a08ed5e44c2365b c97f6e22b4d84b59b153f005950bf4af--792123e634ad4c2e9a08ed5e44c2365b 7e14aa46c45d41c2a8a8debe9c2a50da RX(theta\u2081\u2082) 792123e634ad4c2e9a08ed5e44c2365b--7e14aa46c45d41c2a8a8debe9c2a50da e07ba6ed2f8344d4806ba7e592204537 RY(theta\u2081\u2086) 7e14aa46c45d41c2a8a8debe9c2a50da--e07ba6ed2f8344d4806ba7e592204537 1c0175621d694d529d5515f8557166db RX(theta\u2082\u2080) e07ba6ed2f8344d4806ba7e592204537--1c0175621d694d529d5515f8557166db 951e692c15024505853d6728a8f1268f 1c0175621d694d529d5515f8557166db--951e692c15024505853d6728a8f1268f 6663119da7484d0d930d3f3121170b04 951e692c15024505853d6728a8f1268f--6663119da7484d0d930d3f3121170b04 4e6e837e15b645f188c9eff3ac37e99e 6663119da7484d0d930d3f3121170b04--4e6e837e15b645f188c9eff3ac37e99e cb102c9a044e4b40847b7f6116d7bc01 b618882b7925466aaa7d0adf863e60f6 RX(2.0*acos(phi)) 86a92d4a5ffa46d2868225a78f37894e--b618882b7925466aaa7d0adf863e60f6 c8e0acc79a5e4406951df7690a05d4cd 2 942df93fb31a4405914394a2c85917c3 RX(theta\u2081) b618882b7925466aaa7d0adf863e60f6--942df93fb31a4405914394a2c85917c3 92cecb5291724760a59ccf95b77c23cf RY(theta\u2085) 942df93fb31a4405914394a2c85917c3--92cecb5291724760a59ccf95b77c23cf bf737bc1d68d4e039a5199f54beb5174 RX(theta\u2089) 92cecb5291724760a59ccf95b77c23cf--bf737bc1d68d4e039a5199f54beb5174 8bf100cfae4a40ce9a0e17ecf98a4eeb X bf737bc1d68d4e039a5199f54beb5174--8bf100cfae4a40ce9a0e17ecf98a4eeb 8bf100cfae4a40ce9a0e17ecf98a4eeb--c97f6e22b4d84b59b153f005950bf4af 2a24cb589ba14c5ab7bf4cc576f8daf7 8bf100cfae4a40ce9a0e17ecf98a4eeb--2a24cb589ba14c5ab7bf4cc576f8daf7 a8a12c71d7ac4051b89f7b58015d5b24 RX(theta\u2081\u2083) 2a24cb589ba14c5ab7bf4cc576f8daf7--a8a12c71d7ac4051b89f7b58015d5b24 24421e8620db4ed9a75ee24b1254a5c6 RY(theta\u2081\u2087) a8a12c71d7ac4051b89f7b58015d5b24--24421e8620db4ed9a75ee24b1254a5c6 5ccffe7a697d4167a062acc7494d6b4a RX(theta\u2082\u2081) 24421e8620db4ed9a75ee24b1254a5c6--5ccffe7a697d4167a062acc7494d6b4a c29d0fea9aff40228f15957706e7bc5b X 5ccffe7a697d4167a062acc7494d6b4a--c29d0fea9aff40228f15957706e7bc5b c29d0fea9aff40228f15957706e7bc5b--951e692c15024505853d6728a8f1268f 258b4459307d4cc18f0b8b32b69ae8e0 c29d0fea9aff40228f15957706e7bc5b--258b4459307d4cc18f0b8b32b69ae8e0 258b4459307d4cc18f0b8b32b69ae8e0--cb102c9a044e4b40847b7f6116d7bc01 fa07c1f784364df9bbaacb8859926fce 0d6662d01a28428094f66a785d2c2df8 RX(3.0*acos(phi)) c8e0acc79a5e4406951df7690a05d4cd--0d6662d01a28428094f66a785d2c2df8 04963578e3bd48d5adcacf88bfe7aea1 3 54e6be4c23b04e4ab9d054734cbfd20c RX(theta\u2082) 0d6662d01a28428094f66a785d2c2df8--54e6be4c23b04e4ab9d054734cbfd20c 469c3e196cc444b8a356780f8e0e4682 RY(theta\u2086) 54e6be4c23b04e4ab9d054734cbfd20c--469c3e196cc444b8a356780f8e0e4682 a617a614a6ec4c39ad494593ddc7434e RX(theta\u2081\u2080) 469c3e196cc444b8a356780f8e0e4682--a617a614a6ec4c39ad494593ddc7434e fe8d4b0a8dc9449396edb3d651e116bc a617a614a6ec4c39ad494593ddc7434e--fe8d4b0a8dc9449396edb3d651e116bc 13c39304cb314c599b433b3f4d5369d2 X fe8d4b0a8dc9449396edb3d651e116bc--13c39304cb314c599b433b3f4d5369d2 13c39304cb314c599b433b3f4d5369d2--2a24cb589ba14c5ab7bf4cc576f8daf7 0e506479a2154e07b4aba3b28e054108 RX(theta\u2081\u2084) 13c39304cb314c599b433b3f4d5369d2--0e506479a2154e07b4aba3b28e054108 339f98dcccaa4b228940ba9cbf50b84c RY(theta\u2081\u2088) 0e506479a2154e07b4aba3b28e054108--339f98dcccaa4b228940ba9cbf50b84c f61d0a578cd04ed688ffe731e1b66cc3 RX(theta\u2082\u2082) 339f98dcccaa4b228940ba9cbf50b84c--f61d0a578cd04ed688ffe731e1b66cc3 fd46dcb251494d85a30c268fbd09bc4e f61d0a578cd04ed688ffe731e1b66cc3--fd46dcb251494d85a30c268fbd09bc4e b540decfa68048a5b1bf181e30881d24 X fd46dcb251494d85a30c268fbd09bc4e--b540decfa68048a5b1bf181e30881d24 b540decfa68048a5b1bf181e30881d24--258b4459307d4cc18f0b8b32b69ae8e0 b540decfa68048a5b1bf181e30881d24--fa07c1f784364df9bbaacb8859926fce 6792524466b24de2a7dc861fc058710c a85e51438a9d4fe881bc635a4fe67baa RX(4.0*acos(phi)) 04963578e3bd48d5adcacf88bfe7aea1--a85e51438a9d4fe881bc635a4fe67baa 579f98b621fc408ab352ddba1ff654cc RX(theta\u2083) a85e51438a9d4fe881bc635a4fe67baa--579f98b621fc408ab352ddba1ff654cc ec495ba0c8a645f4ab3e57ec561acd2a RY(theta\u2087) 579f98b621fc408ab352ddba1ff654cc--ec495ba0c8a645f4ab3e57ec561acd2a 4a2eeffc08ee476aaf65b89b6673438d RX(theta\u2081\u2081) ec495ba0c8a645f4ab3e57ec561acd2a--4a2eeffc08ee476aaf65b89b6673438d d32f97fd6d754603b984e719b010c38c X 4a2eeffc08ee476aaf65b89b6673438d--d32f97fd6d754603b984e719b010c38c d32f97fd6d754603b984e719b010c38c--fe8d4b0a8dc9449396edb3d651e116bc aae868abff1d42be8e6abf459d405bc7 d32f97fd6d754603b984e719b010c38c--aae868abff1d42be8e6abf459d405bc7 adcc74e802de4905ae8abe13f9c657aa RX(theta\u2081\u2085) aae868abff1d42be8e6abf459d405bc7--adcc74e802de4905ae8abe13f9c657aa c3868cbbc09a4b298ef210199f16ec52 RY(theta\u2081\u2089) adcc74e802de4905ae8abe13f9c657aa--c3868cbbc09a4b298ef210199f16ec52 c256a62c488349e29f3e951a90d6d7a3 RX(theta\u2082\u2083) c3868cbbc09a4b298ef210199f16ec52--c256a62c488349e29f3e951a90d6d7a3 e4ce326b2cff41a89c3fda4769ddddcd X c256a62c488349e29f3e951a90d6d7a3--e4ce326b2cff41a89c3fda4769ddddcd e4ce326b2cff41a89c3fda4769ddddcd--fd46dcb251494d85a30c268fbd09bc4e b6ffe7216b404efb96b6be9774b4dfce e4ce326b2cff41a89c3fda4769ddddcd--b6ffe7216b404efb96b6be9774b4dfce b6ffe7216b404efb96b6be9774b4dfce--6792524466b24de2a7dc861fc058710c"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\ngraph_attr = {\n\"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n\"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n\"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n\"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\nnode_attr = {\n\"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n\"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n\"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\ndefault_cluster_attr = {\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n\"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\nhamevo_cluster_attr = {\n\"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Add start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\nhamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Define start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n# Define more nodes\nfor i in range(4):\nh.node(f\"b{i}\", group=f\"{i}\")\nfor i in range(4):\nh.edge(f's{i}', f'a{i}')\nh.edge(f'a{i}', f'b{i}')\nh.edge(f'b{i}', f'e{i}')\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/","title":"Digital-Analog Emulation","text":""},{"location":"digital_analog_qc/analog-basics/#from-theory-to-implementation","title":"From theory to implementation","text":"<p>Qadence includes primitives for the construction of Ising-like Hamiltonians to account for custom qubit interaction. This allows to simulate systems close to real quantum computing platforms such as neutral atoms. The general form for time-independent Ising Hamiltonians is</p> \\[ \\mathcal{H} = \\sum_{i} \\frac{\\hbar\\Omega}{2} \\hat\\sigma^x_i - \\sum_{i} \\hbar\\delta \\hat n_i  + \\mathcal{H}_{\\textrm{int}}, \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\hat n = \\frac{1-\\hat\\sigma_z}{2}\\) is the number operator, and \\(\\mathcal{H}_{\\textrm{int}}\\) a pair-wise interaction term. Two central operations implement this Hamiltonian as blocks:</p> <ul> <li><code>WaitBlock</code> by free-evolving \\(\\mathcal{H}_{\\textrm{int}}\\)</li> <li><code>ConstantAnalogRotation</code> by free-evolving \\(\\mathcal{H}\\)</li> </ul> <p>The <code>wait</code> operation can be emulated with an \\(ZZ\\)- (Ising) or an \\(XY\\)-interaction:</p> <pre><code>from qadence import Register, wait, add_interaction, run, Interaction\nblock = wait(duration=3000)\nreg = Register.from_coordinates([(0,0), (0,5)])  # Dimensionless.\nemulated = add_interaction(reg, block, interaction=Interaction.XY)  # or Interaction.ZZ for Ising.\n</code></pre> <pre><code>block = WaitBlock(t=3000.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,)) emulated.generator = AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 29.600] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> <p>The <code>AnalogRot</code> constructor can be used to create a fully customizable <code>ConstantAnalogRotation</code> instances:</p> <pre><code>import torch\nfrom qadence import AnalogRot, AnalogRX\n# Implement a global RX rotation by setting all parameters.\nblock = AnalogRot(\nduration=1000., # [ns]\nomega=torch.pi, # [rad/\u03bcs]\ndelta=0,        # [rad/\u03bcs]\nphase=0,        # [rad]\n)\n# Or use the shortcut.\nblock = AnalogRX(torch.pi)\n</code></pre> <pre><code>AnalogRot = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\nAnalogRX = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\n</code></pre> <p>Automatic emulation in the PyQTorch backend</p> <p>All analog blocks are automatically translated to their emulated version when running them with the PyQTorch backend:</p> <p><pre><code>import torch\nfrom qadence import Register, AnalogRX, sample\nreg = Register.from_coordinates([(0,0), (0,5)])\nsample = sample(reg, AnalogRX(torch.pi))\n</code></pre> <pre><code>sample = [Counter({'00': 40, '10': 32, '01': 28})]\n</code></pre> </p> <p>To compose analog blocks, the regular <code>chain</code> and <code>kron</code> operations can be used under the following restrictions:</p> <ul> <li>The resulting <code>AnalogChain</code> type can only be constructed from <code>AnalogKron</code> blocks   or globally supported primitive analog blocks.</li> <li>The resulting <code>AnalogKron</code> type can only be constructed from non-global   analog blocks with the same duration.</li> </ul> <pre><code>import torch\nfrom qadence import AnalogRot, kron, chain, wait\n# Only analog blocks with a global qubit support can be composed\n# using chain.\nanalog_chain = chain(wait(duration=200), AnalogRot(duration=300, omega=2.0))\n# Only blocks with the same `duration` can be composed using kron.\nanalog_kron = kron(\nwait(duration=1000, qubit_support=(0,1)),\nAnalogRot(duration=1000, omega=2.0, qubit_support=(2,3))\n)\n</code></pre> <pre><code>Analog Chain block = AnalogChain(t=500.000000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u251c\u2500\u2500 WaitBlock(t=200.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=0.600000000000000, t=300, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\nAnalog Kron block = AnalogKron(t=1000, support=(0, 1, 2, 3))\n\u251c\u2500\u2500 WaitBlock(t=1000.0, support=(0, 1))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=2.00000000000000, t=1000, support=(2, 3), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\n</code></pre> <p>Composing digital &amp; analog blocks</p> <p>It is possible to compose digital and analog blocks where the additional restrictions for <code>chain</code> and <code>kron</code> only apply to composite blocks which contain analog blocks only. For further details, see <code>AnalogChain</code> and <code>AnalogKron</code>.</p>"},{"location":"digital_analog_qc/analog-basics/#fitting-a-simple-function","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and paramertized ansatze to fit a sine function. First, define an ansatz block and an observable:</p> <pre><code>import torch\nfrom qadence import Register, FeatureParameter, VariationalParameter\nfrom qadence import AnalogRX, AnalogRZ, Z\nfrom qadence import wait, chain, add\npi = torch.pi\n# A two qubit register.\nreg = Register.from_coordinates([(0, 0), (0, 12)])\n# An analog ansatz with an input time parameter.\nt = FeatureParameter(\"t\")\nblock = chain(\nAnalogRX(pi/2.),\nAnalogRZ(t),\nwait(1000 * VariationalParameter(\"theta\", value=0.5)),\nAnalogRX(pi/2),\n)\n# Total magnetization observable.\nobs = add(Z(i) for i in range(reg.n_qubits))\n</code></pre> Plotting functions <code>plot</code> and <code>scatter</code> <p><pre><code>def plot(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.plot(xnp, ynp, **kwargs)\ndef scatter(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.scatter(xnp, ynp, **kwargs)\n</code></pre> </p> <p>Next, define the dataset to train on and plot the initial prediction. The differentiation mode can be set to either <code>DiffMode.AD</code> or <code>DiffMode.GPSR</code>.</p> <pre><code>import matplotlib.pyplot as plt\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\n# Define a quantum model including digital-analog emulation.\ncirc = QuantumCircuit(reg, block)\nmodel = QuantumModel(circ, obs, diff_mode=DiffMode.GPSR)\n# Time support dataset.\nx_train = torch.linspace(0, 6, steps=30)\n# Function to fit.\ny_train = -0.64 * torch.sin(x_train + 0.33) + 0.1\n# Initial prediction.\ny_pred_initial = model.expectation({\"t\": x_train})\n</code></pre> 2023-10-17T16:39:32.433709 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Finally, the classical optimization part is handled by PyTorch:</p> <pre><code># Use PyTorch built-in functionality.\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=5e-2)\n# Define a loss function.\ndef loss_fn(x_train, y_train):\nreturn mse_loss(model.expectation({\"t\": x_train}).squeeze(), y_train)\n# Number of epochs to train over.\nn_epochs = 200\n# Optimization loop.\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_fn(x_train, y_train)\nloss.backward()\noptimizer.step()\n# Get and visualize the final prediction.\ny_pred = model.expectation({\"t\": x_train})\n</code></pre> 2023-10-17T16:39:41.329900 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom pulser.devices import Chadoq2\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\ndef qubo_register_coords(Q):\n\"\"\"Compute coordinates for register.\"\"\"\nbitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\ncosts = []\n# this takes exponential time with the dimension of the QUBO\nfor b in bitstrings:\nz = np.array(list(b), dtype=int)\ncost = z.T @ Q @ z\ncosts.append(cost)\nzipped = zip(bitstrings, costs)\nsort_zipped = sorted(zipped, key=lambda x: x[1])\ndef evaluate_mapping(new_coords, *args):\n\"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\nQ, shape = args\nnew_coords = np.reshape(new_coords, shape)\nnew_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\nreturn np.linalg.norm(new_Q - Q)\nshape = (len(Q), 2)\ncosts = []\nnp.random.seed(0)\nx0 = np.random.random(shape).flatten()\nres = minimize(\nevaluate_mapping,\nx0,\nargs=(Q, shape),\nmethod=\"Nelder-Mead\",\ntol=1e-6,\noptions={\"maxiter\": 200000, \"maxfev\": None},\n)\nreturn [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom qadence import add_interaction, chain\nfrom qadence import QuantumModel, QuantumCircuit, AnalogRZ, AnalogRX, Register\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\nz = np.array(list(bitstring), dtype=int)\ncost = z.T @ Q @ z\nreturn cost\n# Cost function.\ndef cost_fn(counter, Q):\ncost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\nreturn cost / sum(counter.values())  # Divide by total samples\n# Weights.\nQ = np.array(\n[\n[-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n[19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n[19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n[5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n[5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n]\n)\n</code></pre> <p>Now, build a weighted register graph from the QUBO definition similarly to what is done in Pulser.</p> <pre><code>reg = Register.from_coordinates(qubo_register_coords(Q))\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70.</p> <pre><code>from qadence.transpile.emulate import ising_interaction\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\nemulated = add_interaction(\nreg, block, interaction=lambda r, ps: ising_interaction(r, ps, rydberg_level=70)\n)\n</code></pre> <pre><code>emulated = ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u2502   \u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_4100727736005*t0']]\n\u2502   \u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['39_0388262113427*s0']]\n\u2514\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_4100727736005*t1']]\n\u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['39_0388262113427*s1']]\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(QuantumCircuit(reg, emulated), backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 470, '01000': 90, '00100': 88, '00001': 74, '00010': 71, '10000': 70, '00101': 19, '11000': 19, '10100': 14, '10001': 13, '10010': 12, '00110': 11, '01001': 11, '00011': 9, '01010': 8, '01100': 6, '01101': 3, '10110': 3, '01011': 2, '01110': 2, '10011': 2, '11010': 2, '00111': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\nQ = args[0]\nparam = torch.tensor(param)\nmodel.reset_vparams(param)\nC = model.sample({}, n_shots=1000)[0]\nreturn cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\nres = minimize(\nloss,\nargs=Q,\nx0=np.random.uniform(1, 10, size=2 * layers),\nmethod=\"COBYLA\",\ntol=1e-8,\noptions={\"maxiter\": 20},\n)\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 299, '00011': 187, '01010': 94, '00010': 77, '00101': 62, '01011': 52, '00001': 49, '10010': 44, '00100': 42, '00110': 32, '01001': 15, '01000': 12, '10011': 10, '01111': 7, '10001': 6, '01110': 5, '00000': 3, '01100': 3, '01101': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-10-17T16:39:43.832520 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-basics/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>The DAQC paradigm is typically implemented on quantum computing hardware based on neutral-atoms where both these computations are realizable.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real neutral-atom devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/daqc-basics/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\nn_qubits = 2\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\nH(1),\ncphase_evo,\nH(1)\n)\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n# Interaction strength.\ng_int = 1.0\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\nfor j in range(i):\ninteraction_list.append(g_int * kron(N(i), N(j)))\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\nn_qubits=3,        # Total number of qubits in the transformation\ngen_target=h_int,  # The target Ising generator\nt_f=torch.pi,      # The target evolution time\ngen_build=h_sys,   # The building block Ising generator to be used\nstrategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\nignore_global_phases=False  # Global phases from mapping between Z and N\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_711ed245ee254a6aa70095bd9b4ed8b4 cluster_521a0938af1f4e34b0ba4faa09721369 cluster_57fc70a864794dc483899cb3c28ae59b cluster_1b69a9485533477ea3f2a9badc1c6aab cluster_75d186f20b004ec8965f9e7196f8ea45 cluster_b8999ba155db431186f4e523c2ec1797 cluster_f679be00163a47a8957aa86105e7c75d 24821ab51037459089266b3b7b9389d3 0 36a4ea9ce7f54beb91776d7f1bbafd28 HamEvo 24821ab51037459089266b3b7b9389d3--36a4ea9ce7f54beb91776d7f1bbafd28 7f6056758bd444588f7f0f2aac1b9db6 1 bcfa4d8b1d2b4e0982468a0620a32a13 HamEvo 36a4ea9ce7f54beb91776d7f1bbafd28--bcfa4d8b1d2b4e0982468a0620a32a13 6373dcefca934ae397ccb89e17bac16f HamEvo bcfa4d8b1d2b4e0982468a0620a32a13--6373dcefca934ae397ccb89e17bac16f a9e32ecff3384f0ab8bfb7989ce3ad02 X 6373dcefca934ae397ccb89e17bac16f--a9e32ecff3384f0ab8bfb7989ce3ad02 f0ff3eb211de4e7294c7d0d3eb225091 HamEvo a9e32ecff3384f0ab8bfb7989ce3ad02--f0ff3eb211de4e7294c7d0d3eb225091 ff10d7b19c574e3b964aae4957f45864 HamEvo f0ff3eb211de4e7294c7d0d3eb225091--ff10d7b19c574e3b964aae4957f45864 83703ef81ded460ebff09d683a45275c X ff10d7b19c574e3b964aae4957f45864--83703ef81ded460ebff09d683a45275c dede5145d8d1459db9d8d76317e6608a 83703ef81ded460ebff09d683a45275c--dede5145d8d1459db9d8d76317e6608a d7f5c889ccf9432a99ef19ff04e06271 HamEvo dede5145d8d1459db9d8d76317e6608a--d7f5c889ccf9432a99ef19ff04e06271 38347243dc77480d8000baa4d20234fe HamEvo d7f5c889ccf9432a99ef19ff04e06271--38347243dc77480d8000baa4d20234fe 065e4bbf5c164c5c9787f03cf01f5032 38347243dc77480d8000baa4d20234fe--065e4bbf5c164c5c9787f03cf01f5032 f22a8c3cf31849e89026b095f2c1eb98 065e4bbf5c164c5c9787f03cf01f5032--f22a8c3cf31849e89026b095f2c1eb98 fbdf386699bc4d2e99b1c372b1b1a05d b227194820044cb098566b8f04a1900c t = -3.142 7f6056758bd444588f7f0f2aac1b9db6--b227194820044cb098566b8f04a1900c 3e7d80949f5144c1985f1bbc151e7806 2 29599b28345248a095e14277331415a8 t = 3.142 b227194820044cb098566b8f04a1900c--29599b28345248a095e14277331415a8 ea0bd12c873a4723ac5563dc6e985a80 t = -3.142 29599b28345248a095e14277331415a8--ea0bd12c873a4723ac5563dc6e985a80 d91e65f52185459d84a805250470b4b3 ea0bd12c873a4723ac5563dc6e985a80--d91e65f52185459d84a805250470b4b3 b2c42c3578b047f2855e764cf35b6e50 t = 1.571 d91e65f52185459d84a805250470b4b3--b2c42c3578b047f2855e764cf35b6e50 e41810a27cb844c1b457063bd51a07bb t = 1.571 b2c42c3578b047f2855e764cf35b6e50--e41810a27cb844c1b457063bd51a07bb 5135b4e89320489ea305e4d0c2a9f8ff e41810a27cb844c1b457063bd51a07bb--5135b4e89320489ea305e4d0c2a9f8ff fca6c8a2eeff4107ad75570db33b8024 X 5135b4e89320489ea305e4d0c2a9f8ff--fca6c8a2eeff4107ad75570db33b8024 30c39f1d72ec48de9ffeaad99e576697 t = 1.571 fca6c8a2eeff4107ad75570db33b8024--30c39f1d72ec48de9ffeaad99e576697 ddbd4d45d417459083ffad09041a4be5 t = 1.571 30c39f1d72ec48de9ffeaad99e576697--ddbd4d45d417459083ffad09041a4be5 9cb1abf2e8ab4621956503939d5f1364 X ddbd4d45d417459083ffad09041a4be5--9cb1abf2e8ab4621956503939d5f1364 9cb1abf2e8ab4621956503939d5f1364--fbdf386699bc4d2e99b1c372b1b1a05d 01745c262248465ab02f08d32618fd74 780cdf8e2d514f609378602eb3316214 3e7d80949f5144c1985f1bbc151e7806--780cdf8e2d514f609378602eb3316214 71f51802b9024da28921b5068f946dfe 780cdf8e2d514f609378602eb3316214--71f51802b9024da28921b5068f946dfe 2468450373fb4d019367f1fd77aa8627 71f51802b9024da28921b5068f946dfe--2468450373fb4d019367f1fd77aa8627 022d566c0b5149c9b58f72575bf4b524 X 2468450373fb4d019367f1fd77aa8627--022d566c0b5149c9b58f72575bf4b524 6ffb4f0438bb468d85919bb7e0653829 022d566c0b5149c9b58f72575bf4b524--6ffb4f0438bb468d85919bb7e0653829 bd7de8d67004467aa838182cc0853939 6ffb4f0438bb468d85919bb7e0653829--bd7de8d67004467aa838182cc0853939 4d40b29c6ac6498aafd1d984c45158f6 X bd7de8d67004467aa838182cc0853939--4d40b29c6ac6498aafd1d984c45158f6 a7adcdc5722445eabd3c6288e566f5e7 X 4d40b29c6ac6498aafd1d984c45158f6--a7adcdc5722445eabd3c6288e566f5e7 893a27a60cb74c77b3f5c302f88ba0f9 a7adcdc5722445eabd3c6288e566f5e7--893a27a60cb74c77b3f5c302f88ba0f9 08e910ef4420449aa162ae0761a967a7 893a27a60cb74c77b3f5c302f88ba0f9--08e910ef4420449aa162ae0761a967a7 a71664d586ea41d3ab7c4372a450dd02 X 08e910ef4420449aa162ae0761a967a7--a71664d586ea41d3ab7c4372a450dd02 a71664d586ea41d3ab7c4372a450dd02--01745c262248465ab02f08d32618fd74 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\ncnot_daqc = chain(\nH(j),\ntransformed_ising,\nH(j)\n)\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\nreturn g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=1.0),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_c53209159e184a2c8bd2fd75b3ebae5f cluster_b2d73112493c497e863683344c632c3b e024fd1e9fc2489f9f135c9c36e98753 0 8b57be7e33d949bfa319948b32b05d48 X e024fd1e9fc2489f9f135c9c36e98753--8b57be7e33d949bfa319948b32b05d48 e0e22405cd604cbdb2e6234f7d3d3a46 1 bbd30e91a0c940d291aca8e3b28af14f HamEvo 8b57be7e33d949bfa319948b32b05d48--bbd30e91a0c940d291aca8e3b28af14f 7e20433f75324326a24c1f4b49391bb8 X bbd30e91a0c940d291aca8e3b28af14f--7e20433f75324326a24c1f4b49391bb8 bdd4647552214f408dfd76ee97e723ba 7e20433f75324326a24c1f4b49391bb8--bdd4647552214f408dfd76ee97e723ba 41f510ef38fa4d5aba4e5825e802570f HamEvo bdd4647552214f408dfd76ee97e723ba--41f510ef38fa4d5aba4e5825e802570f a1ad5cb9cd5042d5bfbc5396fc732123 41f510ef38fa4d5aba4e5825e802570f--a1ad5cb9cd5042d5bfbc5396fc732123 48d18749e48c48e3b911d0a6999ae385 a1ad5cb9cd5042d5bfbc5396fc732123--48d18749e48c48e3b911d0a6999ae385 3c3cfede803942db91e0e7d7502c6db4 6c01b4dc499047768b7e58f96aec4d25 e0e22405cd604cbdb2e6234f7d3d3a46--6c01b4dc499047768b7e58f96aec4d25 0dbc690104c5439e89a9a507d84a78dc 2 6b485c1e01814570bccb822e67982a7f t = -0.500 6c01b4dc499047768b7e58f96aec4d25--6b485c1e01814570bccb822e67982a7f 398429a7816d4478925d2f3f7305bfb1 6b485c1e01814570bccb822e67982a7f--398429a7816d4478925d2f3f7305bfb1 6116bfe4dfcc40bc939d23fd71bb913c X 398429a7816d4478925d2f3f7305bfb1--6116bfe4dfcc40bc939d23fd71bb913c 792c8bf3a3364d9aba439d3208ac2be8 t = -0.500 6116bfe4dfcc40bc939d23fd71bb913c--792c8bf3a3364d9aba439d3208ac2be8 ca8261bc52ce4ce8b23c2172010b9c54 X 792c8bf3a3364d9aba439d3208ac2be8--ca8261bc52ce4ce8b23c2172010b9c54 ca8261bc52ce4ce8b23c2172010b9c54--3c3cfede803942db91e0e7d7502c6db4 61a675e76da74806a74642d13ecbfe3f fe9b88bce01c4d1cb93b4145b060e04d X 0dbc690104c5439e89a9a507d84a78dc--fe9b88bce01c4d1cb93b4145b060e04d 033f00e803ea42409f21b82cf079531f fe9b88bce01c4d1cb93b4145b060e04d--033f00e803ea42409f21b82cf079531f f290da1277b24fb7a66622ed96527dd1 X 033f00e803ea42409f21b82cf079531f--f290da1277b24fb7a66622ed96527dd1 dd1d76af67c7408287449344517e1b90 X f290da1277b24fb7a66622ed96527dd1--dd1d76af67c7408287449344517e1b90 603d0dab9a0844238f2f6d22813b2561 dd1d76af67c7408287449344517e1b90--603d0dab9a0844238f2f6d22813b2561 4046cf36ff564aa98ba25bb95c824e31 X 603d0dab9a0844238f2f6d22813b2561--4046cf36ff564aa98ba25bb95c824e31 4046cf36ff564aa98ba25bb95c824e31--61a675e76da74806a74642d13ecbfe3f <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=0.001),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_0897753d71924cfa92ccfe62b56ec08f cluster_142410410e18493db7b304b8f44c1730 9d4a19745b33437d805179fbc6a88393 0 5208aba35e0048368ac8d14807d9433d X 9d4a19745b33437d805179fbc6a88393--5208aba35e0048368ac8d14807d9433d d7d3d30567da4533875dbedb4519e146 1 dc78db547fd84f4ebe6574990f5ff9a3 HamEvo 5208aba35e0048368ac8d14807d9433d--dc78db547fd84f4ebe6574990f5ff9a3 bd4381d069b54d5cb7d1b1f2f54a4e2b X dc78db547fd84f4ebe6574990f5ff9a3--bd4381d069b54d5cb7d1b1f2f54a4e2b 60362b72621c41f994948d6dd096fc02 bd4381d069b54d5cb7d1b1f2f54a4e2b--60362b72621c41f994948d6dd096fc02 cdef7890d0de4e778dd044b70c575499 HamEvo 60362b72621c41f994948d6dd096fc02--cdef7890d0de4e778dd044b70c575499 25c95048e5fa466cb0933e80bc388536 cdef7890d0de4e778dd044b70c575499--25c95048e5fa466cb0933e80bc388536 76ff921e9ce14812bc449090a0960933 25c95048e5fa466cb0933e80bc388536--76ff921e9ce14812bc449090a0960933 b809128f12434abfa2662aa3f90a6f03 c206bea8ba2646dda8e24a41c8aee6ed d7d3d30567da4533875dbedb4519e146--c206bea8ba2646dda8e24a41c8aee6ed 9c6aa9d680734f82be515d4a4fb06677 2 3bc326b17b6d41509ee0636f3f02581f t = -500.000000000000 c206bea8ba2646dda8e24a41c8aee6ed--3bc326b17b6d41509ee0636f3f02581f 60d65c64ebcb4d869085b9cb202dec70 3bc326b17b6d41509ee0636f3f02581f--60d65c64ebcb4d869085b9cb202dec70 f35f9a725bde4f00ae55fafb21af865f X 60d65c64ebcb4d869085b9cb202dec70--f35f9a725bde4f00ae55fafb21af865f afca812b60404d3aa0e3ab4bb7b05e65 t = -500.000000000000 f35f9a725bde4f00ae55fafb21af865f--afca812b60404d3aa0e3ab4bb7b05e65 828b700ca9a84d39988bb9e9e79f864a X afca812b60404d3aa0e3ab4bb7b05e65--828b700ca9a84d39988bb9e9e79f864a 828b700ca9a84d39988bb9e9e79f864a--b809128f12434abfa2662aa3f90a6f03 d110d7c4d95c48cea5eb6c0d21b3755a a5b4cb1ddf9c4926aea990391a13cada X 9c6aa9d680734f82be515d4a4fb06677--a5b4cb1ddf9c4926aea990391a13cada 6cd5b9c4dece479984dd86891c27994a a5b4cb1ddf9c4926aea990391a13cada--6cd5b9c4dece479984dd86891c27994a 97410f5aabc14b629822b5c6c80b0b65 X 6cd5b9c4dece479984dd86891c27994a--97410f5aabc14b629822b5c6c80b0b65 6670e21f4aa9473da9e44b14ef657cc9 X 97410f5aabc14b629822b5c6c80b0b65--6670e21f4aa9473da9e44b14ef657cc9 5533416a97ba438780087c93daf39efb 6670e21f4aa9473da9e44b14ef657cc9--5533416a97ba438780087c93daf39efb e45aceb0eec647bbbcdedd28bdaa59d1 X 5533416a97ba438780087c93daf39efb--e45aceb0eec647bbbcdedd28bdaa59d1 e45aceb0eec647bbbcdedd28bdaa59d1--d110d7c4d95c48cea5eb6c0d21b3755a <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\ntransformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int = 0.0),\n)\nexcept ValueError as error:\nprint(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\nbell_state = chain(\nentangle(\"t\", qubit_support=(0,1)),\nRY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.4033156033573492, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Return the final state vector\nfinal_vector = model.run(params)\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7080-0.0207j,  0.0395+0.3061j,  0.0039-0.0540j,  0.6220-0.1151j]])\nsample = Counter({'00': 27, '11': 18, '01': 5})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-10-17T16:39:44.437251 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-10-17T16:39:44.553558 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence.backends.pulser.devices import Device\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\n# Choose a realistic device\nmodel = QuantumModel(\ncircuit,\nbackend=BackendName.PULSER,\ndiff_mode=DiffMode.GPSR,\nconfiguration={\"device_type\": Device.REALISTIC}\n)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 26, '01': 18, '11': 6})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n# Custom entanglement operation.\ndef my_entanglement(duration):\nreturn chain(\nAnalogRY(-torch.pi / 2),\nwait(duration)\n)\nprotocol = chain(\nmy_entanglement(\"t\"),\nRY(0, \"y\"),\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([torch.pi / 2]),\n}\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-10-17T16:39:45.065478 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\nhea_one_layer = chain(\nkron(RY(0, \"th00\"), RY(1, \"th01\")),\nkron(RX(0, \"th10\"), RX(1, \"th11\")),\nkron(RY(0, \"th20\"), RY(1, \"th21\")),\nentangle(\"t\", qubit_support=(0,1)),\n)\nprotocol = chain(\nfourier_feature_map(1, param=\"x\"),\nhea_one_layer,\nAnalogRX(torch.pi/4)\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"x\": torch.tensor([0.8]), # rad\n\"t\": torch.tensor([900]), # ns\n\"th00\":  torch.rand(1), # rad\n\"th01\":  torch.rand(1), # rad\n\"th10\":  torch.rand(1), # rad\n\"th11\":  torch.rand(1), # rad\n\"th20\":  torch.rand(1), # rad\n\"th21\":  torch.rand(1), # rad\n}\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-10-17T16:39:45.223807 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system. A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n\"\"\"The number of qubits in the whole system.\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n\"\"\"The number of qubits the block is acting on.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on. Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n\"\"\"The indices of the qubit(s) the block is acting on.\n    Qadence uses the ordering [0..,N-1] for qubits.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\nself.blocks = (target_block,)\n# using tuple expansion because some control operations could\n# have multiple targets, e.g. CSWAP\nsuper().__init__((*control, *target_block.qubit_support))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n\"\"\"The number of parameters required by the block\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\nself.blocks = (target_block,)\nself.parameters = target_block.parameters\nsuper().__init__((*control, target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations such as single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n\"\"\"Decomposition into purely digital gates\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\nself.block = block\n# TODO: more meaningful name like `scale`?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nsuper().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks. Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n\"\"\"A chain of analog blocks. Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\nfor b in blocks:\nif not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\nraise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time). Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n\"\"\"Stack analog blocks vertically (i.e. in time). Needed because analog require\n    stricter validation than the general `KronBlock`.\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nself.blocks = blocks\nself.interaction = interaction\nqubit_support = QubitSupport()\nduration = blocks[0].duration\nfor b in blocks:\nif not isinstance(b, AnalogBlock):\nraise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\nif b.qubit_support == QubitSupport(\"global\"):\nraise ValueError(\"Blocks with global support cannot be kron'ed.\")\nif not qubit_support.is_disjoint(b.qubit_support):\nraise ValueError(\"Make sure blocks act on distinct qubits!\")\nif not np.isclose(evaluate(duration), evaluate(b.duration)):\nraise ValueError(\"Kron'ed blocks have to have same duration.\")\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian</p> <pre><code>H = \u2211\u1d62(h\u03a9/2 sin(\u03c6)*X\u1d62 - cos(\u03c6)*Y\u1d62 - h\u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>Can be used with <code>add_interaction</code>. WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits. In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interation</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p> <p>Can be used with <code>add_interaction</code>.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially. On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\nb = chain(X(0), Y(0))\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n\"\"\"Chain blocks sequentially. On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n    Returns:\n        ChainBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n    b = chain(X(0), Y(0))\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogChain` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_chain(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically. On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\nb = kron(X(0), Y(1))\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n\"\"\"Stack blocks vertically. On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n    Returns:\n        KronBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n    b = kron(X(0), Y(1))\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogKron` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_kron(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\nb = add(X(0), Y(0))\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n\"\"\"Sums blocks.\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n    Returns:\n        AddBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n    b = add(X(0), Y(0))\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\nreturn _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks. Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially. Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed). Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally. Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nqubit_support = QubitSupport()\nfor b in blocks:\nassert (\nQubitSupportType.GLOBAL,\n) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\nassert qubit_support.is_disjoint(\nb.qubit_support\n), \"Make sure blocks act on distinct qubits!\"\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\nblock = hea(2,2)\nprint(block_to_tensor(block))\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.5034+0.1645j, -0.2575-0.4773j, -0.1863-0.2398j, -0.5771+0.0125j],\n[ 0.0301-0.4791j,  0.5561+0.0912j, -0.5891-0.2234j, -0.1547-0.1766j],\n[-0.1238-0.5348j, -0.3862-0.0394j,  0.2656+0.1068j, -0.1997-0.6528j],\n[-0.3733-0.2200j, -0.1777-0.4539j,  0.0268-0.6544j,  0.3337+0.1853j]]],\ngrad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n[0, 3]]),\nvalues=tensor([ 2.+0.j, -2.+0.j]),\nsize=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\nblock: AbstractBlock,\nvalues: dict[str, TNumber | torch.Tensor] = {},\nqubit_support: tuple | None = None,\nuse_full_support: bool = True,\ntensor_type: TensorType = TensorType.DENSE,\nendianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n\"\"\"\n    Convert a block into a torch tensor.\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n    block = hea(2,2)\n    print(block_to_tensor(block))\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n# FIXME: default use_full_support to False. In general, it would\n# be more efficient to do that, and make sure that computations such\n# as observables only do the matmul of the size of the qubit support.\nif tensor_type == TensorType.DENSE:\nfrom qadence.blocks import embedding\n(ps, embed) = embedding(block)\nreturn _block_to_tensor_embedded(\nblock, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n)\nelif tensor_type == TensorType.SPARSEDIAGONAL:\nt = block_to_diagonal(block, endianness=endianness)\nindices, values, size = torch.nonzero(t), t[t != 0], len(t)\nindices = torch.stack((indices.flatten(), indices.flatten()))\nreturn torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"x\",\nfeature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Exponential fourier feature map.\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\nif feature_range is None:\nfeature_range = (0.0, 2.0**n_qubits)\nsupport = tuple(range(n_qubits)) if support is None else support\nhlayer = kron(H(qubit) for qubit in support)\nrlayer = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=RZ,\nfm_type=BasisSet.FOURIER,\nreupload_scaling=ReuploadScaling.EXP,\nfeature_range=feature_range,\ntarget_range=(0.0, 2 * pi),\n)\nrlayer.tag = None\nreturn tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | type[Function] | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data is assumed to come from.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] | None = None,\nparam: Parameter | str = \"phi\",\nop: RotationTypes = RX,\nfm_type: BasisSet | type[Function] | str = BasisSet.FOURIER,\nreupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\nfeature_range: tuple[float, float] | None = None,\ntarget_range: tuple[float, float] | None = None,\nmultiplier: Parameter | TParameter | None = None,\n) -&gt; KronBlock:\n\"\"\"Construct a feature map of a given type.\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data is assumed to come from.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n# Process input\nif support is None:\nsupport = tuple(range(n_qubits))\nelif len(support) != n_qubits:\nraise ValueError(\"Wrong qubit support supplied\")\nif op not in ROTATIONS:\nraise ValueError(\nf\"Operation {op} not supported. \"\nf\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n)\n# Backwards compatibility\nif fm_type in (\"fourier\", \"chebyshev\", \"tower\"):\nlogger.warning(\n\"Selecting `fm_type` as 'fourier', 'chebyshev' or 'tower' is deprecated. \"\n\"Please use the respective enumerations: 'fm_type = BasisSet.FOURIER', \"\n\"'fm_type = BasisSet.CHEBYSHEV' or 'reupload_scaling = ReuploadScaling.TOWER'.\"\n)\nif fm_type == \"fourier\":\nfm_type = BasisSet.FOURIER\nelif fm_type == \"chebyshev\":\nfm_type = BasisSet.CHEBYSHEV\nelif fm_type == \"tower\":\nfm_type = BasisSet.CHEBYSHEV\nreupload_scaling = ReuploadScaling.TOWER\nif isinstance(param, Parameter):\nfparam = param\nfparam.trainable = False\nelse:\nfparam = FeatureParameter(param)\n# Set feature and target range\nfeature_range = _set_range(fm_type) if feature_range is None else feature_range\ntarget_range = _set_range(fm_type) if target_range is None else target_range\n# Rescale the feature parameter\nscaling = (max(target_range) - min(target_range)) / (max(feature_range) - min(feature_range))\nshift = min(target_range) - min(feature_range) * scaling\nif isclose(scaling, 1.0):\n# So we don't get 1.0 factor in visualization\nscaled_fparam = fparam + shift\nelse:\nscaled_fparam = scaling * fparam + shift\n# Transform feature parameter\nif fm_type == BasisSet.FOURIER:\ntransformed_feature = scaled_fparam\nelif fm_type == BasisSet.CHEBYSHEV:\ntransformed_feature = acos(scaled_fparam)\nelif inspect.isclass(fm_type) and issubclass(fm_type, Function):\ntransformed_feature = fm_type(scaled_fparam)\nelse:\nraise NotImplementedError(\nf\"Feature map type {fm_type} not implemented. Choose an item from the BasisSet \"\nf\"enum: {[bs.name for bs in BasisSet]}, or your own sympy.Function to wrap \"\n\"the given feature parameter with.\"\n)\nbasis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n# Set reupload scaling function\nif callable(reupload_scaling):\nrs_func = reupload_scaling\nrs_tag = \"Custom\"\nelse:\nrs_func = RS_FUNC_DICT.get(reupload_scaling, None)  # type: ignore [call-overload]\nif rs_func is None:\nraise NotImplementedError(\nf\"Reupload scaling {reupload_scaling} not implemented; choose an item from \"\nf\"the ReuploadScaling enum: {[rs.name for rs in ReuploadScaling]}, or your own \"\n\"python function with a single int arg as input and int or float output.\"\n)\nif isinstance(reupload_scaling, ReuploadScaling):\nrs_tag = reupload_scaling.value\nelse:\nrs_tag = reupload_scaling\n# Set overall multiplier\nmultiplier = 1 if multiplier is None else multiplier\n# Build feature map\nop_list = []\nfor i, qubit in enumerate(support):\nop_list.append(op(qubit, multiplier * rs_func(i) * transformed_feature))\nfm = kron(*op_list)\nfm.tag = rs_tag + \" \" + basis_tag + \" FM\"\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Fourier feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev tower feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\nFutureWarning,\n)\nfm = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=op,\nfm_type=BasisSet.CHEBYSHEV,\nreupload_scaling=ReuploadScaling.TOWER,\n)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\nn_qubits: int,\nn_features: int,\ndepth: int = None,\nansatz: Optional[AbstractBlock] = None,\nfm_pauli: Type[RY] = RY,\nspectrum: str = \"simple\",\nbasis: str = \"fourier\",\nfm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n\"\"\"Helper function to build a qadence QNN quantum circuit\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\ndepth = n_qubits if depth is None else depth\nidx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\nif fm_strategy == \"parallel\":\n_fm = kron(*idx_fms)\nfm = tag(_fm, tag=\"FM\")\nelif fm_strategy == \"serial\":\nfm_components: list[AbstractBlock] = []\nfor j, fm_idx in enumerate(idx_fms[:-1]):\nfm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\nfm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\nfm_components.extend(fm_component)\nfm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\nfm = chain(*fm_components)  # type: ignore[assignment]\nansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\nreturn [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nstrategy=\"sDAQC\",\noperations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nsupport: tuple[int, ...] = None,\nstrategy: Strategy = Strategy.DIGITAL,\n**strategy_args: Any,\n) -&gt; AbstractBlock:\n\"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nhea_func_dict = {\nStrategy.DIGITAL: hea_digital,\nStrategy.SDAQC: hea_sDAQC,\nStrategy.BDAQC: hea_bDAQC,\nStrategy.ANALOG: hea_analog,\n}\ntry:\nhea_func = hea_func_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nhea_block: AbstractBlock = hea_func(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\n**strategy_args,\n)  # type: ignore\nreturn hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nperiodic: bool = False,\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\ntry:\nif entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\nraise ValueError(\n\"Please provide a valid two-qubit entangler operation for digital HEA.\"\n)\nexcept TypeError:\nraise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\nperiodic=periodic,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers using step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers\n    using step-wise digital-analog computation.\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n# TODO: Add qubit support\nif entangler is None:\nentangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif not block_is_qubit_hamiltonian(entangler):\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nexcept NotImplementedError:\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_analog(\ndepth=depth,\nparam_prefix=param_prefix,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, force_update=False)</code>","text":"<p>General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_update</code> <p>force override register detuning and interaction strengths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\nn_qubits = 3\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\nn_qubits,\ninteraction = Interaction.XY,\nrandom_strength = True,\n)\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\nregister,\ninteraction = Interaction.NN,\ninteraction_strength = \"theta\"\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\nregister: Register | int,\ninteraction: Interaction | None = None,\ndetuning: TDetuning | None = None,\ninteraction_strength: TArray | str | None = None,\ndetuning_strength: TArray | str | None = None,\nrandom_strength: bool = False,\nforce_update: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        force_update: force override register detuning and interaction strengths.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n        n_qubits = 3\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\nif interaction is None and detuning is None:\nraise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n# If number of qubits is given, creates all-to-all register\nregister = Register(register) if isinstance(register, int) else register\n# Get interaction function\ntry:\nint_fn = INTERACTION_DICT[interaction]  # type: ignore [index]\nexcept (KeyError, ValueError) as error:\nif interaction is None:\npass\nelse:\nraise KeyError(f\"Interaction {interaction} not supported.\")\n# Check single-qubit detuning\nif (detuning is not None) and (detuning not in DETUNINGS):\nraise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n# Pre-process detuning and interaction strengths and update register\nhas_detuning_strength, detuning_strength = _preprocess_strengths(\nregister, detuning_strength, \"nodes\", force_update, random_strength\n)\nhas_interaction_strength, interaction_strength = _preprocess_strengths(\nregister, interaction_strength, \"edges\", force_update, random_strength\n)\nif (not has_detuning_strength) or force_update:\nregister = _update_detuning_strength(register, detuning_strength)\nif (not has_interaction_strength) or force_update:\nregister = _update_interaction_strength(register, interaction_strength)\n# Create single-qubit detunings:\nsingle_qubit_terms: List[AbstractBlock] = []\nif detuning is not None:\nfor node in register.nodes:\nblock_sq = detuning(node)  # type: ignore [operator]\nstrength_sq = register.nodes[node][\"strength\"]\nsingle_qubit_terms.append(strength_sq * block_sq)\n# Create two-qubit interactions:\ntwo_qubit_terms: List[AbstractBlock] = []\nif interaction is not None:\nfor edge in register.edges:\nblock_tq = int_fn(*edge)  # type: ignore [operator]\nstrength_tq = register.edges[edge][\"strength\"]\ntwo_qubit_terms.append(strength_tq * block_tq)\nreturn add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising NN interaction.\"\"\"\nreturn N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"XY interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Heisenberg XYZ interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising ZZ interaction.\"\"\"\nreturn Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\nn_qubits = 3\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\ninverse: bool = False,\nreverse_in: bool = False,\nswaps_out: bool = False,\nstrategy: Strategy = Strategy.DIGITAL,\ngen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    The Quantum Fourier Transform\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n        n_qubits = 3\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif reverse_in:\nsupport = support[::-1]\nqft_layer_dict = {\nStrategy.DIGITAL: _qft_layer_digital,\nStrategy.SDAQC: _qft_layer_sDAQC,\nStrategy.BDAQC: _qft_layer_bDAQC,\nStrategy.ANALOG: _qft_layer_analog,\n}\ntry:\nlayer_func = qft_layer_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nqft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\nqft_circ = chain(\nlayer_func(\nn_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n)  # type: ignore\nfor layer in qft_layers\n)\nif swaps_out:\nswap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\nqft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\nreturn tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian with another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\nn_qubits = 3\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\ngen_target = 0.1 * (Z(1)@Z(2))\nt_f = 2.0\ntransformed_circuit = daqc_transform(\nn_qubits = n_qubits,\ngen_target = gen_target,\nt_f = t_f,\ngen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\nn_qubits: int,\ngen_target: AbstractBlock,\nt_f: float,\ngen_build: AbstractBlock | None = None,\nzero_tol: float = 1e-08,\nstrategy: Strategy = Strategy.SDAQC,\nignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian\n    with another fixed 2-body Hamiltonian.\n    Reference for universality of 2-body Hamiltonians:\n    -- https://arxiv.org/abs/quant-ph/0106064\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n    -- https://arxiv.org/abs/1812.03637\n    The transform translates a target weighted generator of the type:\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n    To a circuit using analog evolutions with a fixed building block generator:\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n    where `op = Z` or `op = N`.\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n    Notes:\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n        n_qubits = 3\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n        gen_target = 0.1 * (Z(1)@Z(2))\n        t_f = 2.0\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n##################\n# Input controls #\n##################\nif strategy != Strategy.SDAQC:\nraise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\nif n_qubits == 4:\nraise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\nif gen_build is None:\ngen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif (not block_is_qubit_hamiltonian(gen_target)) or (\nnot block_is_qubit_hamiltonian(gen_build)\n):\nraise ValueError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\nexcept NotImplementedError:\n# Happens when block_is_qubit_hamiltonian is called on something that is not a block.\nraise TypeError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\n#####################\n# Generator parsing #\n#####################\ng_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\ng_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n# Get the global phase hamiltonian and single-qubit detuning hamiltonian\nif build_type == GenDAQC.NN:\nh_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\nif target_type == GenDAQC.NN:\nh_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n# Time re-scalings\nif build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\nt_star = t_f / 4.0\nelif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\nt_star = 4.0 * t_f\nelse:\nt_star = t_f\n# Check if target Hamiltonian can be mapped with the build Hamiltonian\nassert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n##################\n# DAQC Transform #\n##################\n# Section III A of https://arxiv.org/abs/1812.03637:\n# Matrix M for the linear system, exemplified in Table I:\nmatrix_M = _build_matrix_M(n_qubits)\n# Linear system mapping interaction ratios -&gt; evolution times.\nt_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n# ZZ-DAQC with ZZ or NN build Hamiltonian\ndaqc_slices = []\nfor m in range(2, n_qubits + 1):\nfor n in range(1, m):\nalpha = _ix_map(n_qubits, n, m)\nt = t_slices[alpha - 1]\nif abs(t) &gt; zero_tol:\nif abs(t) &gt; (1 / (zero_tol**0.5)):\nlogger.warning(\n\"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n)\nx_gates = kron(X(n - 1), X(m - 1))\nanalog_evo = HamEvo(gen_build, t)\n# TODO: Fix repeated X-gates\nif build_type == GenDAQC.NN:\n# Local detuning at each DAQC layer for NN build Hamiltonian\nsq_detuning_build = HamEvo(h_sq_build, t)\ndaqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\nelif build_type == GenDAQC.ZZ:\ndaqc_slices.append(chain(x_gates, analog_evo, x_gates))\ndaqc_circuit = chain(*daqc_slices)\n########################\n# Phases and Detunings #\n########################\nif target_type == GenDAQC.NN:\n# Local detuning given a NN target Hamiltonian\nsq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\ndaqc_circuit = chain(sq_detuning_target, daqc_circuit)\nif not ignore_global_phases:\nif build_type == GenDAQC.NN:\n# Constant global phase given a NN build Hamiltonian\nglobal_phase_build = HamEvo(h_phase_build, t_slices.sum())\ndaqc_circuit = chain(global_phase_build, daqc_circuit)\nif target_type == GenDAQC.NN:\n# Constant global phase and given a NN target Hamiltonian\nglobal_phase_target = HamEvo(h_phase_target, t_f).dagger()\ndaqc_circuit = chain(global_phase_target, daqc_circuit)\nreturn daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\nbasis: str,\nfm_pauli: Type[RY],\nfm_strategy: str,\nn_features: int,\nn_qubits: int,\nspectrum: str,\n) -&gt; list[KronBlock]:\n\"\"\"Builds the index feature maps based on the given parameters.\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\nidx_fms = []\nfor i in range(n_features):\ntarget_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\nparam = FeatureParameter(f\"x{i}\")\nblock = kron(\n*[\nfm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\nfor j, qubit in enumerate(target_qubits)\n]\n)\nidx_fm = block\nidx_fms.append(idx_fm)\nreturn idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n\"\"\"\n    Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.\n    \"\"\"\nspectrum = spectrum.lower()\nconversion_dict: dict[str, float | int] = {\n\"simple\": 1,\n\"tower\": qubit_index + 1,\n\"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n}\nreturn conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n\"\"\"Returns the list of target qubits for the given feature map strategy and feature index\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n    Returns:\n        List[int]: The list of target qubits.\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\nif fm_strategy == \"parallel\":\nn_qubits_per_feature = int(n_qubits / n_features)\ntarget_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\nelif fm_strategy == \"serial\":\ntarget_qubits = range(0, n_qubits)\nelse:\nraise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\nreturn target_qubits\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments (see in the examples).</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\nobservable: Union[list[AbstractBlock], AbstractBlock],\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: Union[DiffMode, str, None] = None,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.expectation` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments\n    (see in the examples).\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\"\"\"\nraise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.run` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    \"\"\"\nraise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Union[Tensor, None] = None,\nn_shots: int = 100,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n\"\"\"Convenience wrapper for the `QuantumModel.sample` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\nraise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function. The default value of each field can be customize with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fce4c357520&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fce4c354ca0&gt;, batch_size=1)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>. Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n\"\"\"Retrieve all trainable model parameters in a single vector\n    Args:\n        model (Module): the input PyTorch model\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\nps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\nreturn torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n\"\"\"Return the total number of parameters of the given model\"\"\"\nreturn len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n\"\"\"Set all trainable parameters of a model from a single vector\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\nwith torch.no_grad():\nidx = 0\nfor ps in model.parameters():\nif ps.requires_grad:\nn = torch.numel(ps)\nif ps.ndim == 0:\nps[()] = theta[idx : idx + n]\nelse:\nps[:] = theta[idx : idx + n].reshape(ps.size())\nidx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.data_to_model","title":"<code>data_to_model(xs, device='cpu')</code>","text":"<p>Default behavior for single-dispatched function</p> <p>Just return the given data independently on the type</p> PARAMETER  DESCRIPTION <code>xs</code> <p>the input data</p> <p> TYPE: <code>Any</code> </p> <code>device</code> <p>The torch device. Not used in this implementation.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>the <code>xs</code> argument untouched</p> <p> TYPE: <code>Any</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>@singledispatch\ndef data_to_model(xs: Any, device: str = \"cpu\") -&gt; Any:\n\"\"\"Default behavior for single-dispatched function\n    Just return the given data independently on the type\n    Args:\n        xs (Any): the input data\n        device (str, optional): The torch device. Not used in this implementation.\n    Returns:\n        Any: the `xs` argument untouched\n    \"\"\"\nreturn xs\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs, device='cpu')</code>","text":"<p>Default Torch optimize step with closure</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> <code>device</code> <p>The device were computations are executed. Defaults to \"cpu\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\nmodel: Module,\noptimizer: Optimizer,\nloss_fn: Callable,\nxs: dict | list | torch.Tensor | None,\ndevice: str = \"cpu\",\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n\"\"\"Default Torch optimize step with closure\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n        device (str, optional): The device were computations are executed.\n            Defaults to \"cpu\".\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\nloss, metrics = None, {}\ndef closure() -&gt; Any:\n# NOTE: We need the nonlocal as we can't return a metric dict and\n# because e.g. LBFGS calls this closure multiple times but for some\n# reason the returned loss is always the first one...\nnonlocal metrics, loss\noptimizer.zero_grad()\nloss, metrics = loss_fn(model, xs)\nloss.backward(retain_graph=True)\nreturn loss.item()\noptimizer.step(closure)\n# return the loss/metrics that are being mutated inside the closure...\nreturn loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n## lets prepare the train routine\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None,\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\"\"\"Runs the training loop with gradient-based optimizer\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence.constructors import hamiltonian_factory, hea, feature_map\n    from qadence import chain, Parameter, QuantumCircuit, Z\n    from qadence.models import QNN\n    from qadence.ml_tools import train_with_grad, TrainConfig\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n    ## lets prepare the train routine\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n        batch_size=batch_size,\n    )\n    batch_size = 25\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    train_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\nassert loss_fn is not None, \"Provide a valid loss function\"\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n## Training\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nif isinstance(dataloader, (list, tuple)):\nfrom qadence.ml_tools.data import to_dataloader\nassert len(dataloader) == 2, \"Please provide exactly two torch tensors.\"\nx, y = dataloader\ndataloader = to_dataloader(x=x, y=y, batch_size=config.batch_size)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\n# outer epoch loop\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\ntry:\n# in case there is not data needed by the model\n# this is the case, for example, of quantum models\n# which do not have classical input data (e.g. chemistry)\nif dataloader is None:\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, dataloader, device=device\n)\nloss = loss.item()\n# single epoch with DictDataloader using a single iteration method\n# DictDataloader returns a single sample of the data\n# with a given batch size decided when the dataloader is defined\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics = optimize_step(model, optimizer, loss_fn, data, device=device)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\n# TODO: make sure to average metrics as well\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, data, device=device\n)\nrunning_loss += loss.item()\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nexcept KeyboardInterrupt:\nprint(\"Terminating training gracefully after the current iteration.\")\nbreak\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | None,\noptimizer: NGOptimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n\"\"\"Runs the training loop with a gradient-free optimizer\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\ndef _update_parameters(\ndata: Tensor | None, ng_params: ng.p.Array\n) -&gt; tuple[float, dict, ng.p.Array]:\nloss, metrics = loss_fn(model, data)  # type: ignore[misc]\noptimizer.tell(ng_params, float(loss))\nng_params = optimizer.ask()  # type: ignore [assignment]\nparams = promote_to_tensor(ng_params.value, requires_grad=False)\nset_parameters(model, params)\nreturn loss, metrics, ng_params\nassert loss_fn is not None, \"Provide a valid loss function\"\n# TODO: support also Scipy optimizers\nassert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n# set optimizer configuration and initial parameters\noptimizer.budget = config.max_iter\noptimizer.enable_pickling()\n# TODO: Make it GPU compatible if possible\nparams = get_parameters(model).detach().numpy()\nng_params = ng.p.Array(init=params)\n# serial training\n# TODO: Add a parallelization using the num_workers argument in Nevergrad\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\nif dataloader is None:\nloss, metrics, ng_params = _update_parameters(None, ng_params)\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nrunning_loss += loss\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nif iteration &gt;= init_iter + config.max_iter:\nbreak\n## Final writing and stuff\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\na11 = 0.5 * (Z(control) - I(control))\na22 = -0.5 * (Z(target) + I(target))\na12 = 0.5 * (chain(X(control), Z(control)) + X(control))\na21 = 0.5 * (chain(Z(target), X(target)) + X(target))\nself.generator = (\nkron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n)\nsuper().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nself.generator = kron((I(control) - Z(control)) * 0.5, X(target) - I(target))\nsuper().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nsuper().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n# TODO: should we give them more meaningful names? like 'angle'?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = X(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Y(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\nself.parameters = ParamMap(parameter=parameter)\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> A block implementing the Hamiltonian evolution operation H where <p>H = exp(-iG, t)</p> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.2374-5.1225e-17j, -0.7288+3.0170e-17j],\n[ 1.1660-4.0583e-17j, -0.5995+2.0868e-17j]])\ntensor([[1.7414-1.2075j, 0.7742-1.1094j],\n[1.3634-0.3266j, 0.4083-0.2874j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ngenerator: Union[TGenerator, AbstractBlock],\nparameter: TParameter,\nqubit_support: tuple[int, ...] = None,\n):\ngen_exprs = {}\nif qubit_support is None and not isinstance(generator, AbstractBlock):\nraise ValueError(\"You have to supply a qubit support for non-block generators.\")\nsuper().__init__(qubit_support if qubit_support else generator.qubit_support)\nif isinstance(generator, AbstractBlock):\nqubit_support = generator.qubit_support\nif generator.is_parametric:\ngen_exprs = {str(e): e for e in expressions(generator)}\nelif isinstance(generator, torch.Tensor):\nmsg = \"Please provide a square generator.\"\nif len(generator.shape) == 2:\nassert generator.shape[0] == generator.shape[1], msg\nelif len(generator.shape) == 3:\nassert generator.shape[1] == generator.shape[2], msg\nassert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\nelse:\nraise TypeError(\n\"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n)\ngen_exprs = {str(generator.__hash__()): generator}\nelif isinstance(generator, (sympy.Basic, sympy.Array)):\ngen_exprs = {str(generator): generator}\nelse:\nraise TypeError(\nf\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n)\nps = {\"parameter\": Parameter(parameter), **gen_exprs}\nself.parameters = ParamMap(**ps)\nself.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n\"\"\"Decompose the Hamiltonian evolution into digital gates\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n# psi(t) = exp(-i * H * t * psi0)\n# psi(t) = exp(-i * lambda * t * psi0)\n# H = sum(Paulin) + sum(Pauli1*Pauli2)\nlogger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\nblocks = []\n# how to change the type/dict to enum effectively\n# when there is a term including non-commuting matrices use st2 or st4\n# 1) should check that the given generator respects the constraints\n# single-qubit gates\nassert isinstance(\nself.generator, AbstractBlock\n), \"Only a generator represented as a block can be decomposed\"\nif block_is_qubit_hamiltonian(self.generator):\ntry:\nblock_is_commuting_hamiltonian(self.generator)\napproximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\nexcept TypeError:\nlogger.warning(\n\"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n)\nblocks.extend(\nlie_trotter_suzuki(\nblock=self.generator,\nparameter=self.parameters.parameter,\norder=LTSOrder[approximation],\n)\n)\n# 2) return an AbstractBlock instance with the set of gates\n# resulting from the decomposition\nreturn chain(*blocks)\nelse:\nraise NotImplementedError(\n\"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\nrydberg_ising_hamiltonian_generator = (\n4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(control)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(target)\n)\nsuper().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global')</code>","text":"<p>Analog X rotation. Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog X rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=0)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global')</code>","text":"<p>Analog Y rotation. Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Y rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=-np.pi / 2)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global')</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nalpha = _cast(Parameter, angle)\ndelta = np.pi\nduration = alpha / delta * 1000\nps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=np.pi / 2)\nreturn ConstantAnalogRotation(qubit_support=q, parameters=ps)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global')</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\nduration: float | str | Parameter = 1000.0,\nomega: float | str | Parameter = 0,\ndelta: float | str | Parameter = 0,\nphase: float | str | Parameter = 0,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"General analog rotation operation.\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nif isinstance(duration, str):\nduration = Parameter(duration)\nalpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000  # type: ignore [operator]\nps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\nreturn ConstantAnalogRotation(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global')</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\nduration: TNumber | sympy.Basic,\nqubit_support: str | QubitSupport | tuple = \"global\",\n) -&gt; WaitBlock:\n\"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n    Returns:\n        a `WaitBlock`\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nps = ParamMap(duration=duration)\nreturn WaitBlock(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names. This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['4887f419-bccc-49fd-8eb4-b8d7b47b1e4d', '6ac770f5-1c6a-40f6-a88a-e12548f9569f'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\nself._name_dict: dict[str, tuple[str, Basic]] = {}\nself._uuid_dict: dict[str, str] = {}\nfor name, v in kwargs.items():\nparam = v if isinstance(v, sympy.Basic) else Parameter(v)\nuuid = str(uuid4())\nself._name_dict[name] = (uuid, param)\nself._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code> to include two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters. Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"PARAMETER  DESCRIPTION <code>name</code> <p>When given a string only, the class constructs a trainable Parameter with a a randomly initialized value.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> </p> <code>**assumptions</code> <p>are passed on to the parent class <code>sympy.Symbol</code>. Two new assumption kwargs are supported by this constructor: <code>trainable: bool</code>, and <code>value: TNumber</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>from qadence import Parameter, VariationalParameter\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.854665659675864\ntheta: trainable=True value=2.0\nexpr=x*y : {x, y}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\ncls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n\"\"\"\n    Arguments:\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Parameter, VariationalParameter\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\np: Parameter\nif isinstance(name, get_args(TNumber)):\nreturn sympify(name)\nelif isinstance(name, Tensor):\nif name.numel() == 1:\nreturn sympify(name)\nelse:\nreturn Array(name.detach().numpy())\nelif isinstance(name, Parameter):\np = super().__new__(cls, name.name, **assumptions)\np.name = name.name\np.trainable = name.trainable\np.value = name.value\nreturn p\nelif isinstance(name, (Basic, Expr)):\nif name.is_number:\nreturn sympify(evaluate(name))\nreturn name\nelif isinstance(name, str):\np = super().__new__(cls, name, **assumptions)\np.trainable = assumptions.get(\"trainable\", True)\np.value = assumptions.get(\"value\", None)\nif p.value is None:\np.value = torch.rand(1).item()\nreturn p\nelse:\nraise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\nreturn Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\nreturn Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> <code>values</code> <p>values dict which contains values for the Parameters, if empty, Parameter.value will be used.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>as_torch</code> <p>Whether to retrieve a torch-differentiable expression result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\nexpr = Parameter(\"x\") * Parameter(\"y\")\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.013496193764961003\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\nres: Basic\nres_value: TNumber | Tensor\nquery: dict[Parameter, TNumber | Tensor] = {}\nif isinstance(expr, Array):\nreturn torch.Tensor(expr.tolist())\nelse:\nif not expr.is_number:\nfor s in expr.free_symbols:\nif s.name in values.keys():\nquery[s] = values[s.name]\nelif hasattr(s, \"value\"):\nquery[s] = s.value\nelse:\nraise ValueError(f\"No value provided for symbol {s.name}\")\nif as_torch:\nres_value = torchify(expr)(**{s.name: torch.tensor(v) for s, v in query.items()})\nelse:\nres = expr.subs(query)\nres_value = sympy_to_numeric(res)\nreturn res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\nparam: Expr,\n) -&gt; TNumber | Tensor | Expr:\n\"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\nreturn param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.torchify","title":"<code>torchify(expr)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> RETURNS DESCRIPTION <code>SymPyModule</code> <p>A torchified, differentiable Expression.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def torchify(expr: Expr) -&gt; SymPyModule:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n    Returns:\n        A torchified, differentiable Expression.\n    \"\"\"\nextra_funcs = {sympy.core.numbers.ImaginaryUnit: 1.0j}\nreturn SymPyModule(expressions=[sympy.N(expr)], extra_funcs=extra_funcs)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level parameters or gate-level parameters. The construced embedding function has the signature:</p> <pre><code> embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\nblock: AbstractBlock, to_gate_params: bool = False\n) -&gt; tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict],]:\n\"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*\n    parameters or *gate-level* parameters. The construced embedding function has the signature:\n         embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\nunique_expressions = unique(expressions(block))\nunique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\nunique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\nunique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n# NOTE\n# there are 3 kinds of parameters in qadence\n# - non-trainable which are considered as inputs for classical data\n# - trainable which are the variational parameters to be optimized\n# - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n#\n# both non-trainable and trainable parameters can have the same element applied\n# to different operations in the quantum circuit, e.g. assigning the same parameter\n# to multiple gates.\nnon_numeric_symbols = [p for p in unique_symbols if not p.is_number]\ntrainable_symbols = [p for p in non_numeric_symbols if p.trainable]\nconstant_expressions = [expr for expr in unique_expressions if expr.is_number]\n# we dont need to care about constant symbols if they are contained in an symbolic expression\n# we only care about gate params which are ONLY a constant\nembeddings: dict[sympy.Expr, sympytorch.SymPyModule] = {\nexpr: torchify(expr) for expr in unique_expressions if not expr.is_number\n}\nuuid_to_expr = uuid_to_expression(block)\ndef embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\nembedded_params: dict[sympy.Expr, Tensor] = {}\nfor expr, fn in embeddings.items():\nangle: Tensor\nvalues = {}\nfor symbol in expr.free_symbols:\nif symbol.name in inputs:\nvalue = inputs[symbol.name]\nelif symbol.name in params:\nvalue = params[symbol.name]\nelse:\nmsg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\nraise KeyError(\nf\"{msg_trainable} parameter '{symbol.name}' not found in the \"\nf\"inputs list: {list(inputs.keys())} nor the \"\nf\"params list: {list(params.keys())}.\"\n)\nvalues[symbol.name] = value\nangle = fn(**values)\n# do not reshape parameters which are multi-dimensional\n# tensors, such as for example generator matrices\nif not len(angle.squeeze().shape) &gt; 1:\nangle = angle.reshape(-1)\nembedded_params[expr] = angle\nfor e in constant_expressions + unique_const_matrices:\nembedded_params[e] = params[stringify(e)]\nif to_gate_params:\ngate_lvl_params: StrTensorDict = {}\nfor uuid, e in uuid_to_expr.items():\ngate_lvl_params[uuid] = embedded_params[e]\nreturn gate_lvl_params\nelse:\nreturn {stringify(k): v for k, v in embedded_params.items()}\nparams: StrTensorDict\nparams = {p.name: torch.tensor([p.value], requires_grad=True) for p in trainable_symbols}\nparams.update(\n{\nstringify(expr): torch.tensor([evaluate(expr)], requires_grad=False)\nfor expr in constant_expressions\n}\n)\nparams.update(\n{\nstringify(expr): torch.tensor(\nnp.array(expr.tolist(), dtype=np.cdouble), requires_grad=False\n)\nfor expr in unique_const_matrices\n}\n)\nreturn params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>A QuantumCircuit instance is completely abstract and it needs to be passed to a quantum backend in order to be executed.</p> PARAMETER  DESCRIPTION <code>support</code> <p><code>Register</code> or number of qubits. If an integer is provided, a register is constructed with <code>Register.all_to_all(x)</code></p> <p> TYPE: <code>int | Register</code> </p> <code>*blocks</code> <p>(Possibly multiple) blocks to construct the circuit from.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>()</code> </p> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n\"\"\"\n    Arguments:\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\nself.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\nself.register = Register(support) if isinstance(support, int) else support\nglobal_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\nif not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\nraise ValueError(\nf\"Register with {self.register.n_qubits} qubits is too small for the \"\nf\"given block with {self.block.n_qubits} qubits\"\n)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n\"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\nreturn QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n\"\"\"Extract one or more blocks using the human-readable tag\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n    Args:\n        tag (str): the tag to look for\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\ndef _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\nblocks = []\nif block.tag == tag:\nblocks += [block]\nif isinstance(block, CompositeBlock):\nblocks += flatten(*[_get_block(b) for b in block.blocks])\nreturn blocks\nreturn _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n\"\"\"Extract all parameters for primitive blocks in the circuit\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\nreturn parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support)</code>","text":"<p>A 2D register of qubits which includes their coordinates (needed for e.g. analog computing). The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <p>Examples: <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(self, support: nx.Graph | int):\n\"\"\"A 2D register of qubits which includes their coordinates (needed for e.g. analog\n    computing). The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\nself.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits, spacing=1.0)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int, spacing: float = 1.0) -&gt; nx.Graph:\n\"\"\"Create graph representing linear lattice.\n    Args:\n        n_qubits (int): number of nodes in the graph\n    Returns:\n        graph instance\n    \"\"\"\ngraph = nx.Graph()\nfor i in range(n_qubits):\ngraph.add_node(i, pos=(i * spacing, 0.0))\nfor i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\ngraph.add_edge(i, j)\nreturn graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('8d19c8ad-8f4a-4255-a1e4-3126df0bd78a', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9649102256983412'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('915e9d8e-71e2-4839-b29c-b0260b9ed0c6', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.855299175233669'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('335adb53-b48a-4a53-8daf-fd868276e961', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.4821242625372467'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('c6542fa1-5754-44a3-9c21-107db9e006cc', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.7216139771883192'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e44ce756-ae92-45a0-b30d-f2a884b21c75', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.5520005343296959'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5045f87a-b546-434a-9855-9fa2dde8e4c0', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.5128236248712018'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nobj: Any\nif d.get(\"expression\"):\nexpr = eval(d[\"expression\"])\nif hasattr(expr, \"free_symbols\"):\nfor symb in expr.free_symbols:\nsymb.value = float(d[\"symbols\"][symb.name][\"value\"])\nobj = expr\nelif d.get(\"QuantumModel\"):\nobj = QuantumModel._from_dict(d, as_torch)\nelif d.get(\"QNN\"):\nobj = QNN._from_dict(d, as_torch)\nelif d.get(\"TransformedModule\"):\nobj = TransformedModule._from_dict(d, as_torch)\nelif d.get(\"block\") and d.get(\"register\"):\nobj = QuantumCircuit._from_dict(d)\nelif d.get(\"graph\"):\nobj = Register._from_dict(d)\nelif d.get(\"type\"):\nif d[\"type\"] in ALL_BLOCK_NAMES:\nblock: AbstractBlock = (\ngetattr(operations, d[\"type\"])._from_dict(d)\nif hasattr(operations, d[\"type\"])\nelse getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n)\nif d[\"tag\"] is not None:\nblock = tag(block, d[\"tag\"])\nobj = block\nelse:\nimport warnings\nmsg = warnings.warn(\n\"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n)\ntry:\nmodule_name = list(d.keys())[0]\nobj = getattr(globals(), module_name)\nobj.load_state_dict(d[module_name])\nexcept Exception as e:\nlogger.error(\nTypeError(\nf\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n)\n)\nreturn obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nd = {}\nif isinstance(file_path, str):\nfile_path = Path(file_path)\nif not os.path.exists(file_path):\nlogger.error(f\"File {file_path} not found.\")\nraise FileNotFoundError\nFORMAT = file_extension(file_path)\n_, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\ntry:\nd = load_fn(file_path, map_location)\nlogger.debug(f\"Successfully loaded {d} from {file_path}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to load Object from {file_path} due to {e}\")\nreturn deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\nobj: SUPPORTED_TYPES,\nfolder: str | Path,\nfile_name: str = \"\",\nformat: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(f\"Serialization of object type {type(obj)} not supported.\")\nfolder = Path(folder)\nif not folder.is_dir():\nlogger.error(NotADirectoryError)\nif file_name == \"\":\nfile_name = type(obj).__name__\ntry:\nsuffix, save_fn, _, save_params = FORMAT_DICT[format]\nd = serialize(obj, save_params)\nfile_path = folder / Path(file_name + suffix)\nsave_fn(d, file_path)\nlogger.debug(f\"Successfully saved {obj} from to {folder}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('f42339f0-05d6-4d9b-b995-954be8179c7e', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.7262773469971591'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('294fa7d5-28a4-414a-85fd-56e613a16ba2', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.9592730319839947'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e72f9f3d-d252-403c-8a2b-2dc7cb3c0afa', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.29853362350562773'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('bfabe27f-0001-4877-a86e-d677eb02a306', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.8358036266838368'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('f0448b1d-7bef-4f9f-9abc-b2fd0088201b', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.5395678859265043'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('15af2a0e-6fc5-402e-be63-4edcbc409081', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.3978401946895035'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\nd: dict = {}\ntry:\nif isinstance(obj, Expr):\nsymb_dict = {}\nexpr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\nsymbs: set[Parameter | Basic] = obj.free_symbols\nif symbs:\nsymb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\nd = {**expr_dict, **symb_dict}\nelif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\nd = obj._to_dict(save_params)\nelif isinstance(obj, torch.nn.Module):\nd = {type(obj).__name__: obj.state_dict()}\nelse:\nd = obj._to_dict()\nexcept Exception as e:\nlogger.error(f\"Serialization of object {obj} failed due to {e}\")\nreturn d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n\"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A ChainBlock representing the GHZ state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\ncnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\nreturn chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a GHZ state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2))\nreturn norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n\"\"\"\n    Checks if a wave function is normalized.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n    Returns:\n        A bool.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nwf = wf.unsqueeze(0)\nsum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\nones = torch.ones_like(sum_probs)\nreturn torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n\"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum())\nelse:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the one state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"1\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n\"\"\"\n    Converts a wave function into a torch Distribution.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n    Returns:\n        A torch.distributions.Distribution.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\nreturn Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n\"\"\"\n    Creates an abstract product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\nreturn _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\nbitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n\"\"\"\n    Creates a product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\nreturn _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>11100010\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n\"\"\"\n    Creates a random bistring.\n    Arguments:\n        N (int): The length of the bitstring.\n    Returns:\n        A string.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\nreturn \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Creates a block representing a random abstract product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\nreturn product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a random product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nwf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\nrand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\nwf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\nreturn wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.backend import BackendName\nfrom torch.distributions import Distribution\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[0.3686-0.0605j, 0.2386+0.1186j, 0.0478+0.7804j, 0.0436-0.4199j]])\ntensor([[0.9998-0.0222j, 0.0000+0.0000j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\nn_qubits: int,\nbatch_size: int = 1,\nbackend: str = BackendName.PYQTORCH,\ntype: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n\"\"\"\n    Generates a random state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.backend import BackendName\n    from torch.distributions import Distribution\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\nif type == StateGeneratorType.HAAR_MEASURE_FAST:\nstate = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.HAAR_MEASURE_SLOW:\nstate = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.RANDOM_ROTATIONS:\nstate = _run_state(_abstract_random_state(n_qubits, batch_size), backend)  # type: ignore\nassert all(list(map(is_normalized, state)))\nreturn state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the uniform state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\nreturn norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the zero state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"0\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation. Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n@blockfn_to_circfn\ndef fn(block):\n# un-decorated function accepts a block and returns a block\nreturn block * block\ntransp = transpile(\n# the decorated function accepts a circuit and returns a circuit\nfn,\n# already existing functions can also be decorated\nblockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n\"\"\"`AbstractBlock` or `QuantumCircuit` transpilation. Compose functions that\n    accept a circuit/block and returns a circuit/block.\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n    Returns:\n        Composed function.\n    Examples:\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\nreturn lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\nif is_chain_of_primitivekrons(block):\ntry:\nreturn kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\nexcept Exception as e:\nlogger.debug(\nf\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n)\nreturn block\nelif isinstance(block, CompositeBlock):\nreturn _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.flatten","title":"<code>flatten(block, types=[ChainBlock, KronBlock, AddBlock])</code>","text":"<p>Flattens the given types of <code>CompositeBlock</code>s if possible.</p> <p>Example: <pre><code>from qadence import chain, kron, X\nfrom qadence.transpile import flatten\nfrom qadence.blocks import ChainBlock, KronBlock, AddBlock\nx = chain(chain(chain(X(0))), kron(kron(X(0))))\n# flatten only `ChainBlock`s\nassert flatten(x, [ChainBlock]) == chain(X(0), kron(kron(X(0))))\n# flatten `ChainBlock`s and `KronBlock`s\nassert flatten(x, [ChainBlock, KronBlock]) == chain(X(0), kron(X(0)))\n# flatten `AddBlock`s (does nothing in this case)\nassert flatten(x, [AddBlock]) == x\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def flatten(block: AbstractBlock, types: list = [ChainBlock, KronBlock, AddBlock]) -&gt; AbstractBlock:\n\"\"\"Flattens the given types of `CompositeBlock`s if possible.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import chain, kron, X\n    from qadence.transpile import flatten\n    from qadence.blocks import ChainBlock, KronBlock, AddBlock\n    x = chain(chain(chain(X(0))), kron(kron(X(0))))\n    # flatten only `ChainBlock`s\n    assert flatten(x, [ChainBlock]) == chain(X(0), kron(kron(X(0))))\n    # flatten `ChainBlock`s and `KronBlock`s\n    assert flatten(x, [ChainBlock, KronBlock]) == chain(X(0), kron(X(0)))\n    # flatten `AddBlock`s (does nothing in this case)\n    assert flatten(x, [AddBlock]) == x\n    ```\n    \"\"\"\nif isinstance(block, CompositeBlock):\ndef fn(b: AbstractBlock, T: Type) -&gt; AbstractBlock:\nreturn _construct(type(block), tuple(_flat_blocks(b, T)))\nreturn reduce(fn, types, block)  # type: ignore[arg-type]\nelif isinstance(block, ScaleBlock):\nblk = deepcopy(block)\nblk.block = flatten(block.block, types=types)\nreturn blk\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks, move the scale all the way down into the leaves of the block tree.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 ChainBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n\"\"\"When given a scaled CompositeBlock consisting of several PrimitiveBlocks,\n    move the scale all the way down into the leaves of the block tree.\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n    Examples:\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\nraise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\nblocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n\"\"\"Set the trainability of all parameters in a block to a given value\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\nif isinstance(blocks, AbstractBlock):\nblocks = [blocks]\nif inplace:\nfor block in blocks:\nparams: list[sympy.Basic] = parameters(block)\nfor p in params:\nif not p.is_number:\np.trainable = value\nelse:\nraise NotImplementedError(\"Not inplace set_trainable is not yet available\")\nreturn blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks and reassigning qubit locations approriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n\u2514\u2500\u2500 ChainBlock(0)\n\u2514\u2500\u2500 put on (0)\n\u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Moves a block from global to local qubit numbers by adding PutBlocks and reassigning\n    qubit locations approriately.\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\nvblock: AbstractBlock\nfrom qadence.transpile import reassign\nif isinstance(block, ControlBlock):\nvblock = deepcopy(block)\nb: AbstractBlock\n(b,) = block.blocks\nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nb = validate(b)\nvblock.blocks = (b,)  # type: ignore[assignment]\nelif isinstance(block, CompositeBlock):\nblocks = []\nfor b in block.blocks:\nmi, ma = min(b.qubit_support), max(b.qubit_support)\nnb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nnb = validate(nb)\nnb = PutBlock(nb, tuple(range(mi, ma + 1)))\nblocks.append(nb)\ntry:\nvblock = _construct(type(block), tuple(blocks))\nexcept AssertionError as e:\nif str(e) == \"Make sure blocks act on distinct qubits!\":\nvblock = chain(*blocks)\nelse:\nraise e\nelif isinstance(block, PrimitiveBlock):\nvblock = deepcopy(block)\nelse:\nraise NotImplementedError\nvblock.tag = block.tag\nreturn vblock\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.emulate.add_interaction","title":"<code>add_interaction(x, *args, interaction=Interaction.NN, spacing=1.0)</code>","text":"<p>Turns blocks or circuits into (a chain of) <code>HamEvo</code> blocks including a chosen interaction term.</p> <p>This is a <code>@singledipatch</code>ed function which can be called in three ways:</p> <ul> <li>With a <code>QuantumCircuit</code> which contains all necessary information: <code>add_interaction(circuit)</code></li> <li>With a <code>Register</code> and an <code>AbstractBlock</code>: <code>add_interaction(reg, block)</code></li> <li>With an <code>AbstractBlock</code> only: <code>add_interaction(block)</code></li> </ul> <p>See the section about analog blocks for detailed information about how which types of blocks are translated.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit or block to be emulated. See the examples on which argument combinations are accepted.</p> <p> TYPE: <code>Register | QuantumCircuit | AbstractBlock</code> </p> <code>interaction</code> <p>Type of interaction that is added. Can also be a function that accepts a register and a list of edges that define which qubits interact (see the examples).</p> <p> TYPE: <code>Interaction | Callable</code> DEFAULT: <code>NN</code> </p> <code>spacing</code> <p>All qubit coordinates are multiplied by <code>spacing</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import QuantumCircuit, AnalogRX, add_interaction\nc = QuantumCircuit(2, AnalogRX(2.0))\ne = add_interaction(c)\n</code></pre> <pre><code>[mul: 0.0] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 AddBlock(0,1)\n\u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u251c\u2500\u2500 [mul: 1.571] \u2502       \u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u2502       \u251c\u2500\u2500 AddBlock(0)\n\u2502       \u2502       \u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502       \u2502   \u2502   \u2514\u2500\u2500 X(0)\n\u2502       \u2502       \u2502   \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502       \u2502       \u2514\u2500\u2500 Y(0)\n\u2502       \u2502       \u2514\u2500\u2500 AddBlock(1)\n\u2502       \u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502           \u2502   \u2514\u2500\u2500 X(1)\n\u2502       \u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502               \u2514\u2500\u2500 Y(1)\n\u2502       \u2514\u2500\u2500 [mul: 0.0] \u2502           \u2514\u2500\u2500 AddBlock(0,1)\n\u2502               \u251c\u2500\u2500 N(0)\n\u2502               \u2514\u2500\u2500 N(1)\n\u2514\u2500\u2500 AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 865723.020] \u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 N(0)\n\u2514\u2500\u2500 N(1)\n</code></pre>  You can also use <code>add_interaction</code> directly on a block, but you have to provide either the <code>Register</code> or define a non-global qubit support. <pre><code>from qadence import AnalogRX, Register, add_interaction\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b)\n# or provide only the block with local qubit support\n# in this case the register is created via `Register(b.n_qubits)`\ne = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\nprint(e.generator)\n</code></pre> <pre><code>[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n</code></pre>  You can specify a custom <code>interaction</code> function which has to accept a <code>Register</code> and a list of <code>edges: list[tuple[int, int]]</code>: <pre><code>from qadence import AnalogRX, Register, add_interaction\nfrom qadence.transpile.emulate import ising_interaction\ndef int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n# do either something completely custom\n# ...\n# or e.g. change the default kwargs to `ising_interaction`\nreturn ising_interaction(r, pairs, rydberg_level=70)\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b, interaction=int_fn)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/emulate.py</code> <pre><code>@singledispatch\ndef add_interaction(\nx: Register | QuantumCircuit | AbstractBlock,\n*args: Any,\ninteraction: Interaction | Callable = Interaction.NN,\nspacing: float = 1.0,\n) -&gt; QuantumCircuit | AbstractBlock:\n\"\"\"Turns blocks or circuits into (a chain of) `HamEvo` blocks including a\n    chosen interaction term.\n    This is a `@singledipatch`ed function which can be called in three ways:\n    * With a `QuantumCircuit` which contains all necessary information: `add_interaction(circuit)`\n    * With a `Register` and an `AbstractBlock`: `add_interaction(reg, block)`\n    * With an `AbstractBlock` only: `add_interaction(block)`\n    See the section about [analog blocks](/digital_analog_qc/analog-basics.md) for\n    detailed information about how which types of blocks are translated.\n    Arguments:\n        x: Circuit or block to be emulated. See the examples on which argument\n            combinations are accepted.\n        interaction: Type of interaction that is added. Can also be a function that accepts a\n            register and a list of edges that define which qubits interact (see the examples).\n        spacing: All qubit coordinates are multiplied by `spacing`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import QuantumCircuit, AnalogRX, add_interaction\n    c = QuantumCircuit(2, AnalogRX(2.0))\n    e = add_interaction(c)\n    print(str(e.block.generator)) # markdown-exec: hide\n    ```\n    You can also use `add_interaction` directly on a block, but you have to provide either\n    the `Register` or define a non-global qubit support.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b)\n    print(e.generator) # markdown-exec: hide\n    # or provide only the block with local qubit support\n    # in this case the register is created via `Register(b.n_qubits)`\n    e = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\n    print(e.generator)\n    ```\n    You can specify a custom `interaction` function which has to accept a `Register` and a list\n    of `edges: list[tuple[int, int]]`:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    from qadence.transpile.emulate import ising_interaction\n    def int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n        # do either something completely custom\n        # ...\n        # or e.g. change the default kwargs to `ising_interaction`\n        return ising_interaction(r, pairs, rydberg_level=70)\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b, interaction=int_fn)\n    ```\n    \"\"\"\nraise ValueError(f\"`add_interaction` is not implemented for {type(x)}\")\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, torch.Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[torch.Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, torch.Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in - <code>add_interaction</code>. - <code>hamiltonian_factory</code>.</p>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Used when dumping enum fields in a schema.\"\"\"\nret: str = self.value\nreturn ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML) [^1] in particular are the target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\nn_qubits = 4\nfp = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(RX(i, 2 * acos(fp)) for i in range(n_qubits))\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(feature_map, values=inputs)\nprint(samples)\n</code></pre>   [Counter({'1111': 75, '1011': 9, '0111': 6, '1101': 4, '1110': 4, '0110': 2}), Counter({'1111': 24, '1110': 16, '1101': 9, '0111': 8, '1001': 7, '0011': 6, '0110': 6, '0100': 5, '1010': 5, '1011': 5, '0101': 3, '0010': 2, '1100': 2, '0000': 1, '0001': 1}), Counter({'0000': 28, '1000': 14, '0001': 12, '0010': 6, '0100': 6, '0101': 6, '1100': 6, '0011': 5, '0110': 4, '1001': 4, '1011': 2, '1101': 2, '1110': 2, '0111': 1, '1010': 1, '1111': 1})]    <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nobservable = qd.kron(X(0), X(1))\nmodel = qd.QNN(circuit, observable)\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\nprint(f\"Quantum model output: {out}\")\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: {dout}\")\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre>   Quantum model output: tensor([[0.1904],         [0.3953],         [0.2193],         [0.0431],         [0.2558],         [0.3160],         [0.0408],         [0.4406],         [0.4627],         [0.4138]], grad_fn=) First-order derivative w.r.t. the feature parameter: tensor([ 0.5730,  0.6237,  0.6140, -1.0375,  0.6560,  0.6914, -0.9687, -0.5948,         -0.1979, -0.8826], grad_fn=)    <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: {dout}\")\n</code></pre>   First-order derivative w.r.t. the feature parameter: tensor([ 0.5730,  0.6237,  0.6140, -1.0375,  0.6560,  0.6914, -0.9687, -0.5948,         -0.1979, -0.8826], grad_fn=)    <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\nnx.draw(graph)\n</code></pre> 2023-10-17T16:39:49.254181 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\nn_qubits = graph.number_of_nodes()\nn_layers = 2\ncost_ham = Zero()\nfor op in zz_ops:\ncost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\nlayers = []\nfor layer in range(n_layers):\n# cost layer with digital decomposition\ncost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\ncost_layer = tag(cost_layer, \"cost\")\n# mixing layer with single qubit rotations\nmixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\nmixing_layer = tag(mixing_layer, \"mixing\")\n# putting all together in a single ChainBlock\nlayers.append(chain(cost_layer, mixing_layer))\nfinal_b = chain(*layers)\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_68efd9a62f1242e093fa281b10363a8d mixing cluster_e26360bc93924f528dafae5ff929181a cost cluster_378e8a2e5efe4890ae9c489725d10ec0 mixing cluster_c157b48a75e545dea93ea4dadacdbd81 cost 730efa6d766b43d4a87957ef019bdfd6 0 c221505775554af7848a3c0166f1883e 730efa6d766b43d4a87957ef019bdfd6--c221505775554af7848a3c0166f1883e 303f1ece6e434f5dbe82ee030249a7ab 1 0716ef3857074b05b011a00d146248c4 c221505775554af7848a3c0166f1883e--0716ef3857074b05b011a00d146248c4 75cc3cc101ca460196c632bbcb6d0e02 0716ef3857074b05b011a00d146248c4--75cc3cc101ca460196c632bbcb6d0e02 c773a42f592d485aa380ed2c59c04f11 75cc3cc101ca460196c632bbcb6d0e02--c773a42f592d485aa380ed2c59c04f11 5f62122e7f3a49499ef32b1074a39d22 c773a42f592d485aa380ed2c59c04f11--5f62122e7f3a49499ef32b1074a39d22 0c9df9df00934df0812f483171f0cfff 5f62122e7f3a49499ef32b1074a39d22--0c9df9df00934df0812f483171f0cfff 3a0d642d76624c75b30facf91147aa4a 0c9df9df00934df0812f483171f0cfff--3a0d642d76624c75b30facf91147aa4a ab12ada224914bcc83678632ac999f5a 3a0d642d76624c75b30facf91147aa4a--ab12ada224914bcc83678632ac999f5a aaf36edf29e644758b68f622e49f7f59 ab12ada224914bcc83678632ac999f5a--aaf36edf29e644758b68f622e49f7f59 5ffcbc6cd165498e8edb4aad50ea5403 aaf36edf29e644758b68f622e49f7f59--5ffcbc6cd165498e8edb4aad50ea5403 98218f06c1364b79b8dd3e62908354cc 5ffcbc6cd165498e8edb4aad50ea5403--98218f06c1364b79b8dd3e62908354cc e247fbe976114c8e9d579c2b56ee81e2 98218f06c1364b79b8dd3e62908354cc--e247fbe976114c8e9d579c2b56ee81e2 0cd625a0f6854948b2f351f8a7117227 e247fbe976114c8e9d579c2b56ee81e2--0cd625a0f6854948b2f351f8a7117227 f4e367bd840941e2b0ebcabf0f85ba26 0cd625a0f6854948b2f351f8a7117227--f4e367bd840941e2b0ebcabf0f85ba26 65f5356f79a346429caefd22734ea086 f4e367bd840941e2b0ebcabf0f85ba26--65f5356f79a346429caefd22734ea086 f87fd1c60518490bbf7760ccdcb1b48b 65f5356f79a346429caefd22734ea086--f87fd1c60518490bbf7760ccdcb1b48b 177f77d4e75e4c30b140aa288b4a01f9 f87fd1c60518490bbf7760ccdcb1b48b--177f77d4e75e4c30b140aa288b4a01f9 f74ba24862df480285cc85e2df4e5afa 177f77d4e75e4c30b140aa288b4a01f9--f74ba24862df480285cc85e2df4e5afa 886f33eaf56e4065be7ed3f1bef6ea53 f74ba24862df480285cc85e2df4e5afa--886f33eaf56e4065be7ed3f1bef6ea53 691631426a094ceca32c85ff8bcc2e04 886f33eaf56e4065be7ed3f1bef6ea53--691631426a094ceca32c85ff8bcc2e04 dc4272b5df3f4ef8b51664c9ce921bcc 691631426a094ceca32c85ff8bcc2e04--dc4272b5df3f4ef8b51664c9ce921bcc 335a2988bee34092a51ed8393ed424e6 dc4272b5df3f4ef8b51664c9ce921bcc--335a2988bee34092a51ed8393ed424e6 1781d1ee6dc648668ed3b756bb6c214a 335a2988bee34092a51ed8393ed424e6--1781d1ee6dc648668ed3b756bb6c214a 3c952b9a002b45ada57bae6b63b9f906 1781d1ee6dc648668ed3b756bb6c214a--3c952b9a002b45ada57bae6b63b9f906 7f4b9530f4b84c54904fd5806ec0b94d 3c952b9a002b45ada57bae6b63b9f906--7f4b9530f4b84c54904fd5806ec0b94d ef22423f751540ab91a2f29a5195aa18 7f4b9530f4b84c54904fd5806ec0b94d--ef22423f751540ab91a2f29a5195aa18 070de7f78436477b8ec51467300fc52d ef22423f751540ab91a2f29a5195aa18--070de7f78436477b8ec51467300fc52d 9a10d887d6794b46986818e15c84130e 070de7f78436477b8ec51467300fc52d--9a10d887d6794b46986818e15c84130e f1ff028479814342a65e07fe63e08a7a 9a10d887d6794b46986818e15c84130e--f1ff028479814342a65e07fe63e08a7a c5494b665d364182b32c64d0adc5556a f1ff028479814342a65e07fe63e08a7a--c5494b665d364182b32c64d0adc5556a 043d11cd0c07474dbe4352b274989376 c5494b665d364182b32c64d0adc5556a--043d11cd0c07474dbe4352b274989376 c314b9e69e86491da64e8c08e16125fe 043d11cd0c07474dbe4352b274989376--c314b9e69e86491da64e8c08e16125fe 203ff9c51bad47be834dae29081b82f7 c314b9e69e86491da64e8c08e16125fe--203ff9c51bad47be834dae29081b82f7 df0f79f18fef479b887cb5bdbbf60214 203ff9c51bad47be834dae29081b82f7--df0f79f18fef479b887cb5bdbbf60214 7d693c9955124fe1845d66659b534718 df0f79f18fef479b887cb5bdbbf60214--7d693c9955124fe1845d66659b534718 5abbe60bcdaa499887b6b936c129d7c1 7d693c9955124fe1845d66659b534718--5abbe60bcdaa499887b6b936c129d7c1 10154e452d374f56b2c1c3ee2334c13d 5abbe60bcdaa499887b6b936c129d7c1--10154e452d374f56b2c1c3ee2334c13d 7a6ff30837b8476faf6608dc94616889 10154e452d374f56b2c1c3ee2334c13d--7a6ff30837b8476faf6608dc94616889 5a33ea775ffa4bde9d5bfa78c3f05853 7a6ff30837b8476faf6608dc94616889--5a33ea775ffa4bde9d5bfa78c3f05853 bc58914c26214f8f810fdc776698a914 5a33ea775ffa4bde9d5bfa78c3f05853--bc58914c26214f8f810fdc776698a914 719dbb84fac4423a887b400bab24d64d bc58914c26214f8f810fdc776698a914--719dbb84fac4423a887b400bab24d64d f2047f1439194a898d64ab01f9268616 719dbb84fac4423a887b400bab24d64d--f2047f1439194a898d64ab01f9268616 c1d4d55a92454bb5bf68c4f0704bfc90 f2047f1439194a898d64ab01f9268616--c1d4d55a92454bb5bf68c4f0704bfc90 147990d6fee54104a6a9ecc594f800c6 c1d4d55a92454bb5bf68c4f0704bfc90--147990d6fee54104a6a9ecc594f800c6 1d562116fe04412eaa9a39d7b4824efc 147990d6fee54104a6a9ecc594f800c6--1d562116fe04412eaa9a39d7b4824efc 1c91bcf334474d4ca1bc31e0fd38a7d9 1d562116fe04412eaa9a39d7b4824efc--1c91bcf334474d4ca1bc31e0fd38a7d9 082074fb9f4c456e9aa12d0fb952dcb3 1c91bcf334474d4ca1bc31e0fd38a7d9--082074fb9f4c456e9aa12d0fb952dcb3 2193fd3418d945fe8df23e14ddcbd29a 082074fb9f4c456e9aa12d0fb952dcb3--2193fd3418d945fe8df23e14ddcbd29a 2ccec157b1624a008684954cc1eb53cc 2193fd3418d945fe8df23e14ddcbd29a--2ccec157b1624a008684954cc1eb53cc 3def346d1a6c4aff98e84d39b2e36108 2ccec157b1624a008684954cc1eb53cc--3def346d1a6c4aff98e84d39b2e36108 c668f403d1c44dbda8ea6c410e77b75e 3def346d1a6c4aff98e84d39b2e36108--c668f403d1c44dbda8ea6c410e77b75e 1e61f5f5e5d546ad9c6405d0027cb531 c668f403d1c44dbda8ea6c410e77b75e--1e61f5f5e5d546ad9c6405d0027cb531 09e1c08aceb24d62aad9b80fe8067b36 1e61f5f5e5d546ad9c6405d0027cb531--09e1c08aceb24d62aad9b80fe8067b36 572ff95a52c148b3b4233a6516782806 09e1c08aceb24d62aad9b80fe8067b36--572ff95a52c148b3b4233a6516782806 0a84b846c6004650b7ed83155ef1523a 572ff95a52c148b3b4233a6516782806--0a84b846c6004650b7ed83155ef1523a cb08eb0f85e14b66a43b7dbbf2f78104 0a84b846c6004650b7ed83155ef1523a--cb08eb0f85e14b66a43b7dbbf2f78104 0bede61de0bd4685ac2e322d1f57fbd9 cb08eb0f85e14b66a43b7dbbf2f78104--0bede61de0bd4685ac2e322d1f57fbd9 3ba99dfd9ba24781a6393968b7a9bd63 0bede61de0bd4685ac2e322d1f57fbd9--3ba99dfd9ba24781a6393968b7a9bd63 6cc514d6943f41f9aeed3786a062b1ef 3ba99dfd9ba24781a6393968b7a9bd63--6cc514d6943f41f9aeed3786a062b1ef d3dd2a0954d34d4ab06052b34aa56f90 6cc514d6943f41f9aeed3786a062b1ef--d3dd2a0954d34d4ab06052b34aa56f90 9d307066f0ae481e8ff4b034403f7a92 d3dd2a0954d34d4ab06052b34aa56f90--9d307066f0ae481e8ff4b034403f7a92 9d9d146f68c64abea36851e197d98c5e 9d307066f0ae481e8ff4b034403f7a92--9d9d146f68c64abea36851e197d98c5e 1eec496c68e4457aa6ba5c9ab69ccd42 9d9d146f68c64abea36851e197d98c5e--1eec496c68e4457aa6ba5c9ab69ccd42 06eac11d9e1a433ebd76b5145f9d2e2e 1eec496c68e4457aa6ba5c9ab69ccd42--06eac11d9e1a433ebd76b5145f9d2e2e 1a816f9b428e46ea86778a5cbf2e6655 06eac11d9e1a433ebd76b5145f9d2e2e--1a816f9b428e46ea86778a5cbf2e6655 bb157a2db9394ac5b08bea36af2fed74 1a816f9b428e46ea86778a5cbf2e6655--bb157a2db9394ac5b08bea36af2fed74 e8ecc301cf504f178cc86eac21bb515c bb157a2db9394ac5b08bea36af2fed74--e8ecc301cf504f178cc86eac21bb515c e16631f166b44c23958807115d58c0a2 e8ecc301cf504f178cc86eac21bb515c--e16631f166b44c23958807115d58c0a2 96dc2c3d935b4a91b3a3acb6b945e838 e16631f166b44c23958807115d58c0a2--96dc2c3d935b4a91b3a3acb6b945e838 c148477496a34ba09c01a9bb38b22497 96dc2c3d935b4a91b3a3acb6b945e838--c148477496a34ba09c01a9bb38b22497 b79d4a3bfcd64784b1f7730e3787b323 c148477496a34ba09c01a9bb38b22497--b79d4a3bfcd64784b1f7730e3787b323 acbed43030a74f2ba4361d8e9bbb8300 b79d4a3bfcd64784b1f7730e3787b323--acbed43030a74f2ba4361d8e9bbb8300 f821632512d845f7b3bade3cca1f2d65 acbed43030a74f2ba4361d8e9bbb8300--f821632512d845f7b3bade3cca1f2d65 55c15471953048b69447386030333308 f821632512d845f7b3bade3cca1f2d65--55c15471953048b69447386030333308 4ff0d3948e4346419d3252fd286602ac 55c15471953048b69447386030333308--4ff0d3948e4346419d3252fd286602ac 35165a82cbfd4e319dfee32ea93db8b2 4ff0d3948e4346419d3252fd286602ac--35165a82cbfd4e319dfee32ea93db8b2 992a3f0db20b4c3d96c538c6d87c9865 35165a82cbfd4e319dfee32ea93db8b2--992a3f0db20b4c3d96c538c6d87c9865 97c6717978144ddebb74382e20c2ed21 992a3f0db20b4c3d96c538c6d87c9865--97c6717978144ddebb74382e20c2ed21 7e8193c3595140f5a9c61ac5b54e2799 97c6717978144ddebb74382e20c2ed21--7e8193c3595140f5a9c61ac5b54e2799 50ba5bc359404fb6bd91044e70e22b84 7e8193c3595140f5a9c61ac5b54e2799--50ba5bc359404fb6bd91044e70e22b84 01fdd2901dd64483b85ffa67657b434d 50ba5bc359404fb6bd91044e70e22b84--01fdd2901dd64483b85ffa67657b434d 2f90350f460c4e53be01eebf29cd9b0b 01fdd2901dd64483b85ffa67657b434d--2f90350f460c4e53be01eebf29cd9b0b de28e98f8ae540a0a2dbeda46c947e3b 2f90350f460c4e53be01eebf29cd9b0b--de28e98f8ae540a0a2dbeda46c947e3b c56c9ffc21044e64b7a6614220634a8c de28e98f8ae540a0a2dbeda46c947e3b--c56c9ffc21044e64b7a6614220634a8c 0f1efee393064fa5937e9cd9aed23e4b c56c9ffc21044e64b7a6614220634a8c--0f1efee393064fa5937e9cd9aed23e4b bef59efb872d49b0a7d9053a2c865c31 0f1efee393064fa5937e9cd9aed23e4b--bef59efb872d49b0a7d9053a2c865c31 6d734fb8c2444e85987db623189d8396 bef59efb872d49b0a7d9053a2c865c31--6d734fb8c2444e85987db623189d8396 04900c1a6fb6442a843ed037f8952891 6d734fb8c2444e85987db623189d8396--04900c1a6fb6442a843ed037f8952891 d3d553f9135849c7b322f198f7f958d6 04900c1a6fb6442a843ed037f8952891--d3d553f9135849c7b322f198f7f958d6 3c88707c3b15435aa427d7955aa805c3 d3d553f9135849c7b322f198f7f958d6--3c88707c3b15435aa427d7955aa805c3 c1343073519840b186a2a69f4504254c 3c88707c3b15435aa427d7955aa805c3--c1343073519840b186a2a69f4504254c 311c8e1c2829400fad9c58ab9c5c3ef9 c1343073519840b186a2a69f4504254c--311c8e1c2829400fad9c58ab9c5c3ef9 1599f90e495245cab98c56bdf43d13d3 311c8e1c2829400fad9c58ab9c5c3ef9--1599f90e495245cab98c56bdf43d13d3 ca13ca11ce67486a8586f15875ffbfb9 1599f90e495245cab98c56bdf43d13d3--ca13ca11ce67486a8586f15875ffbfb9 f7767aa07b3d4a3eb67b32c7cb1ffd08 ca13ca11ce67486a8586f15875ffbfb9--f7767aa07b3d4a3eb67b32c7cb1ffd08 a6e25e982a184096a96e024e2aac14d9 f7767aa07b3d4a3eb67b32c7cb1ffd08--a6e25e982a184096a96e024e2aac14d9 5d427cc3f6b94f3c810c91319a6099b7 a6e25e982a184096a96e024e2aac14d9--5d427cc3f6b94f3c810c91319a6099b7 a1d178cf044948c5b96973f11708dd94 5d427cc3f6b94f3c810c91319a6099b7--a1d178cf044948c5b96973f11708dd94 c973cbe5cb2c42ff8a631404e902dc53 a1d178cf044948c5b96973f11708dd94--c973cbe5cb2c42ff8a631404e902dc53 ab126e09808d4c0da760c3cbbe53b683 c973cbe5cb2c42ff8a631404e902dc53--ab126e09808d4c0da760c3cbbe53b683 6f6afd9055af4ff0af6d43718fb0581c ab126e09808d4c0da760c3cbbe53b683--6f6afd9055af4ff0af6d43718fb0581c babc35ed98a04570bbed91a42a21dcbe 6f6afd9055af4ff0af6d43718fb0581c--babc35ed98a04570bbed91a42a21dcbe d7ec367d695f48819d67e55f8b81e733 babc35ed98a04570bbed91a42a21dcbe--d7ec367d695f48819d67e55f8b81e733 8fde75fc03824ae3883d98e9f247da34 d7ec367d695f48819d67e55f8b81e733--8fde75fc03824ae3883d98e9f247da34 2204405fe0214e5983d8e8e79694f8ed RX(b00) 8fde75fc03824ae3883d98e9f247da34--2204405fe0214e5983d8e8e79694f8ed 843a117088bc4b60804f20d9af8c605b 2204405fe0214e5983d8e8e79694f8ed--843a117088bc4b60804f20d9af8c605b fc5ae9593e8c4483b3b13a61b6daf762 843a117088bc4b60804f20d9af8c605b--fc5ae9593e8c4483b3b13a61b6daf762 7e94d71a26524f9ea610aac0d3089905 fc5ae9593e8c4483b3b13a61b6daf762--7e94d71a26524f9ea610aac0d3089905 a7172cfbffae461b99fd7de301ac895d 7e94d71a26524f9ea610aac0d3089905--a7172cfbffae461b99fd7de301ac895d ab80db699f04421791625a97569671b0 a7172cfbffae461b99fd7de301ac895d--ab80db699f04421791625a97569671b0 7e0d6c7d2b3a4270803da9f4dfcad06e ab80db699f04421791625a97569671b0--7e0d6c7d2b3a4270803da9f4dfcad06e aeb5a6914f9841149f791c6228814adb 7e0d6c7d2b3a4270803da9f4dfcad06e--aeb5a6914f9841149f791c6228814adb d65da566dd3b4ec58374152cd31b0425 aeb5a6914f9841149f791c6228814adb--d65da566dd3b4ec58374152cd31b0425 7023c5ce9b404d1ca8fec7bc086a26a7 d65da566dd3b4ec58374152cd31b0425--7023c5ce9b404d1ca8fec7bc086a26a7 96ed5179c4684211b3da7241f2e7613c 7023c5ce9b404d1ca8fec7bc086a26a7--96ed5179c4684211b3da7241f2e7613c 251314e5f50e48bba19ab295902fe076 96ed5179c4684211b3da7241f2e7613c--251314e5f50e48bba19ab295902fe076 b6ce84c0960b4b6eac798c57c03f4d4e 251314e5f50e48bba19ab295902fe076--b6ce84c0960b4b6eac798c57c03f4d4e 54b1a63a6b2b4dc98fbfb6f15c728a1b b6ce84c0960b4b6eac798c57c03f4d4e--54b1a63a6b2b4dc98fbfb6f15c728a1b c21d8e4241bc4af8b3713915532b2b4a 54b1a63a6b2b4dc98fbfb6f15c728a1b--c21d8e4241bc4af8b3713915532b2b4a aad65e86eab04aad92bdb8f40864b001 c21d8e4241bc4af8b3713915532b2b4a--aad65e86eab04aad92bdb8f40864b001 cf6bd4be3c0646d7a385583a1886d0e8 aad65e86eab04aad92bdb8f40864b001--cf6bd4be3c0646d7a385583a1886d0e8 b77a4a6da3ae4ff080bc1f316638d3af cf6bd4be3c0646d7a385583a1886d0e8--b77a4a6da3ae4ff080bc1f316638d3af d5866e5119e542cfbc082650ee5a4601 b77a4a6da3ae4ff080bc1f316638d3af--d5866e5119e542cfbc082650ee5a4601 83860717a3534ac98e09cd5b3c0c086f d5866e5119e542cfbc082650ee5a4601--83860717a3534ac98e09cd5b3c0c086f c35261ef61874c259afbea46c181c7bb 83860717a3534ac98e09cd5b3c0c086f--c35261ef61874c259afbea46c181c7bb 7f834686b4f84eb89bbcb6dfe7e29618 c35261ef61874c259afbea46c181c7bb--7f834686b4f84eb89bbcb6dfe7e29618 3d1e001059904db38f48b4cca802a4fb 7f834686b4f84eb89bbcb6dfe7e29618--3d1e001059904db38f48b4cca802a4fb 027e79151be14a8cb77141dbee0416a1 3d1e001059904db38f48b4cca802a4fb--027e79151be14a8cb77141dbee0416a1 107a69e789cc47e796dd1e5a89bbbacc 027e79151be14a8cb77141dbee0416a1--107a69e789cc47e796dd1e5a89bbbacc d2dc7cbe3d5f4e04b4b47cf2d9e21797 107a69e789cc47e796dd1e5a89bbbacc--d2dc7cbe3d5f4e04b4b47cf2d9e21797 2c6b7b337d4c4dc4af781ac067df4400 d2dc7cbe3d5f4e04b4b47cf2d9e21797--2c6b7b337d4c4dc4af781ac067df4400 89d6ceb57ea947ffb880a7d2f1ab38db 2c6b7b337d4c4dc4af781ac067df4400--89d6ceb57ea947ffb880a7d2f1ab38db af4c6b8937af4797a618e1c3089c5d36 89d6ceb57ea947ffb880a7d2f1ab38db--af4c6b8937af4797a618e1c3089c5d36 917613d5f7d5460383f87b8872c6dbbf af4c6b8937af4797a618e1c3089c5d36--917613d5f7d5460383f87b8872c6dbbf 34542c4287584c76b6ae98034b7cc1d2 917613d5f7d5460383f87b8872c6dbbf--34542c4287584c76b6ae98034b7cc1d2 68dfa3dab4b94ee7a8c88ae197a82502 34542c4287584c76b6ae98034b7cc1d2--68dfa3dab4b94ee7a8c88ae197a82502 ba331143c5d149f49567399d6108473b 68dfa3dab4b94ee7a8c88ae197a82502--ba331143c5d149f49567399d6108473b 48b4720c40e14554bbcfeb135e4d130f ba331143c5d149f49567399d6108473b--48b4720c40e14554bbcfeb135e4d130f d10049c2f443453fa5d6d5226a6bd5c3 48b4720c40e14554bbcfeb135e4d130f--d10049c2f443453fa5d6d5226a6bd5c3 2c2ea57135e8409a97acd3c81281ead0 d10049c2f443453fa5d6d5226a6bd5c3--2c2ea57135e8409a97acd3c81281ead0 c268fb5d36804600a4f573a22ebd9ba8 2c2ea57135e8409a97acd3c81281ead0--c268fb5d36804600a4f573a22ebd9ba8 2b5fba064a5b430b9002d05238f8d9c8 c268fb5d36804600a4f573a22ebd9ba8--2b5fba064a5b430b9002d05238f8d9c8 b39baab59605460c8e81330bab083866 2b5fba064a5b430b9002d05238f8d9c8--b39baab59605460c8e81330bab083866 e73cec47b3f9463db1de2ad296ea1dba b39baab59605460c8e81330bab083866--e73cec47b3f9463db1de2ad296ea1dba b7e69f0e36d548c8aa94d398263d1c67 e73cec47b3f9463db1de2ad296ea1dba--b7e69f0e36d548c8aa94d398263d1c67 6095ef918da747919823a54c2210be0a b7e69f0e36d548c8aa94d398263d1c67--6095ef918da747919823a54c2210be0a 562bf6895c34492a8343fa2be859fc76 6095ef918da747919823a54c2210be0a--562bf6895c34492a8343fa2be859fc76 0d24b6e995d244bdba1af0f13bc606ed 562bf6895c34492a8343fa2be859fc76--0d24b6e995d244bdba1af0f13bc606ed 1e6f609ce0b74cba953510e318c742ee 0d24b6e995d244bdba1af0f13bc606ed--1e6f609ce0b74cba953510e318c742ee 2f42a2705052488c8d13a5bbdde6f804 1e6f609ce0b74cba953510e318c742ee--2f42a2705052488c8d13a5bbdde6f804 55ce60b66d3648b5a2de886bf65132db 2f42a2705052488c8d13a5bbdde6f804--55ce60b66d3648b5a2de886bf65132db 49c02acf13244425a11b5057c1b33618 55ce60b66d3648b5a2de886bf65132db--49c02acf13244425a11b5057c1b33618 a41c21e2d46a43b4b368c990da320088 49c02acf13244425a11b5057c1b33618--a41c21e2d46a43b4b368c990da320088 fdbbfed5494f4ce08defe7812338c9eb a41c21e2d46a43b4b368c990da320088--fdbbfed5494f4ce08defe7812338c9eb e4e6c6bc107b4b1bac8c2c25eeb28dc0 fdbbfed5494f4ce08defe7812338c9eb--e4e6c6bc107b4b1bac8c2c25eeb28dc0 fb568a794320479091fa8fcc66a9ddee e4e6c6bc107b4b1bac8c2c25eeb28dc0--fb568a794320479091fa8fcc66a9ddee 9dba892da0b646bfb67e332c0f308e5c fb568a794320479091fa8fcc66a9ddee--9dba892da0b646bfb67e332c0f308e5c d7970b1cc37e414d96c37b0d34296928 9dba892da0b646bfb67e332c0f308e5c--d7970b1cc37e414d96c37b0d34296928 74ecccf05ff640f0bcc2298f70f9a57f d7970b1cc37e414d96c37b0d34296928--74ecccf05ff640f0bcc2298f70f9a57f a12f5523d6c341e096a15751f7d695f8 74ecccf05ff640f0bcc2298f70f9a57f--a12f5523d6c341e096a15751f7d695f8 cf67e546d9134f248175c3f7f1d3bbee a12f5523d6c341e096a15751f7d695f8--cf67e546d9134f248175c3f7f1d3bbee 1803fb56287144dc8f68e21aea061057 cf67e546d9134f248175c3f7f1d3bbee--1803fb56287144dc8f68e21aea061057 5d222dd4c2954532b0cae7078e1071ea 1803fb56287144dc8f68e21aea061057--5d222dd4c2954532b0cae7078e1071ea 1a428e971021456192e887fd7066f0c8 5d222dd4c2954532b0cae7078e1071ea--1a428e971021456192e887fd7066f0c8 414bd864d4df440cb062a39290d53b82 1a428e971021456192e887fd7066f0c8--414bd864d4df440cb062a39290d53b82 723ad3a52fb449a4bb6cfb032940ec3f 414bd864d4df440cb062a39290d53b82--723ad3a52fb449a4bb6cfb032940ec3f 959993218657473cb5da52a2126ee0d3 723ad3a52fb449a4bb6cfb032940ec3f--959993218657473cb5da52a2126ee0d3 c4a9e796554d47b18381b6b3e4739d5d 959993218657473cb5da52a2126ee0d3--c4a9e796554d47b18381b6b3e4739d5d aed08ba876cf49688bc0ccf30f50d66f c4a9e796554d47b18381b6b3e4739d5d--aed08ba876cf49688bc0ccf30f50d66f 077f20ca23204cb691c63685558e4a6a aed08ba876cf49688bc0ccf30f50d66f--077f20ca23204cb691c63685558e4a6a b6df8d3935e64b82bf80379f721e57fc 077f20ca23204cb691c63685558e4a6a--b6df8d3935e64b82bf80379f721e57fc 235c1d7c7db149b9ab910e626d9a8c7c b6df8d3935e64b82bf80379f721e57fc--235c1d7c7db149b9ab910e626d9a8c7c 617f5de36e6c4848b0112eadcf2f1597 235c1d7c7db149b9ab910e626d9a8c7c--617f5de36e6c4848b0112eadcf2f1597 b04e4793a1894517a8ebf3cc9d836980 617f5de36e6c4848b0112eadcf2f1597--b04e4793a1894517a8ebf3cc9d836980 41eb14c862b94f649e68791054050ed4 b04e4793a1894517a8ebf3cc9d836980--41eb14c862b94f649e68791054050ed4 be054023aec74a4dbe9cc75d36085187 41eb14c862b94f649e68791054050ed4--be054023aec74a4dbe9cc75d36085187 f364db32266c4c67b2b23cc59e6d8f99 be054023aec74a4dbe9cc75d36085187--f364db32266c4c67b2b23cc59e6d8f99 7260cccb7df148e19b299f75a11e22e4 f364db32266c4c67b2b23cc59e6d8f99--7260cccb7df148e19b299f75a11e22e4 7bc2462f7f13408e90fd7f1231e2891d 7260cccb7df148e19b299f75a11e22e4--7bc2462f7f13408e90fd7f1231e2891d 920fbf1c780648eab7b9d453209c4179 7bc2462f7f13408e90fd7f1231e2891d--920fbf1c780648eab7b9d453209c4179 b63fc0e779314b8787d5917763866b10 920fbf1c780648eab7b9d453209c4179--b63fc0e779314b8787d5917763866b10 3b0bdb09f4e448ad90eaf0798bcf9d28 b63fc0e779314b8787d5917763866b10--3b0bdb09f4e448ad90eaf0798bcf9d28 597c2df2871241a6bf54e4c4b468489c 3b0bdb09f4e448ad90eaf0798bcf9d28--597c2df2871241a6bf54e4c4b468489c 3c917cba60ce44e988c049560fb21d44 597c2df2871241a6bf54e4c4b468489c--3c917cba60ce44e988c049560fb21d44 01fba8547c90422695807987afa8b431 3c917cba60ce44e988c049560fb21d44--01fba8547c90422695807987afa8b431 966e4b4f114342b4a177f522c223ddcb 01fba8547c90422695807987afa8b431--966e4b4f114342b4a177f522c223ddcb 570166f1def54c228313421ef17481c3 966e4b4f114342b4a177f522c223ddcb--570166f1def54c228313421ef17481c3 41eec50f974c4523ba34b8fe89aad4d7 570166f1def54c228313421ef17481c3--41eec50f974c4523ba34b8fe89aad4d7 c484b04254d14608aec3c828fc1063f6 41eec50f974c4523ba34b8fe89aad4d7--c484b04254d14608aec3c828fc1063f6 2b0ebb4f278b4a3ca4242c8bd0f18446 c484b04254d14608aec3c828fc1063f6--2b0ebb4f278b4a3ca4242c8bd0f18446 5b46575851624f6498699f5b52de27c6 2b0ebb4f278b4a3ca4242c8bd0f18446--5b46575851624f6498699f5b52de27c6 4820f99316d343cea448eb2b821cc81d 5b46575851624f6498699f5b52de27c6--4820f99316d343cea448eb2b821cc81d b5e454ecd14a4bdc8886bd096f2eeb09 4820f99316d343cea448eb2b821cc81d--b5e454ecd14a4bdc8886bd096f2eeb09 201034a2e5514e00aa1f1a11a9904ec8 b5e454ecd14a4bdc8886bd096f2eeb09--201034a2e5514e00aa1f1a11a9904ec8 e52ff58d74f744eb9b0f60dc745a5238 201034a2e5514e00aa1f1a11a9904ec8--e52ff58d74f744eb9b0f60dc745a5238 6f39f6b356e8497e95199ee9a401e4f6 e52ff58d74f744eb9b0f60dc745a5238--6f39f6b356e8497e95199ee9a401e4f6 d8e8e378407a412e9e827992443aabd0 6f39f6b356e8497e95199ee9a401e4f6--d8e8e378407a412e9e827992443aabd0 d0e9416ca15b40a48bdc31b850859fdc d8e8e378407a412e9e827992443aabd0--d0e9416ca15b40a48bdc31b850859fdc 44c2abebad2c477a96f6326accf16d4a d0e9416ca15b40a48bdc31b850859fdc--44c2abebad2c477a96f6326accf16d4a 3e3ded45bb694df08cd36d10f7b7ee10 44c2abebad2c477a96f6326accf16d4a--3e3ded45bb694df08cd36d10f7b7ee10 bab2cc09a1fa4b0f908b32141139e178 3e3ded45bb694df08cd36d10f7b7ee10--bab2cc09a1fa4b0f908b32141139e178 07112bb61a3848cab233f80d9462a576 bab2cc09a1fa4b0f908b32141139e178--07112bb61a3848cab233f80d9462a576 4d22657879af45019ca017e352de5502 07112bb61a3848cab233f80d9462a576--4d22657879af45019ca017e352de5502 1ad54dbc9fbd40ea974cae2c42a858f3 4d22657879af45019ca017e352de5502--1ad54dbc9fbd40ea974cae2c42a858f3 bbdac07e47ae49c4ab0352ea16268d18 1ad54dbc9fbd40ea974cae2c42a858f3--bbdac07e47ae49c4ab0352ea16268d18 8d4a8016b8b74deab0505923ce8871ff bbdac07e47ae49c4ab0352ea16268d18--8d4a8016b8b74deab0505923ce8871ff 2f1af172a48f4ae8a7a4d19f55306d3f 8d4a8016b8b74deab0505923ce8871ff--2f1af172a48f4ae8a7a4d19f55306d3f 841ba1b1cc654300b58673153f95d8e9 2f1af172a48f4ae8a7a4d19f55306d3f--841ba1b1cc654300b58673153f95d8e9 2fc93416166141918667f4af485fdb45 841ba1b1cc654300b58673153f95d8e9--2fc93416166141918667f4af485fdb45 49ae01af3f1346fbb9631c591cb79150 RX(b10) 2fc93416166141918667f4af485fdb45--49ae01af3f1346fbb9631c591cb79150 440225f7a8b24dc58555524f67e7ad48 49ae01af3f1346fbb9631c591cb79150--440225f7a8b24dc58555524f67e7ad48 8cfae0698b0447f288ce6c2dec487241 cd5da62ed71147848403495daa1f1aaf X 303f1ece6e434f5dbe82ee030249a7ab--cd5da62ed71147848403495daa1f1aaf 9aed72acf46541c4894a127c20543f74 2 cd5da62ed71147848403495daa1f1aaf--c221505775554af7848a3c0166f1883e 1e20f8c6b6c645c895b1f6ba48dac6e9 cd5da62ed71147848403495daa1f1aaf--1e20f8c6b6c645c895b1f6ba48dac6e9 069dca47440c48fc8f32a75f8499f313 1e20f8c6b6c645c895b1f6ba48dac6e9--069dca47440c48fc8f32a75f8499f313 96fa0b4c042e4d71b9286a4f106e9ffb 069dca47440c48fc8f32a75f8499f313--96fa0b4c042e4d71b9286a4f106e9ffb 0d6b92efc389443ebb51dff57ebab961 96fa0b4c042e4d71b9286a4f106e9ffb--0d6b92efc389443ebb51dff57ebab961 23e025841d2b459da65767a472e01355 0d6b92efc389443ebb51dff57ebab961--23e025841d2b459da65767a472e01355 1c46b52ecbfb412c997ff982a2f07140 23e025841d2b459da65767a472e01355--1c46b52ecbfb412c997ff982a2f07140 eb3f42b6c13e4c6a9bfc7a6486d27d23 1c46b52ecbfb412c997ff982a2f07140--eb3f42b6c13e4c6a9bfc7a6486d27d23 cfc46f8ce71f44fda1faeadb50b26b96 eb3f42b6c13e4c6a9bfc7a6486d27d23--cfc46f8ce71f44fda1faeadb50b26b96 35a6c7ef00cc4a168759037d003d0d53 cfc46f8ce71f44fda1faeadb50b26b96--35a6c7ef00cc4a168759037d003d0d53 dbff1a952107476984b064d4f4416c86 35a6c7ef00cc4a168759037d003d0d53--dbff1a952107476984b064d4f4416c86 741c282e12ea4a2a9a5dedded8307b08 dbff1a952107476984b064d4f4416c86--741c282e12ea4a2a9a5dedded8307b08 b1c30b59fc3c4805b67099c9dea0db04 741c282e12ea4a2a9a5dedded8307b08--b1c30b59fc3c4805b67099c9dea0db04 c4a12c5a4bb4499392cc249e045ac0eb b1c30b59fc3c4805b67099c9dea0db04--c4a12c5a4bb4499392cc249e045ac0eb 035216ef2aad471dad9e34d750826c5f X c4a12c5a4bb4499392cc249e045ac0eb--035216ef2aad471dad9e34d750826c5f 035216ef2aad471dad9e34d750826c5f--65f5356f79a346429caefd22734ea086 f48a0850b7414a1591bd5edbf0a2474e X 035216ef2aad471dad9e34d750826c5f--f48a0850b7414a1591bd5edbf0a2474e f48a0850b7414a1591bd5edbf0a2474e--f87fd1c60518490bbf7760ccdcb1b48b cf735987e0f7490daf626efd8aabb936 RZ(-1.0*g0) f48a0850b7414a1591bd5edbf0a2474e--cf735987e0f7490daf626efd8aabb936 037a42f0a2c54df18e9af50a6e88676a X cf735987e0f7490daf626efd8aabb936--037a42f0a2c54df18e9af50a6e88676a 037a42f0a2c54df18e9af50a6e88676a--f74ba24862df480285cc85e2df4e5afa 4fc4350b0def49399cecb4eaac9b9cf2 037a42f0a2c54df18e9af50a6e88676a--4fc4350b0def49399cecb4eaac9b9cf2 9f926b5fe7ef469a97b0e8b8ec2ae540 4fc4350b0def49399cecb4eaac9b9cf2--9f926b5fe7ef469a97b0e8b8ec2ae540 5ef1afe2032a4d31b21b22452ebcba1e 9f926b5fe7ef469a97b0e8b8ec2ae540--5ef1afe2032a4d31b21b22452ebcba1e 9c0547e51ad34b07a63a54b4a98d930a 5ef1afe2032a4d31b21b22452ebcba1e--9c0547e51ad34b07a63a54b4a98d930a d228e5895de34c3fa1918664eeb5d37b 9c0547e51ad34b07a63a54b4a98d930a--d228e5895de34c3fa1918664eeb5d37b 24491ef06d5d4706a5c9e17fb521fd84 d228e5895de34c3fa1918664eeb5d37b--24491ef06d5d4706a5c9e17fb521fd84 fbe7bfefe3bb4c37a76559586713ecb4 24491ef06d5d4706a5c9e17fb521fd84--fbe7bfefe3bb4c37a76559586713ecb4 71321d92a2274bf581ccabcf22ff3188 fbe7bfefe3bb4c37a76559586713ecb4--71321d92a2274bf581ccabcf22ff3188 b799eb54fdc74200b7979756673bc40f 71321d92a2274bf581ccabcf22ff3188--b799eb54fdc74200b7979756673bc40f 29a488e1ec2e4f48b2de1aecbb5f912c b799eb54fdc74200b7979756673bc40f--29a488e1ec2e4f48b2de1aecbb5f912c be462be666fb4a498771d8f09e952eba 29a488e1ec2e4f48b2de1aecbb5f912c--be462be666fb4a498771d8f09e952eba 9ae00e133c43427eb2c8ebc7a5d63969 be462be666fb4a498771d8f09e952eba--9ae00e133c43427eb2c8ebc7a5d63969 8b20c5398a3e4b2490578adfe0ca0e91 9ae00e133c43427eb2c8ebc7a5d63969--8b20c5398a3e4b2490578adfe0ca0e91 b814acc8947e470e95239124e005e52e 8b20c5398a3e4b2490578adfe0ca0e91--b814acc8947e470e95239124e005e52e 4f85c21674874922ac9b64fe0ded4c6b b814acc8947e470e95239124e005e52e--4f85c21674874922ac9b64fe0ded4c6b 3bd00ba31be84f8eabe67c6f018f15b4 4f85c21674874922ac9b64fe0ded4c6b--3bd00ba31be84f8eabe67c6f018f15b4 2e342a312d6f4b2ca0bb14b13942f162 3bd00ba31be84f8eabe67c6f018f15b4--2e342a312d6f4b2ca0bb14b13942f162 6a9e017aaa5f4d23a75d0eea588859ff 2e342a312d6f4b2ca0bb14b13942f162--6a9e017aaa5f4d23a75d0eea588859ff f0282c09b6894d31be2e4c4b93c7ac5e 6a9e017aaa5f4d23a75d0eea588859ff--f0282c09b6894d31be2e4c4b93c7ac5e aac89e19f9ee40868d816202d922c17f f0282c09b6894d31be2e4c4b93c7ac5e--aac89e19f9ee40868d816202d922c17f c01429338dfc489b8a707d0c5b60959d aac89e19f9ee40868d816202d922c17f--c01429338dfc489b8a707d0c5b60959d 4d153e8572a041808d10bbfcb277a3f8 c01429338dfc489b8a707d0c5b60959d--4d153e8572a041808d10bbfcb277a3f8 1e2bcfcfbdf8408f9a5996360a3a2b7a 4d153e8572a041808d10bbfcb277a3f8--1e2bcfcfbdf8408f9a5996360a3a2b7a 74876470790043308985f6eea94b7bd6 1e2bcfcfbdf8408f9a5996360a3a2b7a--74876470790043308985f6eea94b7bd6 ff7aa29d3b9f49c69b2f83f725309802 74876470790043308985f6eea94b7bd6--ff7aa29d3b9f49c69b2f83f725309802 ce333881c7bf4a2f839c0503b26907d7 ff7aa29d3b9f49c69b2f83f725309802--ce333881c7bf4a2f839c0503b26907d7 8850d9941bb441068031f0000767cd18 ce333881c7bf4a2f839c0503b26907d7--8850d9941bb441068031f0000767cd18 a1fd593ebcf84c369833f887c4392d0e 8850d9941bb441068031f0000767cd18--a1fd593ebcf84c369833f887c4392d0e 8f3c4f24bab340ca880b3ea93f66a79e a1fd593ebcf84c369833f887c4392d0e--8f3c4f24bab340ca880b3ea93f66a79e 25e0f59c0a66412dbc34155e8407def7 8f3c4f24bab340ca880b3ea93f66a79e--25e0f59c0a66412dbc34155e8407def7 8a298fe31baa4680b40b51a8e363f024 25e0f59c0a66412dbc34155e8407def7--8a298fe31baa4680b40b51a8e363f024 3824d58b4ab84c3888be3b4c8381e505 8a298fe31baa4680b40b51a8e363f024--3824d58b4ab84c3888be3b4c8381e505 30077156e8444769bf36c6a5396b389d 3824d58b4ab84c3888be3b4c8381e505--30077156e8444769bf36c6a5396b389d fcd513484f954193899cfbb9c9a32dc8 30077156e8444769bf36c6a5396b389d--fcd513484f954193899cfbb9c9a32dc8 3b86d2667fa24fdab11324dbc7800fa2 fcd513484f954193899cfbb9c9a32dc8--3b86d2667fa24fdab11324dbc7800fa2 529f628d178c4ca8a52a4b04de84028d 3b86d2667fa24fdab11324dbc7800fa2--529f628d178c4ca8a52a4b04de84028d 8e9c24d150684ca6b69e5f018c573346 529f628d178c4ca8a52a4b04de84028d--8e9c24d150684ca6b69e5f018c573346 2d2e062cb1aa41d59568ef571e93946e 8e9c24d150684ca6b69e5f018c573346--2d2e062cb1aa41d59568ef571e93946e 9a5811eb27c64e77abcd9023ad9ecfa2 2d2e062cb1aa41d59568ef571e93946e--9a5811eb27c64e77abcd9023ad9ecfa2 019d9022fcc54cb5b655107f3c972f3e 9a5811eb27c64e77abcd9023ad9ecfa2--019d9022fcc54cb5b655107f3c972f3e 6f4353d07ed7483d9f743cf7ff7c268b 019d9022fcc54cb5b655107f3c972f3e--6f4353d07ed7483d9f743cf7ff7c268b a08d9f8ddd5944649b7bcdc87a1580d3 6f4353d07ed7483d9f743cf7ff7c268b--a08d9f8ddd5944649b7bcdc87a1580d3 f23e9ae982eb4349b70d3aeb81642590 a08d9f8ddd5944649b7bcdc87a1580d3--f23e9ae982eb4349b70d3aeb81642590 1cc91da498ab4a95b8f949fad6237f1c f23e9ae982eb4349b70d3aeb81642590--1cc91da498ab4a95b8f949fad6237f1c 81dfa3f9709543dc82e3835f72342f06 1cc91da498ab4a95b8f949fad6237f1c--81dfa3f9709543dc82e3835f72342f06 efc433dcf757458a8b474272d7f04ec9 81dfa3f9709543dc82e3835f72342f06--efc433dcf757458a8b474272d7f04ec9 686283d9dac24b99a40fdeab5accb9ec efc433dcf757458a8b474272d7f04ec9--686283d9dac24b99a40fdeab5accb9ec 1bb24db7bc6d4c268ea95b949fdcbdba 686283d9dac24b99a40fdeab5accb9ec--1bb24db7bc6d4c268ea95b949fdcbdba a5323a9e46724a24ad322408c7abee92 1bb24db7bc6d4c268ea95b949fdcbdba--a5323a9e46724a24ad322408c7abee92 0476a2feca554b4ba20297a102b7971c a5323a9e46724a24ad322408c7abee92--0476a2feca554b4ba20297a102b7971c e637a893990f48029925d0fc2d048328 0476a2feca554b4ba20297a102b7971c--e637a893990f48029925d0fc2d048328 e25ae46022bc4c86b9c6a232fc104efa e637a893990f48029925d0fc2d048328--e25ae46022bc4c86b9c6a232fc104efa ec47599cd3e648f7ab7a6cd7b59d9fd4 e25ae46022bc4c86b9c6a232fc104efa--ec47599cd3e648f7ab7a6cd7b59d9fd4 17df2a55b3a64fc0ab30aec94331b7e0 ec47599cd3e648f7ab7a6cd7b59d9fd4--17df2a55b3a64fc0ab30aec94331b7e0 7f3b70a8cf3e479ca201781c14ea5296 17df2a55b3a64fc0ab30aec94331b7e0--7f3b70a8cf3e479ca201781c14ea5296 54adff8868044be7a41c06c3fd3e0851 7f3b70a8cf3e479ca201781c14ea5296--54adff8868044be7a41c06c3fd3e0851 4eb20a7a0c014566a6484f877a16ee6e 54adff8868044be7a41c06c3fd3e0851--4eb20a7a0c014566a6484f877a16ee6e 341ffdc2753d4c04b68bf14667f8115d 4eb20a7a0c014566a6484f877a16ee6e--341ffdc2753d4c04b68bf14667f8115d df6bdd596a5547668f69d1bfcb7d894e 341ffdc2753d4c04b68bf14667f8115d--df6bdd596a5547668f69d1bfcb7d894e 5e12b3f0ee5b43a3ab4a8f0973bdacde df6bdd596a5547668f69d1bfcb7d894e--5e12b3f0ee5b43a3ab4a8f0973bdacde 5db467b53f024a1caff622101ad95294 5e12b3f0ee5b43a3ab4a8f0973bdacde--5db467b53f024a1caff622101ad95294 c9e6366e4a494c4e8911f65dfdd74dde 5db467b53f024a1caff622101ad95294--c9e6366e4a494c4e8911f65dfdd74dde 67d7f1d8c9dc41eb92dc16f12622068f c9e6366e4a494c4e8911f65dfdd74dde--67d7f1d8c9dc41eb92dc16f12622068f 45825d97c7794a1ba03d37717c894def 67d7f1d8c9dc41eb92dc16f12622068f--45825d97c7794a1ba03d37717c894def 3c870297b5794dc4be01101896a25966 45825d97c7794a1ba03d37717c894def--3c870297b5794dc4be01101896a25966 257131aeacdb4e6093e4dde8ad4a9dfc 3c870297b5794dc4be01101896a25966--257131aeacdb4e6093e4dde8ad4a9dfc 706b98f661c6452fb7210068e6da9784 257131aeacdb4e6093e4dde8ad4a9dfc--706b98f661c6452fb7210068e6da9784 507fa0c08d124d5fa4be15a5ece5b662 706b98f661c6452fb7210068e6da9784--507fa0c08d124d5fa4be15a5ece5b662 c99b3e78d43247b2a6e2d803ad4d12ec 507fa0c08d124d5fa4be15a5ece5b662--c99b3e78d43247b2a6e2d803ad4d12ec 9614125cadf04b5680de4c4193acd871 c99b3e78d43247b2a6e2d803ad4d12ec--9614125cadf04b5680de4c4193acd871 a23e254e56ac4a60ab2ceb4047b0180e 9614125cadf04b5680de4c4193acd871--a23e254e56ac4a60ab2ceb4047b0180e 8cd0dcbe26454ff5a14e9e80affe63b0 a23e254e56ac4a60ab2ceb4047b0180e--8cd0dcbe26454ff5a14e9e80affe63b0 2e61fe247fca4e12885ddcefae0395ba 8cd0dcbe26454ff5a14e9e80affe63b0--2e61fe247fca4e12885ddcefae0395ba c0a57524949c410788103a10ef3f3e63 2e61fe247fca4e12885ddcefae0395ba--c0a57524949c410788103a10ef3f3e63 0b0eedbfccf64182b9183b8eb8103a30 c0a57524949c410788103a10ef3f3e63--0b0eedbfccf64182b9183b8eb8103a30 96adf2bcbb2a47fdb23fc1aa3fe99f5d 0b0eedbfccf64182b9183b8eb8103a30--96adf2bcbb2a47fdb23fc1aa3fe99f5d 1189c15cd20c4785bb9e0b46e5b5a1ae 96adf2bcbb2a47fdb23fc1aa3fe99f5d--1189c15cd20c4785bb9e0b46e5b5a1ae 1ba58c93419e4738860b51f42cceae15 1189c15cd20c4785bb9e0b46e5b5a1ae--1ba58c93419e4738860b51f42cceae15 fe14f801c93946bb97e44942cc19ecda 1ba58c93419e4738860b51f42cceae15--fe14f801c93946bb97e44942cc19ecda 0a9ddca2028845dcac5ac476e69a0fa6 fe14f801c93946bb97e44942cc19ecda--0a9ddca2028845dcac5ac476e69a0fa6 00855522d5074ea5aa7356f17cc8fe2d 0a9ddca2028845dcac5ac476e69a0fa6--00855522d5074ea5aa7356f17cc8fe2d 89be7306518c4552a24c36a7f128d2b9 00855522d5074ea5aa7356f17cc8fe2d--89be7306518c4552a24c36a7f128d2b9 40bb69245d6e426abb927bfaa1b49dd1 89be7306518c4552a24c36a7f128d2b9--40bb69245d6e426abb927bfaa1b49dd1 c9669ee956614942b5bf7fc5d1f53db2 40bb69245d6e426abb927bfaa1b49dd1--c9669ee956614942b5bf7fc5d1f53db2 2eea70d0309a4544a647b750d8d297f8 c9669ee956614942b5bf7fc5d1f53db2--2eea70d0309a4544a647b750d8d297f8 3c30d5d5369c4f41918d12f8702d6d53 2eea70d0309a4544a647b750d8d297f8--3c30d5d5369c4f41918d12f8702d6d53 e0485ddb47d84229aa21889119b47217 RX(b01) 3c30d5d5369c4f41918d12f8702d6d53--e0485ddb47d84229aa21889119b47217 4c17626921df43e5a25eb7fd2dbb392e X e0485ddb47d84229aa21889119b47217--4c17626921df43e5a25eb7fd2dbb392e 4c17626921df43e5a25eb7fd2dbb392e--843a117088bc4b60804f20d9af8c605b 1bece4a88e4d42449f2cac03bc88374a 4c17626921df43e5a25eb7fd2dbb392e--1bece4a88e4d42449f2cac03bc88374a 0eef2f3d0d754932be18b655d9a93477 1bece4a88e4d42449f2cac03bc88374a--0eef2f3d0d754932be18b655d9a93477 8cab21494a394b7aaac73782a1bb2889 0eef2f3d0d754932be18b655d9a93477--8cab21494a394b7aaac73782a1bb2889 6498f7cdf67a42ffbbaab7abeccd9e77 8cab21494a394b7aaac73782a1bb2889--6498f7cdf67a42ffbbaab7abeccd9e77 ef98f40cefe349048c2799cf9cd4b2a5 6498f7cdf67a42ffbbaab7abeccd9e77--ef98f40cefe349048c2799cf9cd4b2a5 fc75243d197c49e7884d85b139d8a880 ef98f40cefe349048c2799cf9cd4b2a5--fc75243d197c49e7884d85b139d8a880 b874056420394738972dc274856449c0 fc75243d197c49e7884d85b139d8a880--b874056420394738972dc274856449c0 341f5cac91544356b93072a5bf349191 b874056420394738972dc274856449c0--341f5cac91544356b93072a5bf349191 1c1b0809d90a40e690a0e08eca8bf40a 341f5cac91544356b93072a5bf349191--1c1b0809d90a40e690a0e08eca8bf40a 55df7e1bd6ea48d0aa50d13806c33c62 1c1b0809d90a40e690a0e08eca8bf40a--55df7e1bd6ea48d0aa50d13806c33c62 70133bca27ff4009bbe98a7d2852930b 55df7e1bd6ea48d0aa50d13806c33c62--70133bca27ff4009bbe98a7d2852930b beef70c2e687423c94bc3202d52e4615 70133bca27ff4009bbe98a7d2852930b--beef70c2e687423c94bc3202d52e4615 a6dcd6657e4f4d9392316ff49b0f6bb8 beef70c2e687423c94bc3202d52e4615--a6dcd6657e4f4d9392316ff49b0f6bb8 e1ca0c3e1c5349109df0341bb2ba6480 X a6dcd6657e4f4d9392316ff49b0f6bb8--e1ca0c3e1c5349109df0341bb2ba6480 e1ca0c3e1c5349109df0341bb2ba6480--aad65e86eab04aad92bdb8f40864b001 f9d3688fc16546aa92c7a390fa4ea07f X e1ca0c3e1c5349109df0341bb2ba6480--f9d3688fc16546aa92c7a390fa4ea07f f9d3688fc16546aa92c7a390fa4ea07f--cf6bd4be3c0646d7a385583a1886d0e8 c964ab58c3454b038c6f0ff23f4da099 RZ(-1.0*g1) f9d3688fc16546aa92c7a390fa4ea07f--c964ab58c3454b038c6f0ff23f4da099 9b94d7a3358d48f6bfc10a16e52fc070 X c964ab58c3454b038c6f0ff23f4da099--9b94d7a3358d48f6bfc10a16e52fc070 9b94d7a3358d48f6bfc10a16e52fc070--d5866e5119e542cfbc082650ee5a4601 0f5c6de9c1bb4e69aa369aadbc4c2ff8 9b94d7a3358d48f6bfc10a16e52fc070--0f5c6de9c1bb4e69aa369aadbc4c2ff8 0984d772b158412aa0251d9dcc00230d 0f5c6de9c1bb4e69aa369aadbc4c2ff8--0984d772b158412aa0251d9dcc00230d cad9581ad89245e6b2e81a0d618494c3 0984d772b158412aa0251d9dcc00230d--cad9581ad89245e6b2e81a0d618494c3 260bfe9f83a24c7397750a15b6dab80e cad9581ad89245e6b2e81a0d618494c3--260bfe9f83a24c7397750a15b6dab80e d200021dd85d4e69b28e2637b09ff18d 260bfe9f83a24c7397750a15b6dab80e--d200021dd85d4e69b28e2637b09ff18d 33cda8802bda4d8783dc04d68fd22a73 d200021dd85d4e69b28e2637b09ff18d--33cda8802bda4d8783dc04d68fd22a73 a7fa84b82c0d44949031b3b3935dc2c9 33cda8802bda4d8783dc04d68fd22a73--a7fa84b82c0d44949031b3b3935dc2c9 02fd0ff1d8b842739c0a747dc552fa95 a7fa84b82c0d44949031b3b3935dc2c9--02fd0ff1d8b842739c0a747dc552fa95 e6e8edddd88244eda09ea723ae45a1b4 02fd0ff1d8b842739c0a747dc552fa95--e6e8edddd88244eda09ea723ae45a1b4 f9b565624cee4056aff0685d9cd3fc24 e6e8edddd88244eda09ea723ae45a1b4--f9b565624cee4056aff0685d9cd3fc24 08443dfb5afb4b63860ab8c8587c01f5 f9b565624cee4056aff0685d9cd3fc24--08443dfb5afb4b63860ab8c8587c01f5 b2e811cf11fd4f04ae07d6a2223de985 08443dfb5afb4b63860ab8c8587c01f5--b2e811cf11fd4f04ae07d6a2223de985 e6734cf558994ba5be122f0c236a2226 b2e811cf11fd4f04ae07d6a2223de985--e6734cf558994ba5be122f0c236a2226 7e666f4bcce34a0bac491e4d3db6d6c3 e6734cf558994ba5be122f0c236a2226--7e666f4bcce34a0bac491e4d3db6d6c3 0484ed6d77664fceb9dec42d52fe930d 7e666f4bcce34a0bac491e4d3db6d6c3--0484ed6d77664fceb9dec42d52fe930d 83664245752d4db79a363ef2bb6bf5fd 0484ed6d77664fceb9dec42d52fe930d--83664245752d4db79a363ef2bb6bf5fd 1d961605261740e597d63b9014ccdd77 83664245752d4db79a363ef2bb6bf5fd--1d961605261740e597d63b9014ccdd77 d27ef6efbbbb4b7488deb79e3dfbc5ce 1d961605261740e597d63b9014ccdd77--d27ef6efbbbb4b7488deb79e3dfbc5ce 1d5aee20a6014a3c9386855f743c2405 d27ef6efbbbb4b7488deb79e3dfbc5ce--1d5aee20a6014a3c9386855f743c2405 baa764adabf04287ab0ca9b9676bb035 1d5aee20a6014a3c9386855f743c2405--baa764adabf04287ab0ca9b9676bb035 172c363d43d74057b4e1c948e544947c baa764adabf04287ab0ca9b9676bb035--172c363d43d74057b4e1c948e544947c c261c7bd8c964dafb8018b439b73224d 172c363d43d74057b4e1c948e544947c--c261c7bd8c964dafb8018b439b73224d 8fabc1666bf44c2fb58e03fcd41f2521 c261c7bd8c964dafb8018b439b73224d--8fabc1666bf44c2fb58e03fcd41f2521 51a16638f2144808a0335755b5e232c1 8fabc1666bf44c2fb58e03fcd41f2521--51a16638f2144808a0335755b5e232c1 eb69e2550b2a4f44ad60f6c08e5305e9 51a16638f2144808a0335755b5e232c1--eb69e2550b2a4f44ad60f6c08e5305e9 3ef14252aaa04c7d8c7791b1ce9cfeff eb69e2550b2a4f44ad60f6c08e5305e9--3ef14252aaa04c7d8c7791b1ce9cfeff 02019643f1494e4aab7cc3a99c1f4d1e 3ef14252aaa04c7d8c7791b1ce9cfeff--02019643f1494e4aab7cc3a99c1f4d1e 5ca0b5aafefe4c2eb7fe8b458136ad10 02019643f1494e4aab7cc3a99c1f4d1e--5ca0b5aafefe4c2eb7fe8b458136ad10 45dca6f67dbb45fb822e44dceaac17b6 5ca0b5aafefe4c2eb7fe8b458136ad10--45dca6f67dbb45fb822e44dceaac17b6 8aa28b8cf4204a8cb81a9063d261bae2 45dca6f67dbb45fb822e44dceaac17b6--8aa28b8cf4204a8cb81a9063d261bae2 22de137ce71c4b4da01eef61e1f62e97 8aa28b8cf4204a8cb81a9063d261bae2--22de137ce71c4b4da01eef61e1f62e97 a2ce993fdd1f4c07a80f41edbe3c95c2 22de137ce71c4b4da01eef61e1f62e97--a2ce993fdd1f4c07a80f41edbe3c95c2 b943de6328cd47eebb9bceb6917c4623 a2ce993fdd1f4c07a80f41edbe3c95c2--b943de6328cd47eebb9bceb6917c4623 4cca745a3dab410b95ed5f27bb06841d b943de6328cd47eebb9bceb6917c4623--4cca745a3dab410b95ed5f27bb06841d db4b955460814d4bb1ce296d12bacf15 4cca745a3dab410b95ed5f27bb06841d--db4b955460814d4bb1ce296d12bacf15 3ee58f37ebc44b87929fc1c719a4edf9 db4b955460814d4bb1ce296d12bacf15--3ee58f37ebc44b87929fc1c719a4edf9 aa841a087b39447f81ddc04381656e36 3ee58f37ebc44b87929fc1c719a4edf9--aa841a087b39447f81ddc04381656e36 e0e23b51ccb14750918b32b7808360c4 aa841a087b39447f81ddc04381656e36--e0e23b51ccb14750918b32b7808360c4 ba56f67ff712489ab1db848b88b9b857 e0e23b51ccb14750918b32b7808360c4--ba56f67ff712489ab1db848b88b9b857 2a66d3bc321f408d9b88460472556331 ba56f67ff712489ab1db848b88b9b857--2a66d3bc321f408d9b88460472556331 0b87c1140a544a3291e745655225ba2f 2a66d3bc321f408d9b88460472556331--0b87c1140a544a3291e745655225ba2f f2c1087b15844fc1bd70e69cc31bb9c6 0b87c1140a544a3291e745655225ba2f--f2c1087b15844fc1bd70e69cc31bb9c6 6e770a72ddbb477597e755768823f53e f2c1087b15844fc1bd70e69cc31bb9c6--6e770a72ddbb477597e755768823f53e 5457453eba5446d792c460bc2c46b058 6e770a72ddbb477597e755768823f53e--5457453eba5446d792c460bc2c46b058 7eb6ca80f0ca449ebc269fbaa137a198 5457453eba5446d792c460bc2c46b058--7eb6ca80f0ca449ebc269fbaa137a198 77f228dbbdee4d2585c3bb77889bfaf5 7eb6ca80f0ca449ebc269fbaa137a198--77f228dbbdee4d2585c3bb77889bfaf5 6549b2c46de04aa4ada2395df09eab65 77f228dbbdee4d2585c3bb77889bfaf5--6549b2c46de04aa4ada2395df09eab65 ede12b3ebab24b18be43a7bb25261d70 6549b2c46de04aa4ada2395df09eab65--ede12b3ebab24b18be43a7bb25261d70 a31ed2c522b548a3a5d562ad116a88fa ede12b3ebab24b18be43a7bb25261d70--a31ed2c522b548a3a5d562ad116a88fa 8c0e5d9f86c54b07943ce49fe47592fc a31ed2c522b548a3a5d562ad116a88fa--8c0e5d9f86c54b07943ce49fe47592fc e9c7edadd5344ef2a635dad0b2c39094 8c0e5d9f86c54b07943ce49fe47592fc--e9c7edadd5344ef2a635dad0b2c39094 3a13b7a87c744eb6a4e438220a7d4e2f e9c7edadd5344ef2a635dad0b2c39094--3a13b7a87c744eb6a4e438220a7d4e2f 2e27760c010549b096f7f445c6cc8e77 3a13b7a87c744eb6a4e438220a7d4e2f--2e27760c010549b096f7f445c6cc8e77 f66567606bc54cbc8de09512462ed758 2e27760c010549b096f7f445c6cc8e77--f66567606bc54cbc8de09512462ed758 3b8e0d45c8f04f8d837e52c8a160ece8 f66567606bc54cbc8de09512462ed758--3b8e0d45c8f04f8d837e52c8a160ece8 5f3d379167744c49bfda3c585a02ad3d 3b8e0d45c8f04f8d837e52c8a160ece8--5f3d379167744c49bfda3c585a02ad3d 92582e3d4324445c87eeeef23bc56403 5f3d379167744c49bfda3c585a02ad3d--92582e3d4324445c87eeeef23bc56403 c5397d9330dd40e28754e42eae799133 92582e3d4324445c87eeeef23bc56403--c5397d9330dd40e28754e42eae799133 9d5cf6bb0dc54a10850510fafb149bf2 c5397d9330dd40e28754e42eae799133--9d5cf6bb0dc54a10850510fafb149bf2 2b195cf00b0d4a71b34e84322d956bb3 9d5cf6bb0dc54a10850510fafb149bf2--2b195cf00b0d4a71b34e84322d956bb3 e58da78d67b7499f997948831cb3693f 2b195cf00b0d4a71b34e84322d956bb3--e58da78d67b7499f997948831cb3693f 74fa41aebea742a68ec5793182f1d171 e58da78d67b7499f997948831cb3693f--74fa41aebea742a68ec5793182f1d171 bd9da70519a246519135b4ebfeb54494 74fa41aebea742a68ec5793182f1d171--bd9da70519a246519135b4ebfeb54494 c2caa58ee0f942ddaea81f412c0e3ec2 bd9da70519a246519135b4ebfeb54494--c2caa58ee0f942ddaea81f412c0e3ec2 2aa4637d388640bab5185d6963f4f6ca c2caa58ee0f942ddaea81f412c0e3ec2--2aa4637d388640bab5185d6963f4f6ca 0dd39cb12f3b4174ac2a1823ba5e0d15 2aa4637d388640bab5185d6963f4f6ca--0dd39cb12f3b4174ac2a1823ba5e0d15 22ed4c686f06442586c5870135f9d1cb 0dd39cb12f3b4174ac2a1823ba5e0d15--22ed4c686f06442586c5870135f9d1cb 4ed161e0c1df49b5a5a8d4f3a060edd3 22ed4c686f06442586c5870135f9d1cb--4ed161e0c1df49b5a5a8d4f3a060edd3 1d203146dd9745caa3aec948f1c1f739 4ed161e0c1df49b5a5a8d4f3a060edd3--1d203146dd9745caa3aec948f1c1f739 899e745867a046febc2e61bf0c283e27 1d203146dd9745caa3aec948f1c1f739--899e745867a046febc2e61bf0c283e27 edcc5a6eaa5a4beca6a4b568f779b0a7 899e745867a046febc2e61bf0c283e27--edcc5a6eaa5a4beca6a4b568f779b0a7 6dfe8c9ee4f2481e9b590947fbbabcf1 edcc5a6eaa5a4beca6a4b568f779b0a7--6dfe8c9ee4f2481e9b590947fbbabcf1 3e1924f9dd184e9d91dfd35473ec8c5a 6dfe8c9ee4f2481e9b590947fbbabcf1--3e1924f9dd184e9d91dfd35473ec8c5a 2ec7b25d179f48a6acf7a7726ddc6ef4 3e1924f9dd184e9d91dfd35473ec8c5a--2ec7b25d179f48a6acf7a7726ddc6ef4 c19890815c1e4437ae5ceb5b6793d8c1 2ec7b25d179f48a6acf7a7726ddc6ef4--c19890815c1e4437ae5ceb5b6793d8c1 9f9aad97d4dc4705b507cee946faa4b5 c19890815c1e4437ae5ceb5b6793d8c1--9f9aad97d4dc4705b507cee946faa4b5 5bcfec8c12a34b0782546d3e1ac23ffa 9f9aad97d4dc4705b507cee946faa4b5--5bcfec8c12a34b0782546d3e1ac23ffa 372ab53aff5d46338faf653472d5241b 5bcfec8c12a34b0782546d3e1ac23ffa--372ab53aff5d46338faf653472d5241b a1feea4b54604701a3302d395db91cf3 372ab53aff5d46338faf653472d5241b--a1feea4b54604701a3302d395db91cf3 b818a4f08c8141c2a1520ad15429beff a1feea4b54604701a3302d395db91cf3--b818a4f08c8141c2a1520ad15429beff 4ba22cb27bbb42a2b15553eab9e949d3 b818a4f08c8141c2a1520ad15429beff--4ba22cb27bbb42a2b15553eab9e949d3 a25b2337334742c5b49f04d7b64b4de6 4ba22cb27bbb42a2b15553eab9e949d3--a25b2337334742c5b49f04d7b64b4de6 3f60cae9680a477981ea40fe510b8dae a25b2337334742c5b49f04d7b64b4de6--3f60cae9680a477981ea40fe510b8dae d151bc5ac7c0490c9d7caea37ac56fd4 3f60cae9680a477981ea40fe510b8dae--d151bc5ac7c0490c9d7caea37ac56fd4 5b41bf646e3d478d8f40ff8f67e68d54 d151bc5ac7c0490c9d7caea37ac56fd4--5b41bf646e3d478d8f40ff8f67e68d54 99ab5547207341689c4ec3d96e3b41cf 5b41bf646e3d478d8f40ff8f67e68d54--99ab5547207341689c4ec3d96e3b41cf 793b6e3e6f634eb7acef9a0205456f2c RX(b11) 99ab5547207341689c4ec3d96e3b41cf--793b6e3e6f634eb7acef9a0205456f2c 793b6e3e6f634eb7acef9a0205456f2c--8cfae0698b0447f288ce6c2dec487241 8588046986824221a59678cf55bd08a8 8bc7cb8a4321452880cd708a5f02e9b5 9aed72acf46541c4894a127c20543f74--8bc7cb8a4321452880cd708a5f02e9b5 8d59ea75cf9c40a09344835de06c1aa1 3 086c954015fb4ef59b799defbe689c00 X 8bc7cb8a4321452880cd708a5f02e9b5--086c954015fb4ef59b799defbe689c00 086c954015fb4ef59b799defbe689c00--1e20f8c6b6c645c895b1f6ba48dac6e9 24e0a0133e784494bcee56435fa6b792 086c954015fb4ef59b799defbe689c00--24e0a0133e784494bcee56435fa6b792 cf73c61946d84024a2623c907e811798 24e0a0133e784494bcee56435fa6b792--cf73c61946d84024a2623c907e811798 b606c123f7a94ee7a053b1511d566b44 cf73c61946d84024a2623c907e811798--b606c123f7a94ee7a053b1511d566b44 9807c712f3b442fd9820c0692a056fd4 b606c123f7a94ee7a053b1511d566b44--9807c712f3b442fd9820c0692a056fd4 8f6a924ba9524034b95d73aa29dbdb52 9807c712f3b442fd9820c0692a056fd4--8f6a924ba9524034b95d73aa29dbdb52 b808038967e44395b54c6848a679b0c9 8f6a924ba9524034b95d73aa29dbdb52--b808038967e44395b54c6848a679b0c9 e806e25a79d54cb696d10271892836ac b808038967e44395b54c6848a679b0c9--e806e25a79d54cb696d10271892836ac 03cc04bf4955494fb1eab80e8959cd2e e806e25a79d54cb696d10271892836ac--03cc04bf4955494fb1eab80e8959cd2e efa4024bb0f941a5a2fab8d1a59399a5 03cc04bf4955494fb1eab80e8959cd2e--efa4024bb0f941a5a2fab8d1a59399a5 98aad63f4e724fe9b06313d80e9ff54f efa4024bb0f941a5a2fab8d1a59399a5--98aad63f4e724fe9b06313d80e9ff54f bf6699c5e3fe4233aa6fc9a1c895b378 98aad63f4e724fe9b06313d80e9ff54f--bf6699c5e3fe4233aa6fc9a1c895b378 fd794aadb97c4d85be6594a9dc6aa976 X bf6699c5e3fe4233aa6fc9a1c895b378--fd794aadb97c4d85be6594a9dc6aa976 fd794aadb97c4d85be6594a9dc6aa976--c4a12c5a4bb4499392cc249e045ac0eb 96b57c7f6ca74c2c9c0b462e828edcee fd794aadb97c4d85be6594a9dc6aa976--96b57c7f6ca74c2c9c0b462e828edcee 03ba3cc5d843413393738925c7fd7e6c 96b57c7f6ca74c2c9c0b462e828edcee--03ba3cc5d843413393738925c7fd7e6c 63eaedc6bbe1476f8a8ccdbcdb5318d8 03ba3cc5d843413393738925c7fd7e6c--63eaedc6bbe1476f8a8ccdbcdb5318d8 4bf952ed38a04ceca3dec5d596937513 63eaedc6bbe1476f8a8ccdbcdb5318d8--4bf952ed38a04ceca3dec5d596937513 d8e740e115154992b6407d4760a6bd08 X 4bf952ed38a04ceca3dec5d596937513--d8e740e115154992b6407d4760a6bd08 d8e740e115154992b6407d4760a6bd08--4fc4350b0def49399cecb4eaac9b9cf2 b5861491515240d6914becfe5f1b0d75 d8e740e115154992b6407d4760a6bd08--b5861491515240d6914becfe5f1b0d75 c13b66a514f344e494c8ee4d23537186 b5861491515240d6914becfe5f1b0d75--c13b66a514f344e494c8ee4d23537186 2cd1d757f4574336845c6f267c415f66 c13b66a514f344e494c8ee4d23537186--2cd1d757f4574336845c6f267c415f66 4078a832ee0c49e79ac26262dff918f7 2cd1d757f4574336845c6f267c415f66--4078a832ee0c49e79ac26262dff918f7 9705f2f9356e4ee1ab9339befbf51b89 4078a832ee0c49e79ac26262dff918f7--9705f2f9356e4ee1ab9339befbf51b89 c18aa673cfac443a945f167799585093 X 9705f2f9356e4ee1ab9339befbf51b89--c18aa673cfac443a945f167799585093 c18aa673cfac443a945f167799585093--fbe7bfefe3bb4c37a76559586713ecb4 1fd8d56ab7f54f819845e7b9cbbbf88f X c18aa673cfac443a945f167799585093--1fd8d56ab7f54f819845e7b9cbbbf88f 1fd8d56ab7f54f819845e7b9cbbbf88f--71321d92a2274bf581ccabcf22ff3188 4b7babcb019c414e8abb4b6cf586288d 1fd8d56ab7f54f819845e7b9cbbbf88f--4b7babcb019c414e8abb4b6cf586288d 4c1106a5590e40a88c5ec639becbc28a 4b7babcb019c414e8abb4b6cf586288d--4c1106a5590e40a88c5ec639becbc28a d7fefff1efba408f836145dee8b0beaf 4c1106a5590e40a88c5ec639becbc28a--d7fefff1efba408f836145dee8b0beaf 0b1571d52a4543b187d17518bc6f89d2 d7fefff1efba408f836145dee8b0beaf--0b1571d52a4543b187d17518bc6f89d2 b9c893d3d9c5482592c952d8c309d8b2 0b1571d52a4543b187d17518bc6f89d2--b9c893d3d9c5482592c952d8c309d8b2 fb5303c730004531b5f27747e390ae53 b9c893d3d9c5482592c952d8c309d8b2--fb5303c730004531b5f27747e390ae53 f1936ece56834e3888c3e31fbaf512e2 fb5303c730004531b5f27747e390ae53--f1936ece56834e3888c3e31fbaf512e2 61c953dbc7ba476c816b709477228bff X f1936ece56834e3888c3e31fbaf512e2--61c953dbc7ba476c816b709477228bff 61c953dbc7ba476c816b709477228bff--3bd00ba31be84f8eabe67c6f018f15b4 51f47838c7a8439094577ace9cc6d45e X 61c953dbc7ba476c816b709477228bff--51f47838c7a8439094577ace9cc6d45e 51f47838c7a8439094577ace9cc6d45e--2e342a312d6f4b2ca0bb14b13942f162 360dfb3f265345dc98494a77ffbbe3bf 51f47838c7a8439094577ace9cc6d45e--360dfb3f265345dc98494a77ffbbe3bf a47331af7f36401fb60946ded315f7f9 360dfb3f265345dc98494a77ffbbe3bf--a47331af7f36401fb60946ded315f7f9 914fbf0d2ab949bba9af8248bf431b2a a47331af7f36401fb60946ded315f7f9--914fbf0d2ab949bba9af8248bf431b2a a8d8d8b26f38402cae459ba4bc16a235 914fbf0d2ab949bba9af8248bf431b2a--a8d8d8b26f38402cae459ba4bc16a235 1f63e8416b524e04a5dd8745c2b4f871 a8d8d8b26f38402cae459ba4bc16a235--1f63e8416b524e04a5dd8745c2b4f871 f258a974a0984aeea2c5799453cb4f3d 1f63e8416b524e04a5dd8745c2b4f871--f258a974a0984aeea2c5799453cb4f3d d66d68e8b5fc43cb9363f3e01e360953 f258a974a0984aeea2c5799453cb4f3d--d66d68e8b5fc43cb9363f3e01e360953 9579cbd7379d41cfb7d8ffff624479b5 d66d68e8b5fc43cb9363f3e01e360953--9579cbd7379d41cfb7d8ffff624479b5 90b9da4ea29e4c69977ffdefa76b05f5 9579cbd7379d41cfb7d8ffff624479b5--90b9da4ea29e4c69977ffdefa76b05f5 29321443ab0e43bcb58b0f84663b0786 X 90b9da4ea29e4c69977ffdefa76b05f5--29321443ab0e43bcb58b0f84663b0786 29321443ab0e43bcb58b0f84663b0786--8850d9941bb441068031f0000767cd18 9c3bbe114b344e3f81c688ae29fcf7fa 29321443ab0e43bcb58b0f84663b0786--9c3bbe114b344e3f81c688ae29fcf7fa 417c94b9218d464e9600ccfe987e3dc8 9c3bbe114b344e3f81c688ae29fcf7fa--417c94b9218d464e9600ccfe987e3dc8 38f810f12fdb46ee8541dc9035a13bc1 417c94b9218d464e9600ccfe987e3dc8--38f810f12fdb46ee8541dc9035a13bc1 fd267083a5044e16af5959de3e6fd8af 38f810f12fdb46ee8541dc9035a13bc1--fd267083a5044e16af5959de3e6fd8af c873da8f8b434a9488ddc4af17bc7be5 fd267083a5044e16af5959de3e6fd8af--c873da8f8b434a9488ddc4af17bc7be5 2c49e8489cdf48c8b4bc072a56a8ae87 c873da8f8b434a9488ddc4af17bc7be5--2c49e8489cdf48c8b4bc072a56a8ae87 2b460fd462f84413a857b6f26e6d4eee 2c49e8489cdf48c8b4bc072a56a8ae87--2b460fd462f84413a857b6f26e6d4eee e6c061c40402425792e0d1b64d49340c 2b460fd462f84413a857b6f26e6d4eee--e6c061c40402425792e0d1b64d49340c eabf3bef37f0489088a86f63dc7dffbb e6c061c40402425792e0d1b64d49340c--eabf3bef37f0489088a86f63dc7dffbb f3576712505b435c9c73060de4c06547 eabf3bef37f0489088a86f63dc7dffbb--f3576712505b435c9c73060de4c06547 e081964fa53e48569b9b295091751567 f3576712505b435c9c73060de4c06547--e081964fa53e48569b9b295091751567 665da90017f74d1f867687c5345269b7 e081964fa53e48569b9b295091751567--665da90017f74d1f867687c5345269b7 45eec72a33aa464bb1b22fec5ffb84b3 665da90017f74d1f867687c5345269b7--45eec72a33aa464bb1b22fec5ffb84b3 01a666d4664c4a80b09dea9ae387556f 45eec72a33aa464bb1b22fec5ffb84b3--01a666d4664c4a80b09dea9ae387556f 4cdf3b48a3a24ea995adae8b73eb87e4 01a666d4664c4a80b09dea9ae387556f--4cdf3b48a3a24ea995adae8b73eb87e4 f8cee53ebd354ceda27953f3bf1370c1 4cdf3b48a3a24ea995adae8b73eb87e4--f8cee53ebd354ceda27953f3bf1370c1 df6fe306cdf7407c91d4617596914af4 f8cee53ebd354ceda27953f3bf1370c1--df6fe306cdf7407c91d4617596914af4 c0483289e05b4dae85970e80ebc5990f df6fe306cdf7407c91d4617596914af4--c0483289e05b4dae85970e80ebc5990f 04492aa459264166a822cd518a8eb714 c0483289e05b4dae85970e80ebc5990f--04492aa459264166a822cd518a8eb714 eb638d77c7184f878fd1aa1ef32ebad8 04492aa459264166a822cd518a8eb714--eb638d77c7184f878fd1aa1ef32ebad8 f550ae40d4e84e67a1f78aa675c34357 eb638d77c7184f878fd1aa1ef32ebad8--f550ae40d4e84e67a1f78aa675c34357 a9b81f70d55f4f80881559867a2ea7be f550ae40d4e84e67a1f78aa675c34357--a9b81f70d55f4f80881559867a2ea7be e2676b70665c4d24a8246549adeddbe9 a9b81f70d55f4f80881559867a2ea7be--e2676b70665c4d24a8246549adeddbe9 9a99643481d64195bd80241918ef4c8e e2676b70665c4d24a8246549adeddbe9--9a99643481d64195bd80241918ef4c8e 8af61352b1bd41e9b376e28a9d90c14c 9a99643481d64195bd80241918ef4c8e--8af61352b1bd41e9b376e28a9d90c14c fded1218c6234620a056d4091ae544dc 8af61352b1bd41e9b376e28a9d90c14c--fded1218c6234620a056d4091ae544dc 12df0afcc94f4836bbc9f304c8de676f fded1218c6234620a056d4091ae544dc--12df0afcc94f4836bbc9f304c8de676f 31f4a314552745b8bfb5157a49bfeef9 12df0afcc94f4836bbc9f304c8de676f--31f4a314552745b8bfb5157a49bfeef9 bcb99a6b35e24df695f5b5fd17e388e3 31f4a314552745b8bfb5157a49bfeef9--bcb99a6b35e24df695f5b5fd17e388e3 632ff15a8a6b40179b89b53a85a2ce1f bcb99a6b35e24df695f5b5fd17e388e3--632ff15a8a6b40179b89b53a85a2ce1f d23447aa6f9a422ea7e9f7199de064cc 632ff15a8a6b40179b89b53a85a2ce1f--d23447aa6f9a422ea7e9f7199de064cc 142f9f2a27e44333b32dc030528cf174 d23447aa6f9a422ea7e9f7199de064cc--142f9f2a27e44333b32dc030528cf174 8d17721f5f644cb8806275cdec8672c2 142f9f2a27e44333b32dc030528cf174--8d17721f5f644cb8806275cdec8672c2 35ee86dbc3af441f8ec108d06af0346d 8d17721f5f644cb8806275cdec8672c2--35ee86dbc3af441f8ec108d06af0346d aab4e02d5a9149c7a016e76d55da8127 35ee86dbc3af441f8ec108d06af0346d--aab4e02d5a9149c7a016e76d55da8127 9f9f1830dd76484ebb9d57b923b7c8f2 aab4e02d5a9149c7a016e76d55da8127--9f9f1830dd76484ebb9d57b923b7c8f2 9870c2ed90ad457d89d9eabe8ba89017 9f9f1830dd76484ebb9d57b923b7c8f2--9870c2ed90ad457d89d9eabe8ba89017 703b062248604660a021c1b4350c1ea9 9870c2ed90ad457d89d9eabe8ba89017--703b062248604660a021c1b4350c1ea9 4c5f0afd808b421da281e82000f8605a 703b062248604660a021c1b4350c1ea9--4c5f0afd808b421da281e82000f8605a ed822b9ca763428f835b644d4a0b2070 4c5f0afd808b421da281e82000f8605a--ed822b9ca763428f835b644d4a0b2070 fc5a5e0d268d4e63859200daea3019ce ed822b9ca763428f835b644d4a0b2070--fc5a5e0d268d4e63859200daea3019ce 8491afc13d4740898f2dc015f99888e8 fc5a5e0d268d4e63859200daea3019ce--8491afc13d4740898f2dc015f99888e8 8c32b0af4be94798a2be70816d8d9e6f 8491afc13d4740898f2dc015f99888e8--8c32b0af4be94798a2be70816d8d9e6f bd201f9ea8274071bd9f3c046c2dc237 8c32b0af4be94798a2be70816d8d9e6f--bd201f9ea8274071bd9f3c046c2dc237 55b01f79969a41aea38d3382f164f433 bd201f9ea8274071bd9f3c046c2dc237--55b01f79969a41aea38d3382f164f433 579507e01d7d4069a2e9a70f00166c87 55b01f79969a41aea38d3382f164f433--579507e01d7d4069a2e9a70f00166c87 7950432614474d2eb5f685388eefb01e 579507e01d7d4069a2e9a70f00166c87--7950432614474d2eb5f685388eefb01e 55a7fb6669274c2bb80fc586b5c4e455 7950432614474d2eb5f685388eefb01e--55a7fb6669274c2bb80fc586b5c4e455 e1a6aa7800d0468890095bb1aa321f1d 55a7fb6669274c2bb80fc586b5c4e455--e1a6aa7800d0468890095bb1aa321f1d 00051aaa06b9494facf5034dcab03c23 e1a6aa7800d0468890095bb1aa321f1d--00051aaa06b9494facf5034dcab03c23 58aa0be642b443b28b2e19ab3e78028a 00051aaa06b9494facf5034dcab03c23--58aa0be642b443b28b2e19ab3e78028a 4a39c62caf37416181ce4a4f46b0dc48 58aa0be642b443b28b2e19ab3e78028a--4a39c62caf37416181ce4a4f46b0dc48 da9d5367505c448297c8efba988e7f66 4a39c62caf37416181ce4a4f46b0dc48--da9d5367505c448297c8efba988e7f66 e3d7193ac51f422d8ae2c92624d822b0 da9d5367505c448297c8efba988e7f66--e3d7193ac51f422d8ae2c92624d822b0 6b4b8d72ad29485982fc5f3264456f7b e3d7193ac51f422d8ae2c92624d822b0--6b4b8d72ad29485982fc5f3264456f7b 5c89846852614273b79dd3a0a4ef93e7 6b4b8d72ad29485982fc5f3264456f7b--5c89846852614273b79dd3a0a4ef93e7 4f2e2ad7aa5643f6bff7d658870192ed 5c89846852614273b79dd3a0a4ef93e7--4f2e2ad7aa5643f6bff7d658870192ed 2c7ef3582b8b4a7e82faa88400485a3b 4f2e2ad7aa5643f6bff7d658870192ed--2c7ef3582b8b4a7e82faa88400485a3b c55cef5fe7ec47aea35e5e82b1b06e32 2c7ef3582b8b4a7e82faa88400485a3b--c55cef5fe7ec47aea35e5e82b1b06e32 fce4f8921b684bc0a627372e0d618c45 RX(b02) c55cef5fe7ec47aea35e5e82b1b06e32--fce4f8921b684bc0a627372e0d618c45 819cd49e1f1642feab8ba1da1e79f9fb fce4f8921b684bc0a627372e0d618c45--819cd49e1f1642feab8ba1da1e79f9fb 05576015dcb341dc88fa3dad7637b948 X 819cd49e1f1642feab8ba1da1e79f9fb--05576015dcb341dc88fa3dad7637b948 05576015dcb341dc88fa3dad7637b948--1bece4a88e4d42449f2cac03bc88374a 7258e34645544afb9b3e91575355d928 05576015dcb341dc88fa3dad7637b948--7258e34645544afb9b3e91575355d928 988ccc266a73402bab024af6252b1504 7258e34645544afb9b3e91575355d928--988ccc266a73402bab024af6252b1504 3e1506bac8b440f196e53b11039b5df4 988ccc266a73402bab024af6252b1504--3e1506bac8b440f196e53b11039b5df4 c5ed1f7c1a8949169bc0c7fbf7735c25 3e1506bac8b440f196e53b11039b5df4--c5ed1f7c1a8949169bc0c7fbf7735c25 03c9e3b92f18444e92d3532a983f9438 c5ed1f7c1a8949169bc0c7fbf7735c25--03c9e3b92f18444e92d3532a983f9438 4bace610898e46a7a9fcbdc2588c3fd2 03c9e3b92f18444e92d3532a983f9438--4bace610898e46a7a9fcbdc2588c3fd2 6c54627c8d304a12ae9c68cbabc6b93b 4bace610898e46a7a9fcbdc2588c3fd2--6c54627c8d304a12ae9c68cbabc6b93b b560607151ca421abdd8367984ef7f6e 6c54627c8d304a12ae9c68cbabc6b93b--b560607151ca421abdd8367984ef7f6e 82be71e40ecf4ce09b251a605cb771f5 b560607151ca421abdd8367984ef7f6e--82be71e40ecf4ce09b251a605cb771f5 0a3da52220554dbaa8eb6a39bdf63ee3 82be71e40ecf4ce09b251a605cb771f5--0a3da52220554dbaa8eb6a39bdf63ee3 8bafaacd6ad1473aa594b0a62c77a88d 0a3da52220554dbaa8eb6a39bdf63ee3--8bafaacd6ad1473aa594b0a62c77a88d 9b72537106564b8b9df72f662f1c7e65 X 8bafaacd6ad1473aa594b0a62c77a88d--9b72537106564b8b9df72f662f1c7e65 9b72537106564b8b9df72f662f1c7e65--a6dcd6657e4f4d9392316ff49b0f6bb8 0f39b3e7c0314222b367a40697705486 9b72537106564b8b9df72f662f1c7e65--0f39b3e7c0314222b367a40697705486 6bcc4fb92c274bb8bacd81c71939a1ca 0f39b3e7c0314222b367a40697705486--6bcc4fb92c274bb8bacd81c71939a1ca 2877c34157014e928ae5599a3b581d2c 6bcc4fb92c274bb8bacd81c71939a1ca--2877c34157014e928ae5599a3b581d2c 9c15a397beba412b8b11ad2d1bd887b5 2877c34157014e928ae5599a3b581d2c--9c15a397beba412b8b11ad2d1bd887b5 93645f1672494c92845469b0f85429c5 X 9c15a397beba412b8b11ad2d1bd887b5--93645f1672494c92845469b0f85429c5 93645f1672494c92845469b0f85429c5--0f5c6de9c1bb4e69aa369aadbc4c2ff8 a4ace78609f44506a755f865c36d7be0 93645f1672494c92845469b0f85429c5--a4ace78609f44506a755f865c36d7be0 8685e7700c8747b392c247b52f74791c a4ace78609f44506a755f865c36d7be0--8685e7700c8747b392c247b52f74791c f3eda3f055d14a14a6e662bd52a7fa88 8685e7700c8747b392c247b52f74791c--f3eda3f055d14a14a6e662bd52a7fa88 893142b682674399b218a10678552e22 f3eda3f055d14a14a6e662bd52a7fa88--893142b682674399b218a10678552e22 409254cede924e78a2f325205c79cad7 893142b682674399b218a10678552e22--409254cede924e78a2f325205c79cad7 819cf86f06054c32985ee5f4e56c4868 X 409254cede924e78a2f325205c79cad7--819cf86f06054c32985ee5f4e56c4868 819cf86f06054c32985ee5f4e56c4868--a7fa84b82c0d44949031b3b3935dc2c9 0bedad69428041ee849398af485de0eb X 819cf86f06054c32985ee5f4e56c4868--0bedad69428041ee849398af485de0eb 0bedad69428041ee849398af485de0eb--02fd0ff1d8b842739c0a747dc552fa95 e2134824db974d4fae3a156ed08f2f8a 0bedad69428041ee849398af485de0eb--e2134824db974d4fae3a156ed08f2f8a 1bb398cb18b04846af96b751b9704214 e2134824db974d4fae3a156ed08f2f8a--1bb398cb18b04846af96b751b9704214 b7795f44e26748639e53f5d6830f407a 1bb398cb18b04846af96b751b9704214--b7795f44e26748639e53f5d6830f407a dd66b9120b6d425686a52e4174bf93a2 b7795f44e26748639e53f5d6830f407a--dd66b9120b6d425686a52e4174bf93a2 db675ab0187748858d9eddf93e35f872 dd66b9120b6d425686a52e4174bf93a2--db675ab0187748858d9eddf93e35f872 e993e771d8c0449f997d2d409cd3dbab db675ab0187748858d9eddf93e35f872--e993e771d8c0449f997d2d409cd3dbab 47bf9d08cdd64be9b5c89c140960f684 e993e771d8c0449f997d2d409cd3dbab--47bf9d08cdd64be9b5c89c140960f684 e048b844b3b1409e941e73388f58285d X 47bf9d08cdd64be9b5c89c140960f684--e048b844b3b1409e941e73388f58285d e048b844b3b1409e941e73388f58285d--83664245752d4db79a363ef2bb6bf5fd 2c21dd6ab1c04eca9236b286de3c4cd0 X e048b844b3b1409e941e73388f58285d--2c21dd6ab1c04eca9236b286de3c4cd0 2c21dd6ab1c04eca9236b286de3c4cd0--1d961605261740e597d63b9014ccdd77 2461054a8c3d4dac9482a4c4da8489fb 2c21dd6ab1c04eca9236b286de3c4cd0--2461054a8c3d4dac9482a4c4da8489fb 04bda0a7dda34e9ca696ce806c938806 2461054a8c3d4dac9482a4c4da8489fb--04bda0a7dda34e9ca696ce806c938806 0b24b31c75514fe0bfbcad8876f87551 04bda0a7dda34e9ca696ce806c938806--0b24b31c75514fe0bfbcad8876f87551 361254aacb2145c68482593322733937 0b24b31c75514fe0bfbcad8876f87551--361254aacb2145c68482593322733937 ab05759775724a9d9f59bc0ca0d07de7 361254aacb2145c68482593322733937--ab05759775724a9d9f59bc0ca0d07de7 71cdb0beefc046d993c409a3d8d67049 ab05759775724a9d9f59bc0ca0d07de7--71cdb0beefc046d993c409a3d8d67049 9b5c9110dba54d01a22a0109c83695d4 71cdb0beefc046d993c409a3d8d67049--9b5c9110dba54d01a22a0109c83695d4 8ffa578812794e9b8dd7683182deccf2 9b5c9110dba54d01a22a0109c83695d4--8ffa578812794e9b8dd7683182deccf2 68c41083157a44a4a2aa719b363fdf27 8ffa578812794e9b8dd7683182deccf2--68c41083157a44a4a2aa719b363fdf27 8c7fefed0b9d4d6cb7d1d26788347be3 X 68c41083157a44a4a2aa719b363fdf27--8c7fefed0b9d4d6cb7d1d26788347be3 8c7fefed0b9d4d6cb7d1d26788347be3--02019643f1494e4aab7cc3a99c1f4d1e e576ce8036e748b8ba100e71dbbf71f3 8c7fefed0b9d4d6cb7d1d26788347be3--e576ce8036e748b8ba100e71dbbf71f3 b14e92b5a20945f5b1bc4dc473851e0b e576ce8036e748b8ba100e71dbbf71f3--b14e92b5a20945f5b1bc4dc473851e0b 280344d785bd41dd99e7477d66f2eb90 b14e92b5a20945f5b1bc4dc473851e0b--280344d785bd41dd99e7477d66f2eb90 5619a3b7ab054b03918c4e3a698a2c07 280344d785bd41dd99e7477d66f2eb90--5619a3b7ab054b03918c4e3a698a2c07 51e5e5df704b4bb891a6864563a88d71 5619a3b7ab054b03918c4e3a698a2c07--51e5e5df704b4bb891a6864563a88d71 ba68aaa518624353a57d10cff4f10a52 51e5e5df704b4bb891a6864563a88d71--ba68aaa518624353a57d10cff4f10a52 df03d3b7f4cf4d3f9e1958c3b42273e5 ba68aaa518624353a57d10cff4f10a52--df03d3b7f4cf4d3f9e1958c3b42273e5 85d6e62433c84fc2a816d139d43deb81 df03d3b7f4cf4d3f9e1958c3b42273e5--85d6e62433c84fc2a816d139d43deb81 2316cd34fe4f4369879ac9f1b1d54dae 85d6e62433c84fc2a816d139d43deb81--2316cd34fe4f4369879ac9f1b1d54dae da5e0ab284784f27929be327383d1076 2316cd34fe4f4369879ac9f1b1d54dae--da5e0ab284784f27929be327383d1076 5a3cdd5ea4324940a061e8c6ed31234d da5e0ab284784f27929be327383d1076--5a3cdd5ea4324940a061e8c6ed31234d 1746e37e192d40d1a0be4bc9acdba6fe 5a3cdd5ea4324940a061e8c6ed31234d--1746e37e192d40d1a0be4bc9acdba6fe 509ef6ca0d484657bdaf3853b50453cd 1746e37e192d40d1a0be4bc9acdba6fe--509ef6ca0d484657bdaf3853b50453cd 5473f8c90d314bb7957ed4d127019ce8 509ef6ca0d484657bdaf3853b50453cd--5473f8c90d314bb7957ed4d127019ce8 bdcb5528bbea4b329d7f1031d4dca8de 5473f8c90d314bb7957ed4d127019ce8--bdcb5528bbea4b329d7f1031d4dca8de f74a4775271d418f81c355207c2ba984 bdcb5528bbea4b329d7f1031d4dca8de--f74a4775271d418f81c355207c2ba984 2c1853a6b0a34a17af5b0cd9aa251f6e f74a4775271d418f81c355207c2ba984--2c1853a6b0a34a17af5b0cd9aa251f6e e9d0e0650aa84720a921f758362781e1 2c1853a6b0a34a17af5b0cd9aa251f6e--e9d0e0650aa84720a921f758362781e1 fab5c4afdf944305b12fd1285f471229 e9d0e0650aa84720a921f758362781e1--fab5c4afdf944305b12fd1285f471229 87b084486dea4ef183a81a43073ec09a fab5c4afdf944305b12fd1285f471229--87b084486dea4ef183a81a43073ec09a be82014675134a0e81d142920c4984b8 87b084486dea4ef183a81a43073ec09a--be82014675134a0e81d142920c4984b8 a3c26a23c86546f0a4e3ece5ac124d91 be82014675134a0e81d142920c4984b8--a3c26a23c86546f0a4e3ece5ac124d91 5771af5fdddb4ec6b6eb33d392afbbc8 a3c26a23c86546f0a4e3ece5ac124d91--5771af5fdddb4ec6b6eb33d392afbbc8 7a04fac0e85e47bcb3b134a96f875ffd 5771af5fdddb4ec6b6eb33d392afbbc8--7a04fac0e85e47bcb3b134a96f875ffd 300b515740b449b086c3d55fae011232 7a04fac0e85e47bcb3b134a96f875ffd--300b515740b449b086c3d55fae011232 1f5bb7b181fb458384b5d2487674e61c 300b515740b449b086c3d55fae011232--1f5bb7b181fb458384b5d2487674e61c a3b516330dbd440f8e6d2174261b22e4 1f5bb7b181fb458384b5d2487674e61c--a3b516330dbd440f8e6d2174261b22e4 fc7d222d75e642b49bfc3b1fe990e39f a3b516330dbd440f8e6d2174261b22e4--fc7d222d75e642b49bfc3b1fe990e39f dad14127e2564453aab518652d352273 fc7d222d75e642b49bfc3b1fe990e39f--dad14127e2564453aab518652d352273 3140cf1fdf534b0687b4c5fa2e438f36 dad14127e2564453aab518652d352273--3140cf1fdf534b0687b4c5fa2e438f36 b8412cbf2e7d4a108081d4722ceef42d 3140cf1fdf534b0687b4c5fa2e438f36--b8412cbf2e7d4a108081d4722ceef42d 74f49cc6c170419e88f4d486dcd7720f b8412cbf2e7d4a108081d4722ceef42d--74f49cc6c170419e88f4d486dcd7720f b617e95dd3884505b95c003dcc2acbb9 74f49cc6c170419e88f4d486dcd7720f--b617e95dd3884505b95c003dcc2acbb9 50829ab226a34069af052629f2ee1d00 b617e95dd3884505b95c003dcc2acbb9--50829ab226a34069af052629f2ee1d00 1fdc89cdf40d42778ac1c8aa0208cdc0 50829ab226a34069af052629f2ee1d00--1fdc89cdf40d42778ac1c8aa0208cdc0 91c32ae8a3b14ee3be22621c77bd1d86 1fdc89cdf40d42778ac1c8aa0208cdc0--91c32ae8a3b14ee3be22621c77bd1d86 c1e42cbd11ef42acbdf4cd3a00963485 91c32ae8a3b14ee3be22621c77bd1d86--c1e42cbd11ef42acbdf4cd3a00963485 21234c6d96d84f49aa0d46145a47f512 c1e42cbd11ef42acbdf4cd3a00963485--21234c6d96d84f49aa0d46145a47f512 75979285423b48a2ba15262e12cab6df 21234c6d96d84f49aa0d46145a47f512--75979285423b48a2ba15262e12cab6df 1ab9a27ac4114ce49579604a74b97861 75979285423b48a2ba15262e12cab6df--1ab9a27ac4114ce49579604a74b97861 e589bce3cb64488d9d7bc73ce51599b1 1ab9a27ac4114ce49579604a74b97861--e589bce3cb64488d9d7bc73ce51599b1 6df40978e3974a0a8e604d7933e21ad6 e589bce3cb64488d9d7bc73ce51599b1--6df40978e3974a0a8e604d7933e21ad6 d83afdefdaf2462baf8fb45bad09f5c5 6df40978e3974a0a8e604d7933e21ad6--d83afdefdaf2462baf8fb45bad09f5c5 73a0fc8173e84077b45e6b126b72df1f d83afdefdaf2462baf8fb45bad09f5c5--73a0fc8173e84077b45e6b126b72df1f 6be57518f1bb4ab8ba04b854e36e45e0 73a0fc8173e84077b45e6b126b72df1f--6be57518f1bb4ab8ba04b854e36e45e0 9834df38d5e04c4089ea3fde4e02bf3b 6be57518f1bb4ab8ba04b854e36e45e0--9834df38d5e04c4089ea3fde4e02bf3b 87fb4762339f40daae3232e0b8907678 9834df38d5e04c4089ea3fde4e02bf3b--87fb4762339f40daae3232e0b8907678 639023ad094449df852f2bafb47a43ef 87fb4762339f40daae3232e0b8907678--639023ad094449df852f2bafb47a43ef aa7dfcec815548e184c581e5a5b58eb7 639023ad094449df852f2bafb47a43ef--aa7dfcec815548e184c581e5a5b58eb7 76d3b702312f4f308a02f8222e2ec844 aa7dfcec815548e184c581e5a5b58eb7--76d3b702312f4f308a02f8222e2ec844 02bf9ec01bce4766b442b3ae128e6c0d 76d3b702312f4f308a02f8222e2ec844--02bf9ec01bce4766b442b3ae128e6c0d 2b33774c7b5443f4a2d9aef9039b4d9d 02bf9ec01bce4766b442b3ae128e6c0d--2b33774c7b5443f4a2d9aef9039b4d9d ee2548afd6a94223a3b84d88806c12e2 2b33774c7b5443f4a2d9aef9039b4d9d--ee2548afd6a94223a3b84d88806c12e2 75a7327227a54ecf90c50d6c8cd425e6 ee2548afd6a94223a3b84d88806c12e2--75a7327227a54ecf90c50d6c8cd425e6 23440b1a78ac430d858371d8f5845a2a 75a7327227a54ecf90c50d6c8cd425e6--23440b1a78ac430d858371d8f5845a2a 9607f673476f4e9b9db9563e725b62fe 23440b1a78ac430d858371d8f5845a2a--9607f673476f4e9b9db9563e725b62fe fadc948debd340409d4ed2e652c073e0 9607f673476f4e9b9db9563e725b62fe--fadc948debd340409d4ed2e652c073e0 65fc3476cfe84d2e9c36657bb6495da9 fadc948debd340409d4ed2e652c073e0--65fc3476cfe84d2e9c36657bb6495da9 d259317b3d5147608cef7eafa0bc77ed 65fc3476cfe84d2e9c36657bb6495da9--d259317b3d5147608cef7eafa0bc77ed 992121379476447e900ed8675c54ea18 RX(b12) d259317b3d5147608cef7eafa0bc77ed--992121379476447e900ed8675c54ea18 992121379476447e900ed8675c54ea18--8588046986824221a59678cf55bd08a8 5a7663a31fa34a65ad633bfc8906a4a6 d44aab9ce35e4c439f5d9b78612a750d 8d59ea75cf9c40a09344835de06c1aa1--d44aab9ce35e4c439f5d9b78612a750d 4c1411b6c3174900a086e99d80208e76 4 c5a15bfb78894cfcb20ac8b9c463fadc d44aab9ce35e4c439f5d9b78612a750d--c5a15bfb78894cfcb20ac8b9c463fadc 4da08a859f764a52896347125cb1af82 X c5a15bfb78894cfcb20ac8b9c463fadc--4da08a859f764a52896347125cb1af82 4da08a859f764a52896347125cb1af82--24e0a0133e784494bcee56435fa6b792 46cd427215f44978a75f1aed7ee982c4 4da08a859f764a52896347125cb1af82--46cd427215f44978a75f1aed7ee982c4 00ea1832560a4f418bd7c03fa741dc57 46cd427215f44978a75f1aed7ee982c4--00ea1832560a4f418bd7c03fa741dc57 bdafa9adf8d34dc7afda0aa7cf98e843 00ea1832560a4f418bd7c03fa741dc57--bdafa9adf8d34dc7afda0aa7cf98e843 d39fa141237940ccbb5fc9ec9d344b8c bdafa9adf8d34dc7afda0aa7cf98e843--d39fa141237940ccbb5fc9ec9d344b8c d54e7367ebfb40688342669c43935e2e d39fa141237940ccbb5fc9ec9d344b8c--d54e7367ebfb40688342669c43935e2e 36a434c30b95480aa6890c5a0c86d194 d54e7367ebfb40688342669c43935e2e--36a434c30b95480aa6890c5a0c86d194 9b88d2bb993a48dfbb2f4c82d17bef40 36a434c30b95480aa6890c5a0c86d194--9b88d2bb993a48dfbb2f4c82d17bef40 14aad67f135848cd9b8254f332a0dd07 9b88d2bb993a48dfbb2f4c82d17bef40--14aad67f135848cd9b8254f332a0dd07 3efc7f709e9640049b3d7a4271c54473 14aad67f135848cd9b8254f332a0dd07--3efc7f709e9640049b3d7a4271c54473 608d3c6fc255401abf97d238c26bd63b X 3efc7f709e9640049b3d7a4271c54473--608d3c6fc255401abf97d238c26bd63b 608d3c6fc255401abf97d238c26bd63b--bf6699c5e3fe4233aa6fc9a1c895b378 c0bd69d53d8f461695146bcf634c6a7f 608d3c6fc255401abf97d238c26bd63b--c0bd69d53d8f461695146bcf634c6a7f 445263ec2191460db424fa08b1570047 c0bd69d53d8f461695146bcf634c6a7f--445263ec2191460db424fa08b1570047 8d1a121ab24f40b986584d9b6665a1b4 445263ec2191460db424fa08b1570047--8d1a121ab24f40b986584d9b6665a1b4 8e9e6d33023443168575ad26d6a3df7b 8d1a121ab24f40b986584d9b6665a1b4--8e9e6d33023443168575ad26d6a3df7b c6010a098fec4a869d46f6d7e4ed295a 8e9e6d33023443168575ad26d6a3df7b--c6010a098fec4a869d46f6d7e4ed295a c3b8f57a95be47d5b47b2b9a7873792d c6010a098fec4a869d46f6d7e4ed295a--c3b8f57a95be47d5b47b2b9a7873792d 288fede5927a4410bb738b40f154fbe0 X c3b8f57a95be47d5b47b2b9a7873792d--288fede5927a4410bb738b40f154fbe0 288fede5927a4410bb738b40f154fbe0--b5861491515240d6914becfe5f1b0d75 6fde7a5c25c0408d8f16b61c501ad924 288fede5927a4410bb738b40f154fbe0--6fde7a5c25c0408d8f16b61c501ad924 ff9c3f39989e47eba78f60a476b6830f 6fde7a5c25c0408d8f16b61c501ad924--ff9c3f39989e47eba78f60a476b6830f 42f6d11af9264426989b39960afae559 ff9c3f39989e47eba78f60a476b6830f--42f6d11af9264426989b39960afae559 7d0aa45a5fab4be6b8155ad7d64e0a9d X 42f6d11af9264426989b39960afae559--7d0aa45a5fab4be6b8155ad7d64e0a9d 7d0aa45a5fab4be6b8155ad7d64e0a9d--9705f2f9356e4ee1ab9339befbf51b89 4bc9ae84db414b908705ac2b44d2728f 7d0aa45a5fab4be6b8155ad7d64e0a9d--4bc9ae84db414b908705ac2b44d2728f 72ea3fe3babf43c194a929365a05d116 4bc9ae84db414b908705ac2b44d2728f--72ea3fe3babf43c194a929365a05d116 6d083e7b19b94a4eaad4ca59df9c5748 X 72ea3fe3babf43c194a929365a05d116--6d083e7b19b94a4eaad4ca59df9c5748 6d083e7b19b94a4eaad4ca59df9c5748--4b7babcb019c414e8abb4b6cf586288d 121864818de94189a150909992ea8d1b 6d083e7b19b94a4eaad4ca59df9c5748--121864818de94189a150909992ea8d1b 4f0bf9f84d174d4cac29952d0ee8b2ac 121864818de94189a150909992ea8d1b--4f0bf9f84d174d4cac29952d0ee8b2ac 2734ccff14304170b01edfb5f0352155 4f0bf9f84d174d4cac29952d0ee8b2ac--2734ccff14304170b01edfb5f0352155 32127954a4b5499a9ff53774b03fcae2 2734ccff14304170b01edfb5f0352155--32127954a4b5499a9ff53774b03fcae2 11132fd72ab44d7cb91614d8aeaab613 32127954a4b5499a9ff53774b03fcae2--11132fd72ab44d7cb91614d8aeaab613 161bde5a7af44d68aa821cd90ff46cad X 11132fd72ab44d7cb91614d8aeaab613--161bde5a7af44d68aa821cd90ff46cad 161bde5a7af44d68aa821cd90ff46cad--f1936ece56834e3888c3e31fbaf512e2 94a0e2a5a0c5451d91443b75037a5ea1 161bde5a7af44d68aa821cd90ff46cad--94a0e2a5a0c5451d91443b75037a5ea1 86f2faf672ba45cda117c64052be3772 94a0e2a5a0c5451d91443b75037a5ea1--86f2faf672ba45cda117c64052be3772 f43e7e1b168e40069d043b6c03eb1ff6 X 86f2faf672ba45cda117c64052be3772--f43e7e1b168e40069d043b6c03eb1ff6 f43e7e1b168e40069d043b6c03eb1ff6--360dfb3f265345dc98494a77ffbbe3bf 28169eee7be943f1a7bd61c9ec21831f f43e7e1b168e40069d043b6c03eb1ff6--28169eee7be943f1a7bd61c9ec21831f 1e8cd73c6f2e420f9fbcf90f10340dd5 28169eee7be943f1a7bd61c9ec21831f--1e8cd73c6f2e420f9fbcf90f10340dd5 8128a47bb1df465e8e8245a15c1b7ea3 1e8cd73c6f2e420f9fbcf90f10340dd5--8128a47bb1df465e8e8245a15c1b7ea3 59ac4d0ba1ad4ba29e33c3cebc454cfe 8128a47bb1df465e8e8245a15c1b7ea3--59ac4d0ba1ad4ba29e33c3cebc454cfe 3f7d1bded28d4db39836b24503eddd03 59ac4d0ba1ad4ba29e33c3cebc454cfe--3f7d1bded28d4db39836b24503eddd03 9cec4ede2bf54dd486b724d93d0ad5fe 3f7d1bded28d4db39836b24503eddd03--9cec4ede2bf54dd486b724d93d0ad5fe 74af52db7b214ee38a395b769aaec038 9cec4ede2bf54dd486b724d93d0ad5fe--74af52db7b214ee38a395b769aaec038 c84c98642f2d450088274b090215986a X 74af52db7b214ee38a395b769aaec038--c84c98642f2d450088274b090215986a c84c98642f2d450088274b090215986a--90b9da4ea29e4c69977ffdefa76b05f5 23c262a4ada744fab64dd04ed4e51560 c84c98642f2d450088274b090215986a--23c262a4ada744fab64dd04ed4e51560 8063f35f785649d5b5536286922cd301 X 23c262a4ada744fab64dd04ed4e51560--8063f35f785649d5b5536286922cd301 8063f35f785649d5b5536286922cd301--9c3bbe114b344e3f81c688ae29fcf7fa 6c8d6627a9684b7a94f395695e4a5209 8063f35f785649d5b5536286922cd301--6c8d6627a9684b7a94f395695e4a5209 e7a51948cbe7472d93cd5fb815dd8381 6c8d6627a9684b7a94f395695e4a5209--e7a51948cbe7472d93cd5fb815dd8381 fe1eb189b2234aa68428e49444e66226 e7a51948cbe7472d93cd5fb815dd8381--fe1eb189b2234aa68428e49444e66226 48718b9197e14192bcee65c90bfdac62 X fe1eb189b2234aa68428e49444e66226--48718b9197e14192bcee65c90bfdac62 48718b9197e14192bcee65c90bfdac62--c873da8f8b434a9488ddc4af17bc7be5 7e59bd8ca7d1457f909aedc41824078e X 48718b9197e14192bcee65c90bfdac62--7e59bd8ca7d1457f909aedc41824078e 7e59bd8ca7d1457f909aedc41824078e--2c49e8489cdf48c8b4bc072a56a8ae87 7d84295efeaf4e60a53ac49bcb3eda3f 7e59bd8ca7d1457f909aedc41824078e--7d84295efeaf4e60a53ac49bcb3eda3f d67d894995974090809c7931f28fa422 7d84295efeaf4e60a53ac49bcb3eda3f--d67d894995974090809c7931f28fa422 8fa6e43b731a4c1e9aa6647bb6903eef d67d894995974090809c7931f28fa422--8fa6e43b731a4c1e9aa6647bb6903eef 6cb030f96ec347a5b60a55729f6d2d43 8fa6e43b731a4c1e9aa6647bb6903eef--6cb030f96ec347a5b60a55729f6d2d43 feeb8d1dfc3341058c9f079861978b08 6cb030f96ec347a5b60a55729f6d2d43--feeb8d1dfc3341058c9f079861978b08 aadd548430294f28b92c97efeb54f16f X feeb8d1dfc3341058c9f079861978b08--aadd548430294f28b92c97efeb54f16f aadd548430294f28b92c97efeb54f16f--665da90017f74d1f867687c5345269b7 1b8b8a34888c409ea15809be417a2929 X aadd548430294f28b92c97efeb54f16f--1b8b8a34888c409ea15809be417a2929 1b8b8a34888c409ea15809be417a2929--45eec72a33aa464bb1b22fec5ffb84b3 5d78e5f54001490e8b6e5f385f2dff69 1b8b8a34888c409ea15809be417a2929--5d78e5f54001490e8b6e5f385f2dff69 87abe08e46224d0ab7556959a8fb906c 5d78e5f54001490e8b6e5f385f2dff69--87abe08e46224d0ab7556959a8fb906c 4277d928ba6d43cd844e804c0cb03115 87abe08e46224d0ab7556959a8fb906c--4277d928ba6d43cd844e804c0cb03115 2f1a8a77aec344f1b992ee7de6205987 4277d928ba6d43cd844e804c0cb03115--2f1a8a77aec344f1b992ee7de6205987 bcb59b35202941e38ea8223e8c7e27af 2f1a8a77aec344f1b992ee7de6205987--bcb59b35202941e38ea8223e8c7e27af f9a6196634fb4b4eb95147fba796bdbf bcb59b35202941e38ea8223e8c7e27af--f9a6196634fb4b4eb95147fba796bdbf cd72dc730bd546028f55990d320f9ec7 f9a6196634fb4b4eb95147fba796bdbf--cd72dc730bd546028f55990d320f9ec7 4f432f74ea074de39beb6e0aa7a55330 X cd72dc730bd546028f55990d320f9ec7--4f432f74ea074de39beb6e0aa7a55330 4f432f74ea074de39beb6e0aa7a55330--f550ae40d4e84e67a1f78aa675c34357 d7d6fbf1de594700ad3d09c98d05ef49 X 4f432f74ea074de39beb6e0aa7a55330--d7d6fbf1de594700ad3d09c98d05ef49 d7d6fbf1de594700ad3d09c98d05ef49--a9b81f70d55f4f80881559867a2ea7be bc886659e97a42008402259927a94639 d7d6fbf1de594700ad3d09c98d05ef49--bc886659e97a42008402259927a94639 348643ca25404d76b6c7d8883e546a5a bc886659e97a42008402259927a94639--348643ca25404d76b6c7d8883e546a5a f6d68e9bc3fc4f13b2f3892726cd8683 348643ca25404d76b6c7d8883e546a5a--f6d68e9bc3fc4f13b2f3892726cd8683 3d61dc586d3f496cb8ec28c0d15c66db f6d68e9bc3fc4f13b2f3892726cd8683--3d61dc586d3f496cb8ec28c0d15c66db 0e105c05f4de4bc591bdd70fcfc7b97c 3d61dc586d3f496cb8ec28c0d15c66db--0e105c05f4de4bc591bdd70fcfc7b97c fc24c9f3d36940b485fedb15d629e752 0e105c05f4de4bc591bdd70fcfc7b97c--fc24c9f3d36940b485fedb15d629e752 1fb81a8d6df047d3a5442794ec5aea0d fc24c9f3d36940b485fedb15d629e752--1fb81a8d6df047d3a5442794ec5aea0d 733ca394a0bf434db7279851b8a6091f 1fb81a8d6df047d3a5442794ec5aea0d--733ca394a0bf434db7279851b8a6091f 38604969acb74fb09e81e55d502621e6 733ca394a0bf434db7279851b8a6091f--38604969acb74fb09e81e55d502621e6 833242357170474da3d3d18eeb3b4684 X 38604969acb74fb09e81e55d502621e6--833242357170474da3d3d18eeb3b4684 833242357170474da3d3d18eeb3b4684--142f9f2a27e44333b32dc030528cf174 1a46a523ec4f4f4999da770dceb2c0fe 833242357170474da3d3d18eeb3b4684--1a46a523ec4f4f4999da770dceb2c0fe 470bc285b800465b9ff06274dd51db1d 1a46a523ec4f4f4999da770dceb2c0fe--470bc285b800465b9ff06274dd51db1d acf9cb73c8aa420e822bb93f7435d121 470bc285b800465b9ff06274dd51db1d--acf9cb73c8aa420e822bb93f7435d121 4393a0647542446fb64183c97288ca0e acf9cb73c8aa420e822bb93f7435d121--4393a0647542446fb64183c97288ca0e ce147f429a2a4dcdac862ba5e86c1750 4393a0647542446fb64183c97288ca0e--ce147f429a2a4dcdac862ba5e86c1750 e923ec79cac844b0b91b03a34db06101 ce147f429a2a4dcdac862ba5e86c1750--e923ec79cac844b0b91b03a34db06101 3880f5f5765a46bc9346465404f8f8ec e923ec79cac844b0b91b03a34db06101--3880f5f5765a46bc9346465404f8f8ec f740db066c644e249d1b0350933d0b71 3880f5f5765a46bc9346465404f8f8ec--f740db066c644e249d1b0350933d0b71 bddee7eade274a4da9b930d95e9cde94 f740db066c644e249d1b0350933d0b71--bddee7eade274a4da9b930d95e9cde94 5a6e93544699495dbb5503341bdd1e58 bddee7eade274a4da9b930d95e9cde94--5a6e93544699495dbb5503341bdd1e58 e16e972edbfe47c9b3ee9df4a9fce90c 5a6e93544699495dbb5503341bdd1e58--e16e972edbfe47c9b3ee9df4a9fce90c 0a53bbd620ca40e79536a402275a8b88 e16e972edbfe47c9b3ee9df4a9fce90c--0a53bbd620ca40e79536a402275a8b88 2111520c11554cdeab4be74d8d9133d8 0a53bbd620ca40e79536a402275a8b88--2111520c11554cdeab4be74d8d9133d8 8974e6a29692413181e0b5ffd63e2955 2111520c11554cdeab4be74d8d9133d8--8974e6a29692413181e0b5ffd63e2955 bccc1b0744174aa1a1fcfa4621aa16a7 8974e6a29692413181e0b5ffd63e2955--bccc1b0744174aa1a1fcfa4621aa16a7 92823dba2ad24f7681590cf0dfbf9189 bccc1b0744174aa1a1fcfa4621aa16a7--92823dba2ad24f7681590cf0dfbf9189 db28f5cff99949d0a67880beed15e3aa 92823dba2ad24f7681590cf0dfbf9189--db28f5cff99949d0a67880beed15e3aa c248cc6faf1b42f08d0632ca3c8ede0b db28f5cff99949d0a67880beed15e3aa--c248cc6faf1b42f08d0632ca3c8ede0b 958c4a0b61fb4ac1adfee6cb1f42176e c248cc6faf1b42f08d0632ca3c8ede0b--958c4a0b61fb4ac1adfee6cb1f42176e 5728240c706940a9b886f4a2f162a634 958c4a0b61fb4ac1adfee6cb1f42176e--5728240c706940a9b886f4a2f162a634 675e17c136fa424383292db72e01c366 5728240c706940a9b886f4a2f162a634--675e17c136fa424383292db72e01c366 4a578c776dcf4bd9b28501229c38d616 675e17c136fa424383292db72e01c366--4a578c776dcf4bd9b28501229c38d616 95299d8f1ae94438a8881384c3c11fb5 4a578c776dcf4bd9b28501229c38d616--95299d8f1ae94438a8881384c3c11fb5 3a7ae100f869404db6d1c704c8f7d083 95299d8f1ae94438a8881384c3c11fb5--3a7ae100f869404db6d1c704c8f7d083 85e4fd46ea8e4b099a06b4e0157a3a91 3a7ae100f869404db6d1c704c8f7d083--85e4fd46ea8e4b099a06b4e0157a3a91 f0d76c1d09bd4f18979b191e21e4e017 85e4fd46ea8e4b099a06b4e0157a3a91--f0d76c1d09bd4f18979b191e21e4e017 7eafc918c15f4732ac515e1e70f1e9ba f0d76c1d09bd4f18979b191e21e4e017--7eafc918c15f4732ac515e1e70f1e9ba fb4faf8ee61242bcbfbfe85e72c2ba3e RX(b03) 7eafc918c15f4732ac515e1e70f1e9ba--fb4faf8ee61242bcbfbfe85e72c2ba3e 0f52bc8c52d24e7cac8aff1ca54c5846 fb4faf8ee61242bcbfbfe85e72c2ba3e--0f52bc8c52d24e7cac8aff1ca54c5846 49d4d18dbeb04058936a782fbabe1bb4 0f52bc8c52d24e7cac8aff1ca54c5846--49d4d18dbeb04058936a782fbabe1bb4 5cf10bc756094afeacddebbafaf6881f X 49d4d18dbeb04058936a782fbabe1bb4--5cf10bc756094afeacddebbafaf6881f 5cf10bc756094afeacddebbafaf6881f--7258e34645544afb9b3e91575355d928 bce02b2d38b347bfbc0851cef561191f 5cf10bc756094afeacddebbafaf6881f--bce02b2d38b347bfbc0851cef561191f 6cb518c38d234f50af30d16f48f2015a bce02b2d38b347bfbc0851cef561191f--6cb518c38d234f50af30d16f48f2015a dd5f435bed8d4a1e87f37aa034698534 6cb518c38d234f50af30d16f48f2015a--dd5f435bed8d4a1e87f37aa034698534 9b439165420a41c5ba30bd1b6cf312b9 dd5f435bed8d4a1e87f37aa034698534--9b439165420a41c5ba30bd1b6cf312b9 17cdd97a8f714233903cee188b4cf986 9b439165420a41c5ba30bd1b6cf312b9--17cdd97a8f714233903cee188b4cf986 5eea8e69c7cd45b18f093556582b8cf7 17cdd97a8f714233903cee188b4cf986--5eea8e69c7cd45b18f093556582b8cf7 90901306c17f48fdbcdf7abaacd517c4 5eea8e69c7cd45b18f093556582b8cf7--90901306c17f48fdbcdf7abaacd517c4 999c1c0d04334caa98a87e307ea18369 90901306c17f48fdbcdf7abaacd517c4--999c1c0d04334caa98a87e307ea18369 bbe506bee5ed4e87830d97ebc608bc03 999c1c0d04334caa98a87e307ea18369--bbe506bee5ed4e87830d97ebc608bc03 3e56716f4acb4af19f9c762a70651a57 X bbe506bee5ed4e87830d97ebc608bc03--3e56716f4acb4af19f9c762a70651a57 3e56716f4acb4af19f9c762a70651a57--8bafaacd6ad1473aa594b0a62c77a88d 2046fec3a817460a8552f0c1fd439b93 3e56716f4acb4af19f9c762a70651a57--2046fec3a817460a8552f0c1fd439b93 c4a26b16690343e2be1e6b4262cb4ccd 2046fec3a817460a8552f0c1fd439b93--c4a26b16690343e2be1e6b4262cb4ccd 0c3f5a390a724ad782b6c744fa84cc98 c4a26b16690343e2be1e6b4262cb4ccd--0c3f5a390a724ad782b6c744fa84cc98 4ff9ec81cd1e4982bb00148b1fc9cd21 0c3f5a390a724ad782b6c744fa84cc98--4ff9ec81cd1e4982bb00148b1fc9cd21 2116813229014b47a55e44203b25202a 4ff9ec81cd1e4982bb00148b1fc9cd21--2116813229014b47a55e44203b25202a 96e74995b73f4cb8b471bb785a43e4b8 2116813229014b47a55e44203b25202a--96e74995b73f4cb8b471bb785a43e4b8 775827f15de14cf684a44d727bd9d4b2 X 96e74995b73f4cb8b471bb785a43e4b8--775827f15de14cf684a44d727bd9d4b2 775827f15de14cf684a44d727bd9d4b2--a4ace78609f44506a755f865c36d7be0 e1a13e2f623c46c4aa0daf1a423900da 775827f15de14cf684a44d727bd9d4b2--e1a13e2f623c46c4aa0daf1a423900da b1e0262471234333b5cf65ec6a0f53af e1a13e2f623c46c4aa0daf1a423900da--b1e0262471234333b5cf65ec6a0f53af 0f16161f075042d5a1d10c3c2d8e1a92 b1e0262471234333b5cf65ec6a0f53af--0f16161f075042d5a1d10c3c2d8e1a92 8a839829b1bf4373ba7b2d820b8b435d X 0f16161f075042d5a1d10c3c2d8e1a92--8a839829b1bf4373ba7b2d820b8b435d 8a839829b1bf4373ba7b2d820b8b435d--409254cede924e78a2f325205c79cad7 d10889eb37db4ee584f56c17ce1fc396 8a839829b1bf4373ba7b2d820b8b435d--d10889eb37db4ee584f56c17ce1fc396 95ad0172343640d08cda7bd9d194d990 d10889eb37db4ee584f56c17ce1fc396--95ad0172343640d08cda7bd9d194d990 efe88822c53e4ce2809659cef8ee0b99 X 95ad0172343640d08cda7bd9d194d990--efe88822c53e4ce2809659cef8ee0b99 efe88822c53e4ce2809659cef8ee0b99--e2134824db974d4fae3a156ed08f2f8a 373ab902a51d43a9a69589e71f3a6aa0 efe88822c53e4ce2809659cef8ee0b99--373ab902a51d43a9a69589e71f3a6aa0 cb2e29c9215340ed8d56ffb5c8e3df62 373ab902a51d43a9a69589e71f3a6aa0--cb2e29c9215340ed8d56ffb5c8e3df62 ba0fd5eabcab420190e8d56d99c74584 cb2e29c9215340ed8d56ffb5c8e3df62--ba0fd5eabcab420190e8d56d99c74584 f7f7c802b6c341559e363c3c98fa6092 ba0fd5eabcab420190e8d56d99c74584--f7f7c802b6c341559e363c3c98fa6092 5b76814e73f044c09d32aaf21b6c7e4e f7f7c802b6c341559e363c3c98fa6092--5b76814e73f044c09d32aaf21b6c7e4e 4c1de5da287f41a6b7def311bcb96587 X 5b76814e73f044c09d32aaf21b6c7e4e--4c1de5da287f41a6b7def311bcb96587 4c1de5da287f41a6b7def311bcb96587--47bf9d08cdd64be9b5c89c140960f684 cc35e86702b4467abc8e264507ee2cdb 4c1de5da287f41a6b7def311bcb96587--cc35e86702b4467abc8e264507ee2cdb d54353f01a304630a5bbd78e3f393a16 cc35e86702b4467abc8e264507ee2cdb--d54353f01a304630a5bbd78e3f393a16 152b7ead87a14274bc56381010fcb00f X d54353f01a304630a5bbd78e3f393a16--152b7ead87a14274bc56381010fcb00f 152b7ead87a14274bc56381010fcb00f--2461054a8c3d4dac9482a4c4da8489fb f39cf22b08554503a3feebe61e31259c 152b7ead87a14274bc56381010fcb00f--f39cf22b08554503a3feebe61e31259c 44b73b0efa8242c390ca52ce54bd9b61 f39cf22b08554503a3feebe61e31259c--44b73b0efa8242c390ca52ce54bd9b61 8386d893cf3e412a9b9a09c919e2c4c4 44b73b0efa8242c390ca52ce54bd9b61--8386d893cf3e412a9b9a09c919e2c4c4 cbb5de33815f446f9d796de5dea61359 8386d893cf3e412a9b9a09c919e2c4c4--cbb5de33815f446f9d796de5dea61359 7e6c3f25fe6645448554fbb2e3106c18 cbb5de33815f446f9d796de5dea61359--7e6c3f25fe6645448554fbb2e3106c18 af0f244afcb64887b094166744c8c0c1 7e6c3f25fe6645448554fbb2e3106c18--af0f244afcb64887b094166744c8c0c1 a76a30f19cbb4416aa413b199aea6277 af0f244afcb64887b094166744c8c0c1--a76a30f19cbb4416aa413b199aea6277 3d09029672df43f7a219030e823ca165 X a76a30f19cbb4416aa413b199aea6277--3d09029672df43f7a219030e823ca165 3d09029672df43f7a219030e823ca165--68c41083157a44a4a2aa719b363fdf27 c949ae09c900434ca411189fb5eae8ad 3d09029672df43f7a219030e823ca165--c949ae09c900434ca411189fb5eae8ad 23a0b07793a04ef19226edcdb67ec547 X c949ae09c900434ca411189fb5eae8ad--23a0b07793a04ef19226edcdb67ec547 23a0b07793a04ef19226edcdb67ec547--e576ce8036e748b8ba100e71dbbf71f3 0607ebe60ea146f1b81832d4e21d209f 23a0b07793a04ef19226edcdb67ec547--0607ebe60ea146f1b81832d4e21d209f 06314a2f4e2c449a89607a85c8e321b2 0607ebe60ea146f1b81832d4e21d209f--06314a2f4e2c449a89607a85c8e321b2 34ee69fbbe734d36845fa77cefa9ec7e 06314a2f4e2c449a89607a85c8e321b2--34ee69fbbe734d36845fa77cefa9ec7e f337a6c3767d4ef487ff03d7e8192139 X 34ee69fbbe734d36845fa77cefa9ec7e--f337a6c3767d4ef487ff03d7e8192139 f337a6c3767d4ef487ff03d7e8192139--51e5e5df704b4bb891a6864563a88d71 5f05f76ce8984bbe95f92bab11141292 X f337a6c3767d4ef487ff03d7e8192139--5f05f76ce8984bbe95f92bab11141292 5f05f76ce8984bbe95f92bab11141292--ba68aaa518624353a57d10cff4f10a52 694615c9163c4d94a06d3c5b6b6e5fde 5f05f76ce8984bbe95f92bab11141292--694615c9163c4d94a06d3c5b6b6e5fde b340df6f6e86436d9ea6b2e226121389 694615c9163c4d94a06d3c5b6b6e5fde--b340df6f6e86436d9ea6b2e226121389 d5482f9f7b164e0e8b8235823f708ae0 b340df6f6e86436d9ea6b2e226121389--d5482f9f7b164e0e8b8235823f708ae0 54fcf83b39f04f85bae063ee43fe4a85 d5482f9f7b164e0e8b8235823f708ae0--54fcf83b39f04f85bae063ee43fe4a85 1f73a41872f844bd95e7293d1275abaf 54fcf83b39f04f85bae063ee43fe4a85--1f73a41872f844bd95e7293d1275abaf ca160946065e4fd79b33727a24df6214 X 1f73a41872f844bd95e7293d1275abaf--ca160946065e4fd79b33727a24df6214 ca160946065e4fd79b33727a24df6214--1746e37e192d40d1a0be4bc9acdba6fe 27170d8be059489e9eaa99187fbad329 X ca160946065e4fd79b33727a24df6214--27170d8be059489e9eaa99187fbad329 27170d8be059489e9eaa99187fbad329--509ef6ca0d484657bdaf3853b50453cd 1dbca751d53149c1845b7bf3dd8420c2 27170d8be059489e9eaa99187fbad329--1dbca751d53149c1845b7bf3dd8420c2 9377c826ec184839b1208988d145afe7 1dbca751d53149c1845b7bf3dd8420c2--9377c826ec184839b1208988d145afe7 3c68af45a11242d9849905c0791155c0 9377c826ec184839b1208988d145afe7--3c68af45a11242d9849905c0791155c0 829508e8e8244aecab11f0bcb37f6469 3c68af45a11242d9849905c0791155c0--829508e8e8244aecab11f0bcb37f6469 da23e8dea3bb482aa0549988925870f2 829508e8e8244aecab11f0bcb37f6469--da23e8dea3bb482aa0549988925870f2 17996a1640364053ae0a4c8936a22428 da23e8dea3bb482aa0549988925870f2--17996a1640364053ae0a4c8936a22428 7c39043ba72c4139bb34f4d8e553e8f8 17996a1640364053ae0a4c8936a22428--7c39043ba72c4139bb34f4d8e553e8f8 216e07e7a8dd46b583414ce0db0d71b7 X 7c39043ba72c4139bb34f4d8e553e8f8--216e07e7a8dd46b583414ce0db0d71b7 216e07e7a8dd46b583414ce0db0d71b7--be82014675134a0e81d142920c4984b8 ba0e7451523e420fb6e6c10fb671da18 X 216e07e7a8dd46b583414ce0db0d71b7--ba0e7451523e420fb6e6c10fb671da18 ba0e7451523e420fb6e6c10fb671da18--a3c26a23c86546f0a4e3ece5ac124d91 7ba35cf3328f490e895fbe1b198f7577 ba0e7451523e420fb6e6c10fb671da18--7ba35cf3328f490e895fbe1b198f7577 95fe1d60af7c4a8f8784309a332b3a06 7ba35cf3328f490e895fbe1b198f7577--95fe1d60af7c4a8f8784309a332b3a06 62ba5ad2fc4a42b58ac0eb110c257594 95fe1d60af7c4a8f8784309a332b3a06--62ba5ad2fc4a42b58ac0eb110c257594 ceb60831bbce4bd29d8ecc03ad0e5595 62ba5ad2fc4a42b58ac0eb110c257594--ceb60831bbce4bd29d8ecc03ad0e5595 a18c10d2601b46c98b84f580c962d6df ceb60831bbce4bd29d8ecc03ad0e5595--a18c10d2601b46c98b84f580c962d6df 522d042a7a504556a596fde0ffafd428 a18c10d2601b46c98b84f580c962d6df--522d042a7a504556a596fde0ffafd428 88d1938f34ae4ce0a334d468783de9d2 522d042a7a504556a596fde0ffafd428--88d1938f34ae4ce0a334d468783de9d2 04fcebc22b3c4d1193d879a8ae7a8a30 88d1938f34ae4ce0a334d468783de9d2--04fcebc22b3c4d1193d879a8ae7a8a30 6ada6b0a1d1040b8a9103363252e84f7 04fcebc22b3c4d1193d879a8ae7a8a30--6ada6b0a1d1040b8a9103363252e84f7 6ee9240c93654091a60dc024ce9dae82 X 6ada6b0a1d1040b8a9103363252e84f7--6ee9240c93654091a60dc024ce9dae82 6ee9240c93654091a60dc024ce9dae82--74f49cc6c170419e88f4d486dcd7720f bc3674f7fd00467aae423b5f56386514 6ee9240c93654091a60dc024ce9dae82--bc3674f7fd00467aae423b5f56386514 9bf43f7cb0034dbdb44c73c1149d76c5 bc3674f7fd00467aae423b5f56386514--9bf43f7cb0034dbdb44c73c1149d76c5 5cfe7e93720a40a284d76ac66420ed7e 9bf43f7cb0034dbdb44c73c1149d76c5--5cfe7e93720a40a284d76ac66420ed7e ff4beb15d55646519ccf70cbaefa1a3a 5cfe7e93720a40a284d76ac66420ed7e--ff4beb15d55646519ccf70cbaefa1a3a c0f4eb2b3f2b4e8e981f7b6d244e4e75 ff4beb15d55646519ccf70cbaefa1a3a--c0f4eb2b3f2b4e8e981f7b6d244e4e75 19380039b84f4aee8ae21cd7c96cb231 c0f4eb2b3f2b4e8e981f7b6d244e4e75--19380039b84f4aee8ae21cd7c96cb231 0b3be1d7ef78409e9abd8b98a2e866ac 19380039b84f4aee8ae21cd7c96cb231--0b3be1d7ef78409e9abd8b98a2e866ac 912f50b9eaac46bc89483a0a3bcbd28a 0b3be1d7ef78409e9abd8b98a2e866ac--912f50b9eaac46bc89483a0a3bcbd28a 2868d3c89d8b4ab6954473dd9dfa87e9 912f50b9eaac46bc89483a0a3bcbd28a--2868d3c89d8b4ab6954473dd9dfa87e9 ce60a93ed5e94cd1995baebe53841ff1 2868d3c89d8b4ab6954473dd9dfa87e9--ce60a93ed5e94cd1995baebe53841ff1 30073e1e4ee7496e836a3048fff4cc0e ce60a93ed5e94cd1995baebe53841ff1--30073e1e4ee7496e836a3048fff4cc0e 778420daaf9840609eaa8c8357c92cd1 30073e1e4ee7496e836a3048fff4cc0e--778420daaf9840609eaa8c8357c92cd1 803193a6b4a04a16a7d651cbde0604d4 778420daaf9840609eaa8c8357c92cd1--803193a6b4a04a16a7d651cbde0604d4 69843a3574b64f6fb1ad3305db8f1b19 803193a6b4a04a16a7d651cbde0604d4--69843a3574b64f6fb1ad3305db8f1b19 bc1973223bcb4be0adab757cac00973a 69843a3574b64f6fb1ad3305db8f1b19--bc1973223bcb4be0adab757cac00973a a626d22a6e2f45b9a90dfdd6b32f809d bc1973223bcb4be0adab757cac00973a--a626d22a6e2f45b9a90dfdd6b32f809d 08446d45a246435b9e8bd4a9ac4945d3 a626d22a6e2f45b9a90dfdd6b32f809d--08446d45a246435b9e8bd4a9ac4945d3 cabadbcb032e49a4898540db3589861f 08446d45a246435b9e8bd4a9ac4945d3--cabadbcb032e49a4898540db3589861f 623137db7cff448a87642c94529d6c48 cabadbcb032e49a4898540db3589861f--623137db7cff448a87642c94529d6c48 6d3a8121dcfa42d38998e2ab47bbf827 623137db7cff448a87642c94529d6c48--6d3a8121dcfa42d38998e2ab47bbf827 f452404fd3da4654ad60d671113836ae 6d3a8121dcfa42d38998e2ab47bbf827--f452404fd3da4654ad60d671113836ae 40de5e2735b047649dfbfd78d003825d f452404fd3da4654ad60d671113836ae--40de5e2735b047649dfbfd78d003825d a52a3df9c051413ea8c2188ecd90340d 40de5e2735b047649dfbfd78d003825d--a52a3df9c051413ea8c2188ecd90340d a57fba5446b2438faf05cf39b8dd0bc1 a52a3df9c051413ea8c2188ecd90340d--a57fba5446b2438faf05cf39b8dd0bc1 f06635113b8046b580905982290b0af7 a57fba5446b2438faf05cf39b8dd0bc1--f06635113b8046b580905982290b0af7 70908f2e371e4cbab4f26eaaa8b8ec51 f06635113b8046b580905982290b0af7--70908f2e371e4cbab4f26eaaa8b8ec51 189c00ccd6684f4bb3425f0103c7708c 70908f2e371e4cbab4f26eaaa8b8ec51--189c00ccd6684f4bb3425f0103c7708c ac2830f983644168b90acdef9ed926ef RX(b13) 189c00ccd6684f4bb3425f0103c7708c--ac2830f983644168b90acdef9ed926ef ac2830f983644168b90acdef9ed926ef--5a7663a31fa34a65ad633bfc8906a4a6 4d7f5a38dba245c8af6fc683b2209c1b 6b052d4c97a84d34b93fc44283b04978 4c1411b6c3174900a086e99d80208e76--6b052d4c97a84d34b93fc44283b04978 7251d5a267264c249b61e0fd54cb7bd6 5 6873cbc78e134676b267c7e240025050 6b052d4c97a84d34b93fc44283b04978--6873cbc78e134676b267c7e240025050 68e568591459484b8b6a54dabad02c47 6873cbc78e134676b267c7e240025050--68e568591459484b8b6a54dabad02c47 acbcf39762bb4841a030394ffe3456d4 X 68e568591459484b8b6a54dabad02c47--acbcf39762bb4841a030394ffe3456d4 acbcf39762bb4841a030394ffe3456d4--46cd427215f44978a75f1aed7ee982c4 d80374acf9af42bc9d56b5db5f716355 acbcf39762bb4841a030394ffe3456d4--d80374acf9af42bc9d56b5db5f716355 63fe874c3c00488595c1743e89281dbe d80374acf9af42bc9d56b5db5f716355--63fe874c3c00488595c1743e89281dbe b02d3321d80d46978aafe420b06a224e 63fe874c3c00488595c1743e89281dbe--b02d3321d80d46978aafe420b06a224e bae1eb63941540c0b70e7235b0d618b6 b02d3321d80d46978aafe420b06a224e--bae1eb63941540c0b70e7235b0d618b6 f52f72aec4ad436188b9b450a740b812 bae1eb63941540c0b70e7235b0d618b6--f52f72aec4ad436188b9b450a740b812 6a4f9e4a50be48299c2ed22bb335ecd4 f52f72aec4ad436188b9b450a740b812--6a4f9e4a50be48299c2ed22bb335ecd4 46941dd8c69b4dca949c35943b4a1644 6a4f9e4a50be48299c2ed22bb335ecd4--46941dd8c69b4dca949c35943b4a1644 40fbd2349b3946ff8f987db25ee42d75 X 46941dd8c69b4dca949c35943b4a1644--40fbd2349b3946ff8f987db25ee42d75 40fbd2349b3946ff8f987db25ee42d75--3efc7f709e9640049b3d7a4271c54473 eda2e3040cf641ceba43306c605081b5 40fbd2349b3946ff8f987db25ee42d75--eda2e3040cf641ceba43306c605081b5 3667d65a4b0d40c385d512f6a70f1f8d eda2e3040cf641ceba43306c605081b5--3667d65a4b0d40c385d512f6a70f1f8d 3ee6732b5b8142e8b7586bf0daff982c 3667d65a4b0d40c385d512f6a70f1f8d--3ee6732b5b8142e8b7586bf0daff982c 49912adbb1f14702bdb13d6de2f0135e 3ee6732b5b8142e8b7586bf0daff982c--49912adbb1f14702bdb13d6de2f0135e 1744caef8eaf4efb8a46fc0ec9473fee 49912adbb1f14702bdb13d6de2f0135e--1744caef8eaf4efb8a46fc0ec9473fee 1bb08ac3060c472481279e3aff12cb22 1744caef8eaf4efb8a46fc0ec9473fee--1bb08ac3060c472481279e3aff12cb22 d6e2543bdf99481abda72770951cd9e1 1bb08ac3060c472481279e3aff12cb22--d6e2543bdf99481abda72770951cd9e1 34b56f430c1b4922a1a20cb4e5b4a1fc d6e2543bdf99481abda72770951cd9e1--34b56f430c1b4922a1a20cb4e5b4a1fc a7f06d9561db4de1a4a34bdece09c64f X 34b56f430c1b4922a1a20cb4e5b4a1fc--a7f06d9561db4de1a4a34bdece09c64f a7f06d9561db4de1a4a34bdece09c64f--6fde7a5c25c0408d8f16b61c501ad924 a1f4b924e88a47ab9090817d7b48c601 RZ(-1.0*g0) a7f06d9561db4de1a4a34bdece09c64f--a1f4b924e88a47ab9090817d7b48c601 f1e5077d4b5e459ead93f5cb66e89382 X a1f4b924e88a47ab9090817d7b48c601--f1e5077d4b5e459ead93f5cb66e89382 f1e5077d4b5e459ead93f5cb66e89382--42f6d11af9264426989b39960afae559 7969c2e353c14eb78503504046f1734b f1e5077d4b5e459ead93f5cb66e89382--7969c2e353c14eb78503504046f1734b 7175107402ff4410b2877aacaf9e1c5b 7969c2e353c14eb78503504046f1734b--7175107402ff4410b2877aacaf9e1c5b c1da1cf2417a493fb91d565a9523a94a 7175107402ff4410b2877aacaf9e1c5b--c1da1cf2417a493fb91d565a9523a94a 9050f9cf6c7b43559e65b069e5a3f254 c1da1cf2417a493fb91d565a9523a94a--9050f9cf6c7b43559e65b069e5a3f254 3935b0a6011744ee9c251de3aba3db11 X 9050f9cf6c7b43559e65b069e5a3f254--3935b0a6011744ee9c251de3aba3db11 3935b0a6011744ee9c251de3aba3db11--121864818de94189a150909992ea8d1b f943d3864c06428bb217f2e6da0b2a71 3935b0a6011744ee9c251de3aba3db11--f943d3864c06428bb217f2e6da0b2a71 963caa06789b4307b0befc5a8a7afbdc f943d3864c06428bb217f2e6da0b2a71--963caa06789b4307b0befc5a8a7afbdc a587df905f7349a0b33dfc5ed12401a7 963caa06789b4307b0befc5a8a7afbdc--a587df905f7349a0b33dfc5ed12401a7 dcf0a7f2bcc7412f9b0b31f0e106960f X a587df905f7349a0b33dfc5ed12401a7--dcf0a7f2bcc7412f9b0b31f0e106960f dcf0a7f2bcc7412f9b0b31f0e106960f--11132fd72ab44d7cb91614d8aeaab613 4bcb796119314b9a98de1174e140acfb dcf0a7f2bcc7412f9b0b31f0e106960f--4bcb796119314b9a98de1174e140acfb c10fb1900baa489a974ba9c048fcb05d 4bcb796119314b9a98de1174e140acfb--c10fb1900baa489a974ba9c048fcb05d 9ff8c777c0f4410c91666456ea51926c c10fb1900baa489a974ba9c048fcb05d--9ff8c777c0f4410c91666456ea51926c 90a14cab7b174233925c33d46cc95779 9ff8c777c0f4410c91666456ea51926c--90a14cab7b174233925c33d46cc95779 cd668433520f4e65a02708cadb661e7b X 90a14cab7b174233925c33d46cc95779--cd668433520f4e65a02708cadb661e7b cd668433520f4e65a02708cadb661e7b--28169eee7be943f1a7bd61c9ec21831f 4a6e36d36f0a443d9f6e690cd195f905 cd668433520f4e65a02708cadb661e7b--4a6e36d36f0a443d9f6e690cd195f905 7127e57cd7054e13862a904a6b16c03d 4a6e36d36f0a443d9f6e690cd195f905--7127e57cd7054e13862a904a6b16c03d cb756955879f4611aee807a34c30b9af 7127e57cd7054e13862a904a6b16c03d--cb756955879f4611aee807a34c30b9af b809bfb7844a4a598d0924c43d8ea71f cb756955879f4611aee807a34c30b9af--b809bfb7844a4a598d0924c43d8ea71f 51b4a762d03a4f4fbc92ba83fb098d5b b809bfb7844a4a598d0924c43d8ea71f--51b4a762d03a4f4fbc92ba83fb098d5b 3e59a62a6c7443a29fcc0dce5c3f1749 X 51b4a762d03a4f4fbc92ba83fb098d5b--3e59a62a6c7443a29fcc0dce5c3f1749 3e59a62a6c7443a29fcc0dce5c3f1749--74af52db7b214ee38a395b769aaec038 49da23ebfa504ed88b627eed1cba3f17 3e59a62a6c7443a29fcc0dce5c3f1749--49da23ebfa504ed88b627eed1cba3f17 35912d5d47ef4fa398fb5b0c60b55e39 49da23ebfa504ed88b627eed1cba3f17--35912d5d47ef4fa398fb5b0c60b55e39 14fd4e30d2244a4ab14983bef69a532b 35912d5d47ef4fa398fb5b0c60b55e39--14fd4e30d2244a4ab14983bef69a532b 301789f326fc4b048e3d00259f8dad55 X 14fd4e30d2244a4ab14983bef69a532b--301789f326fc4b048e3d00259f8dad55 301789f326fc4b048e3d00259f8dad55--6c8d6627a9684b7a94f395695e4a5209 e6100dd6fce74e938d8aff25c40b5d03 RZ(-1.0*g0) 301789f326fc4b048e3d00259f8dad55--e6100dd6fce74e938d8aff25c40b5d03 93a94fa279b84551bdb93c2e65c45e67 X e6100dd6fce74e938d8aff25c40b5d03--93a94fa279b84551bdb93c2e65c45e67 93a94fa279b84551bdb93c2e65c45e67--fe1eb189b2234aa68428e49444e66226 e264e369d3a3451dbf6b316569760084 93a94fa279b84551bdb93c2e65c45e67--e264e369d3a3451dbf6b316569760084 c82b3c1b8a744413b63aad67bb827f9d e264e369d3a3451dbf6b316569760084--c82b3c1b8a744413b63aad67bb827f9d 973c9b39f32140e69c1431b10c66d2f2 X c82b3c1b8a744413b63aad67bb827f9d--973c9b39f32140e69c1431b10c66d2f2 973c9b39f32140e69c1431b10c66d2f2--7d84295efeaf4e60a53ac49bcb3eda3f ddb5274e05bb4734bd2506e9453bb48e 973c9b39f32140e69c1431b10c66d2f2--ddb5274e05bb4734bd2506e9453bb48e 68299ad424e4461aa106f9aa22736788 ddb5274e05bb4734bd2506e9453bb48e--68299ad424e4461aa106f9aa22736788 1c26d573775647469ca35c0b8cba1277 68299ad424e4461aa106f9aa22736788--1c26d573775647469ca35c0b8cba1277 821f37a5d81d478095826490d459b6f2 X 1c26d573775647469ca35c0b8cba1277--821f37a5d81d478095826490d459b6f2 821f37a5d81d478095826490d459b6f2--feeb8d1dfc3341058c9f079861978b08 08b9d2d6a0a84df38828ec37c8d9aeac 821f37a5d81d478095826490d459b6f2--08b9d2d6a0a84df38828ec37c8d9aeac b038effd4b6545d3a6a89a6599af955c 08b9d2d6a0a84df38828ec37c8d9aeac--b038effd4b6545d3a6a89a6599af955c 30854599879f4a0abde69c72d974ef0b X b038effd4b6545d3a6a89a6599af955c--30854599879f4a0abde69c72d974ef0b 30854599879f4a0abde69c72d974ef0b--5d78e5f54001490e8b6e5f385f2dff69 6795e871d8304004878c291b45696011 30854599879f4a0abde69c72d974ef0b--6795e871d8304004878c291b45696011 fd60b310bfa447b4a4876e0ca2e51844 6795e871d8304004878c291b45696011--fd60b310bfa447b4a4876e0ca2e51844 8f91f0495b094f2e9b867baa7e128ef2 fd60b310bfa447b4a4876e0ca2e51844--8f91f0495b094f2e9b867baa7e128ef2 8bb5e1b89ed549b9bf000e6ad996ce79 8f91f0495b094f2e9b867baa7e128ef2--8bb5e1b89ed549b9bf000e6ad996ce79 1fe8e2e024254b089bb64710677e9072 8bb5e1b89ed549b9bf000e6ad996ce79--1fe8e2e024254b089bb64710677e9072 45ace1a95d9c4363baeb758687afdfd7 X 1fe8e2e024254b089bb64710677e9072--45ace1a95d9c4363baeb758687afdfd7 45ace1a95d9c4363baeb758687afdfd7--cd72dc730bd546028f55990d320f9ec7 16212fa032e74e5e9cf16381bf31febe 45ace1a95d9c4363baeb758687afdfd7--16212fa032e74e5e9cf16381bf31febe 0ee752cb264a4735b7d485e2f2b4100c 16212fa032e74e5e9cf16381bf31febe--0ee752cb264a4735b7d485e2f2b4100c ec183af86d23407c89a2540c85f5c541 X 0ee752cb264a4735b7d485e2f2b4100c--ec183af86d23407c89a2540c85f5c541 ec183af86d23407c89a2540c85f5c541--bc886659e97a42008402259927a94639 97e7a9a5dc3a41c8aa4ac652ee0bb125 ec183af86d23407c89a2540c85f5c541--97e7a9a5dc3a41c8aa4ac652ee0bb125 5c3e6479315c4a3884774fbe3085dd05 97e7a9a5dc3a41c8aa4ac652ee0bb125--5c3e6479315c4a3884774fbe3085dd05 6227dab448954bbd9298b1139d77a7f4 5c3e6479315c4a3884774fbe3085dd05--6227dab448954bbd9298b1139d77a7f4 4ee527d5f5ac49938a90d5d0a35f5990 6227dab448954bbd9298b1139d77a7f4--4ee527d5f5ac49938a90d5d0a35f5990 5e676bf49b5f44319773219c2b554066 4ee527d5f5ac49938a90d5d0a35f5990--5e676bf49b5f44319773219c2b554066 957a3c2e658048d3869964fbdee1f904 5e676bf49b5f44319773219c2b554066--957a3c2e658048d3869964fbdee1f904 0793c17055d349fe9c636f7bb6954d0f 957a3c2e658048d3869964fbdee1f904--0793c17055d349fe9c636f7bb6954d0f 166643faad3a49bb9740260d061cc4b4 X 0793c17055d349fe9c636f7bb6954d0f--166643faad3a49bb9740260d061cc4b4 166643faad3a49bb9740260d061cc4b4--38604969acb74fb09e81e55d502621e6 4e46c0f5238145d6bf3f49b992ce8c01 166643faad3a49bb9740260d061cc4b4--4e46c0f5238145d6bf3f49b992ce8c01 111dcbd12d194b61a2c24858a07920f9 X 4e46c0f5238145d6bf3f49b992ce8c01--111dcbd12d194b61a2c24858a07920f9 111dcbd12d194b61a2c24858a07920f9--1a46a523ec4f4f4999da770dceb2c0fe 783fee4a37514da2a4dcad513b5d8648 RZ(-1.0*g0) 111dcbd12d194b61a2c24858a07920f9--783fee4a37514da2a4dcad513b5d8648 bf857ee8b0c64abd83bb2d5e7d4a209d X 783fee4a37514da2a4dcad513b5d8648--bf857ee8b0c64abd83bb2d5e7d4a209d bf857ee8b0c64abd83bb2d5e7d4a209d--acf9cb73c8aa420e822bb93f7435d121 5fc3454050534142a21995693a53d287 X bf857ee8b0c64abd83bb2d5e7d4a209d--5fc3454050534142a21995693a53d287 5fc3454050534142a21995693a53d287--4393a0647542446fb64183c97288ca0e 6354a8bfc49348e3a99bf9ab6ffd189f 5fc3454050534142a21995693a53d287--6354a8bfc49348e3a99bf9ab6ffd189f e5e0fcd813fa42c3a6e8ef25b500bc02 6354a8bfc49348e3a99bf9ab6ffd189f--e5e0fcd813fa42c3a6e8ef25b500bc02 67e7dd2a286c40a4b199b85982ab9360 e5e0fcd813fa42c3a6e8ef25b500bc02--67e7dd2a286c40a4b199b85982ab9360 7b6262886b6549739025ba8d6e02c506 X 67e7dd2a286c40a4b199b85982ab9360--7b6262886b6549739025ba8d6e02c506 7b6262886b6549739025ba8d6e02c506--f740db066c644e249d1b0350933d0b71 689ed8990bef485fa215f0efb2356006 X 7b6262886b6549739025ba8d6e02c506--689ed8990bef485fa215f0efb2356006 689ed8990bef485fa215f0efb2356006--bddee7eade274a4da9b930d95e9cde94 0e0170760ea942d7bb929ff6b29b2398 689ed8990bef485fa215f0efb2356006--0e0170760ea942d7bb929ff6b29b2398 46a2dd60ca07463ebb2e6562adf15a47 0e0170760ea942d7bb929ff6b29b2398--46a2dd60ca07463ebb2e6562adf15a47 ef2bb20550ee4dac980d628551eb72b1 46a2dd60ca07463ebb2e6562adf15a47--ef2bb20550ee4dac980d628551eb72b1 412a5afd02a844df95ad8a424ea3118b ef2bb20550ee4dac980d628551eb72b1--412a5afd02a844df95ad8a424ea3118b 77298e4cd3b54c42b70916163f21c3a2 412a5afd02a844df95ad8a424ea3118b--77298e4cd3b54c42b70916163f21c3a2 4cdd843b3edc48ca987f17684716e695 X 77298e4cd3b54c42b70916163f21c3a2--4cdd843b3edc48ca987f17684716e695 4cdd843b3edc48ca987f17684716e695--bccc1b0744174aa1a1fcfa4621aa16a7 648b98e9adc34d3cac0feed0821e2f2e 4cdd843b3edc48ca987f17684716e695--648b98e9adc34d3cac0feed0821e2f2e 7552ef3f1fa347a596b9006693673f96 648b98e9adc34d3cac0feed0821e2f2e--7552ef3f1fa347a596b9006693673f96 047f5e582ef84245aa1f300b08bdad2a 7552ef3f1fa347a596b9006693673f96--047f5e582ef84245aa1f300b08bdad2a 00f192f9f85d4799afb7ed2a9f084021 047f5e582ef84245aa1f300b08bdad2a--00f192f9f85d4799afb7ed2a9f084021 5759e2c508a3405aac172da4ccef04b1 00f192f9f85d4799afb7ed2a9f084021--5759e2c508a3405aac172da4ccef04b1 867632faf93844a4b32a42b5f18f04c8 5759e2c508a3405aac172da4ccef04b1--867632faf93844a4b32a42b5f18f04c8 acb8758dd578411392c5b5102012bb11 867632faf93844a4b32a42b5f18f04c8--acb8758dd578411392c5b5102012bb11 064b7269d11f4f8792eae650c942cdc7 acb8758dd578411392c5b5102012bb11--064b7269d11f4f8792eae650c942cdc7 901186a6a4c5464ead8a11eaca754be5 064b7269d11f4f8792eae650c942cdc7--901186a6a4c5464ead8a11eaca754be5 4e72d0d2a99448f9bfe8d62a325d63f3 901186a6a4c5464ead8a11eaca754be5--4e72d0d2a99448f9bfe8d62a325d63f3 e407e38399aa43689f1aeed59d3eca0f 4e72d0d2a99448f9bfe8d62a325d63f3--e407e38399aa43689f1aeed59d3eca0f 866c191fcdf54767a22496761db3d879 e407e38399aa43689f1aeed59d3eca0f--866c191fcdf54767a22496761db3d879 018d783e7e304e4f8e14e2bec25a0e7e RX(b04) 866c191fcdf54767a22496761db3d879--018d783e7e304e4f8e14e2bec25a0e7e c5aa64f8d9f34bfb9f94276a3fdc8286 018d783e7e304e4f8e14e2bec25a0e7e--c5aa64f8d9f34bfb9f94276a3fdc8286 0908236d211643428a8238e3b7143844 c5aa64f8d9f34bfb9f94276a3fdc8286--0908236d211643428a8238e3b7143844 9125a58195d440e08a418b3c607009e9 0908236d211643428a8238e3b7143844--9125a58195d440e08a418b3c607009e9 eeb808f64aa544a197036eee7a843efc X 9125a58195d440e08a418b3c607009e9--eeb808f64aa544a197036eee7a843efc eeb808f64aa544a197036eee7a843efc--bce02b2d38b347bfbc0851cef561191f e5d0091d5dda4167a17417e24ca3bf67 eeb808f64aa544a197036eee7a843efc--e5d0091d5dda4167a17417e24ca3bf67 4c052aacd5be45e185e0949a6312c4bb e5d0091d5dda4167a17417e24ca3bf67--4c052aacd5be45e185e0949a6312c4bb 7d28f2e0ae0945e38e6089d9249c4f21 4c052aacd5be45e185e0949a6312c4bb--7d28f2e0ae0945e38e6089d9249c4f21 c4f70f2f6e0a4c25b437f4b213a8024e 7d28f2e0ae0945e38e6089d9249c4f21--c4f70f2f6e0a4c25b437f4b213a8024e 23603955c4844b8aa48418e588476b44 c4f70f2f6e0a4c25b437f4b213a8024e--23603955c4844b8aa48418e588476b44 ca7b3c5e43684c5b9b0dbba93d3c248a 23603955c4844b8aa48418e588476b44--ca7b3c5e43684c5b9b0dbba93d3c248a 9115e77250264d4f9dd99856e974d564 ca7b3c5e43684c5b9b0dbba93d3c248a--9115e77250264d4f9dd99856e974d564 a1c51085e078457c9b49b75f1002c5e3 X 9115e77250264d4f9dd99856e974d564--a1c51085e078457c9b49b75f1002c5e3 a1c51085e078457c9b49b75f1002c5e3--bbe506bee5ed4e87830d97ebc608bc03 e1bc5e61f30a450bb9a43dc513e7de97 a1c51085e078457c9b49b75f1002c5e3--e1bc5e61f30a450bb9a43dc513e7de97 b745058e7647459bbe053d4cb26349aa e1bc5e61f30a450bb9a43dc513e7de97--b745058e7647459bbe053d4cb26349aa e1ecd1a6c9cb418fac84bd40f1f2bc22 b745058e7647459bbe053d4cb26349aa--e1ecd1a6c9cb418fac84bd40f1f2bc22 49b940a0e0b7408ca8f6e1eb9e615a4f e1ecd1a6c9cb418fac84bd40f1f2bc22--49b940a0e0b7408ca8f6e1eb9e615a4f 28eb81405a674a23a9196072146a23d8 49b940a0e0b7408ca8f6e1eb9e615a4f--28eb81405a674a23a9196072146a23d8 65bcaba0698f4e1d97a68cdb7e5db5a2 28eb81405a674a23a9196072146a23d8--65bcaba0698f4e1d97a68cdb7e5db5a2 a885997a271c4b38925982a1d8c31b87 65bcaba0698f4e1d97a68cdb7e5db5a2--a885997a271c4b38925982a1d8c31b87 b624e982868f4219bd10956d8c21243b a885997a271c4b38925982a1d8c31b87--b624e982868f4219bd10956d8c21243b 62669118b38247c09b3e85d8a2d2ad1d X b624e982868f4219bd10956d8c21243b--62669118b38247c09b3e85d8a2d2ad1d 62669118b38247c09b3e85d8a2d2ad1d--e1a13e2f623c46c4aa0daf1a423900da 89669e1c054f481988c2fc58f502c5ca RZ(-1.0*g1) 62669118b38247c09b3e85d8a2d2ad1d--89669e1c054f481988c2fc58f502c5ca ee4cf045aafb41c6a56151e852f60a4e X 89669e1c054f481988c2fc58f502c5ca--ee4cf045aafb41c6a56151e852f60a4e ee4cf045aafb41c6a56151e852f60a4e--0f16161f075042d5a1d10c3c2d8e1a92 bbfb9022d08248cea2f6c3af23845552 ee4cf045aafb41c6a56151e852f60a4e--bbfb9022d08248cea2f6c3af23845552 c7112fdfbbe54f149870af383a36761a bbfb9022d08248cea2f6c3af23845552--c7112fdfbbe54f149870af383a36761a bb4769f13b3e4d1a912486631b2ca946 c7112fdfbbe54f149870af383a36761a--bb4769f13b3e4d1a912486631b2ca946 25eb0a85cb304c92b297180bdf30e2e5 bb4769f13b3e4d1a912486631b2ca946--25eb0a85cb304c92b297180bdf30e2e5 abaa464964184da5a425c0ead6f46bcd X 25eb0a85cb304c92b297180bdf30e2e5--abaa464964184da5a425c0ead6f46bcd abaa464964184da5a425c0ead6f46bcd--373ab902a51d43a9a69589e71f3a6aa0 b38aed6be07d45bba58cc72ae1e82e28 abaa464964184da5a425c0ead6f46bcd--b38aed6be07d45bba58cc72ae1e82e28 16b1b0fe34674701adf782955d2f44f6 b38aed6be07d45bba58cc72ae1e82e28--16b1b0fe34674701adf782955d2f44f6 e0249fc2b2de4ac99ef811a9ded77012 16b1b0fe34674701adf782955d2f44f6--e0249fc2b2de4ac99ef811a9ded77012 69849ccfc4c34bb4bb846e6703e57f23 X e0249fc2b2de4ac99ef811a9ded77012--69849ccfc4c34bb4bb846e6703e57f23 69849ccfc4c34bb4bb846e6703e57f23--5b76814e73f044c09d32aaf21b6c7e4e 540b6859fcff484b93ef9052dfc7f776 69849ccfc4c34bb4bb846e6703e57f23--540b6859fcff484b93ef9052dfc7f776 b55b3d59b9794be898f5c2b234e3243f 540b6859fcff484b93ef9052dfc7f776--b55b3d59b9794be898f5c2b234e3243f 4946b36967a14821af522c1e490bd436 b55b3d59b9794be898f5c2b234e3243f--4946b36967a14821af522c1e490bd436 6ccdb2b66b024c8bbd7129767709e6c6 4946b36967a14821af522c1e490bd436--6ccdb2b66b024c8bbd7129767709e6c6 ff3a50230fe140de94e80c5c95a66054 X 6ccdb2b66b024c8bbd7129767709e6c6--ff3a50230fe140de94e80c5c95a66054 ff3a50230fe140de94e80c5c95a66054--f39cf22b08554503a3feebe61e31259c 98876435b8aa41fc98a85c2561a2ec6a ff3a50230fe140de94e80c5c95a66054--98876435b8aa41fc98a85c2561a2ec6a a7c761104c56468281812d19a3a07b10 98876435b8aa41fc98a85c2561a2ec6a--a7c761104c56468281812d19a3a07b10 a38919d5ba5140e1916875b39fdcbf4b a7c761104c56468281812d19a3a07b10--a38919d5ba5140e1916875b39fdcbf4b 4c89acea1fe647ce8a829f1b0759f18b a38919d5ba5140e1916875b39fdcbf4b--4c89acea1fe647ce8a829f1b0759f18b 4b78e6c27fa24875a453a5138e404eee 4c89acea1fe647ce8a829f1b0759f18b--4b78e6c27fa24875a453a5138e404eee cebb29ce98d841e49e03470aa183953e X 4b78e6c27fa24875a453a5138e404eee--cebb29ce98d841e49e03470aa183953e cebb29ce98d841e49e03470aa183953e--a76a30f19cbb4416aa413b199aea6277 51df52089103435d97af79e1788f7d2b cebb29ce98d841e49e03470aa183953e--51df52089103435d97af79e1788f7d2b cce04f6336264f9eac9846f7e394ae78 51df52089103435d97af79e1788f7d2b--cce04f6336264f9eac9846f7e394ae78 34bdebd18fde443fa85e9439972670dd cce04f6336264f9eac9846f7e394ae78--34bdebd18fde443fa85e9439972670dd 3e1bb77cc052458793f239ea39f4b9c9 X 34bdebd18fde443fa85e9439972670dd--3e1bb77cc052458793f239ea39f4b9c9 3e1bb77cc052458793f239ea39f4b9c9--0607ebe60ea146f1b81832d4e21d209f 47f11a46edaa4238b8c18cec711a8b9f RZ(-1.0*g1) 3e1bb77cc052458793f239ea39f4b9c9--47f11a46edaa4238b8c18cec711a8b9f c56a7282020448f797dda6d5a3786e06 X 47f11a46edaa4238b8c18cec711a8b9f--c56a7282020448f797dda6d5a3786e06 c56a7282020448f797dda6d5a3786e06--34ee69fbbe734d36845fa77cefa9ec7e 02d228b182c7422e95bcb24a206dd306 c56a7282020448f797dda6d5a3786e06--02d228b182c7422e95bcb24a206dd306 6a48a65549b94e7ab25d91905ecde2e6 02d228b182c7422e95bcb24a206dd306--6a48a65549b94e7ab25d91905ecde2e6 e0dac04bf9434357aeaa4f2fee59cc1c X 6a48a65549b94e7ab25d91905ecde2e6--e0dac04bf9434357aeaa4f2fee59cc1c e0dac04bf9434357aeaa4f2fee59cc1c--694615c9163c4d94a06d3c5b6b6e5fde 5e105cc412e84cd9a84d3b137b0cf863 e0dac04bf9434357aeaa4f2fee59cc1c--5e105cc412e84cd9a84d3b137b0cf863 b3055476fdda4939b0c42e62badaacbf 5e105cc412e84cd9a84d3b137b0cf863--b3055476fdda4939b0c42e62badaacbf e61d6622e32743ab8849c58d6c532c0e b3055476fdda4939b0c42e62badaacbf--e61d6622e32743ab8849c58d6c532c0e 9a2922bb64cd445a901d75936913199b X e61d6622e32743ab8849c58d6c532c0e--9a2922bb64cd445a901d75936913199b 9a2922bb64cd445a901d75936913199b--1f73a41872f844bd95e7293d1275abaf 63c6d9553a9c40109feeec1cd4e18c11 9a2922bb64cd445a901d75936913199b--63c6d9553a9c40109feeec1cd4e18c11 c759e2a125354a87ad232629812243b0 63c6d9553a9c40109feeec1cd4e18c11--c759e2a125354a87ad232629812243b0 98000650a60d44aa8f2ca343cd7b28f6 X c759e2a125354a87ad232629812243b0--98000650a60d44aa8f2ca343cd7b28f6 98000650a60d44aa8f2ca343cd7b28f6--1dbca751d53149c1845b7bf3dd8420c2 1e5e87d60b644a12a4227bff194286a4 98000650a60d44aa8f2ca343cd7b28f6--1e5e87d60b644a12a4227bff194286a4 1dd3a10a474444c6820142af96e436af 1e5e87d60b644a12a4227bff194286a4--1dd3a10a474444c6820142af96e436af 9b61d247dc484327a2a1e732d1a54ab2 1dd3a10a474444c6820142af96e436af--9b61d247dc484327a2a1e732d1a54ab2 7ae45168756440548b038bd0b1bcc4b8 9b61d247dc484327a2a1e732d1a54ab2--7ae45168756440548b038bd0b1bcc4b8 7d37e1a47a4c4065bb2fff0758c0788a 7ae45168756440548b038bd0b1bcc4b8--7d37e1a47a4c4065bb2fff0758c0788a 1c44e2ee9726401ca4d42be12e29059e X 7d37e1a47a4c4065bb2fff0758c0788a--1c44e2ee9726401ca4d42be12e29059e 1c44e2ee9726401ca4d42be12e29059e--7c39043ba72c4139bb34f4d8e553e8f8 67d42c3c77bb4bff9f095a8ee3bfa184 1c44e2ee9726401ca4d42be12e29059e--67d42c3c77bb4bff9f095a8ee3bfa184 8defbb17556d4869b268ad7c5d3d776a 67d42c3c77bb4bff9f095a8ee3bfa184--8defbb17556d4869b268ad7c5d3d776a d45e1bc986994afa96dfac9298ee574c X 8defbb17556d4869b268ad7c5d3d776a--d45e1bc986994afa96dfac9298ee574c d45e1bc986994afa96dfac9298ee574c--7ba35cf3328f490e895fbe1b198f7577 8692bf4178904c45870a1178ddde9c86 d45e1bc986994afa96dfac9298ee574c--8692bf4178904c45870a1178ddde9c86 3f1ebf94fe1d4af4917cdf2d05e641ba 8692bf4178904c45870a1178ddde9c86--3f1ebf94fe1d4af4917cdf2d05e641ba 5a1c1f5cc2c84f7481221dd2144e80fd 3f1ebf94fe1d4af4917cdf2d05e641ba--5a1c1f5cc2c84f7481221dd2144e80fd eb21cb8e6cb24e708fe12050e7254007 5a1c1f5cc2c84f7481221dd2144e80fd--eb21cb8e6cb24e708fe12050e7254007 59c60e7e351e464a888ab29a1a58ab00 eb21cb8e6cb24e708fe12050e7254007--59c60e7e351e464a888ab29a1a58ab00 e628f3c6a4a749279dd3714eeff2e2b2 59c60e7e351e464a888ab29a1a58ab00--e628f3c6a4a749279dd3714eeff2e2b2 a6a2fe0625ea4517b4c95f661526c27b e628f3c6a4a749279dd3714eeff2e2b2--a6a2fe0625ea4517b4c95f661526c27b 7e41575f37454afca625d6f02caea7f4 X a6a2fe0625ea4517b4c95f661526c27b--7e41575f37454afca625d6f02caea7f4 7e41575f37454afca625d6f02caea7f4--6ada6b0a1d1040b8a9103363252e84f7 41f5edba0f0b436c8581045527b113e3 7e41575f37454afca625d6f02caea7f4--41f5edba0f0b436c8581045527b113e3 bdc77485f3c04d2cad687aa19cd2b979 X 41f5edba0f0b436c8581045527b113e3--bdc77485f3c04d2cad687aa19cd2b979 bdc77485f3c04d2cad687aa19cd2b979--bc3674f7fd00467aae423b5f56386514 2af730d8d52c4262b1f3ee0ea150a4b5 RZ(-1.0*g1) bdc77485f3c04d2cad687aa19cd2b979--2af730d8d52c4262b1f3ee0ea150a4b5 ac16f25840db47e59a1879f413655d58 X 2af730d8d52c4262b1f3ee0ea150a4b5--ac16f25840db47e59a1879f413655d58 ac16f25840db47e59a1879f413655d58--5cfe7e93720a40a284d76ac66420ed7e 0614903dc82547dc83a8c29292fa7039 X ac16f25840db47e59a1879f413655d58--0614903dc82547dc83a8c29292fa7039 0614903dc82547dc83a8c29292fa7039--ff4beb15d55646519ccf70cbaefa1a3a 43c267dc72594eb3a2ff2439688688a6 0614903dc82547dc83a8c29292fa7039--43c267dc72594eb3a2ff2439688688a6 c22136690d6c4c478bac72ad6d34573c 43c267dc72594eb3a2ff2439688688a6--c22136690d6c4c478bac72ad6d34573c 2674e0ca90344f4b8da50cf65359ef14 c22136690d6c4c478bac72ad6d34573c--2674e0ca90344f4b8da50cf65359ef14 a97b573be1134d8cb4165ed0a4aa62ea X 2674e0ca90344f4b8da50cf65359ef14--a97b573be1134d8cb4165ed0a4aa62ea a97b573be1134d8cb4165ed0a4aa62ea--912f50b9eaac46bc89483a0a3bcbd28a 950387e899be488f917296a972ca0bbe X a97b573be1134d8cb4165ed0a4aa62ea--950387e899be488f917296a972ca0bbe 950387e899be488f917296a972ca0bbe--2868d3c89d8b4ab6954473dd9dfa87e9 6eb8d97b1a19447d92e3aa4013f26bb2 950387e899be488f917296a972ca0bbe--6eb8d97b1a19447d92e3aa4013f26bb2 072093e97fb24c3ead59d9d53970151a 6eb8d97b1a19447d92e3aa4013f26bb2--072093e97fb24c3ead59d9d53970151a f2150fdbe221479cb6ed927fd509a422 072093e97fb24c3ead59d9d53970151a--f2150fdbe221479cb6ed927fd509a422 759789d852434f8892d7d9c8374102ee f2150fdbe221479cb6ed927fd509a422--759789d852434f8892d7d9c8374102ee 934638609ec84c9ebed9ac71a2e68f29 759789d852434f8892d7d9c8374102ee--934638609ec84c9ebed9ac71a2e68f29 ee62bce71272463d816fd97b82b4f2ff X 934638609ec84c9ebed9ac71a2e68f29--ee62bce71272463d816fd97b82b4f2ff ee62bce71272463d816fd97b82b4f2ff--bc1973223bcb4be0adab757cac00973a afcbdcb31a8e4d2398beef931744a285 ee62bce71272463d816fd97b82b4f2ff--afcbdcb31a8e4d2398beef931744a285 862627967af846f9a3caf1dffcb6a9a2 afcbdcb31a8e4d2398beef931744a285--862627967af846f9a3caf1dffcb6a9a2 f06579bbb6da4eedacec32d1dc764e5d 862627967af846f9a3caf1dffcb6a9a2--f06579bbb6da4eedacec32d1dc764e5d 320b6194fb8e4dca84f77c3c51a1a216 f06579bbb6da4eedacec32d1dc764e5d--320b6194fb8e4dca84f77c3c51a1a216 3ada147c38e9422d9fb02f3a27b259c6 320b6194fb8e4dca84f77c3c51a1a216--3ada147c38e9422d9fb02f3a27b259c6 27e5a2685db14966b1ecdfa31f1246f9 3ada147c38e9422d9fb02f3a27b259c6--27e5a2685db14966b1ecdfa31f1246f9 1ad8fbcbbc9a462e94ebb9b2cf6e84cf 27e5a2685db14966b1ecdfa31f1246f9--1ad8fbcbbc9a462e94ebb9b2cf6e84cf cbcffb129fec494e9928e55ca480d26a 1ad8fbcbbc9a462e94ebb9b2cf6e84cf--cbcffb129fec494e9928e55ca480d26a 9cdb3490b4c142e29dc3c96238350f29 cbcffb129fec494e9928e55ca480d26a--9cdb3490b4c142e29dc3c96238350f29 833cc76ab82c4928836f118d921d9481 9cdb3490b4c142e29dc3c96238350f29--833cc76ab82c4928836f118d921d9481 94b8d5d771974580a28a42db1de31b25 833cc76ab82c4928836f118d921d9481--94b8d5d771974580a28a42db1de31b25 f43cdb0f949b43508d4a907b6c531ae8 94b8d5d771974580a28a42db1de31b25--f43cdb0f949b43508d4a907b6c531ae8 fce4843aa5c9445f93eb61c0949ce965 RX(b14) f43cdb0f949b43508d4a907b6c531ae8--fce4843aa5c9445f93eb61c0949ce965 fce4843aa5c9445f93eb61c0949ce965--4d7f5a38dba245c8af6fc683b2209c1b 9ba6c8dfeabe4a7a9ea9d46bc7565836 c5e3c189cc4140ffbc9282e59135bfe9 7251d5a267264c249b61e0fd54cb7bd6--c5e3c189cc4140ffbc9282e59135bfe9 586d90f203584f8a9089f2fd2cb1c23d 6 5350543d5d6d435fb8e75198088529a9 c5e3c189cc4140ffbc9282e59135bfe9--5350543d5d6d435fb8e75198088529a9 3a5d7d95a2434edcb6d38beabbb2bf90 5350543d5d6d435fb8e75198088529a9--3a5d7d95a2434edcb6d38beabbb2bf90 a90b2e7fd6a74413978bc2cdd6598f3b 3a5d7d95a2434edcb6d38beabbb2bf90--a90b2e7fd6a74413978bc2cdd6598f3b 9e0e3393275a47c38a00a3b640bb6bb2 X a90b2e7fd6a74413978bc2cdd6598f3b--9e0e3393275a47c38a00a3b640bb6bb2 9e0e3393275a47c38a00a3b640bb6bb2--d80374acf9af42bc9d56b5db5f716355 2e47e4e07db648b6bfb782b78454fae8 9e0e3393275a47c38a00a3b640bb6bb2--2e47e4e07db648b6bfb782b78454fae8 4920b57c70bf455c89a8bdaf4b3e8b4e 2e47e4e07db648b6bfb782b78454fae8--4920b57c70bf455c89a8bdaf4b3e8b4e 32c05823d1e2441eb454b885874c0a4b 4920b57c70bf455c89a8bdaf4b3e8b4e--32c05823d1e2441eb454b885874c0a4b 922231b5116b47df8ed0a6b734ee90de 32c05823d1e2441eb454b885874c0a4b--922231b5116b47df8ed0a6b734ee90de bcbc134d5514423296090615cd185875 922231b5116b47df8ed0a6b734ee90de--bcbc134d5514423296090615cd185875 a391ed60ffcc4f4f8e7a4945d975e0d5 X bcbc134d5514423296090615cd185875--a391ed60ffcc4f4f8e7a4945d975e0d5 a391ed60ffcc4f4f8e7a4945d975e0d5--46941dd8c69b4dca949c35943b4a1644 7a2ba01090fe4918aa5ac0bdc930bf06 a391ed60ffcc4f4f8e7a4945d975e0d5--7a2ba01090fe4918aa5ac0bdc930bf06 9e44de2520684a61b9f28c3d41bf0de4 7a2ba01090fe4918aa5ac0bdc930bf06--9e44de2520684a61b9f28c3d41bf0de4 4dc194d396a44baaa4bfb3038bf13f0b 9e44de2520684a61b9f28c3d41bf0de4--4dc194d396a44baaa4bfb3038bf13f0b c393b9e1d8314fc79b2f137445544301 4dc194d396a44baaa4bfb3038bf13f0b--c393b9e1d8314fc79b2f137445544301 764114e66fe140a3b03aab4fad0873a2 c393b9e1d8314fc79b2f137445544301--764114e66fe140a3b03aab4fad0873a2 8eb5d645220545e8a3a7a36e54445cff 764114e66fe140a3b03aab4fad0873a2--8eb5d645220545e8a3a7a36e54445cff f324543afe9c4d22b2b8b45607fa9868 8eb5d645220545e8a3a7a36e54445cff--f324543afe9c4d22b2b8b45607fa9868 7aed7013c9394c53b609489cb8165278 f324543afe9c4d22b2b8b45607fa9868--7aed7013c9394c53b609489cb8165278 72c383a2a7124b9e819d89fea6ce1b63 7aed7013c9394c53b609489cb8165278--72c383a2a7124b9e819d89fea6ce1b63 274f567361434dbeb64b5be3a4409c6a 72c383a2a7124b9e819d89fea6ce1b63--274f567361434dbeb64b5be3a4409c6a ebfae469ffdb420692d05fe9b41d3889 274f567361434dbeb64b5be3a4409c6a--ebfae469ffdb420692d05fe9b41d3889 e09999f2ecba4fe2a5645565195c7647 ebfae469ffdb420692d05fe9b41d3889--e09999f2ecba4fe2a5645565195c7647 d026ecfc5ff2421c8720d30ab35e8115 e09999f2ecba4fe2a5645565195c7647--d026ecfc5ff2421c8720d30ab35e8115 642d87a6072c4285b4021be3bd5796dc d026ecfc5ff2421c8720d30ab35e8115--642d87a6072c4285b4021be3bd5796dc 443419b5789047c0a0121c09a6e809db 642d87a6072c4285b4021be3bd5796dc--443419b5789047c0a0121c09a6e809db d657bc8765b647f596dcf8e5afdb0406 443419b5789047c0a0121c09a6e809db--d657bc8765b647f596dcf8e5afdb0406 e03b0bd2f34240a49e4aa96742b4723a d657bc8765b647f596dcf8e5afdb0406--e03b0bd2f34240a49e4aa96742b4723a 9b25ecbdfd2f487f852ab38e1c659285 X e03b0bd2f34240a49e4aa96742b4723a--9b25ecbdfd2f487f852ab38e1c659285 9b25ecbdfd2f487f852ab38e1c659285--f943d3864c06428bb217f2e6da0b2a71 deccabdf1d504dcb8e058af053ebceab RZ(-1.0*g0) 9b25ecbdfd2f487f852ab38e1c659285--deccabdf1d504dcb8e058af053ebceab 27504575a01c40d09c0ea41d1ecd94b7 X deccabdf1d504dcb8e058af053ebceab--27504575a01c40d09c0ea41d1ecd94b7 27504575a01c40d09c0ea41d1ecd94b7--a587df905f7349a0b33dfc5ed12401a7 d3113a6860dd49e6b409ac8ed36e07df 27504575a01c40d09c0ea41d1ecd94b7--d3113a6860dd49e6b409ac8ed36e07df 484ea876f527456baa1b80b9d11d87e0 d3113a6860dd49e6b409ac8ed36e07df--484ea876f527456baa1b80b9d11d87e0 f328b6ee0409492eab98a49cde5f7ba6 484ea876f527456baa1b80b9d11d87e0--f328b6ee0409492eab98a49cde5f7ba6 754bb0dc71b549aa9344e369b4dda2ce f328b6ee0409492eab98a49cde5f7ba6--754bb0dc71b549aa9344e369b4dda2ce 41e70cbd1dfc4951b4254cf9c8679100 754bb0dc71b549aa9344e369b4dda2ce--41e70cbd1dfc4951b4254cf9c8679100 9924998a72124aa8bb2a8478e0cbd00b 41e70cbd1dfc4951b4254cf9c8679100--9924998a72124aa8bb2a8478e0cbd00b e8baa822926346caa6d350ee58d96744 X 9924998a72124aa8bb2a8478e0cbd00b--e8baa822926346caa6d350ee58d96744 e8baa822926346caa6d350ee58d96744--4a6e36d36f0a443d9f6e690cd195f905 9df99fa248a049488f318b8d7bcf8048 e8baa822926346caa6d350ee58d96744--9df99fa248a049488f318b8d7bcf8048 fc66cdc0a1c14fe4a7eff998f9488da4 9df99fa248a049488f318b8d7bcf8048--fc66cdc0a1c14fe4a7eff998f9488da4 33e58c46729c432a96794a59cea18514 fc66cdc0a1c14fe4a7eff998f9488da4--33e58c46729c432a96794a59cea18514 4289d4d1331948a68f65d9274bca34f5 X 33e58c46729c432a96794a59cea18514--4289d4d1331948a68f65d9274bca34f5 4289d4d1331948a68f65d9274bca34f5--51b4a762d03a4f4fbc92ba83fb098d5b 36ae8b7d1cba464c8502ae70bf56849d 4289d4d1331948a68f65d9274bca34f5--36ae8b7d1cba464c8502ae70bf56849d 92377e2a1b7d4df3bc4851949414612e 36ae8b7d1cba464c8502ae70bf56849d--92377e2a1b7d4df3bc4851949414612e 2a08dc6e896a482e8e7c1d81d4a19d96 92377e2a1b7d4df3bc4851949414612e--2a08dc6e896a482e8e7c1d81d4a19d96 9d5765c2065a4521a869fd42e8f74ab2 2a08dc6e896a482e8e7c1d81d4a19d96--9d5765c2065a4521a869fd42e8f74ab2 8140572a34e7453ebefa6f6eaa7b8389 9d5765c2065a4521a869fd42e8f74ab2--8140572a34e7453ebefa6f6eaa7b8389 cd75d972118d457aab47edd25eeda232 8140572a34e7453ebefa6f6eaa7b8389--cd75d972118d457aab47edd25eeda232 616ab323942d454f958b493bca8288f5 cd75d972118d457aab47edd25eeda232--616ab323942d454f958b493bca8288f5 02289a2a7fc648b7bebe0967c9c39568 616ab323942d454f958b493bca8288f5--02289a2a7fc648b7bebe0967c9c39568 9a2f6cfd17854defa66a862742910ca0 02289a2a7fc648b7bebe0967c9c39568--9a2f6cfd17854defa66a862742910ca0 1122b2e12f8743f889f3d2c08b97d272 9a2f6cfd17854defa66a862742910ca0--1122b2e12f8743f889f3d2c08b97d272 73ae570a7cdf4d6bbc6dd2dfc097ba9a X 1122b2e12f8743f889f3d2c08b97d272--73ae570a7cdf4d6bbc6dd2dfc097ba9a 73ae570a7cdf4d6bbc6dd2dfc097ba9a--ddb5274e05bb4734bd2506e9453bb48e 90b5483f2d18484daa946e81ccea2d2b RZ(-1.0*g0) 73ae570a7cdf4d6bbc6dd2dfc097ba9a--90b5483f2d18484daa946e81ccea2d2b 4a3416a907ff4a98823abd3d571115b3 X 90b5483f2d18484daa946e81ccea2d2b--4a3416a907ff4a98823abd3d571115b3 4a3416a907ff4a98823abd3d571115b3--1c26d573775647469ca35c0b8cba1277 92fe7512f9304fe3b7c7862325dc96f8 4a3416a907ff4a98823abd3d571115b3--92fe7512f9304fe3b7c7862325dc96f8 64cd3de2f64e4dd2a61b851a48b2af10 92fe7512f9304fe3b7c7862325dc96f8--64cd3de2f64e4dd2a61b851a48b2af10 ecbd88508efa44e0a45a345684022d90 64cd3de2f64e4dd2a61b851a48b2af10--ecbd88508efa44e0a45a345684022d90 1ff9be1e2c704143882cc052036d0307 ecbd88508efa44e0a45a345684022d90--1ff9be1e2c704143882cc052036d0307 12e3761d721a406eaacb6fb0c66196b3 X 1ff9be1e2c704143882cc052036d0307--12e3761d721a406eaacb6fb0c66196b3 12e3761d721a406eaacb6fb0c66196b3--6795e871d8304004878c291b45696011 ca4da75d33c9404cb386b44e943d870b 12e3761d721a406eaacb6fb0c66196b3--ca4da75d33c9404cb386b44e943d870b db29aadcad29430fa823ef9450f1be7e ca4da75d33c9404cb386b44e943d870b--db29aadcad29430fa823ef9450f1be7e 7adb72e821ee4b0cbb9b8080dad72c45 db29aadcad29430fa823ef9450f1be7e--7adb72e821ee4b0cbb9b8080dad72c45 064c0f3f4630423e82ae17aa523fd305 X 7adb72e821ee4b0cbb9b8080dad72c45--064c0f3f4630423e82ae17aa523fd305 064c0f3f4630423e82ae17aa523fd305--1fe8e2e024254b089bb64710677e9072 da58bdb5b56b428295026bd94adb5a00 064c0f3f4630423e82ae17aa523fd305--da58bdb5b56b428295026bd94adb5a00 d82a30afa833493ea496ccfb50afd2ba da58bdb5b56b428295026bd94adb5a00--d82a30afa833493ea496ccfb50afd2ba 21454402d7fa4715885883e08cb2f19b d82a30afa833493ea496ccfb50afd2ba--21454402d7fa4715885883e08cb2f19b d3bbdcd84e7c48e3a1fdc9dd15528035 21454402d7fa4715885883e08cb2f19b--d3bbdcd84e7c48e3a1fdc9dd15528035 4402a9ed39cf45cdb5242e4a134b0315 X d3bbdcd84e7c48e3a1fdc9dd15528035--4402a9ed39cf45cdb5242e4a134b0315 4402a9ed39cf45cdb5242e4a134b0315--97e7a9a5dc3a41c8aa4ac652ee0bb125 e58c2e007ab34e4297328180ae3084db 4402a9ed39cf45cdb5242e4a134b0315--e58c2e007ab34e4297328180ae3084db fb355944685f4ef49168eb6ec59e6bd1 e58c2e007ab34e4297328180ae3084db--fb355944685f4ef49168eb6ec59e6bd1 da37fa35a79946f19c914a4fe76b47cd fb355944685f4ef49168eb6ec59e6bd1--da37fa35a79946f19c914a4fe76b47cd f8b12a13b1954cd1b7a7fb363efa0a81 da37fa35a79946f19c914a4fe76b47cd--f8b12a13b1954cd1b7a7fb363efa0a81 853e252ddb634606a85fb4bfb5e26c30 f8b12a13b1954cd1b7a7fb363efa0a81--853e252ddb634606a85fb4bfb5e26c30 a3e3f524db0843099486ca612d40885c X 853e252ddb634606a85fb4bfb5e26c30--a3e3f524db0843099486ca612d40885c a3e3f524db0843099486ca612d40885c--0793c17055d349fe9c636f7bb6954d0f b7906c93ce41451eb7f52d193bf9ddc3 a3e3f524db0843099486ca612d40885c--b7906c93ce41451eb7f52d193bf9ddc3 13bb0acf22764c2b849d6afdf9a827de b7906c93ce41451eb7f52d193bf9ddc3--13bb0acf22764c2b849d6afdf9a827de 54c568300f9e4b3d934cb6dae5b03161 13bb0acf22764c2b849d6afdf9a827de--54c568300f9e4b3d934cb6dae5b03161 b6a7dfb854df4943a00bb4a7a4446058 54c568300f9e4b3d934cb6dae5b03161--b6a7dfb854df4943a00bb4a7a4446058 621f484b3f08493a9b8c0f3d744ea0aa b6a7dfb854df4943a00bb4a7a4446058--621f484b3f08493a9b8c0f3d744ea0aa 3919da8e14d74e9288fd67a4bebf422b 621f484b3f08493a9b8c0f3d744ea0aa--3919da8e14d74e9288fd67a4bebf422b e9a0a767687947119dab5dc1068dcce4 X 3919da8e14d74e9288fd67a4bebf422b--e9a0a767687947119dab5dc1068dcce4 e9a0a767687947119dab5dc1068dcce4--6354a8bfc49348e3a99bf9ab6ffd189f abe683c14fbf415b98e912eb4b23835e RZ(-1.0*g0) e9a0a767687947119dab5dc1068dcce4--abe683c14fbf415b98e912eb4b23835e a308e5f251784fe69d1a384ab0a33f72 X abe683c14fbf415b98e912eb4b23835e--a308e5f251784fe69d1a384ab0a33f72 a308e5f251784fe69d1a384ab0a33f72--67e7dd2a286c40a4b199b85982ab9360 f52b827352c84069ada165be9d20bd58 a308e5f251784fe69d1a384ab0a33f72--f52b827352c84069ada165be9d20bd58 ebf454a88dc04905ad7041007c760faf f52b827352c84069ada165be9d20bd58--ebf454a88dc04905ad7041007c760faf 0af9728ecb004c90aac96b1aa2531ace X ebf454a88dc04905ad7041007c760faf--0af9728ecb004c90aac96b1aa2531ace 0af9728ecb004c90aac96b1aa2531ace--0e0170760ea942d7bb929ff6b29b2398 3aad73536b2f41138edfc2d5402bfb1b 0af9728ecb004c90aac96b1aa2531ace--3aad73536b2f41138edfc2d5402bfb1b 522f248aea9a4efab7f0ea162878e9b5 3aad73536b2f41138edfc2d5402bfb1b--522f248aea9a4efab7f0ea162878e9b5 acdc474c82f3426191049cd7e17be701 522f248aea9a4efab7f0ea162878e9b5--acdc474c82f3426191049cd7e17be701 a38d30b5453e4e4489d548bea0248ce6 X acdc474c82f3426191049cd7e17be701--a38d30b5453e4e4489d548bea0248ce6 a38d30b5453e4e4489d548bea0248ce6--77298e4cd3b54c42b70916163f21c3a2 3e6c51cd24dc46898caf1487e9eee97d a38d30b5453e4e4489d548bea0248ce6--3e6c51cd24dc46898caf1487e9eee97d d2193e058e83477a9458f0356556e472 X 3e6c51cd24dc46898caf1487e9eee97d--d2193e058e83477a9458f0356556e472 d2193e058e83477a9458f0356556e472--648b98e9adc34d3cac0feed0821e2f2e 83545d11d862453a804de62b86b7d653 d2193e058e83477a9458f0356556e472--83545d11d862453a804de62b86b7d653 5b01e54edccd426aa3aa2e903de222e3 83545d11d862453a804de62b86b7d653--5b01e54edccd426aa3aa2e903de222e3 c9cc6f4aecf64ca0a9283594b781cd2d 5b01e54edccd426aa3aa2e903de222e3--c9cc6f4aecf64ca0a9283594b781cd2d 8fc2331d59d84cc088e7d9b812ed959f c9cc6f4aecf64ca0a9283594b781cd2d--8fc2331d59d84cc088e7d9b812ed959f 2eefda15583041989edd50b3ebbcf5c3 8fc2331d59d84cc088e7d9b812ed959f--2eefda15583041989edd50b3ebbcf5c3 126bec65d06847aca9669c9b5991c302 X 2eefda15583041989edd50b3ebbcf5c3--126bec65d06847aca9669c9b5991c302 126bec65d06847aca9669c9b5991c302--acb8758dd578411392c5b5102012bb11 421b3fa25f6e4620b06607bc33fb345e 126bec65d06847aca9669c9b5991c302--421b3fa25f6e4620b06607bc33fb345e 9322010438e24d3f9ea5f2d320eb7115 421b3fa25f6e4620b06607bc33fb345e--9322010438e24d3f9ea5f2d320eb7115 89c267bdfedd439382427f56c202b0ca 9322010438e24d3f9ea5f2d320eb7115--89c267bdfedd439382427f56c202b0ca 17f27d625a064da686d60492df0dbdce 89c267bdfedd439382427f56c202b0ca--17f27d625a064da686d60492df0dbdce 0957ce7402854d5ab77adea3bfd9fedd 17f27d625a064da686d60492df0dbdce--0957ce7402854d5ab77adea3bfd9fedd ed979803a96a45f79a0b6e54f26ef1ba RX(b05) 0957ce7402854d5ab77adea3bfd9fedd--ed979803a96a45f79a0b6e54f26ef1ba 74c07e6e23a9426d988ebf53513aa574 ed979803a96a45f79a0b6e54f26ef1ba--74c07e6e23a9426d988ebf53513aa574 6d456161da9d4e33b63ea6ca69c90685 74c07e6e23a9426d988ebf53513aa574--6d456161da9d4e33b63ea6ca69c90685 03f7c46124cb4181a572f42eadcd0f48 6d456161da9d4e33b63ea6ca69c90685--03f7c46124cb4181a572f42eadcd0f48 f898297824c04ed69121fcd4d3cc303f 03f7c46124cb4181a572f42eadcd0f48--f898297824c04ed69121fcd4d3cc303f f93dbbaaad184615aaef6477ccbb776a X f898297824c04ed69121fcd4d3cc303f--f93dbbaaad184615aaef6477ccbb776a f93dbbaaad184615aaef6477ccbb776a--e5d0091d5dda4167a17417e24ca3bf67 0d3981beb54c4dbab0672169730c881b f93dbbaaad184615aaef6477ccbb776a--0d3981beb54c4dbab0672169730c881b f95e605b993c4bf3871b344061df5f44 0d3981beb54c4dbab0672169730c881b--f95e605b993c4bf3871b344061df5f44 b4a52d214fd04eabbbc461048c284a9d f95e605b993c4bf3871b344061df5f44--b4a52d214fd04eabbbc461048c284a9d 98e21f923fe94a569e3b402a8fdf4cc3 b4a52d214fd04eabbbc461048c284a9d--98e21f923fe94a569e3b402a8fdf4cc3 debce0aeca264a8a9016c99522068bbf 98e21f923fe94a569e3b402a8fdf4cc3--debce0aeca264a8a9016c99522068bbf 25a6ef4734224de8a7a0262180d28240 X debce0aeca264a8a9016c99522068bbf--25a6ef4734224de8a7a0262180d28240 25a6ef4734224de8a7a0262180d28240--9115e77250264d4f9dd99856e974d564 0911a31682ec448ab8dbf942a0f7e47e 25a6ef4734224de8a7a0262180d28240--0911a31682ec448ab8dbf942a0f7e47e 146dd5caecdb42b8ae56dbdc54410d6c 0911a31682ec448ab8dbf942a0f7e47e--146dd5caecdb42b8ae56dbdc54410d6c c602bdaf542847f5a5010957d694bf29 146dd5caecdb42b8ae56dbdc54410d6c--c602bdaf542847f5a5010957d694bf29 a56bdefab3324d81958a943cf90aa3bc c602bdaf542847f5a5010957d694bf29--a56bdefab3324d81958a943cf90aa3bc 6789562c7f5a41c79f095938552d4ce7 a56bdefab3324d81958a943cf90aa3bc--6789562c7f5a41c79f095938552d4ce7 84f7546ebb6946f3b9336f4cb325dc47 6789562c7f5a41c79f095938552d4ce7--84f7546ebb6946f3b9336f4cb325dc47 b1669e4cbc1048d6abfc22443257aa52 84f7546ebb6946f3b9336f4cb325dc47--b1669e4cbc1048d6abfc22443257aa52 5df86446e5814771857d61ae5f25ebe3 b1669e4cbc1048d6abfc22443257aa52--5df86446e5814771857d61ae5f25ebe3 6ec2d909d6e74ceca61308914644d96e 5df86446e5814771857d61ae5f25ebe3--6ec2d909d6e74ceca61308914644d96e 6d8051fc24a242198f78f7932a521a9b 6ec2d909d6e74ceca61308914644d96e--6d8051fc24a242198f78f7932a521a9b 634accf192a94696ab748cfb6dfa837c 6d8051fc24a242198f78f7932a521a9b--634accf192a94696ab748cfb6dfa837c 1faceb5aee164ae789840b21a981e823 634accf192a94696ab748cfb6dfa837c--1faceb5aee164ae789840b21a981e823 4893c50502724022abb4c6ccd2c4cbca 1faceb5aee164ae789840b21a981e823--4893c50502724022abb4c6ccd2c4cbca be81bb20e3d84272b08d2cc9ae456aa4 4893c50502724022abb4c6ccd2c4cbca--be81bb20e3d84272b08d2cc9ae456aa4 180150729ad9421b853942dfd7491c6b be81bb20e3d84272b08d2cc9ae456aa4--180150729ad9421b853942dfd7491c6b 8ee544da49854306933b19b8ca8b0b35 180150729ad9421b853942dfd7491c6b--8ee544da49854306933b19b8ca8b0b35 dd63ebdf3f024e6b8f5d07c66889eafc 8ee544da49854306933b19b8ca8b0b35--dd63ebdf3f024e6b8f5d07c66889eafc d48a30ca4fb14f788064e2645543af59 X dd63ebdf3f024e6b8f5d07c66889eafc--d48a30ca4fb14f788064e2645543af59 d48a30ca4fb14f788064e2645543af59--b38aed6be07d45bba58cc72ae1e82e28 becf54d00f654929a524fa1d3b3366fe RZ(-1.0*g1) d48a30ca4fb14f788064e2645543af59--becf54d00f654929a524fa1d3b3366fe b6baadd9fd6b472688fde09fa345aa3d X becf54d00f654929a524fa1d3b3366fe--b6baadd9fd6b472688fde09fa345aa3d b6baadd9fd6b472688fde09fa345aa3d--e0249fc2b2de4ac99ef811a9ded77012 c608a2d0787a4b86a8c3af6b616bd79b b6baadd9fd6b472688fde09fa345aa3d--c608a2d0787a4b86a8c3af6b616bd79b 5367b8a3498f458c830583ee1f25019b c608a2d0787a4b86a8c3af6b616bd79b--5367b8a3498f458c830583ee1f25019b 902dfa61f01d45a4b88e8dc489e84034 5367b8a3498f458c830583ee1f25019b--902dfa61f01d45a4b88e8dc489e84034 eb4bf78601794dfdb5855fbaf4c13b5a 902dfa61f01d45a4b88e8dc489e84034--eb4bf78601794dfdb5855fbaf4c13b5a 6928f12f2d80439c846fd246ee27a09b eb4bf78601794dfdb5855fbaf4c13b5a--6928f12f2d80439c846fd246ee27a09b e47986ba75db41dfa44d722a2082d946 6928f12f2d80439c846fd246ee27a09b--e47986ba75db41dfa44d722a2082d946 aedfe12ea0cb48e793345962ae41ba5b X e47986ba75db41dfa44d722a2082d946--aedfe12ea0cb48e793345962ae41ba5b aedfe12ea0cb48e793345962ae41ba5b--98876435b8aa41fc98a85c2561a2ec6a 04b0c02eee52479fa270ff23028ee806 aedfe12ea0cb48e793345962ae41ba5b--04b0c02eee52479fa270ff23028ee806 d8741249a3f54cb4a0822e9f5984bb08 04b0c02eee52479fa270ff23028ee806--d8741249a3f54cb4a0822e9f5984bb08 2373b1e9995e4a51b74d3451fb655025 d8741249a3f54cb4a0822e9f5984bb08--2373b1e9995e4a51b74d3451fb655025 bcb0ab7923a04ce0af4795a0f3fa7bd8 X 2373b1e9995e4a51b74d3451fb655025--bcb0ab7923a04ce0af4795a0f3fa7bd8 bcb0ab7923a04ce0af4795a0f3fa7bd8--4b78e6c27fa24875a453a5138e404eee 7597e0af6e914155b236c8abe178c6cf bcb0ab7923a04ce0af4795a0f3fa7bd8--7597e0af6e914155b236c8abe178c6cf a78637479b5c4b4791b732e401300e98 7597e0af6e914155b236c8abe178c6cf--a78637479b5c4b4791b732e401300e98 a8cdf69c257240aaa3b877168fece441 a78637479b5c4b4791b732e401300e98--a8cdf69c257240aaa3b877168fece441 3ec629a901054fdcbcd5bc71ff35c648 a8cdf69c257240aaa3b877168fece441--3ec629a901054fdcbcd5bc71ff35c648 f5ba6559134047c98cd7990d6c188a68 3ec629a901054fdcbcd5bc71ff35c648--f5ba6559134047c98cd7990d6c188a68 6472a6fb3cb347f8bcdd7b65b5fc47ad f5ba6559134047c98cd7990d6c188a68--6472a6fb3cb347f8bcdd7b65b5fc47ad 41e8463962924c68a1fa79e2db226a5b 6472a6fb3cb347f8bcdd7b65b5fc47ad--41e8463962924c68a1fa79e2db226a5b b2341b0846a841809be7589e2a5dca7d 41e8463962924c68a1fa79e2db226a5b--b2341b0846a841809be7589e2a5dca7d e3551768aec74fb880b50f2b53c24e97 b2341b0846a841809be7589e2a5dca7d--e3551768aec74fb880b50f2b53c24e97 3cac2035ce5c4505ad66a52349728eea e3551768aec74fb880b50f2b53c24e97--3cac2035ce5c4505ad66a52349728eea e3095b129c064f5983eb22219f761b41 X 3cac2035ce5c4505ad66a52349728eea--e3095b129c064f5983eb22219f761b41 e3095b129c064f5983eb22219f761b41--5e105cc412e84cd9a84d3b137b0cf863 4c4fe9640d1547f081661b84d8999fbb RZ(-1.0*g1) e3095b129c064f5983eb22219f761b41--4c4fe9640d1547f081661b84d8999fbb 4fc58fd38ee948d082b61513314a9db2 X 4c4fe9640d1547f081661b84d8999fbb--4fc58fd38ee948d082b61513314a9db2 4fc58fd38ee948d082b61513314a9db2--e61d6622e32743ab8849c58d6c532c0e 6d556a79f641486cb2035bfca27509d8 4fc58fd38ee948d082b61513314a9db2--6d556a79f641486cb2035bfca27509d8 14108f701d7743a8ae20f36cca29dc93 6d556a79f641486cb2035bfca27509d8--14108f701d7743a8ae20f36cca29dc93 cf6f519e88824465a0a89f79d22b7f4b 14108f701d7743a8ae20f36cca29dc93--cf6f519e88824465a0a89f79d22b7f4b 310edda602e9453f8001aea9bc844008 cf6f519e88824465a0a89f79d22b7f4b--310edda602e9453f8001aea9bc844008 7072bfd90bbf4f34b5b048ef8c4e0951 X 310edda602e9453f8001aea9bc844008--7072bfd90bbf4f34b5b048ef8c4e0951 7072bfd90bbf4f34b5b048ef8c4e0951--1e5e87d60b644a12a4227bff194286a4 b17109df7a434412b8af05411f0a6c31 7072bfd90bbf4f34b5b048ef8c4e0951--b17109df7a434412b8af05411f0a6c31 0dee5883098d47858f8193257ad8271d b17109df7a434412b8af05411f0a6c31--0dee5883098d47858f8193257ad8271d 156cd9a3d3404d7e98c1cd3e903c8a0c 0dee5883098d47858f8193257ad8271d--156cd9a3d3404d7e98c1cd3e903c8a0c a0f5e905922340fdbd202c89ecca44ce X 156cd9a3d3404d7e98c1cd3e903c8a0c--a0f5e905922340fdbd202c89ecca44ce a0f5e905922340fdbd202c89ecca44ce--7d37e1a47a4c4065bb2fff0758c0788a 71216af5b6fe4cd08d36eb2dfc26b854 a0f5e905922340fdbd202c89ecca44ce--71216af5b6fe4cd08d36eb2dfc26b854 a014c51d44d747a5b10cc25437f7ee76 71216af5b6fe4cd08d36eb2dfc26b854--a014c51d44d747a5b10cc25437f7ee76 29a850e55e414db98fb8127ca9cd46b0 a014c51d44d747a5b10cc25437f7ee76--29a850e55e414db98fb8127ca9cd46b0 6219ac57fc6e4489bc3c5e12fd5c0299 29a850e55e414db98fb8127ca9cd46b0--6219ac57fc6e4489bc3c5e12fd5c0299 c9b1dc8227f5422494f9f1664aad49ac X 6219ac57fc6e4489bc3c5e12fd5c0299--c9b1dc8227f5422494f9f1664aad49ac c9b1dc8227f5422494f9f1664aad49ac--8692bf4178904c45870a1178ddde9c86 e6e068e407044677a9ac4cc1f053be6f c9b1dc8227f5422494f9f1664aad49ac--e6e068e407044677a9ac4cc1f053be6f df46a6c7c33f4e01bdf470e34af63b6f e6e068e407044677a9ac4cc1f053be6f--df46a6c7c33f4e01bdf470e34af63b6f 5ee306c7ac174f94a9c3459d3f36e888 df46a6c7c33f4e01bdf470e34af63b6f--5ee306c7ac174f94a9c3459d3f36e888 5a3bd7491c874781b4a6df5c4c3eee00 5ee306c7ac174f94a9c3459d3f36e888--5a3bd7491c874781b4a6df5c4c3eee00 b021fb8356354cb7b05baefdbba8313e 5a3bd7491c874781b4a6df5c4c3eee00--b021fb8356354cb7b05baefdbba8313e 25d833ee078c44dcaf574025763d4bc7 X b021fb8356354cb7b05baefdbba8313e--25d833ee078c44dcaf574025763d4bc7 25d833ee078c44dcaf574025763d4bc7--a6a2fe0625ea4517b4c95f661526c27b b613873f90bd4761901062d081c7299d 25d833ee078c44dcaf574025763d4bc7--b613873f90bd4761901062d081c7299d 81e101e98eb443c8b07d0c250f195d26 b613873f90bd4761901062d081c7299d--81e101e98eb443c8b07d0c250f195d26 48c3d9be5d17477888a364c19b68b8e4 81e101e98eb443c8b07d0c250f195d26--48c3d9be5d17477888a364c19b68b8e4 dc4c6205635b4b0d987357045f8a5412 48c3d9be5d17477888a364c19b68b8e4--dc4c6205635b4b0d987357045f8a5412 b17821713eec416eacc2e6a198918d41 dc4c6205635b4b0d987357045f8a5412--b17821713eec416eacc2e6a198918d41 1699523fd8064e4aa977be9f9e13b04c b17821713eec416eacc2e6a198918d41--1699523fd8064e4aa977be9f9e13b04c 54f9a83298694c168179a8caa8c58ece X 1699523fd8064e4aa977be9f9e13b04c--54f9a83298694c168179a8caa8c58ece 54f9a83298694c168179a8caa8c58ece--43c267dc72594eb3a2ff2439688688a6 9be840bfa25c41edb288fa94d8014d8f RZ(-1.0*g1) 54f9a83298694c168179a8caa8c58ece--9be840bfa25c41edb288fa94d8014d8f 07f4a797e8a4421fa0afcb75ca98ae7d X 9be840bfa25c41edb288fa94d8014d8f--07f4a797e8a4421fa0afcb75ca98ae7d 07f4a797e8a4421fa0afcb75ca98ae7d--2674e0ca90344f4b8da50cf65359ef14 bf84bb10fb4249a1a7d3940f423d50d2 07f4a797e8a4421fa0afcb75ca98ae7d--bf84bb10fb4249a1a7d3940f423d50d2 96315c6178e8484087640af896a24612 bf84bb10fb4249a1a7d3940f423d50d2--96315c6178e8484087640af896a24612 900c438a74c147a18e62951ed197bf75 X 96315c6178e8484087640af896a24612--900c438a74c147a18e62951ed197bf75 900c438a74c147a18e62951ed197bf75--6eb8d97b1a19447d92e3aa4013f26bb2 02949149a95b4b469731e800f0efa4f9 900c438a74c147a18e62951ed197bf75--02949149a95b4b469731e800f0efa4f9 fdc9e737fab448178fd5a3f19dbb463c 02949149a95b4b469731e800f0efa4f9--fdc9e737fab448178fd5a3f19dbb463c 5edd3ea4525a4ea9b08faedbc5a0db61 fdc9e737fab448178fd5a3f19dbb463c--5edd3ea4525a4ea9b08faedbc5a0db61 c4055ed86f9d403bba43295fd49e9067 X 5edd3ea4525a4ea9b08faedbc5a0db61--c4055ed86f9d403bba43295fd49e9067 c4055ed86f9d403bba43295fd49e9067--934638609ec84c9ebed9ac71a2e68f29 78f332dde6474b85b34ff859713bf962 c4055ed86f9d403bba43295fd49e9067--78f332dde6474b85b34ff859713bf962 0bb7b82180d64d2780a7fc2938c236b6 X 78f332dde6474b85b34ff859713bf962--0bb7b82180d64d2780a7fc2938c236b6 0bb7b82180d64d2780a7fc2938c236b6--afcbdcb31a8e4d2398beef931744a285 1e80dbe5c9a84e15af57216693009212 0bb7b82180d64d2780a7fc2938c236b6--1e80dbe5c9a84e15af57216693009212 e2532f82abf64b039ba13a164b630dd4 1e80dbe5c9a84e15af57216693009212--e2532f82abf64b039ba13a164b630dd4 ecec0da7b2bc43609e8cb5a00b3e9a6f e2532f82abf64b039ba13a164b630dd4--ecec0da7b2bc43609e8cb5a00b3e9a6f e4b2a6c5624e4160b8823521ac1e8e86 ecec0da7b2bc43609e8cb5a00b3e9a6f--e4b2a6c5624e4160b8823521ac1e8e86 80ee0bf42e5547b99d56e5caf608b028 e4b2a6c5624e4160b8823521ac1e8e86--80ee0bf42e5547b99d56e5caf608b028 759eebf4e83442c7821e1f46faecf37c X 80ee0bf42e5547b99d56e5caf608b028--759eebf4e83442c7821e1f46faecf37c 759eebf4e83442c7821e1f46faecf37c--1ad8fbcbbc9a462e94ebb9b2cf6e84cf 4a3b7aacdff7448d979bd570b8fb13a5 759eebf4e83442c7821e1f46faecf37c--4a3b7aacdff7448d979bd570b8fb13a5 972573212dbc405b93b5b7a5481b31ad 4a3b7aacdff7448d979bd570b8fb13a5--972573212dbc405b93b5b7a5481b31ad 032c0caa22d14a9c8049fe916d97a5b1 972573212dbc405b93b5b7a5481b31ad--032c0caa22d14a9c8049fe916d97a5b1 05de72e1849b45a287e87f90c8a0000e 032c0caa22d14a9c8049fe916d97a5b1--05de72e1849b45a287e87f90c8a0000e 257cf66731634d87a2acfaadc6c25428 05de72e1849b45a287e87f90c8a0000e--257cf66731634d87a2acfaadc6c25428 02ae7a9850c94068a69cbbeeefbf123e RX(b15) 257cf66731634d87a2acfaadc6c25428--02ae7a9850c94068a69cbbeeefbf123e 02ae7a9850c94068a69cbbeeefbf123e--9ba6c8dfeabe4a7a9ea9d46bc7565836 e68c1428835748c48fdb46377318bf4e 74429fe461b24df3b73938ec26edb1c1 586d90f203584f8a9089f2fd2cb1c23d--74429fe461b24df3b73938ec26edb1c1 83f42cb3cf5d449697b9525c6ee46b7f 7 b92f93e44f5e451ca7852f0c330ca51b 74429fe461b24df3b73938ec26edb1c1--b92f93e44f5e451ca7852f0c330ca51b f16c67890c474a7db1180b655542b7c1 b92f93e44f5e451ca7852f0c330ca51b--f16c67890c474a7db1180b655542b7c1 b63ad128f18242a58f45a600b5e66fac f16c67890c474a7db1180b655542b7c1--b63ad128f18242a58f45a600b5e66fac c143f3a09bbe4e4aae27e229e9c5ef84 b63ad128f18242a58f45a600b5e66fac--c143f3a09bbe4e4aae27e229e9c5ef84 c94d592137b24ca5b6a9b8aaedb28869 X c143f3a09bbe4e4aae27e229e9c5ef84--c94d592137b24ca5b6a9b8aaedb28869 c94d592137b24ca5b6a9b8aaedb28869--2e47e4e07db648b6bfb782b78454fae8 21cf1573ca384cfbab0a36ee2452f370 c94d592137b24ca5b6a9b8aaedb28869--21cf1573ca384cfbab0a36ee2452f370 43a7e2c4c60247c4ba1e67ff75bafd01 21cf1573ca384cfbab0a36ee2452f370--43a7e2c4c60247c4ba1e67ff75bafd01 58fbc9d4d81f4a8b97e1de0b6937e267 43a7e2c4c60247c4ba1e67ff75bafd01--58fbc9d4d81f4a8b97e1de0b6937e267 10478da579f448d4913bfbe1da92e664 X 58fbc9d4d81f4a8b97e1de0b6937e267--10478da579f448d4913bfbe1da92e664 10478da579f448d4913bfbe1da92e664--bcbc134d5514423296090615cd185875 31fe4a8f326d401d8ff07b88661d4ca1 10478da579f448d4913bfbe1da92e664--31fe4a8f326d401d8ff07b88661d4ca1 7460865e4d2a4f6ea2747ef9eb1e190f 31fe4a8f326d401d8ff07b88661d4ca1--7460865e4d2a4f6ea2747ef9eb1e190f 21909d1508714862b1ddf26e7fa99811 7460865e4d2a4f6ea2747ef9eb1e190f--21909d1508714862b1ddf26e7fa99811 42d0cc2294fb4a31aae7462d59fe20a5 21909d1508714862b1ddf26e7fa99811--42d0cc2294fb4a31aae7462d59fe20a5 76acdc54efb24e6681766b0fb6bb5a0e 42d0cc2294fb4a31aae7462d59fe20a5--76acdc54efb24e6681766b0fb6bb5a0e 23376990838e40f79a4b31fa905725d0 76acdc54efb24e6681766b0fb6bb5a0e--23376990838e40f79a4b31fa905725d0 7a7676c249ac44f8b8aa5a3d6c99ae1a 23376990838e40f79a4b31fa905725d0--7a7676c249ac44f8b8aa5a3d6c99ae1a 0fecb7d98388422199ffb559a197fb27 7a7676c249ac44f8b8aa5a3d6c99ae1a--0fecb7d98388422199ffb559a197fb27 453dbcfa63ce400ea877cf0bd7870951 0fecb7d98388422199ffb559a197fb27--453dbcfa63ce400ea877cf0bd7870951 303f94f310cb41e3a202af3d7b2f8955 453dbcfa63ce400ea877cf0bd7870951--303f94f310cb41e3a202af3d7b2f8955 b4c92afacbf74cf7ae76eee367d43c0c 303f94f310cb41e3a202af3d7b2f8955--b4c92afacbf74cf7ae76eee367d43c0c 2f081479213f4a02aa741401a9f9b40f b4c92afacbf74cf7ae76eee367d43c0c--2f081479213f4a02aa741401a9f9b40f 9e85b8759f7a47e39f5fe84852c1bbcd 2f081479213f4a02aa741401a9f9b40f--9e85b8759f7a47e39f5fe84852c1bbcd a9021176234043d98331786627477225 9e85b8759f7a47e39f5fe84852c1bbcd--a9021176234043d98331786627477225 30f80946b0ed49d49bb0ff255cd636c2 a9021176234043d98331786627477225--30f80946b0ed49d49bb0ff255cd636c2 3c9d7f8bcbf74c6faaa6cffeec57b545 30f80946b0ed49d49bb0ff255cd636c2--3c9d7f8bcbf74c6faaa6cffeec57b545 6b4d6638981b4b278fcaae004aff5ff4 3c9d7f8bcbf74c6faaa6cffeec57b545--6b4d6638981b4b278fcaae004aff5ff4 1d65d1cb66654030b829c83e0a3e3d0a 6b4d6638981b4b278fcaae004aff5ff4--1d65d1cb66654030b829c83e0a3e3d0a f7f3cad031814af0806bc029788404d2 1d65d1cb66654030b829c83e0a3e3d0a--f7f3cad031814af0806bc029788404d2 c7d2631f75384e3ba76b266bf8119d02 f7f3cad031814af0806bc029788404d2--c7d2631f75384e3ba76b266bf8119d02 463e5c91fde34fc1b514de1336035a33 c7d2631f75384e3ba76b266bf8119d02--463e5c91fde34fc1b514de1336035a33 54b9964e1abc4699878a2be0e8899dd4 463e5c91fde34fc1b514de1336035a33--54b9964e1abc4699878a2be0e8899dd4 920a8676a3954dbe83779e9f7323bb71 54b9964e1abc4699878a2be0e8899dd4--920a8676a3954dbe83779e9f7323bb71 73e4dae4bfc5429ba07e149b93698f47 920a8676a3954dbe83779e9f7323bb71--73e4dae4bfc5429ba07e149b93698f47 bf63b5551fdf49028bf14701b8ea7e73 73e4dae4bfc5429ba07e149b93698f47--bf63b5551fdf49028bf14701b8ea7e73 fbcd8cf6e94a4dbb83d6bbd4255942db bf63b5551fdf49028bf14701b8ea7e73--fbcd8cf6e94a4dbb83d6bbd4255942db 7b82087e387c4ca88e62b3e5f9283afc fbcd8cf6e94a4dbb83d6bbd4255942db--7b82087e387c4ca88e62b3e5f9283afc c98d5b676a57452da8bd82b2783f81c5 7b82087e387c4ca88e62b3e5f9283afc--c98d5b676a57452da8bd82b2783f81c5 e883fa1fcaf8490ea11b6e67063193ee X c98d5b676a57452da8bd82b2783f81c5--e883fa1fcaf8490ea11b6e67063193ee e883fa1fcaf8490ea11b6e67063193ee--9df99fa248a049488f318b8d7bcf8048 793e47239630404a977da0b8c8293f08 RZ(-1.0*g0) e883fa1fcaf8490ea11b6e67063193ee--793e47239630404a977da0b8c8293f08 ecd3b7fa81d84e51a44907c939f1e668 X 793e47239630404a977da0b8c8293f08--ecd3b7fa81d84e51a44907c939f1e668 ecd3b7fa81d84e51a44907c939f1e668--33e58c46729c432a96794a59cea18514 cc8e57c32edb45a99dfcb84bea6fc102 ecd3b7fa81d84e51a44907c939f1e668--cc8e57c32edb45a99dfcb84bea6fc102 bc428b15818042d484acf99de4add02c cc8e57c32edb45a99dfcb84bea6fc102--bc428b15818042d484acf99de4add02c 215b2b6f22774d328b5b4d5c4316d2ae bc428b15818042d484acf99de4add02c--215b2b6f22774d328b5b4d5c4316d2ae 73922120a2af4b628b56027debd5c7ab 215b2b6f22774d328b5b4d5c4316d2ae--73922120a2af4b628b56027debd5c7ab fe6607cdf1624a77bc44ee5cead8f66c 73922120a2af4b628b56027debd5c7ab--fe6607cdf1624a77bc44ee5cead8f66c edcd8a1e7bf542988e669c5ce8545946 fe6607cdf1624a77bc44ee5cead8f66c--edcd8a1e7bf542988e669c5ce8545946 3f752d7c8e2f4ec4b7cddb32fea9dc32 edcd8a1e7bf542988e669c5ce8545946--3f752d7c8e2f4ec4b7cddb32fea9dc32 4df946f30c194779ba595c29aaeeed3a 3f752d7c8e2f4ec4b7cddb32fea9dc32--4df946f30c194779ba595c29aaeeed3a d565df80417d4c9088b80dc0b748c558 4df946f30c194779ba595c29aaeeed3a--d565df80417d4c9088b80dc0b748c558 dcc3db454896451abd2a2a9bffb3241e d565df80417d4c9088b80dc0b748c558--dcc3db454896451abd2a2a9bffb3241e c9a504d4d1974f878c53c877fec51986 dcc3db454896451abd2a2a9bffb3241e--c9a504d4d1974f878c53c877fec51986 2c6bfea750444d59a4a96a759903e844 c9a504d4d1974f878c53c877fec51986--2c6bfea750444d59a4a96a759903e844 ea2f9cf66d494a88a94e389acf381764 2c6bfea750444d59a4a96a759903e844--ea2f9cf66d494a88a94e389acf381764 74345f4996e14757a7a8c8955dfc655e ea2f9cf66d494a88a94e389acf381764--74345f4996e14757a7a8c8955dfc655e 4f87b9e55dd6434588148a1264f0ca63 74345f4996e14757a7a8c8955dfc655e--4f87b9e55dd6434588148a1264f0ca63 f6cd1cc606904384885edf01b4a8fad8 4f87b9e55dd6434588148a1264f0ca63--f6cd1cc606904384885edf01b4a8fad8 85a76701a2164298998877b21bf326f6 f6cd1cc606904384885edf01b4a8fad8--85a76701a2164298998877b21bf326f6 ec6d03ac10864a0f89190aea27eeacb3 85a76701a2164298998877b21bf326f6--ec6d03ac10864a0f89190aea27eeacb3 8fd89302c1c243dfb7718f32c5dbbfdc ec6d03ac10864a0f89190aea27eeacb3--8fd89302c1c243dfb7718f32c5dbbfdc ea28e0aa15424fe1aed894f01f16c0cf X 8fd89302c1c243dfb7718f32c5dbbfdc--ea28e0aa15424fe1aed894f01f16c0cf ea28e0aa15424fe1aed894f01f16c0cf--ca4da75d33c9404cb386b44e943d870b f0b6e15694354f9189e47c9aeba5d1db RZ(-1.0*g0) ea28e0aa15424fe1aed894f01f16c0cf--f0b6e15694354f9189e47c9aeba5d1db 4db1732ba6544df584dfe871ee0fbf86 X f0b6e15694354f9189e47c9aeba5d1db--4db1732ba6544df584dfe871ee0fbf86 4db1732ba6544df584dfe871ee0fbf86--7adb72e821ee4b0cbb9b8080dad72c45 3b53d3d8a95040acadd567f5f92f5693 4db1732ba6544df584dfe871ee0fbf86--3b53d3d8a95040acadd567f5f92f5693 9e023f21ecc14f4daa0e532f7da5edfa 3b53d3d8a95040acadd567f5f92f5693--9e023f21ecc14f4daa0e532f7da5edfa 950c88ef1b7d48418696752d8eba40ed 9e023f21ecc14f4daa0e532f7da5edfa--950c88ef1b7d48418696752d8eba40ed ef67b913f7b04ec9a6b5dae83b7030d2 950c88ef1b7d48418696752d8eba40ed--ef67b913f7b04ec9a6b5dae83b7030d2 143987345a8f4a16b984a22fce79f2bd ef67b913f7b04ec9a6b5dae83b7030d2--143987345a8f4a16b984a22fce79f2bd abc51c7c61f04d368e5cc8b6d30212a4 143987345a8f4a16b984a22fce79f2bd--abc51c7c61f04d368e5cc8b6d30212a4 6826beb494b84b9aa65a2c0c501dcdc2 X abc51c7c61f04d368e5cc8b6d30212a4--6826beb494b84b9aa65a2c0c501dcdc2 6826beb494b84b9aa65a2c0c501dcdc2--e58c2e007ab34e4297328180ae3084db 463fe4c602594d3c9b3346b300058179 6826beb494b84b9aa65a2c0c501dcdc2--463fe4c602594d3c9b3346b300058179 4e9931ee275e44d791e2bfac66e2a879 463fe4c602594d3c9b3346b300058179--4e9931ee275e44d791e2bfac66e2a879 fd4b0a5de5c64562b3a97371813a804f 4e9931ee275e44d791e2bfac66e2a879--fd4b0a5de5c64562b3a97371813a804f be6b94b616f54af09b9989c0d7fa7eb7 X fd4b0a5de5c64562b3a97371813a804f--be6b94b616f54af09b9989c0d7fa7eb7 be6b94b616f54af09b9989c0d7fa7eb7--853e252ddb634606a85fb4bfb5e26c30 b7df295794ca40e1a366d5d865fcb1fb be6b94b616f54af09b9989c0d7fa7eb7--b7df295794ca40e1a366d5d865fcb1fb f3295f3e0d544f189306eaf10e3f6f00 b7df295794ca40e1a366d5d865fcb1fb--f3295f3e0d544f189306eaf10e3f6f00 5b62787ac2aa4073a7389378391753f4 f3295f3e0d544f189306eaf10e3f6f00--5b62787ac2aa4073a7389378391753f4 f273eeda271049a6a0e71f039c91446a 5b62787ac2aa4073a7389378391753f4--f273eeda271049a6a0e71f039c91446a 5f252772249e42f2bd43f3f79eeb349c f273eeda271049a6a0e71f039c91446a--5f252772249e42f2bd43f3f79eeb349c ce3b5bf7323c41a48470e90923db8e66 5f252772249e42f2bd43f3f79eeb349c--ce3b5bf7323c41a48470e90923db8e66 643b3c8ec9344bce9002baf8ab2f20d8 ce3b5bf7323c41a48470e90923db8e66--643b3c8ec9344bce9002baf8ab2f20d8 00f0f0b9f0ff43709aaf5ea38e9b886a 643b3c8ec9344bce9002baf8ab2f20d8--00f0f0b9f0ff43709aaf5ea38e9b886a 1d4821651bd3471d81aab6461e375de8 00f0f0b9f0ff43709aaf5ea38e9b886a--1d4821651bd3471d81aab6461e375de8 ded66db4d37e4407a9642b0f9065a468 1d4821651bd3471d81aab6461e375de8--ded66db4d37e4407a9642b0f9065a468 6b6f2d10bb3c4245a347848c723b1031 ded66db4d37e4407a9642b0f9065a468--6b6f2d10bb3c4245a347848c723b1031 d7324ff4f18048dd8eb522fa4b6abe37 6b6f2d10bb3c4245a347848c723b1031--d7324ff4f18048dd8eb522fa4b6abe37 d3d8dc54739241b49404cdec04cb0520 d7324ff4f18048dd8eb522fa4b6abe37--d3d8dc54739241b49404cdec04cb0520 c90de8dd35324d5593709843cfc76bc1 X d3d8dc54739241b49404cdec04cb0520--c90de8dd35324d5593709843cfc76bc1 c90de8dd35324d5593709843cfc76bc1--3aad73536b2f41138edfc2d5402bfb1b 556bfdf9015c40eca7a1af8cf0238352 RZ(-1.0*g0) c90de8dd35324d5593709843cfc76bc1--556bfdf9015c40eca7a1af8cf0238352 7cd5a94fcf6345dab20c06c339547154 X 556bfdf9015c40eca7a1af8cf0238352--7cd5a94fcf6345dab20c06c339547154 7cd5a94fcf6345dab20c06c339547154--acdc474c82f3426191049cd7e17be701 fee164b4932e44c2a8b43b29200072db 7cd5a94fcf6345dab20c06c339547154--fee164b4932e44c2a8b43b29200072db dedc7b46a7864cd1a10694bd94e49d43 fee164b4932e44c2a8b43b29200072db--dedc7b46a7864cd1a10694bd94e49d43 57a2092fa8954ff2b2a9bd980626dcd7 dedc7b46a7864cd1a10694bd94e49d43--57a2092fa8954ff2b2a9bd980626dcd7 dc964cff1dd84d6aaef11d2d51f4863b X 57a2092fa8954ff2b2a9bd980626dcd7--dc964cff1dd84d6aaef11d2d51f4863b dc964cff1dd84d6aaef11d2d51f4863b--83545d11d862453a804de62b86b7d653 6de3704d35c247299d2a1f0d97a086e4 dc964cff1dd84d6aaef11d2d51f4863b--6de3704d35c247299d2a1f0d97a086e4 1588122a937f4039ab1b2f0962ba7b32 6de3704d35c247299d2a1f0d97a086e4--1588122a937f4039ab1b2f0962ba7b32 12bc08519b404e11b79299803e28a80f 1588122a937f4039ab1b2f0962ba7b32--12bc08519b404e11b79299803e28a80f 0dc2788903244c3d80a39a85ad92e4aa X 12bc08519b404e11b79299803e28a80f--0dc2788903244c3d80a39a85ad92e4aa 0dc2788903244c3d80a39a85ad92e4aa--2eefda15583041989edd50b3ebbcf5c3 d6d1962e9a874494a3a68cdabe357701 0dc2788903244c3d80a39a85ad92e4aa--d6d1962e9a874494a3a68cdabe357701 d3137965f1d54dc2914f0add6e19cc0d X d6d1962e9a874494a3a68cdabe357701--d3137965f1d54dc2914f0add6e19cc0d d3137965f1d54dc2914f0add6e19cc0d--421b3fa25f6e4620b06607bc33fb345e 0b725e8200f244ab89abaf23296082a9 d3137965f1d54dc2914f0add6e19cc0d--0b725e8200f244ab89abaf23296082a9 bfd4e78ac413428aaaa0ae31ab0b94df 0b725e8200f244ab89abaf23296082a9--bfd4e78ac413428aaaa0ae31ab0b94df 72eff391098a473888a03fdf07e47479 bfd4e78ac413428aaaa0ae31ab0b94df--72eff391098a473888a03fdf07e47479 a4223bfa784e41c0a56ea5dcd9eff3da X 72eff391098a473888a03fdf07e47479--a4223bfa784e41c0a56ea5dcd9eff3da a4223bfa784e41c0a56ea5dcd9eff3da--0957ce7402854d5ab77adea3bfd9fedd 51d15463dc3342539955d17c7a6166b3 RX(b06) a4223bfa784e41c0a56ea5dcd9eff3da--51d15463dc3342539955d17c7a6166b3 77ff54ede3ad495081b8bfae4058bba5 51d15463dc3342539955d17c7a6166b3--77ff54ede3ad495081b8bfae4058bba5 9c2e20a7078f4e1a93ee88014ebd41ff 77ff54ede3ad495081b8bfae4058bba5--9c2e20a7078f4e1a93ee88014ebd41ff 82ed15e5523b43fa9c2939bb4b8dc204 9c2e20a7078f4e1a93ee88014ebd41ff--82ed15e5523b43fa9c2939bb4b8dc204 ba9998f1970246cd9d51d9a54e085bab 82ed15e5523b43fa9c2939bb4b8dc204--ba9998f1970246cd9d51d9a54e085bab e70f840b17ac4d7c812284b193f48ccc ba9998f1970246cd9d51d9a54e085bab--e70f840b17ac4d7c812284b193f48ccc 9cedbe6f47c747378e410c509f46f051 X e70f840b17ac4d7c812284b193f48ccc--9cedbe6f47c747378e410c509f46f051 9cedbe6f47c747378e410c509f46f051--0d3981beb54c4dbab0672169730c881b de09d81f043a416791b7935dec1e6837 9cedbe6f47c747378e410c509f46f051--de09d81f043a416791b7935dec1e6837 6201fb1b718d4f8ba286c076b3d01a5e de09d81f043a416791b7935dec1e6837--6201fb1b718d4f8ba286c076b3d01a5e 638e54d669ca448fabea47e8b74c740e 6201fb1b718d4f8ba286c076b3d01a5e--638e54d669ca448fabea47e8b74c740e 1186583bcac5435c9922582ed24eda48 X 638e54d669ca448fabea47e8b74c740e--1186583bcac5435c9922582ed24eda48 1186583bcac5435c9922582ed24eda48--debce0aeca264a8a9016c99522068bbf e60aef3050c2413194bccf9625af043c 1186583bcac5435c9922582ed24eda48--e60aef3050c2413194bccf9625af043c 6331a3d6f7464a858438055a254d0737 e60aef3050c2413194bccf9625af043c--6331a3d6f7464a858438055a254d0737 ca44a34f164b43e78cce452134fe7814 6331a3d6f7464a858438055a254d0737--ca44a34f164b43e78cce452134fe7814 bb846d0b58af4ac7a847f61f430c224c ca44a34f164b43e78cce452134fe7814--bb846d0b58af4ac7a847f61f430c224c 69532ba542404c9985a4d6c1baf8f3f2 bb846d0b58af4ac7a847f61f430c224c--69532ba542404c9985a4d6c1baf8f3f2 2b462c5b933b42058877334902401677 69532ba542404c9985a4d6c1baf8f3f2--2b462c5b933b42058877334902401677 b7f03b3ed93c48a8abe0b7756e6bbf7f 2b462c5b933b42058877334902401677--b7f03b3ed93c48a8abe0b7756e6bbf7f 424deb16f73b4d36ba0db9b987b9bdfb b7f03b3ed93c48a8abe0b7756e6bbf7f--424deb16f73b4d36ba0db9b987b9bdfb 6bb422eff3ce4ef68c0f3cb3f98b1935 424deb16f73b4d36ba0db9b987b9bdfb--6bb422eff3ce4ef68c0f3cb3f98b1935 8cf6edabcdc54de79175844b364ccfd6 6bb422eff3ce4ef68c0f3cb3f98b1935--8cf6edabcdc54de79175844b364ccfd6 5a5ea2fc7a3a4255a04213962ab3e566 8cf6edabcdc54de79175844b364ccfd6--5a5ea2fc7a3a4255a04213962ab3e566 6442c751e2a446d9aa392857475445cc 5a5ea2fc7a3a4255a04213962ab3e566--6442c751e2a446d9aa392857475445cc e937fd1de33440a09673645f3b2c5328 6442c751e2a446d9aa392857475445cc--e937fd1de33440a09673645f3b2c5328 47a8aa7ddb1f488fb6f41df083b0044c e937fd1de33440a09673645f3b2c5328--47a8aa7ddb1f488fb6f41df083b0044c f525c6d8107546f0b23e651fd43f06c1 47a8aa7ddb1f488fb6f41df083b0044c--f525c6d8107546f0b23e651fd43f06c1 52a68ae1550d46ae9f4771e5641e7212 f525c6d8107546f0b23e651fd43f06c1--52a68ae1550d46ae9f4771e5641e7212 7da78bbe17ee4273a2cfddfe491a7cca 52a68ae1550d46ae9f4771e5641e7212--7da78bbe17ee4273a2cfddfe491a7cca af360f0535ec43a1a0558197fb5970b0 7da78bbe17ee4273a2cfddfe491a7cca--af360f0535ec43a1a0558197fb5970b0 84324035ab2e4e158492ef20646e89c6 af360f0535ec43a1a0558197fb5970b0--84324035ab2e4e158492ef20646e89c6 0e362de66c9a4971b3eb13e8d1a66aef 84324035ab2e4e158492ef20646e89c6--0e362de66c9a4971b3eb13e8d1a66aef 3fe7cedf1b224bacb265cbc389fca90d 0e362de66c9a4971b3eb13e8d1a66aef--3fe7cedf1b224bacb265cbc389fca90d c5455f5141dc417fbf8e87b0d3a6dfd7 3fe7cedf1b224bacb265cbc389fca90d--c5455f5141dc417fbf8e87b0d3a6dfd7 3cd03ce9d9784cbe9795cce673480d2d c5455f5141dc417fbf8e87b0d3a6dfd7--3cd03ce9d9784cbe9795cce673480d2d 3fb71a6c55494ce89a56b3aeb3632c7e 3cd03ce9d9784cbe9795cce673480d2d--3fb71a6c55494ce89a56b3aeb3632c7e 38bd15649b9b403da4878554a0c67e06 3fb71a6c55494ce89a56b3aeb3632c7e--38bd15649b9b403da4878554a0c67e06 8e59ce3ee57c40d297c85286bac226b7 38bd15649b9b403da4878554a0c67e06--8e59ce3ee57c40d297c85286bac226b7 275aab187ed045fd8719f9eeb4c955ac 8e59ce3ee57c40d297c85286bac226b7--275aab187ed045fd8719f9eeb4c955ac 2a7c2c56d0cf4abe872d6c70d9211e44 275aab187ed045fd8719f9eeb4c955ac--2a7c2c56d0cf4abe872d6c70d9211e44 20f59ec58f2f40ff99d4d740c7fdad7c X 2a7c2c56d0cf4abe872d6c70d9211e44--20f59ec58f2f40ff99d4d740c7fdad7c 20f59ec58f2f40ff99d4d740c7fdad7c--04b0c02eee52479fa270ff23028ee806 d3e5aab3fb0940988478ae14371695dc RZ(-1.0*g1) 20f59ec58f2f40ff99d4d740c7fdad7c--d3e5aab3fb0940988478ae14371695dc 58723b3800d74d97898bf0188cf4a9f7 X d3e5aab3fb0940988478ae14371695dc--58723b3800d74d97898bf0188cf4a9f7 58723b3800d74d97898bf0188cf4a9f7--2373b1e9995e4a51b74d3451fb655025 f8da88854cf542239f0d031d12c150bb 58723b3800d74d97898bf0188cf4a9f7--f8da88854cf542239f0d031d12c150bb 02a00daf4b714ba4a1939e9ad6749a52 f8da88854cf542239f0d031d12c150bb--02a00daf4b714ba4a1939e9ad6749a52 f02f6cc60b2b45da85752a9cc55bd09c 02a00daf4b714ba4a1939e9ad6749a52--f02f6cc60b2b45da85752a9cc55bd09c d244f0dc818340a287530c3935d26b4f f02f6cc60b2b45da85752a9cc55bd09c--d244f0dc818340a287530c3935d26b4f 3cd96e0c60684918929ca7d50acdb295 d244f0dc818340a287530c3935d26b4f--3cd96e0c60684918929ca7d50acdb295 bcc26e4cd10c4cf2be54992f89f30455 3cd96e0c60684918929ca7d50acdb295--bcc26e4cd10c4cf2be54992f89f30455 027466de39ea4e58bb4eddad4048b419 bcc26e4cd10c4cf2be54992f89f30455--027466de39ea4e58bb4eddad4048b419 d927ef76343941fd831c2ad918f00832 027466de39ea4e58bb4eddad4048b419--d927ef76343941fd831c2ad918f00832 2c5eb891db284e2b9398d5814ec7b289 d927ef76343941fd831c2ad918f00832--2c5eb891db284e2b9398d5814ec7b289 577dfcd987f34dc0b24005d83832a36a 2c5eb891db284e2b9398d5814ec7b289--577dfcd987f34dc0b24005d83832a36a 1e9c0a30635b4cdbb04a5b8ab1414edd 577dfcd987f34dc0b24005d83832a36a--1e9c0a30635b4cdbb04a5b8ab1414edd 2869b9cc7a9243e3b6a313adf6f6c252 1e9c0a30635b4cdbb04a5b8ab1414edd--2869b9cc7a9243e3b6a313adf6f6c252 495fdf7ba67d42f787df9b7d91728456 2869b9cc7a9243e3b6a313adf6f6c252--495fdf7ba67d42f787df9b7d91728456 b34a15d852ea4caaa0db029a1dfed09b 495fdf7ba67d42f787df9b7d91728456--b34a15d852ea4caaa0db029a1dfed09b e2dfaa5d1b15469e998b4af575b38eff b34a15d852ea4caaa0db029a1dfed09b--e2dfaa5d1b15469e998b4af575b38eff 44bc0581fedb496a9667463c4e37f063 e2dfaa5d1b15469e998b4af575b38eff--44bc0581fedb496a9667463c4e37f063 3c535207466749e189c07a47fb1947ae 44bc0581fedb496a9667463c4e37f063--3c535207466749e189c07a47fb1947ae 122485273d324abcbcf93749f018d9a2 3c535207466749e189c07a47fb1947ae--122485273d324abcbcf93749f018d9a2 42abe404f32b4f528fa7f529069ecba9 122485273d324abcbcf93749f018d9a2--42abe404f32b4f528fa7f529069ecba9 79f8c7d37c1c4e31813d67a2b29a42dd X 42abe404f32b4f528fa7f529069ecba9--79f8c7d37c1c4e31813d67a2b29a42dd 79f8c7d37c1c4e31813d67a2b29a42dd--b17109df7a434412b8af05411f0a6c31 7fb9dd907a8549cbacddcd7e9fdee323 RZ(-1.0*g1) 79f8c7d37c1c4e31813d67a2b29a42dd--7fb9dd907a8549cbacddcd7e9fdee323 86580b6cf058434ea9e09613b2a028e5 X 7fb9dd907a8549cbacddcd7e9fdee323--86580b6cf058434ea9e09613b2a028e5 86580b6cf058434ea9e09613b2a028e5--156cd9a3d3404d7e98c1cd3e903c8a0c f3aeed5de6c7473faab88681765f0182 86580b6cf058434ea9e09613b2a028e5--f3aeed5de6c7473faab88681765f0182 a2d99223a54b4ccebcf3c76083f18c17 f3aeed5de6c7473faab88681765f0182--a2d99223a54b4ccebcf3c76083f18c17 38cad2bbd65b47908d6fc7e79aeb6711 a2d99223a54b4ccebcf3c76083f18c17--38cad2bbd65b47908d6fc7e79aeb6711 f5b52811a1f6439a919ba7c1fafe6fa4 38cad2bbd65b47908d6fc7e79aeb6711--f5b52811a1f6439a919ba7c1fafe6fa4 fa12d3e057e049cbab8ac29759bfbc85 f5b52811a1f6439a919ba7c1fafe6fa4--fa12d3e057e049cbab8ac29759bfbc85 1e12dd20154d41a18dd10389d5126984 fa12d3e057e049cbab8ac29759bfbc85--1e12dd20154d41a18dd10389d5126984 5250c45abaa247a68600423d68488df2 X 1e12dd20154d41a18dd10389d5126984--5250c45abaa247a68600423d68488df2 5250c45abaa247a68600423d68488df2--e6e068e407044677a9ac4cc1f053be6f 05253e1c051e48ada41439bca1af17c3 5250c45abaa247a68600423d68488df2--05253e1c051e48ada41439bca1af17c3 6a4c39550825431194fc884dcaf9e988 05253e1c051e48ada41439bca1af17c3--6a4c39550825431194fc884dcaf9e988 21216fb26ebb4505a5eb0858116b1739 6a4c39550825431194fc884dcaf9e988--21216fb26ebb4505a5eb0858116b1739 dfddc5a3e96544f79ad29be975424077 X 21216fb26ebb4505a5eb0858116b1739--dfddc5a3e96544f79ad29be975424077 dfddc5a3e96544f79ad29be975424077--b021fb8356354cb7b05baefdbba8313e 202c51c234ee47c19dc569ce58cff0ea dfddc5a3e96544f79ad29be975424077--202c51c234ee47c19dc569ce58cff0ea 13b5dfbf484b42e1bdf3dd5ad2fae0c8 202c51c234ee47c19dc569ce58cff0ea--13b5dfbf484b42e1bdf3dd5ad2fae0c8 240dad2138ac4dca99bf49385f2c320b 13b5dfbf484b42e1bdf3dd5ad2fae0c8--240dad2138ac4dca99bf49385f2c320b 7036cac05d854921be18713f71acf397 240dad2138ac4dca99bf49385f2c320b--7036cac05d854921be18713f71acf397 0b0204905b014f588953502115a35a28 7036cac05d854921be18713f71acf397--0b0204905b014f588953502115a35a28 2a5eadf57df244db814497ad284e5a89 0b0204905b014f588953502115a35a28--2a5eadf57df244db814497ad284e5a89 83f6714fdb8e4eea86f48f5e4c449241 2a5eadf57df244db814497ad284e5a89--83f6714fdb8e4eea86f48f5e4c449241 25cfb5d95deb40db8e46569c6c00b461 83f6714fdb8e4eea86f48f5e4c449241--25cfb5d95deb40db8e46569c6c00b461 6d6415cc2fcb4976b09a450edc35a6e4 25cfb5d95deb40db8e46569c6c00b461--6d6415cc2fcb4976b09a450edc35a6e4 8f2c0e57560c46bc94b919f862a0efa1 6d6415cc2fcb4976b09a450edc35a6e4--8f2c0e57560c46bc94b919f862a0efa1 6d215701230e416fb4fe8b84e0f53f80 8f2c0e57560c46bc94b919f862a0efa1--6d215701230e416fb4fe8b84e0f53f80 e92b673d704b451ba014e05109416a1b 6d215701230e416fb4fe8b84e0f53f80--e92b673d704b451ba014e05109416a1b fc2ac0753c004056bba41b121603fb22 e92b673d704b451ba014e05109416a1b--fc2ac0753c004056bba41b121603fb22 ad53bce4cd8848079578c034a70931ed X fc2ac0753c004056bba41b121603fb22--ad53bce4cd8848079578c034a70931ed ad53bce4cd8848079578c034a70931ed--02949149a95b4b469731e800f0efa4f9 2a5a03c08f194fcd923df97078d00185 RZ(-1.0*g1) ad53bce4cd8848079578c034a70931ed--2a5a03c08f194fcd923df97078d00185 81d2dd0e6c914a29b6df08c56b991e43 X 2a5a03c08f194fcd923df97078d00185--81d2dd0e6c914a29b6df08c56b991e43 81d2dd0e6c914a29b6df08c56b991e43--5edd3ea4525a4ea9b08faedbc5a0db61 0161e6e9493242debc394b9058daa3ea 81d2dd0e6c914a29b6df08c56b991e43--0161e6e9493242debc394b9058daa3ea 9d98cbb34bc943c8bd50cdfe7f0d0101 0161e6e9493242debc394b9058daa3ea--9d98cbb34bc943c8bd50cdfe7f0d0101 086d1a5454654571a596caa6e604bb8b 9d98cbb34bc943c8bd50cdfe7f0d0101--086d1a5454654571a596caa6e604bb8b efe31ef06355492398148eeb139cf8f9 X 086d1a5454654571a596caa6e604bb8b--efe31ef06355492398148eeb139cf8f9 efe31ef06355492398148eeb139cf8f9--1e80dbe5c9a84e15af57216693009212 c7932326a3854514b4c823f3df298da0 efe31ef06355492398148eeb139cf8f9--c7932326a3854514b4c823f3df298da0 90e0e211b0a746ad81b178f4e8e370ea c7932326a3854514b4c823f3df298da0--90e0e211b0a746ad81b178f4e8e370ea 16c6ccf094724c29acc23d649e84bea6 90e0e211b0a746ad81b178f4e8e370ea--16c6ccf094724c29acc23d649e84bea6 5703c11f56264f748704098e0cc671a2 X 16c6ccf094724c29acc23d649e84bea6--5703c11f56264f748704098e0cc671a2 5703c11f56264f748704098e0cc671a2--80ee0bf42e5547b99d56e5caf608b028 235c7b8d90eb44ccac105120a838309e 5703c11f56264f748704098e0cc671a2--235c7b8d90eb44ccac105120a838309e 45713a84042f45e28b2bd3b38eb8ee42 X 235c7b8d90eb44ccac105120a838309e--45713a84042f45e28b2bd3b38eb8ee42 45713a84042f45e28b2bd3b38eb8ee42--4a3b7aacdff7448d979bd570b8fb13a5 a1da67b60fac41cd8ce2bb28d34e9d40 45713a84042f45e28b2bd3b38eb8ee42--a1da67b60fac41cd8ce2bb28d34e9d40 e7da6a4fb58b4013bf01d23cbf476387 a1da67b60fac41cd8ce2bb28d34e9d40--e7da6a4fb58b4013bf01d23cbf476387 b4eb7d1f2f6c4cf4a33cbf8ca41fb510 e7da6a4fb58b4013bf01d23cbf476387--b4eb7d1f2f6c4cf4a33cbf8ca41fb510 8728b776d5344bea9f764686d83e0554 X b4eb7d1f2f6c4cf4a33cbf8ca41fb510--8728b776d5344bea9f764686d83e0554 8728b776d5344bea9f764686d83e0554--257cf66731634d87a2acfaadc6c25428 92e02b71172c41a1926b0597d7b46a48 RX(b16) 8728b776d5344bea9f764686d83e0554--92e02b71172c41a1926b0597d7b46a48 92e02b71172c41a1926b0597d7b46a48--e68c1428835748c48fdb46377318bf4e 015a0b3dfa5b49f99045683c1add4705 1e1be508cc6a4632b1f0427c906a9078 83f42cb3cf5d449697b9525c6ee46b7f--1e1be508cc6a4632b1f0427c906a9078 8d69b685907144be8d7837f3e047af41 1e1be508cc6a4632b1f0427c906a9078--8d69b685907144be8d7837f3e047af41 0ccbe9ed825c4aafa9bb35f4db149905 8d69b685907144be8d7837f3e047af41--0ccbe9ed825c4aafa9bb35f4db149905 c7f0b206166f4b79a7731f742cd412c0 0ccbe9ed825c4aafa9bb35f4db149905--c7f0b206166f4b79a7731f742cd412c0 2c133907848d44699149c14eeea59b37 c7f0b206166f4b79a7731f742cd412c0--2c133907848d44699149c14eeea59b37 7e04b3a906ce423e903ab51437b19ef1 2c133907848d44699149c14eeea59b37--7e04b3a906ce423e903ab51437b19ef1 b5f367047c264b4ca10f3f0237fed786 X 7e04b3a906ce423e903ab51437b19ef1--b5f367047c264b4ca10f3f0237fed786 b5f367047c264b4ca10f3f0237fed786--21cf1573ca384cfbab0a36ee2452f370 6998621e1cff403589c2c5b234f2b47f RZ(1.0*g0) b5f367047c264b4ca10f3f0237fed786--6998621e1cff403589c2c5b234f2b47f 2203d62e5abe410e9a5784ac9250791d X 6998621e1cff403589c2c5b234f2b47f--2203d62e5abe410e9a5784ac9250791d 2203d62e5abe410e9a5784ac9250791d--58fbc9d4d81f4a8b97e1de0b6937e267 cf670e4bd9e04016b831a0fb02f352a7 2203d62e5abe410e9a5784ac9250791d--cf670e4bd9e04016b831a0fb02f352a7 2e8aa23de5684781b52e038e4ae34354 cf670e4bd9e04016b831a0fb02f352a7--2e8aa23de5684781b52e038e4ae34354 a3335da1142b422183deb2c085f2a06c 2e8aa23de5684781b52e038e4ae34354--a3335da1142b422183deb2c085f2a06c ef5c2b06ed724d209eab0f32a64978bf a3335da1142b422183deb2c085f2a06c--ef5c2b06ed724d209eab0f32a64978bf 13e664c970f8442793c83f49a6fbf886 ef5c2b06ed724d209eab0f32a64978bf--13e664c970f8442793c83f49a6fbf886 cc5797c6f2c7445b91208aad907183c3 13e664c970f8442793c83f49a6fbf886--cc5797c6f2c7445b91208aad907183c3 89b9695b6b6341339b965d660a9107f2 cc5797c6f2c7445b91208aad907183c3--89b9695b6b6341339b965d660a9107f2 4b77105030e34620a81abad2e0242abe 89b9695b6b6341339b965d660a9107f2--4b77105030e34620a81abad2e0242abe 046cfbe9ca764b878a49f68101ac04b4 4b77105030e34620a81abad2e0242abe--046cfbe9ca764b878a49f68101ac04b4 18e003f7a84440268f4cec010dd4c218 046cfbe9ca764b878a49f68101ac04b4--18e003f7a84440268f4cec010dd4c218 1a2c05887b664d05957cf19b94707ee9 18e003f7a84440268f4cec010dd4c218--1a2c05887b664d05957cf19b94707ee9 464255987efe4147b71ae39124ac2844 1a2c05887b664d05957cf19b94707ee9--464255987efe4147b71ae39124ac2844 9455d5f67f804ec0baac49e5062be807 464255987efe4147b71ae39124ac2844--9455d5f67f804ec0baac49e5062be807 8ea547786e1840c89f2f1ede37981655 9455d5f67f804ec0baac49e5062be807--8ea547786e1840c89f2f1ede37981655 f6708b01abe54986873953e9aea8f4db 8ea547786e1840c89f2f1ede37981655--f6708b01abe54986873953e9aea8f4db 8ef46e76da5a4e21a3df1189d1b56a3d f6708b01abe54986873953e9aea8f4db--8ef46e76da5a4e21a3df1189d1b56a3d 34e07fbb0e4849e69b8d0c57dda99aa2 8ef46e76da5a4e21a3df1189d1b56a3d--34e07fbb0e4849e69b8d0c57dda99aa2 ef82d2c5ea4f46b29ad23f06453bd687 34e07fbb0e4849e69b8d0c57dda99aa2--ef82d2c5ea4f46b29ad23f06453bd687 5c546773e4d64821b252aac29718f792 ef82d2c5ea4f46b29ad23f06453bd687--5c546773e4d64821b252aac29718f792 99c83fbe47c840a7a3837c39aa936be2 5c546773e4d64821b252aac29718f792--99c83fbe47c840a7a3837c39aa936be2 3bbf3da9bfc047a8a49ac1097c53cfa2 99c83fbe47c840a7a3837c39aa936be2--3bbf3da9bfc047a8a49ac1097c53cfa2 a964fae2287d4e0cb7e0870a16061e9c 3bbf3da9bfc047a8a49ac1097c53cfa2--a964fae2287d4e0cb7e0870a16061e9c 181a696311844c4ea44b8ef9b9f9e7ee a964fae2287d4e0cb7e0870a16061e9c--181a696311844c4ea44b8ef9b9f9e7ee 4ebded0435c24815afc6bd0fecd86d75 181a696311844c4ea44b8ef9b9f9e7ee--4ebded0435c24815afc6bd0fecd86d75 7811d18aa5784042985743fda340e3c3 4ebded0435c24815afc6bd0fecd86d75--7811d18aa5784042985743fda340e3c3 41e1f72b419146d6bfb985a38c0e1869 7811d18aa5784042985743fda340e3c3--41e1f72b419146d6bfb985a38c0e1869 8544a8cd847447659219a7a702a3d7c1 41e1f72b419146d6bfb985a38c0e1869--8544a8cd847447659219a7a702a3d7c1 a54fdbf7f489490cb477f5e06ea271d2 8544a8cd847447659219a7a702a3d7c1--a54fdbf7f489490cb477f5e06ea271d2 76f3d25b179c4b42b8bef349bc9a1c93 a54fdbf7f489490cb477f5e06ea271d2--76f3d25b179c4b42b8bef349bc9a1c93 0cf78282bf334605978504baa71e3f1f 76f3d25b179c4b42b8bef349bc9a1c93--0cf78282bf334605978504baa71e3f1f b8636c284fc24d7eb3e858a92c903e51 0cf78282bf334605978504baa71e3f1f--b8636c284fc24d7eb3e858a92c903e51 2116d375778b45bbb4801093b1d0c95a b8636c284fc24d7eb3e858a92c903e51--2116d375778b45bbb4801093b1d0c95a c46995b1319c469c8fdcc87a58297326 2116d375778b45bbb4801093b1d0c95a--c46995b1319c469c8fdcc87a58297326 4232d269afa64c8689cd003287d36b86 c46995b1319c469c8fdcc87a58297326--4232d269afa64c8689cd003287d36b86 6dc5e3d2dad34c52987d37a2f5d87f5a 4232d269afa64c8689cd003287d36b86--6dc5e3d2dad34c52987d37a2f5d87f5a 1b2da77bb60945d0bfc60c2fca6db8cd 6dc5e3d2dad34c52987d37a2f5d87f5a--1b2da77bb60945d0bfc60c2fca6db8cd a713e701ffee4c009b9a70dfd19098c7 1b2da77bb60945d0bfc60c2fca6db8cd--a713e701ffee4c009b9a70dfd19098c7 db3a21a3dcdf4c3faca31d9efaa7bf4a a713e701ffee4c009b9a70dfd19098c7--db3a21a3dcdf4c3faca31d9efaa7bf4a 1895c0f373254a91a377ac729c163e4d db3a21a3dcdf4c3faca31d9efaa7bf4a--1895c0f373254a91a377ac729c163e4d 6e57011199fa417da1a3c6817f8d04bb 1895c0f373254a91a377ac729c163e4d--6e57011199fa417da1a3c6817f8d04bb f87981d9759148b7b9f8d2e350d48d76 6e57011199fa417da1a3c6817f8d04bb--f87981d9759148b7b9f8d2e350d48d76 993b1b3b3a6446cc91d12968922d4ae4 f87981d9759148b7b9f8d2e350d48d76--993b1b3b3a6446cc91d12968922d4ae4 737806a53a734f558ccc8819e27d2850 993b1b3b3a6446cc91d12968922d4ae4--737806a53a734f558ccc8819e27d2850 b496826c9b5e49e0b6d1d8c30c525da1 737806a53a734f558ccc8819e27d2850--b496826c9b5e49e0b6d1d8c30c525da1 b39e984ce3e340e09073c94f74bf76a3 b496826c9b5e49e0b6d1d8c30c525da1--b39e984ce3e340e09073c94f74bf76a3 2693b4bc628f4ea591b3713635b33bca b39e984ce3e340e09073c94f74bf76a3--2693b4bc628f4ea591b3713635b33bca c24eb51909c34c21be858fed142535d9 2693b4bc628f4ea591b3713635b33bca--c24eb51909c34c21be858fed142535d9 b973ff501543488e9b4b11e98bc989e9 c24eb51909c34c21be858fed142535d9--b973ff501543488e9b4b11e98bc989e9 297e33c6a4c44943ba4ab870734c44b1 b973ff501543488e9b4b11e98bc989e9--297e33c6a4c44943ba4ab870734c44b1 8d7e19fd33b241dd8f17da161454e79a 297e33c6a4c44943ba4ab870734c44b1--8d7e19fd33b241dd8f17da161454e79a f83c5f49d445498fb5762ec614dfd36f 8d7e19fd33b241dd8f17da161454e79a--f83c5f49d445498fb5762ec614dfd36f e4ff141e24144d64b33421f5e3edeae1 f83c5f49d445498fb5762ec614dfd36f--e4ff141e24144d64b33421f5e3edeae1 7ed0d893381e4059a65ebf0c378fbd78 e4ff141e24144d64b33421f5e3edeae1--7ed0d893381e4059a65ebf0c378fbd78 3fc52192a81342759fc1e22d3e056d80 7ed0d893381e4059a65ebf0c378fbd78--3fc52192a81342759fc1e22d3e056d80 c4b371b767ae457aab35bd9274ca11ec 3fc52192a81342759fc1e22d3e056d80--c4b371b767ae457aab35bd9274ca11ec febba945de8447f4b28c7dbf8355ac78 c4b371b767ae457aab35bd9274ca11ec--febba945de8447f4b28c7dbf8355ac78 ed280b6d07d94b508f234edcc296e7cf febba945de8447f4b28c7dbf8355ac78--ed280b6d07d94b508f234edcc296e7cf 8b245153c5ac4354bf12627dbba958d2 ed280b6d07d94b508f234edcc296e7cf--8b245153c5ac4354bf12627dbba958d2 37890706c22f4428a3189a145a3fc292 8b245153c5ac4354bf12627dbba958d2--37890706c22f4428a3189a145a3fc292 1e8c76f414944a76b8c57df5c46c2bc1 37890706c22f4428a3189a145a3fc292--1e8c76f414944a76b8c57df5c46c2bc1 8d4765e2ffc043268f67aefa4635fd02 1e8c76f414944a76b8c57df5c46c2bc1--8d4765e2ffc043268f67aefa4635fd02 ed9b46f366bc49d69efdcf18dc91e46e X 8d4765e2ffc043268f67aefa4635fd02--ed9b46f366bc49d69efdcf18dc91e46e ed9b46f366bc49d69efdcf18dc91e46e--463fe4c602594d3c9b3346b300058179 c3755964bdd148bb8fc3e72a624f1b90 RZ(-1.0*g0) ed9b46f366bc49d69efdcf18dc91e46e--c3755964bdd148bb8fc3e72a624f1b90 0b57133d74974671a58eac72dd80916d X c3755964bdd148bb8fc3e72a624f1b90--0b57133d74974671a58eac72dd80916d 0b57133d74974671a58eac72dd80916d--fd4b0a5de5c64562b3a97371813a804f a377b4fe3c3a424194ba7cbbbd5d10d6 0b57133d74974671a58eac72dd80916d--a377b4fe3c3a424194ba7cbbbd5d10d6 fd955d9cdf49423b920f3899564334c6 a377b4fe3c3a424194ba7cbbbd5d10d6--fd955d9cdf49423b920f3899564334c6 bb5dcbb9693a4b649f41fb9f9e5f6967 fd955d9cdf49423b920f3899564334c6--bb5dcbb9693a4b649f41fb9f9e5f6967 9725d12b759b47cf9930bec8f48a305b bb5dcbb9693a4b649f41fb9f9e5f6967--9725d12b759b47cf9930bec8f48a305b a648d101723f49b2a97a2e71f642d39f 9725d12b759b47cf9930bec8f48a305b--a648d101723f49b2a97a2e71f642d39f 607fb3dc63c6481295332d91f57df972 a648d101723f49b2a97a2e71f642d39f--607fb3dc63c6481295332d91f57df972 01d368f8ec1f4e7fa11ab27e8c3063be 607fb3dc63c6481295332d91f57df972--01d368f8ec1f4e7fa11ab27e8c3063be 1a58621b84c54f43a89f27c0b43a01ab 01d368f8ec1f4e7fa11ab27e8c3063be--1a58621b84c54f43a89f27c0b43a01ab 90f98e791e72433491eb6eaf2f9a43b1 1a58621b84c54f43a89f27c0b43a01ab--90f98e791e72433491eb6eaf2f9a43b1 7c612104f99f4811b357666b74c5fff0 90f98e791e72433491eb6eaf2f9a43b1--7c612104f99f4811b357666b74c5fff0 4497fd4c77d343c4908689cf9e189052 7c612104f99f4811b357666b74c5fff0--4497fd4c77d343c4908689cf9e189052 3f99f73103a9400b935d718b8c43dfad 4497fd4c77d343c4908689cf9e189052--3f99f73103a9400b935d718b8c43dfad b40cebb84ba247fbb5b78451097cd045 3f99f73103a9400b935d718b8c43dfad--b40cebb84ba247fbb5b78451097cd045 d3ea9034653f4d609807c653ca499724 b40cebb84ba247fbb5b78451097cd045--d3ea9034653f4d609807c653ca499724 5b77d80f898644d7bdb0487cc120a585 d3ea9034653f4d609807c653ca499724--5b77d80f898644d7bdb0487cc120a585 513eb8d34f794700ac380c43c59f383f 5b77d80f898644d7bdb0487cc120a585--513eb8d34f794700ac380c43c59f383f 005950378ecf49c8b4da3ebe419a725f 513eb8d34f794700ac380c43c59f383f--005950378ecf49c8b4da3ebe419a725f 6be467b8cba44a6393c214ea1e607848 005950378ecf49c8b4da3ebe419a725f--6be467b8cba44a6393c214ea1e607848 83f4a4dd106648a5b16dea91bba7e2ee 6be467b8cba44a6393c214ea1e607848--83f4a4dd106648a5b16dea91bba7e2ee 6622bc2dfc8d42a59105f220cd701c67 83f4a4dd106648a5b16dea91bba7e2ee--6622bc2dfc8d42a59105f220cd701c67 0a798256ee7448b3a2016af31d1c10bb 6622bc2dfc8d42a59105f220cd701c67--0a798256ee7448b3a2016af31d1c10bb dfd76d2ad4004a5ea748f1fbfa69e892 X 0a798256ee7448b3a2016af31d1c10bb--dfd76d2ad4004a5ea748f1fbfa69e892 dfd76d2ad4004a5ea748f1fbfa69e892--6de3704d35c247299d2a1f0d97a086e4 70742a6fa7fd49f78263759e6b1a3d12 RZ(-1.0*g0) dfd76d2ad4004a5ea748f1fbfa69e892--70742a6fa7fd49f78263759e6b1a3d12 cf24df091d124e0eb7c7f9c309563b87 X 70742a6fa7fd49f78263759e6b1a3d12--cf24df091d124e0eb7c7f9c309563b87 cf24df091d124e0eb7c7f9c309563b87--12bc08519b404e11b79299803e28a80f 9bf1726ff3174b04a383b9f63037355d cf24df091d124e0eb7c7f9c309563b87--9bf1726ff3174b04a383b9f63037355d e5155b1d2938431db162acde2291182e 9bf1726ff3174b04a383b9f63037355d--e5155b1d2938431db162acde2291182e e4b6363fdaaf4f6f97297ac74be9956f e5155b1d2938431db162acde2291182e--e4b6363fdaaf4f6f97297ac74be9956f d7ca6244acd94024896627e252169b85 X e4b6363fdaaf4f6f97297ac74be9956f--d7ca6244acd94024896627e252169b85 d7ca6244acd94024896627e252169b85--0b725e8200f244ab89abaf23296082a9 380adba26e254e5c9d19204b5460d1a7 RZ(-1.0*g0) d7ca6244acd94024896627e252169b85--380adba26e254e5c9d19204b5460d1a7 04455e7321614cd9aab30f7a326c92ea X 380adba26e254e5c9d19204b5460d1a7--04455e7321614cd9aab30f7a326c92ea 04455e7321614cd9aab30f7a326c92ea--72eff391098a473888a03fdf07e47479 4d27b1d9bc41414e859726dab18c2eff 04455e7321614cd9aab30f7a326c92ea--4d27b1d9bc41414e859726dab18c2eff 6c8678a855ba4857b67efc2cbc2ce0bc RX(b07) 4d27b1d9bc41414e859726dab18c2eff--6c8678a855ba4857b67efc2cbc2ce0bc 2da2efeea865489485647af04439b366 6c8678a855ba4857b67efc2cbc2ce0bc--2da2efeea865489485647af04439b366 6131db5c40204adea0ef871a37148be3 2da2efeea865489485647af04439b366--6131db5c40204adea0ef871a37148be3 6b4029967bd44e4b9f574bd8c30e6eac 6131db5c40204adea0ef871a37148be3--6b4029967bd44e4b9f574bd8c30e6eac 2343757fba9f43f9a8c6692d74e3a8ca 6b4029967bd44e4b9f574bd8c30e6eac--2343757fba9f43f9a8c6692d74e3a8ca 9ff0b70cef27402283c9118109bdb56a 2343757fba9f43f9a8c6692d74e3a8ca--9ff0b70cef27402283c9118109bdb56a eac24aafbd6f400081e3429bcc7e13a0 9ff0b70cef27402283c9118109bdb56a--eac24aafbd6f400081e3429bcc7e13a0 74038972e0ab4583bf31fd70b6bc23d5 X eac24aafbd6f400081e3429bcc7e13a0--74038972e0ab4583bf31fd70b6bc23d5 74038972e0ab4583bf31fd70b6bc23d5--de09d81f043a416791b7935dec1e6837 a774edb8b95e4e8d81ceb5bf92efd2e3 RZ(1.0*g1) 74038972e0ab4583bf31fd70b6bc23d5--a774edb8b95e4e8d81ceb5bf92efd2e3 6e7d069fa0494060924364b7a8e81b02 X a774edb8b95e4e8d81ceb5bf92efd2e3--6e7d069fa0494060924364b7a8e81b02 6e7d069fa0494060924364b7a8e81b02--638e54d669ca448fabea47e8b74c740e 5f6972b886ec4c9f9619f637dd148a67 6e7d069fa0494060924364b7a8e81b02--5f6972b886ec4c9f9619f637dd148a67 a9c05f5bacac41a189cbc59f574ba7d3 5f6972b886ec4c9f9619f637dd148a67--a9c05f5bacac41a189cbc59f574ba7d3 462521bbd52b420e971b1843a90f86f7 a9c05f5bacac41a189cbc59f574ba7d3--462521bbd52b420e971b1843a90f86f7 295ff7c610194ecbae1117fc377707b4 462521bbd52b420e971b1843a90f86f7--295ff7c610194ecbae1117fc377707b4 927b0c53cdb24ad2bb03dbe6db752800 295ff7c610194ecbae1117fc377707b4--927b0c53cdb24ad2bb03dbe6db752800 dedafb9f182f41f184a3c14027259adb 927b0c53cdb24ad2bb03dbe6db752800--dedafb9f182f41f184a3c14027259adb a5a6de128d1b40c38e632a610e0147bb dedafb9f182f41f184a3c14027259adb--a5a6de128d1b40c38e632a610e0147bb 03a23380713a4576b4402ad7f3a6e4ff a5a6de128d1b40c38e632a610e0147bb--03a23380713a4576b4402ad7f3a6e4ff 957a23a1273b4558a9bff930dbbc3e31 03a23380713a4576b4402ad7f3a6e4ff--957a23a1273b4558a9bff930dbbc3e31 c374163369f0488d9da8dd13c02f576b 957a23a1273b4558a9bff930dbbc3e31--c374163369f0488d9da8dd13c02f576b 650bb040370a43aabc10d02b32390f08 c374163369f0488d9da8dd13c02f576b--650bb040370a43aabc10d02b32390f08 622d54bcc5e7497da3dbc96f64cdf2d1 650bb040370a43aabc10d02b32390f08--622d54bcc5e7497da3dbc96f64cdf2d1 267c1549801e49a19129f33832615123 622d54bcc5e7497da3dbc96f64cdf2d1--267c1549801e49a19129f33832615123 54983a0f2e314c26b36dccb285ee9dd8 267c1549801e49a19129f33832615123--54983a0f2e314c26b36dccb285ee9dd8 42842060203d4644b083742037e60c39 54983a0f2e314c26b36dccb285ee9dd8--42842060203d4644b083742037e60c39 1a2bc69d835643ceaa457be9e38f2002 42842060203d4644b083742037e60c39--1a2bc69d835643ceaa457be9e38f2002 82a190f283ce4d2abd242d0b41967f98 1a2bc69d835643ceaa457be9e38f2002--82a190f283ce4d2abd242d0b41967f98 43bb2951971c4e649e5931fff256548d 82a190f283ce4d2abd242d0b41967f98--43bb2951971c4e649e5931fff256548d 49c7153bd4ea4c888795dea42f87c6ec 43bb2951971c4e649e5931fff256548d--49c7153bd4ea4c888795dea42f87c6ec dfa2f5ced47b46dbab2bd63aa4cf4b6d 49c7153bd4ea4c888795dea42f87c6ec--dfa2f5ced47b46dbab2bd63aa4cf4b6d 4dc1c3d505c14aefbcd1fa5457b96aea dfa2f5ced47b46dbab2bd63aa4cf4b6d--4dc1c3d505c14aefbcd1fa5457b96aea 6d15dd11ced842759e94bd6998c26ac6 4dc1c3d505c14aefbcd1fa5457b96aea--6d15dd11ced842759e94bd6998c26ac6 9457c68676394dca9a97bc2fa18c15c4 6d15dd11ced842759e94bd6998c26ac6--9457c68676394dca9a97bc2fa18c15c4 089b985b8a924a27b2c90b8d1bc37ee6 9457c68676394dca9a97bc2fa18c15c4--089b985b8a924a27b2c90b8d1bc37ee6 114fdb212313482bb473da7df651b90b 089b985b8a924a27b2c90b8d1bc37ee6--114fdb212313482bb473da7df651b90b a9122513b2084f9bb9bd63493248339b 114fdb212313482bb473da7df651b90b--a9122513b2084f9bb9bd63493248339b 21b6e310fe08436f9e6ec7202d092cbe a9122513b2084f9bb9bd63493248339b--21b6e310fe08436f9e6ec7202d092cbe 843a8f75a8ca4b3da315a40e805ecf1a 21b6e310fe08436f9e6ec7202d092cbe--843a8f75a8ca4b3da315a40e805ecf1a e372712f831046ec846e6222f767c127 843a8f75a8ca4b3da315a40e805ecf1a--e372712f831046ec846e6222f767c127 79af3da3e09e47a58208c5374bc36eab e372712f831046ec846e6222f767c127--79af3da3e09e47a58208c5374bc36eab 0455ab49e06541ae9ee0fb34fbb2ad86 79af3da3e09e47a58208c5374bc36eab--0455ab49e06541ae9ee0fb34fbb2ad86 901dd28728b34f0ba74c0ad4fd82d9f8 0455ab49e06541ae9ee0fb34fbb2ad86--901dd28728b34f0ba74c0ad4fd82d9f8 ea49ebfb494e4e4cb55d538dde9cc7fa 901dd28728b34f0ba74c0ad4fd82d9f8--ea49ebfb494e4e4cb55d538dde9cc7fa 02eabd9b25f34dcf806686528e134676 ea49ebfb494e4e4cb55d538dde9cc7fa--02eabd9b25f34dcf806686528e134676 4e1d6510ad394b579f230fbd1a0070f5 02eabd9b25f34dcf806686528e134676--4e1d6510ad394b579f230fbd1a0070f5 8355b0a1dacf46ffbf3c972ca989035d 4e1d6510ad394b579f230fbd1a0070f5--8355b0a1dacf46ffbf3c972ca989035d 33c6e912c69e48b19b47ad8edb2bc428 8355b0a1dacf46ffbf3c972ca989035d--33c6e912c69e48b19b47ad8edb2bc428 4b7b638eb4e545729fe29002aab1b89a 33c6e912c69e48b19b47ad8edb2bc428--4b7b638eb4e545729fe29002aab1b89a c7186ecda57547d6b14f10631fc68f35 4b7b638eb4e545729fe29002aab1b89a--c7186ecda57547d6b14f10631fc68f35 7d6d830e50d24f1fbfe72332bb5e37bc c7186ecda57547d6b14f10631fc68f35--7d6d830e50d24f1fbfe72332bb5e37bc aa48a1278733417b9648002379ccedcb 7d6d830e50d24f1fbfe72332bb5e37bc--aa48a1278733417b9648002379ccedcb 6980562898a94aafa6e26d6a238d9a9e aa48a1278733417b9648002379ccedcb--6980562898a94aafa6e26d6a238d9a9e d9f4b8c4b38d4870a170fe3de8f2c881 6980562898a94aafa6e26d6a238d9a9e--d9f4b8c4b38d4870a170fe3de8f2c881 a3aef8ab322f47b99333e79ea4790fed d9f4b8c4b38d4870a170fe3de8f2c881--a3aef8ab322f47b99333e79ea4790fed ea83adee91f3490f9dd5c7d05adaafef a3aef8ab322f47b99333e79ea4790fed--ea83adee91f3490f9dd5c7d05adaafef 21bada36990c466eb253c42b1b38a8d4 ea83adee91f3490f9dd5c7d05adaafef--21bada36990c466eb253c42b1b38a8d4 89d6eb12f81449a3aeb76f8c3659c028 21bada36990c466eb253c42b1b38a8d4--89d6eb12f81449a3aeb76f8c3659c028 9999e94f3dd04866b1fc413f428a7b44 89d6eb12f81449a3aeb76f8c3659c028--9999e94f3dd04866b1fc413f428a7b44 e1cac71b37514f84aabd95d1e20df3b8 9999e94f3dd04866b1fc413f428a7b44--e1cac71b37514f84aabd95d1e20df3b8 a8890fd05a3e429392943a44402bb2b0 e1cac71b37514f84aabd95d1e20df3b8--a8890fd05a3e429392943a44402bb2b0 a4f340d968494f5793a6b2f64c15ad94 a8890fd05a3e429392943a44402bb2b0--a4f340d968494f5793a6b2f64c15ad94 8afa6b252571419890bd484e86113285 a4f340d968494f5793a6b2f64c15ad94--8afa6b252571419890bd484e86113285 d56ac2fd40a142f98fa3108ae4843319 8afa6b252571419890bd484e86113285--d56ac2fd40a142f98fa3108ae4843319 beabcf7555634810acbc67c573d2d0f5 d56ac2fd40a142f98fa3108ae4843319--beabcf7555634810acbc67c573d2d0f5 6248524c0d844d2987f63b479f8761ae beabcf7555634810acbc67c573d2d0f5--6248524c0d844d2987f63b479f8761ae a3b7d27c2e9849dfb9af06a22610ef08 6248524c0d844d2987f63b479f8761ae--a3b7d27c2e9849dfb9af06a22610ef08 671b63b2d9aa4b85bff52fa5af0ab4cc a3b7d27c2e9849dfb9af06a22610ef08--671b63b2d9aa4b85bff52fa5af0ab4cc dc2b9faf79f04d45819c93b880f34755 671b63b2d9aa4b85bff52fa5af0ab4cc--dc2b9faf79f04d45819c93b880f34755 0411c420394c4ae980dbfed498611b05 dc2b9faf79f04d45819c93b880f34755--0411c420394c4ae980dbfed498611b05 547ed87c4fee4c6c839e1ff5e6d25e32 0411c420394c4ae980dbfed498611b05--547ed87c4fee4c6c839e1ff5e6d25e32 47fed90720d946f28a0f35f89847c7b3 547ed87c4fee4c6c839e1ff5e6d25e32--47fed90720d946f28a0f35f89847c7b3 739802f73235496389de54693034d811 X 47fed90720d946f28a0f35f89847c7b3--739802f73235496389de54693034d811 739802f73235496389de54693034d811--05253e1c051e48ada41439bca1af17c3 1156171bbf784015a61a9ed7f050398e RZ(-1.0*g1) 739802f73235496389de54693034d811--1156171bbf784015a61a9ed7f050398e d4e43b399d1d45109b28a2f5eb5b14e5 X 1156171bbf784015a61a9ed7f050398e--d4e43b399d1d45109b28a2f5eb5b14e5 d4e43b399d1d45109b28a2f5eb5b14e5--21216fb26ebb4505a5eb0858116b1739 1a560df2b60f4c6494795744e4a52b71 d4e43b399d1d45109b28a2f5eb5b14e5--1a560df2b60f4c6494795744e4a52b71 50f9ce2021bb4dea9f0858296edf2c00 1a560df2b60f4c6494795744e4a52b71--50f9ce2021bb4dea9f0858296edf2c00 c61ab997438e4a8bb47c9e712eacb69a 50f9ce2021bb4dea9f0858296edf2c00--c61ab997438e4a8bb47c9e712eacb69a 10b0e5283d6d43a0b0374d2d0509c9f1 c61ab997438e4a8bb47c9e712eacb69a--10b0e5283d6d43a0b0374d2d0509c9f1 5bf65095990548bc98d761ffdc4cd6d8 10b0e5283d6d43a0b0374d2d0509c9f1--5bf65095990548bc98d761ffdc4cd6d8 b828e877a0624697a900f3ce9a457a5a 5bf65095990548bc98d761ffdc4cd6d8--b828e877a0624697a900f3ce9a457a5a 22f546afb1ea4fbdb7cd780e928f17e8 b828e877a0624697a900f3ce9a457a5a--22f546afb1ea4fbdb7cd780e928f17e8 09c2956557214a6bbd00f07b27b75328 22f546afb1ea4fbdb7cd780e928f17e8--09c2956557214a6bbd00f07b27b75328 dc5eca9e4d794343a6c976966e99a65c 09c2956557214a6bbd00f07b27b75328--dc5eca9e4d794343a6c976966e99a65c 3134333beb46470d801dbf8ae71216c3 dc5eca9e4d794343a6c976966e99a65c--3134333beb46470d801dbf8ae71216c3 3be8703f74c2485ea25b26ae6e3b0099 3134333beb46470d801dbf8ae71216c3--3be8703f74c2485ea25b26ae6e3b0099 590f3359201040b4bbdadb02e6375357 3be8703f74c2485ea25b26ae6e3b0099--590f3359201040b4bbdadb02e6375357 65bd3e3d9bc54c5483b19fbf68518cc5 590f3359201040b4bbdadb02e6375357--65bd3e3d9bc54c5483b19fbf68518cc5 d32acd9a81b14880aad665371001c37f 65bd3e3d9bc54c5483b19fbf68518cc5--d32acd9a81b14880aad665371001c37f 69c4e537c03c491c9cb7ff3300512d12 d32acd9a81b14880aad665371001c37f--69c4e537c03c491c9cb7ff3300512d12 edefb66614d74fbbbf400027508602f9 69c4e537c03c491c9cb7ff3300512d12--edefb66614d74fbbbf400027508602f9 1a47026ff1ac4293a1265783570a6f47 edefb66614d74fbbbf400027508602f9--1a47026ff1ac4293a1265783570a6f47 701658f1400946a88dda79191d197ef9 1a47026ff1ac4293a1265783570a6f47--701658f1400946a88dda79191d197ef9 af614c785db54c7fa70dd8b4b7c6cd16 701658f1400946a88dda79191d197ef9--af614c785db54c7fa70dd8b4b7c6cd16 5624358a96274bb7bf0bc84f05b81c66 af614c785db54c7fa70dd8b4b7c6cd16--5624358a96274bb7bf0bc84f05b81c66 cf05c62c4be4483bb12e9017331b79c1 5624358a96274bb7bf0bc84f05b81c66--cf05c62c4be4483bb12e9017331b79c1 a6cee194aabe40dba896cb7dacae2c50 X cf05c62c4be4483bb12e9017331b79c1--a6cee194aabe40dba896cb7dacae2c50 a6cee194aabe40dba896cb7dacae2c50--c7932326a3854514b4c823f3df298da0 9f73278740b1489d87b474a5858f1e8e RZ(-1.0*g1) a6cee194aabe40dba896cb7dacae2c50--9f73278740b1489d87b474a5858f1e8e 6ebea6b45a844981b856439e4e85dab1 X 9f73278740b1489d87b474a5858f1e8e--6ebea6b45a844981b856439e4e85dab1 6ebea6b45a844981b856439e4e85dab1--16c6ccf094724c29acc23d649e84bea6 9e88b8f8b92047f0b24d1ca1a90d02e6 6ebea6b45a844981b856439e4e85dab1--9e88b8f8b92047f0b24d1ca1a90d02e6 8edaa4dec21643bf9b0e842f921d16e1 9e88b8f8b92047f0b24d1ca1a90d02e6--8edaa4dec21643bf9b0e842f921d16e1 bfca67ede60a4783867cf375324b6f84 8edaa4dec21643bf9b0e842f921d16e1--bfca67ede60a4783867cf375324b6f84 42ca7197a16a4fb3b1f06bfe8cff1d33 X bfca67ede60a4783867cf375324b6f84--42ca7197a16a4fb3b1f06bfe8cff1d33 42ca7197a16a4fb3b1f06bfe8cff1d33--a1da67b60fac41cd8ce2bb28d34e9d40 0497a43cc31f4720beaef5cf78a958b5 RZ(-1.0*g1) 42ca7197a16a4fb3b1f06bfe8cff1d33--0497a43cc31f4720beaef5cf78a958b5 c4bfad2859af488e8c42d2eb302a6467 X 0497a43cc31f4720beaef5cf78a958b5--c4bfad2859af488e8c42d2eb302a6467 c4bfad2859af488e8c42d2eb302a6467--b4eb7d1f2f6c4cf4a33cbf8ca41fb510 f3c57da3789849d8bca824e9e36032d3 c4bfad2859af488e8c42d2eb302a6467--f3c57da3789849d8bca824e9e36032d3 011cfff615f04a28be962933ade78657 RX(b17) f3c57da3789849d8bca824e9e36032d3--011cfff615f04a28be962933ade78657 011cfff615f04a28be962933ade78657--015a0b3dfa5b49f99045683c1add4705"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\ntorch.manual_seed(seed)\ndef loss_function(_model: QuantumModel):\nexpval_ops = _model.expectation().squeeze()\n# this corresponds to the MaxCut cost by definition\n# with negative sign in front to perform maximization\nexpval = 0.0\nfor val in expval_ops:\nexpval += 0.5 * (1 - val)\nreturn -1.0 * expval\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n# train the model\nn_epochs = 100\nlr = 1.0\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_function(model)\nloss.backward()\noptimizer.step()\nif (i+1) % (n_epochs // 10) == 0:\nprint(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -3.9995295369645705\nMaxCut cost at iteration 10: 11.484621229236241\nMaxCut cost at iteration 20: 11.97787206647239\nMaxCut cost at iteration 30: 11.998403414806697\nMaxCut cost at iteration 40: 11.995416673898124\nMaxCut cost at iteration 50: 11.997710050922034\nMaxCut cost at iteration 60: 11.999626902474224\nMaxCut cost at iteration 70: 11.999883561522937\nMaxCut cost at iteration 80: 11.999924942323913\nMaxCut cost at iteration 90: 11.99994328254055\nMaxCut cost at iteration 100: 11.999957002714279\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\ncolors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\nlabels[node] = \"A\" if int(b) == 0 else \"B\"\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 10001110  2023-10-17T16:39:56.412778 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\ndef qcl_training_data(\ndomain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\nstart, end = domain\nx_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\ny_rand = torch.sin(x_rand)\nreturn x_rand, y_rand\nx, y = qcl_training_data()\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\nn_qubits = 4\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n[0.1315],\n[0.2424],\n[0.1552],\n[0.1592],\n[0.2063],\n[0.1899],\n[0.2208],\n[0.2472],\n[0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\nfor i in range(n_epochs):\noptimizer.zero_grad()\n# given a `n_batch` number of input points and a `n_observables`\n# number of input observables to measure, the QNN returns\n# an output of the following shape: [n_batch x n_observables]\n# given that there is only one observable, a squeeze is applied to get\n# a 1-dimensional tensor\nloss = mse_loss(model(values=x_train).squeeze(), y_train)\nloss.backward()\noptimizer.step()\nif (i+1) % 20 == 0:\nprint(f\"Epoch {i+1} - Loss: {loss.item()}\")\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.006756732932883128\nEpoch 40 - Loss: 0.0013178262682414356\nEpoch 60 - Loss: 0.00024411275385789364\nEpoch 80 - Loss: 1.810927009147257e-05\nEpoch 100 - Loss: 3.344354751233859e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\ny_pred = model({\"phi\": x_test})\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-10-17T16:40:03.447535 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_tools/","title":"Tools for quantum machine learning","text":"<p>Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning</li> <li>a set of tools for optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/qml_tools/#quantum-machine-learning-constructors","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_tools/#feature-maps","title":"Feature maps","text":"<p>A few feature maps are directly available for loading classical data into quantum circuits by encoding them into gate rotation angles.</p> <pre><code>from qadence import feature_map\nn_qubits = 3\nfm = feature_map(n_qubits, fm_type=\"fourier\")\nfm = feature_map(n_qubits, fm_type=\"chebyshev\")\nfm = feature_map(n_qubits, fm_type=\"tower\")\n</code></pre> <pre><code>Fourier = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nChebyshev KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nTower KronBlock(0,1,2) [tag: Tower Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*acos(phi)']]\n</code></pre>"},{"location":"qml/qml_tools/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\nn_qubits = 3\ndepth = 2\nansatz = hea(n_qubits, depth)\n</code></pre> %3 679764d795a447eab8f9083935b1146f 0 f3daf302b8ae46c28279d4461da109cc RX(theta\u2080) 679764d795a447eab8f9083935b1146f--f3daf302b8ae46c28279d4461da109cc d863a82b00af434aa9761f68de885517 1 bf87bb799a824d25b7d4b4df0375a552 RY(theta\u2083) f3daf302b8ae46c28279d4461da109cc--bf87bb799a824d25b7d4b4df0375a552 3853b9e246824159b5f2d2cf842adcd0 RX(theta\u2086) bf87bb799a824d25b7d4b4df0375a552--3853b9e246824159b5f2d2cf842adcd0 b75052383b7a4894a0e97ffdaf151644 3853b9e246824159b5f2d2cf842adcd0--b75052383b7a4894a0e97ffdaf151644 f4f577a53756489aa1e716e52a1d4031 b75052383b7a4894a0e97ffdaf151644--f4f577a53756489aa1e716e52a1d4031 ef6fe76537e943dd8c5caebf32bff68b RX(theta\u2089) f4f577a53756489aa1e716e52a1d4031--ef6fe76537e943dd8c5caebf32bff68b 4458f724c70f4df39cd943d517441d5c RY(theta\u2081\u2082) ef6fe76537e943dd8c5caebf32bff68b--4458f724c70f4df39cd943d517441d5c df523b322e564fb8a1edbc21ba56164f RX(theta\u2081\u2085) 4458f724c70f4df39cd943d517441d5c--df523b322e564fb8a1edbc21ba56164f 3a38bf56b06c43f0b96baf4369ec91d2 df523b322e564fb8a1edbc21ba56164f--3a38bf56b06c43f0b96baf4369ec91d2 41bc617668584cc2bb92651c570126d4 3a38bf56b06c43f0b96baf4369ec91d2--41bc617668584cc2bb92651c570126d4 66be092eb2134d36b6ff8e40bd556858 41bc617668584cc2bb92651c570126d4--66be092eb2134d36b6ff8e40bd556858 72879ed255624ceaad310177bf9b269d 4ead801d2def400a85a1f52a77482b8c RX(theta\u2081) d863a82b00af434aa9761f68de885517--4ead801d2def400a85a1f52a77482b8c bcace2ecac254226af0b9cc345fc0dbf 2 3f27db8ee4a34ca18e94428d1eb9e965 RY(theta\u2084) 4ead801d2def400a85a1f52a77482b8c--3f27db8ee4a34ca18e94428d1eb9e965 458c7612c3894b3f8a4394a8e3c3f6cc RX(theta\u2087) 3f27db8ee4a34ca18e94428d1eb9e965--458c7612c3894b3f8a4394a8e3c3f6cc 835b5e9e7f374aa6aa1a4707d1020d23 X 458c7612c3894b3f8a4394a8e3c3f6cc--835b5e9e7f374aa6aa1a4707d1020d23 835b5e9e7f374aa6aa1a4707d1020d23--b75052383b7a4894a0e97ffdaf151644 7774022a70724c0ab705b86eaefe4740 835b5e9e7f374aa6aa1a4707d1020d23--7774022a70724c0ab705b86eaefe4740 347f2b2c1f7e486da465d6b87e3cdb70 RX(theta\u2081\u2080) 7774022a70724c0ab705b86eaefe4740--347f2b2c1f7e486da465d6b87e3cdb70 3db478e7fe2b49aa8e34758c9729c1c9 RY(theta\u2081\u2083) 347f2b2c1f7e486da465d6b87e3cdb70--3db478e7fe2b49aa8e34758c9729c1c9 3a75940b97004ea8b7dbb86f193542e5 RX(theta\u2081\u2086) 3db478e7fe2b49aa8e34758c9729c1c9--3a75940b97004ea8b7dbb86f193542e5 4e9e3a56264a469f8eaf57bfdf2ddab1 X 3a75940b97004ea8b7dbb86f193542e5--4e9e3a56264a469f8eaf57bfdf2ddab1 4e9e3a56264a469f8eaf57bfdf2ddab1--3a38bf56b06c43f0b96baf4369ec91d2 4d01af5007834fee8a838e75c19e8bd5 4e9e3a56264a469f8eaf57bfdf2ddab1--4d01af5007834fee8a838e75c19e8bd5 4d01af5007834fee8a838e75c19e8bd5--72879ed255624ceaad310177bf9b269d 8e73862bb45d4807847f4a55dea3df4d 2a84ea4d463641b58f1be1d20023333d RX(theta\u2082) bcace2ecac254226af0b9cc345fc0dbf--2a84ea4d463641b58f1be1d20023333d f32c821a3f9a4be9973629f626489fdc RY(theta\u2085) 2a84ea4d463641b58f1be1d20023333d--f32c821a3f9a4be9973629f626489fdc b0d8bdfd98a743e7820839c677cbef30 RX(theta\u2088) f32c821a3f9a4be9973629f626489fdc--b0d8bdfd98a743e7820839c677cbef30 b5fb17c770214286aba0d47039394a1b b0d8bdfd98a743e7820839c677cbef30--b5fb17c770214286aba0d47039394a1b 7d35e428f40d41e18d6ab11f36b5b7dd X b5fb17c770214286aba0d47039394a1b--7d35e428f40d41e18d6ab11f36b5b7dd 7d35e428f40d41e18d6ab11f36b5b7dd--7774022a70724c0ab705b86eaefe4740 dcab188348ad48de912f6bbbf11ff272 RX(theta\u2081\u2081) 7d35e428f40d41e18d6ab11f36b5b7dd--dcab188348ad48de912f6bbbf11ff272 9f655ec419da4089a83772353c07230a RY(theta\u2081\u2084) dcab188348ad48de912f6bbbf11ff272--9f655ec419da4089a83772353c07230a 43b466ebdc7f4ba793d208a7a74494ea RX(theta\u2081\u2087) 9f655ec419da4089a83772353c07230a--43b466ebdc7f4ba793d208a7a74494ea f20864d5b9374c1ba1acebf531c22952 43b466ebdc7f4ba793d208a7a74494ea--f20864d5b9374c1ba1acebf531c22952 f6433a5e74d745f985b02bd0609d5599 X f20864d5b9374c1ba1acebf531c22952--f6433a5e74d745f985b02bd0609d5599 f6433a5e74d745f985b02bd0609d5599--4d01af5007834fee8a838e75c19e8bd5 f6433a5e74d745f985b02bd0609d5599--8e73862bb45d4807847f4a55dea3df4d <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=\"phi\",\noperations=[RX, RY, RX],\nentangler=CPHASE\n)\n</code></pre> %3 44c3dceafa5d44fab2a8985dc46e2123 0 7e93250e489b4b69a0571d15df807488 RX(phi\u2080) 44c3dceafa5d44fab2a8985dc46e2123--7e93250e489b4b69a0571d15df807488 9bae0c624235485ab999ce5f529ca1f8 1 209423b5d9e24f86a152a1190b537d21 RY(phi\u2083) 7e93250e489b4b69a0571d15df807488--209423b5d9e24f86a152a1190b537d21 9d8243eddd5044b0b790ef9dd3d4e049 RX(phi\u2086) 209423b5d9e24f86a152a1190b537d21--9d8243eddd5044b0b790ef9dd3d4e049 a38cee1039ba4f0bb79c57451b594465 9d8243eddd5044b0b790ef9dd3d4e049--a38cee1039ba4f0bb79c57451b594465 ca90c759df7a436c89d374ee6bc66f7a a38cee1039ba4f0bb79c57451b594465--ca90c759df7a436c89d374ee6bc66f7a b407067b591246ddb6b502b69278118c RX(phi\u2089) ca90c759df7a436c89d374ee6bc66f7a--b407067b591246ddb6b502b69278118c c06da2eff51648ef90bd39a03996ce90 RY(phi\u2081\u2082) b407067b591246ddb6b502b69278118c--c06da2eff51648ef90bd39a03996ce90 22240678eac148aa81d437da2ee4428a RX(phi\u2081\u2085) c06da2eff51648ef90bd39a03996ce90--22240678eac148aa81d437da2ee4428a 44f3861dc13e417bb04e8d6a1e039680 22240678eac148aa81d437da2ee4428a--44f3861dc13e417bb04e8d6a1e039680 23597a16f6e543e8bb8c0822f394a18c 44f3861dc13e417bb04e8d6a1e039680--23597a16f6e543e8bb8c0822f394a18c efa907bcc4ff489d8ab1a778fd49c727 23597a16f6e543e8bb8c0822f394a18c--efa907bcc4ff489d8ab1a778fd49c727 bd0d23bf2ca24ce3b26ca5b039c8f055 380f58fe1582466fbd748df0688b117f RX(phi\u2081) 9bae0c624235485ab999ce5f529ca1f8--380f58fe1582466fbd748df0688b117f 9784a437abb442d9950efd89f48116c9 2 6929a1368a5a495f807a8988b8f83d97 RY(phi\u2084) 380f58fe1582466fbd748df0688b117f--6929a1368a5a495f807a8988b8f83d97 ab6583cba5d9401f80acf7f1252900d0 RX(phi\u2087) 6929a1368a5a495f807a8988b8f83d97--ab6583cba5d9401f80acf7f1252900d0 f259b1ae2c434fddbb532a4b7c54b080 PHASE(phi_ent\u2080) ab6583cba5d9401f80acf7f1252900d0--f259b1ae2c434fddbb532a4b7c54b080 f259b1ae2c434fddbb532a4b7c54b080--a38cee1039ba4f0bb79c57451b594465 57b1f69c6c524a19b8de7926397aa23a f259b1ae2c434fddbb532a4b7c54b080--57b1f69c6c524a19b8de7926397aa23a 4ed4739666d245d8b3dd1d8c68bca1f4 RX(phi\u2081\u2080) 57b1f69c6c524a19b8de7926397aa23a--4ed4739666d245d8b3dd1d8c68bca1f4 04ccb86a9835467d948c6d8f290561ee RY(phi\u2081\u2083) 4ed4739666d245d8b3dd1d8c68bca1f4--04ccb86a9835467d948c6d8f290561ee 59ea5537da064e699b7b5d72343cb9df RX(phi\u2081\u2086) 04ccb86a9835467d948c6d8f290561ee--59ea5537da064e699b7b5d72343cb9df 197ac493b3db478fbf2a3c0e296fecf3 PHASE(phi_ent\u2082) 59ea5537da064e699b7b5d72343cb9df--197ac493b3db478fbf2a3c0e296fecf3 197ac493b3db478fbf2a3c0e296fecf3--44f3861dc13e417bb04e8d6a1e039680 83fed5a667844db5a9b2a12a9afb4341 197ac493b3db478fbf2a3c0e296fecf3--83fed5a667844db5a9b2a12a9afb4341 83fed5a667844db5a9b2a12a9afb4341--bd0d23bf2ca24ce3b26ca5b039c8f055 74da340f369f4d1e96b8412b9fea794f 676db064d7434d1e97f447798006bc94 RX(phi\u2082) 9784a437abb442d9950efd89f48116c9--676db064d7434d1e97f447798006bc94 3cca5ca3ebf144828130520931341339 RY(phi\u2085) 676db064d7434d1e97f447798006bc94--3cca5ca3ebf144828130520931341339 712db55a7c864a88812ba9ad84b638fb RX(phi\u2088) 3cca5ca3ebf144828130520931341339--712db55a7c864a88812ba9ad84b638fb 4df51d53263844c3a311f118a27be645 712db55a7c864a88812ba9ad84b638fb--4df51d53263844c3a311f118a27be645 e2f3f6cdf79c4cd78ff4b9657606adc9 PHASE(phi_ent\u2081) 4df51d53263844c3a311f118a27be645--e2f3f6cdf79c4cd78ff4b9657606adc9 e2f3f6cdf79c4cd78ff4b9657606adc9--57b1f69c6c524a19b8de7926397aa23a 213fea7656da4a78a092c3dd8eb7ae7f RX(phi\u2081\u2081) e2f3f6cdf79c4cd78ff4b9657606adc9--213fea7656da4a78a092c3dd8eb7ae7f d63df83e5f5a4853b73b76c7af29b2c7 RY(phi\u2081\u2084) 213fea7656da4a78a092c3dd8eb7ae7f--d63df83e5f5a4853b73b76c7af29b2c7 2be8d4309506400283387eb075bd6895 RX(phi\u2081\u2087) d63df83e5f5a4853b73b76c7af29b2c7--2be8d4309506400283387eb075bd6895 af6d44869aa84bfa878f1ddc78499e84 2be8d4309506400283387eb075bd6895--af6d44869aa84bfa878f1ddc78499e84 071ab36520014f16866e85169f56cc62 PHASE(phi_ent\u2083) af6d44869aa84bfa878f1ddc78499e84--071ab36520014f16866e85169f56cc62 071ab36520014f16866e85169f56cc62--83fed5a667844db5a9b2a12a9afb4341 071ab36520014f16866e85169f56cc62--74da340f369f4d1e96b8412b9fea794f <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like NN interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\nansatz = hea(\nn_qubits,\ndepth=depth,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_91070a282ac44dba90ad235f6b5794f4 cluster_b5312f749b554c18ab4ffe0798658940 bd6f26f9f07246d7b8d681d5086d6139 0 e5186aec317c470a8258f3ca2d3bdb3f RX(theta\u2080) bd6f26f9f07246d7b8d681d5086d6139--e5186aec317c470a8258f3ca2d3bdb3f b792e8600cc34c89a7df11ba85f6c071 1 ca08af697bf743d292ce390ca966d2c6 RY(theta\u2083) e5186aec317c470a8258f3ca2d3bdb3f--ca08af697bf743d292ce390ca966d2c6 223b0a7373b64c11bd9d5cd0ae187033 RX(theta\u2086) ca08af697bf743d292ce390ca966d2c6--223b0a7373b64c11bd9d5cd0ae187033 2bb5280c240647e7af5dc21ca17f5930 HamEvo 223b0a7373b64c11bd9d5cd0ae187033--2bb5280c240647e7af5dc21ca17f5930 b92ec6dee87e44069c50928ed58a4b2d RX(theta\u2089) 2bb5280c240647e7af5dc21ca17f5930--b92ec6dee87e44069c50928ed58a4b2d 202bc61aadf749c2856131013b392442 RY(theta\u2081\u2082) b92ec6dee87e44069c50928ed58a4b2d--202bc61aadf749c2856131013b392442 df53ad07a46c492dad787fc4b0e8db03 RX(theta\u2081\u2085) 202bc61aadf749c2856131013b392442--df53ad07a46c492dad787fc4b0e8db03 d2826c2e107842798b059144df51edde HamEvo df53ad07a46c492dad787fc4b0e8db03--d2826c2e107842798b059144df51edde 02b06dd02c184c04bf21cc4f21f0390a d2826c2e107842798b059144df51edde--02b06dd02c184c04bf21cc4f21f0390a 5a51b4646e72447d8156e34cb07470cb 2cef04fff2634b71a01b099b9b91cb9f RX(theta\u2081) b792e8600cc34c89a7df11ba85f6c071--2cef04fff2634b71a01b099b9b91cb9f 0c4798bc3cd64e3e81a0c22be35166cf 2 8a2f0e4aecbb4549a020d72aa1f0cb14 RY(theta\u2084) 2cef04fff2634b71a01b099b9b91cb9f--8a2f0e4aecbb4549a020d72aa1f0cb14 3a01fdc289c746a9a3940c055fed0116 RX(theta\u2087) 8a2f0e4aecbb4549a020d72aa1f0cb14--3a01fdc289c746a9a3940c055fed0116 01adffde729f4e1ea27d1381d94d06c0 t = theta_t\u2080 3a01fdc289c746a9a3940c055fed0116--01adffde729f4e1ea27d1381d94d06c0 5dba1a91669442d2b0cc3a022668d470 RX(theta\u2081\u2080) 01adffde729f4e1ea27d1381d94d06c0--5dba1a91669442d2b0cc3a022668d470 08dae9117e2f4ccfa6454b32eb92a1c2 RY(theta\u2081\u2083) 5dba1a91669442d2b0cc3a022668d470--08dae9117e2f4ccfa6454b32eb92a1c2 70699c2f371c4222b67661975aba7b6c RX(theta\u2081\u2086) 08dae9117e2f4ccfa6454b32eb92a1c2--70699c2f371c4222b67661975aba7b6c b136e9f829694aa8beb443bee22cfba4 t = theta_t\u2081 70699c2f371c4222b67661975aba7b6c--b136e9f829694aa8beb443bee22cfba4 b136e9f829694aa8beb443bee22cfba4--5a51b4646e72447d8156e34cb07470cb 5cd326c125fc40b39b1643db3b492b4e 1094eaf8253c4d7ab9ce5801dfe240a1 RX(theta\u2082) 0c4798bc3cd64e3e81a0c22be35166cf--1094eaf8253c4d7ab9ce5801dfe240a1 cd84ce9a9cfb4db19b1a5f2c3dcd7c54 RY(theta\u2085) 1094eaf8253c4d7ab9ce5801dfe240a1--cd84ce9a9cfb4db19b1a5f2c3dcd7c54 cf6e72e368154b45848616ea7eef32c4 RX(theta\u2088) cd84ce9a9cfb4db19b1a5f2c3dcd7c54--cf6e72e368154b45848616ea7eef32c4 8e001bd8253645da817b69e75d92dff4 cf6e72e368154b45848616ea7eef32c4--8e001bd8253645da817b69e75d92dff4 281eaf734e5b405ea3572324d0bbf582 RX(theta\u2081\u2081) 8e001bd8253645da817b69e75d92dff4--281eaf734e5b405ea3572324d0bbf582 938f3ad1378e4afc9a564d4546a1cbde RY(theta\u2081\u2084) 281eaf734e5b405ea3572324d0bbf582--938f3ad1378e4afc9a564d4546a1cbde 8830fc177b734514b1fa23df5d01d6ab RX(theta\u2081\u2087) 938f3ad1378e4afc9a564d4546a1cbde--8830fc177b734514b1fa23df5d01d6ab 2fc2eee431fb44379c279d96a2a940ee 8830fc177b734514b1fa23df5d01d6ab--2fc2eee431fb44379c279d96a2a940ee 2fc2eee431fb44379c279d96a2a940ee--5cd326c125fc40b39b1643db3b492b4e <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\nentangler = hamiltonian_factory(\nregister,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"e\",\ndetuning_strength=\"n\"\n)\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\nansatz = hea(\nn_qubits=register.n_qubits,\ndepth=depth,\noperations=[RX, RY, RX],\nentangler=entangler,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_641c66e4ff58478d974f97cd71a21045 cluster_2f81b32f4e1346ef934ce0ecbc34a8ad 784192b82e5d485c9af468c188cf6216 0 ab8bc7dcec17462c9099203db72ae52e RX(theta\u2080) 784192b82e5d485c9af468c188cf6216--ab8bc7dcec17462c9099203db72ae52e 11a74a6e22a24c5483387d998e389280 1 e8b8292eb887476abdebe3b68336dd8e RY(theta\u2086) ab8bc7dcec17462c9099203db72ae52e--e8b8292eb887476abdebe3b68336dd8e e5071b138c2546ff8b45dbe9ff669495 RX(theta\u2081\u2082) e8b8292eb887476abdebe3b68336dd8e--e5071b138c2546ff8b45dbe9ff669495 d1666e630917412abe24d9bba9874be1 e5071b138c2546ff8b45dbe9ff669495--d1666e630917412abe24d9bba9874be1 94c8befdb9e1417f9596a39e44edea9d RX(theta\u2081\u2088) d1666e630917412abe24d9bba9874be1--94c8befdb9e1417f9596a39e44edea9d 669d5a348bfb417887a6d2fcf863baf9 RY(theta\u2082\u2084) 94c8befdb9e1417f9596a39e44edea9d--669d5a348bfb417887a6d2fcf863baf9 a86722d4543b4fd9b4447a5b912faa05 RX(theta\u2083\u2080) 669d5a348bfb417887a6d2fcf863baf9--a86722d4543b4fd9b4447a5b912faa05 f2855efdf0d24210b122ca4eca6074ca a86722d4543b4fd9b4447a5b912faa05--f2855efdf0d24210b122ca4eca6074ca c45b2306acba46b7b165c597b101fdcb f2855efdf0d24210b122ca4eca6074ca--c45b2306acba46b7b165c597b101fdcb 0077dde88dad4a1290f096e24602ffa3 1eb7ab90ec3240fa9ec7b58df8cf76df RX(theta\u2081) 11a74a6e22a24c5483387d998e389280--1eb7ab90ec3240fa9ec7b58df8cf76df f2e55223aec74268b28fccfaa156f540 2 bba7e2eeecc4477b8c617234f735a6cd RY(theta\u2087) 1eb7ab90ec3240fa9ec7b58df8cf76df--bba7e2eeecc4477b8c617234f735a6cd 78e79c981f7341c8976a1ef08fc460c8 RX(theta\u2081\u2083) bba7e2eeecc4477b8c617234f735a6cd--78e79c981f7341c8976a1ef08fc460c8 c055ca2892814f33b5e8d0f0d094136d 78e79c981f7341c8976a1ef08fc460c8--c055ca2892814f33b5e8d0f0d094136d 25c2ac17242a4bacaa8f209caec43c78 RX(theta\u2081\u2089) c055ca2892814f33b5e8d0f0d094136d--25c2ac17242a4bacaa8f209caec43c78 1e349dc50bca47f1a6d916cf0acf0f0e RY(theta\u2082\u2085) 25c2ac17242a4bacaa8f209caec43c78--1e349dc50bca47f1a6d916cf0acf0f0e f3a30a0bfa604ca78f5ff952a8511c28 RX(theta\u2083\u2081) 1e349dc50bca47f1a6d916cf0acf0f0e--f3a30a0bfa604ca78f5ff952a8511c28 ce1fb13e327940029e379c310e6eace7 f3a30a0bfa604ca78f5ff952a8511c28--ce1fb13e327940029e379c310e6eace7 ce1fb13e327940029e379c310e6eace7--0077dde88dad4a1290f096e24602ffa3 97035589de174e81a36c592433f63ffe a08f76190b654b3c8c80083a1377a63f RX(theta\u2082) f2e55223aec74268b28fccfaa156f540--a08f76190b654b3c8c80083a1377a63f 33cd027d64224bccb31cb19a5518fc7e 3 9f75c12161ab450296a39449122db647 RY(theta\u2088) a08f76190b654b3c8c80083a1377a63f--9f75c12161ab450296a39449122db647 cef003680cdd463e9dc9f9378612bc08 RX(theta\u2081\u2084) 9f75c12161ab450296a39449122db647--cef003680cdd463e9dc9f9378612bc08 6fa1d21849074439b23bf4040122d82f HamEvo cef003680cdd463e9dc9f9378612bc08--6fa1d21849074439b23bf4040122d82f 2e3df8f4cafc4bf494df7b590939bae1 RX(theta\u2082\u2080) 6fa1d21849074439b23bf4040122d82f--2e3df8f4cafc4bf494df7b590939bae1 51c9fc07f30941c893393f933317f847 RY(theta\u2082\u2086) 2e3df8f4cafc4bf494df7b590939bae1--51c9fc07f30941c893393f933317f847 0c67424d634a4e72b76d3c2e7d16a63e RX(theta\u2083\u2082) 51c9fc07f30941c893393f933317f847--0c67424d634a4e72b76d3c2e7d16a63e 301cdde396174915bfed092c791de799 HamEvo 0c67424d634a4e72b76d3c2e7d16a63e--301cdde396174915bfed092c791de799 301cdde396174915bfed092c791de799--97035589de174e81a36c592433f63ffe 41a3a02b23a0442481632ecf2b1551f2 f671ae56a7454319b1cd33b9bff25cc3 RX(theta\u2083) 33cd027d64224bccb31cb19a5518fc7e--f671ae56a7454319b1cd33b9bff25cc3 98603726468949eab1b3a5aec70181f5 4 aaa640bb04144c54808ed585bfea6a05 RY(theta\u2089) f671ae56a7454319b1cd33b9bff25cc3--aaa640bb04144c54808ed585bfea6a05 63bf6ed32c6e42bc844aaa68ce391ea4 RX(theta\u2081\u2085) aaa640bb04144c54808ed585bfea6a05--63bf6ed32c6e42bc844aaa68ce391ea4 375f8aa1f2194821af241082dd0cf8f2 t = theta_t\u2080 63bf6ed32c6e42bc844aaa68ce391ea4--375f8aa1f2194821af241082dd0cf8f2 641ca5e1d2f1495dae4721af04257610 RX(theta\u2082\u2081) 375f8aa1f2194821af241082dd0cf8f2--641ca5e1d2f1495dae4721af04257610 21f4ec7696884899bd598cfe3fa50fc2 RY(theta\u2082\u2087) 641ca5e1d2f1495dae4721af04257610--21f4ec7696884899bd598cfe3fa50fc2 de797f4f1fe742759f1cc11065050a03 RX(theta\u2083\u2083) 21f4ec7696884899bd598cfe3fa50fc2--de797f4f1fe742759f1cc11065050a03 e6718d796fcc42109942be7f46f9ad83 t = theta_t\u2081 de797f4f1fe742759f1cc11065050a03--e6718d796fcc42109942be7f46f9ad83 e6718d796fcc42109942be7f46f9ad83--41a3a02b23a0442481632ecf2b1551f2 9621c63e92c14e6d9100223a77d6d73f cf16e154768144a7a92d42d8a5d361c4 RX(theta\u2084) 98603726468949eab1b3a5aec70181f5--cf16e154768144a7a92d42d8a5d361c4 d8899c059ed44e6dbf6a9c14f6c498b1 5 1c112850a6424151aa9b590d8314ed42 RY(theta\u2081\u2080) cf16e154768144a7a92d42d8a5d361c4--1c112850a6424151aa9b590d8314ed42 d3c5a0a8bf544fb89e2e492506fb2ed6 RX(theta\u2081\u2086) 1c112850a6424151aa9b590d8314ed42--d3c5a0a8bf544fb89e2e492506fb2ed6 03b8cb6a7d054ce59867f17552f63580 d3c5a0a8bf544fb89e2e492506fb2ed6--03b8cb6a7d054ce59867f17552f63580 34656ee8c0fa440fb563e2f14e2a194c RX(theta\u2082\u2082) 03b8cb6a7d054ce59867f17552f63580--34656ee8c0fa440fb563e2f14e2a194c 1d3ec49a6cf74025bc5306ae43c17c1e RY(theta\u2082\u2088) 34656ee8c0fa440fb563e2f14e2a194c--1d3ec49a6cf74025bc5306ae43c17c1e 3c3a0697c9084a0c90fe9a998b7acc30 RX(theta\u2083\u2084) 1d3ec49a6cf74025bc5306ae43c17c1e--3c3a0697c9084a0c90fe9a998b7acc30 36ecdb4c0c81443688d5ca75e58b4d85 3c3a0697c9084a0c90fe9a998b7acc30--36ecdb4c0c81443688d5ca75e58b4d85 36ecdb4c0c81443688d5ca75e58b4d85--9621c63e92c14e6d9100223a77d6d73f 04c0c6706d3444ec80054a069ed97bad bec680a4104f4894996d1b62cb5b46c9 RX(theta\u2085) d8899c059ed44e6dbf6a9c14f6c498b1--bec680a4104f4894996d1b62cb5b46c9 cc2dc21f17c14c5fbbc189c045082398 RY(theta\u2081\u2081) bec680a4104f4894996d1b62cb5b46c9--cc2dc21f17c14c5fbbc189c045082398 ceded9dc698f47ec80e6e4ce94835f2d RX(theta\u2081\u2087) cc2dc21f17c14c5fbbc189c045082398--ceded9dc698f47ec80e6e4ce94835f2d c62bc7420a8741a5b079ec58d478fec8 ceded9dc698f47ec80e6e4ce94835f2d--c62bc7420a8741a5b079ec58d478fec8 d62b3a5a018a4170a5e8d2b82cfa6300 RX(theta\u2082\u2083) c62bc7420a8741a5b079ec58d478fec8--d62b3a5a018a4170a5e8d2b82cfa6300 b672c4e78ed4497ebfe636c8bfb8c2de RY(theta\u2082\u2089) d62b3a5a018a4170a5e8d2b82cfa6300--b672c4e78ed4497ebfe636c8bfb8c2de a514f73402824887a066bd4c9472b7c6 RX(theta\u2083\u2085) b672c4e78ed4497ebfe636c8bfb8c2de--a514f73402824887a066bd4c9472b7c6 2e54cc4e8a0b4c97affca7a6f579d371 a514f73402824887a066bd4c9472b7c6--2e54cc4e8a0b4c97affca7a6f579d371 2e54cc4e8a0b4c97affca7a6f579d371--04c0c6706d3444ec80054a069ed97bad"},{"location":"qml/qml_tools/#machine-learning-tools","title":"Machine Learning Tools","text":""},{"location":"qml/qml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using <code>qadence</code>, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader\ndef dataloader() -&gt; DataLoader:\nbatch_size = 5\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\nreturn DataLoader(dataset, batch_size=batch_size)\ndef dictdataloader() -&gt; DictDataLoader:\nbatch_size = 5\nkeys = [\"y1\", \"y2\"]\ndls = {}\nfor k in keys:\nx = torch.rand(batch_size, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\ndataloader = DataLoader(dataset, batch_size=batch_size)\ndls[k] = dataloader\nreturn DictDataLoader(dls)\nn_epochs = 2\n# iterate standard DataLoader\ndl = dataloader()\nfor i in range(n_epochs):\ndata = next(iter(dl))\n# iterate DictDataLoader\nddl = dictdataloader()\nfor i in range(n_epochs):\ndata = next(iter(ddl))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"qml/qml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, <code>qadence</code> also offers a few out-of-the-box routines for optimizing differentiable models like <code>QNN</code>s and <code>QuantumModel</code>s containing either trainable and/or non-trainable parameters (you can refer to this for a refresh about different parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\n</code></pre> <pre><code>\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\nbatch_size = 5\nn_epochs = 100\nconfig = TrainConfig(\nfolder=\"some_path/\",\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\n</code></pre> <pre><code>\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/qml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nimport matplotlib.pyplot as plt\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\nplt.plot(y.numpy())\nplt.plot(model(input_values).detach().numpy())\n</code></pre> <pre><code>\n</code></pre> <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/qml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\ntmp_path = Path(\"/tmp\")\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\nfor i in range(n_epochs):\nout = model(x)\nloss = criterion(out, y)\nloss.backward()\noptimizer.step()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\nRX(0, 3 * x),\nRX(0, x),\nRZ(1, sympy.exp(y)),\nRX(0, 3.14),\nRZ(1, \"theta\")\n)\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\ncircuit = QuantumCircuit(2, block)\nobservable = Z(0)\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n# Compute expectation.\nexp = model.expectation(values)\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1,2)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n\u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2514\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 KronBlock(1,2)\n\u2514\u2500\u2500 CNOT(1,2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': c7f9383c-a456-47db-a3cd-e78b17d199b5, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 78e14906-8f60-42d7-8ed6-2439f2a465df, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 04833e54-3f89-44ff-b6d1-87fcdc9b89c4, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 01ba14f4-1eb0-409b-8e1d-f7736d1e45bb, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': b17f69c4-2eba-45e2-894e-6d53f6e2016e, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': f12f3721-4c38-472d-80eb-b1b70c61a8b2, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 90efe370-d889-4f46-b0c7-67ac1014798e, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': d134c10d-f913-445f-8e66-faf905c86404, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': b8e46660-5db9-4a08-ac82-eebda742d211, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 0a9c65c7-d6f1-4235-b737-73002dd18ba3, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 5466482c-e72b-4864-bc76-0b4def1a26ac, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n# Contains fixed parameters and variational (from the HEA)\nconv.params\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\ntheta_4: tensor([0.0779], requires_grad=True)\ntheta_3: tensor([0.4370], requires_grad=True)\ntheta_6: tensor([0.5825], requires_grad=True)\ntheta_2: tensor([0.8681], requires_grad=True)\ntheta_1: tensor([0.9099], requires_grad=True)\ntheta_7: tensor([0.8215], requires_grad=True)\ntheta_5: tensor([0.3829], requires_grad=True)\ntheta_0: tensor([0.7224], requires_grad=True)\ntheta_8: tensor([0.1922], requires_grad=True)\n}\nembedded = {\nc7f9383c-a456-47db-a3cd-e78b17d199b5: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n78e14906-8f60-42d7-8ed6-2439f2a465df: tensor([2., 2.])\n04833e54-3f89-44ff-b6d1-87fcdc9b89c4: tensor([0.7224], grad_fn=&lt;ViewBackward0&gt;)\n01ba14f4-1eb0-409b-8e1d-f7736d1e45bb: tensor([0.9099], grad_fn=&lt;ViewBackward0&gt;)\nb17f69c4-2eba-45e2-894e-6d53f6e2016e: tensor([0.8681], grad_fn=&lt;ViewBackward0&gt;)\nf12f3721-4c38-472d-80eb-b1b70c61a8b2: tensor([0.4370], grad_fn=&lt;ViewBackward0&gt;)\n90efe370-d889-4f46-b0c7-67ac1014798e: tensor([0.0779], grad_fn=&lt;ViewBackward0&gt;)\nd134c10d-f913-445f-8e66-faf905c86404: tensor([0.3829], grad_fn=&lt;ViewBackward0&gt;)\nb8e46660-5db9-4a08-ac82-eebda742d211: tensor([0.5825], grad_fn=&lt;ViewBackward0&gt;)\n0a9c65c7-d6f1-4235-b737-73002dd18ba3: tensor([0.8215], grad_fn=&lt;ViewBackward0&gt;)\n5466482c-e72b-4864-bc76-0b4def1a26ac: tensor([0.1922], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\ntheta_4: tensor([0.0779], grad_fn=&lt;ViewBackward0&gt;)\ntheta_3: tensor([0.4370], grad_fn=&lt;ViewBackward0&gt;)\ny: tensor([2., 2.])\ntheta_6: tensor([0.5825], grad_fn=&lt;ViewBackward0&gt;)\ntheta_2: tensor([0.8681], grad_fn=&lt;ViewBackward0&gt;)\ntheta_1: tensor([0.9099], grad_fn=&lt;ViewBackward0&gt;)\ntheta_7: tensor([0.8215], grad_fn=&lt;ViewBackward0&gt;)\ntheta_5: tensor([0.3829], grad_fn=&lt;ViewBackward0&gt;)\ntheta_0: tensor([0.7224], grad_fn=&lt;ViewBackward0&gt;)\ntheta_8: tensor([0.1922], grad_fn=&lt;ViewBackward0&gt;)\n3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.4139+0.0748j,  0.1140-0.2352j,  0.1632+0.1274j, -0.1267+0.3081j,\n-0.3707-0.2339j, -0.2020+0.1828j,  0.1915+0.2378j, -0.2855+0.3998j],\n[ 0.4139+0.0748j,  0.1140-0.2352j,  0.1632+0.1274j, -0.1267+0.3081j,\n-0.3707-0.2339j, -0.2020+0.1828j,  0.1915+0.2378j, -0.2855+0.3998j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 175, '011': 143, '100': 142, '111': 123, '010': 118, '001': 106, '101': 98, '110': 95})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nq0 : -Rx(c7f9383c-a456-47db-a3cd-e78b17d199b5)-C----------------------------------------Rx(04833e54-3f89-44ff-b6d1-87fcdc9b89c4)-Ry(f12f3721-4c38-472d-80eb-b1b70c61a8b2)-Rx(b8e46660-5db9-4a08-ac82-eebda742d211)-C---\n|                                                                                                                                                                   |   q1 : -Rz(78e14906-8f60-42d7-8ed6-2439f2a465df)-X----------------------------------------Rx(01ba14f4-1eb0-409b-8e1d-f7736d1e45bb)-Ry(90efe370-d889-4f46-b0c7-67ac1014798e)-Rx(0a9c65c7-d6f1-4235-b737-73002dd18ba3)-X-C-\n| q2 : -Rx(b17f69c4-2eba-45e2-894e-6d53f6e2016e)-Ry(d134c10d-f913-445f-8e66-faf905c86404)-Rx(5466482c-e72b-4864-bc76-0b4def1a26ac)-------------------------------------------------------------------------------------X-\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nUnassigned parameters: [01ba14f4-1eb0-409b-8e1d-f7736d1e45bb, 04833e54-3f89-44ff-b6d1-87fcdc9b89c4, 0a9c65c7-d6f1-4235-b737-73002dd18ba3, 5466482c-e72b-4864-bc76-0b4def1a26ac, 78e14906-8f60-42d7-8ed6-2439f2a465df, 90efe370-d889-4f46-b0c7-67ac1014798e, b17f69c4-2eba-45e2-894e-6d53f6e2016e, b8e46660-5db9-4a08-ac82-eebda742d211, c7f9383c-a456-47db-a3cd-e78b17d199b5, d134c10d-f913-445f-8e66-faf905c86404, f12f3721-4c38-472d-80eb-b1b70c61a8b2].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\nq0 : -Rx(0.73)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.72)-DEPO(0.1)-Ry(0.44)-DEPO(0.1)-Rx(0.58)-DEPO(0.1)-C-DEPO(0.1)-------------\n|                                                                           |                       q1 : -Rz(0.96)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.91)-DEPO(0.1)-Ry(0.08)-DEPO(0.1)-Rx(0.82)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n|           q2 : -Rx(0.87)-DEPO(0.1)-Ry(0.38)-DEPO(0.1)-Rx(0.19)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 7b9a0413d36248a7a26e3e353e428f3b 0 d37c6b55eaa34216ad477913f1a06cb8 X 7b9a0413d36248a7a26e3e353e428f3b--d37c6b55eaa34216ad477913f1a06cb8 3998a573da394c32913290d9e0791e4a 1 adc77daabdc74ddd95fcee50a54ed40d d37c6b55eaa34216ad477913f1a06cb8--adc77daabdc74ddd95fcee50a54ed40d aad086fca36b4f94b093ef9af2f7b2ce 07e2944f73c54332a7dd3c9a66e33555 Y 3998a573da394c32913290d9e0791e4a--07e2944f73c54332a7dd3c9a66e33555 07e2944f73c54332a7dd3c9a66e33555--aad086fca36b4f94b093ef9af2f7b2ce </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 9352ca2268ab4491908ae716ac1637e1 0 244c9c9d27194d69a1bff456e4183f30 RX(0.5) 9352ca2268ab4491908ae716ac1637e1--244c9c9d27194d69a1bff456e4183f30 63155083c097439fa74ac3b7a7fceea4 244c9c9d27194d69a1bff456e4183f30--63155083c097439fa74ac3b7a7fceea4 <pre><code>from qadence import CNOT\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 bf4733366153466f94a34e0917d82c53 0 a8d67fd0d8554558a719d30fabc3b4f5 bf4733366153466f94a34e0917d82c53--a8d67fd0d8554558a719d30fabc3b4f5 de18df1f056c4e96a68e4b47f9c7c6b7 1 cd7b78b9921b492c8707b32fc6409a22 a8d67fd0d8554558a719d30fabc3b4f5--cd7b78b9921b492c8707b32fc6409a22 ca9d4bc4e0a14990a7a0d3446e753c95 807fd9af177049ac90d1c2437d6b23cf X de18df1f056c4e96a68e4b47f9c7c6b7--807fd9af177049ac90d1c2437d6b23cf 807fd9af177049ac90d1c2437d6b23cf--a8d67fd0d8554558a719d30fabc3b4f5 807fd9af177049ac90d1c2437d6b23cf--ca9d4bc4e0a14990a7a0d3446e753c95 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 11f294e00e2043a5a0723b977d5eb91a 0 23749de27b69476a8cbd9153f65f3784 X 11f294e00e2043a5a0723b977d5eb91a--23749de27b69476a8cbd9153f65f3784 2ee37747fab7490887450c2283189d7d X 23749de27b69476a8cbd9153f65f3784--2ee37747fab7490887450c2283189d7d 53c84602120e4766a7784ee7314aa23b 2ee37747fab7490887450c2283189d7d--53c84602120e4766a7784ee7314aa23b <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 a757f88c56c54481839cc264d5261fa2 0 8779f24215ae42de91b6b0e997ee4c45 X a757f88c56c54481839cc264d5261fa2--8779f24215ae42de91b6b0e997ee4c45 a603dc89dee041499fc72ee70a9117e0 1 c1650f5228364a1dbce8a5dcf946fa89 8779f24215ae42de91b6b0e997ee4c45--c1650f5228364a1dbce8a5dcf946fa89 334a9d5c77c04e12b7b1ea93dbb1c18b c1650f5228364a1dbce8a5dcf946fa89--334a9d5c77c04e12b7b1ea93dbb1c18b ef1ec308b109411590f717fb7347f7ab f9dc3a74e08a4a479c531fb3d6fe66cd a603dc89dee041499fc72ee70a9117e0--f9dc3a74e08a4a479c531fb3d6fe66cd 6bc2372c04544bad9eecaf8179b3d060 X f9dc3a74e08a4a479c531fb3d6fe66cd--6bc2372c04544bad9eecaf8179b3d060 6bc2372c04544bad9eecaf8179b3d060--ef1ec308b109411590f717fb7347f7ab </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 3f51f7e135954e6eb9e1a1f0d89ce00a 0 8bd52c1435d64847bbb18389fd78499e X 3f51f7e135954e6eb9e1a1f0d89ce00a--8bd52c1435d64847bbb18389fd78499e 73c1b97a1d7a4d07b8a90535742c73dd 1 39e52e5c5ab741da9c6840fb82858538 8bd52c1435d64847bbb18389fd78499e--39e52e5c5ab741da9c6840fb82858538 b720d810045b44928b02ec8e9b99cbb5 9cbc4ca9277a47d9bbe9f6a221508169 X 73c1b97a1d7a4d07b8a90535742c73dd--9cbc4ca9277a47d9bbe9f6a221508169 9cbc4ca9277a47d9bbe9f6a221508169--b720d810045b44928b02ec8e9b99cbb5 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n[ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_8e66f09e29354a0bb9a72d29e387f1bb subblock cluster_413a4c0800194376ae241c8ef109a98d subblock 48aad6d61ee441b4ad51b0981d4eb7aa 0 9d8f6a42ab8048379e6a3499943dbac4 X 48aad6d61ee441b4ad51b0981d4eb7aa--9d8f6a42ab8048379e6a3499943dbac4 9793b62d671940e781e3bd5a8853ed75 1 cefc04eeef7b4ad4bed2525ab57265b3 X 9d8f6a42ab8048379e6a3499943dbac4--cefc04eeef7b4ad4bed2525ab57265b3 f6939089e92445509865379fdf150a8f cefc04eeef7b4ad4bed2525ab57265b3--f6939089e92445509865379fdf150a8f e8a83ca8ec7941a7bbeaf988b14bf11d 70bb701348ae407bab1dfd73f8d35bda Y 9793b62d671940e781e3bd5a8853ed75--70bb701348ae407bab1dfd73f8d35bda f2ca276b07e74645b3a34eafa6a0ca4b 2 96b8ea15538d40e598a7fb1e4866c2b5 Y 70bb701348ae407bab1dfd73f8d35bda--96b8ea15538d40e598a7fb1e4866c2b5 96b8ea15538d40e598a7fb1e4866c2b5--e8a83ca8ec7941a7bbeaf988b14bf11d 1b55151ffd224b748cefd20e11bc11e2 a8e968c2f5374e128a72829759a8bb25 f2ca276b07e74645b3a34eafa6a0ca4b--a8e968c2f5374e128a72829759a8bb25 07a675a4d61f46a58909d5b175c5f703 3 08a2e2e958764ed68f7861f8c0234dea a8e968c2f5374e128a72829759a8bb25--08a2e2e958764ed68f7861f8c0234dea 08a2e2e958764ed68f7861f8c0234dea--1b55151ffd224b748cefd20e11bc11e2 e17ba372006f416d9011f3ace6d13a2d 1a8a9050f8b547fd97f4efcedc5aeee5 07a675a4d61f46a58909d5b175c5f703--1a8a9050f8b547fd97f4efcedc5aeee5 0f70eb5d378140fa87e0875ad0307b32 4 617542123078428cb9fda7c8dbf0b0f8 1a8a9050f8b547fd97f4efcedc5aeee5--617542123078428cb9fda7c8dbf0b0f8 617542123078428cb9fda7c8dbf0b0f8--e17ba372006f416d9011f3ace6d13a2d 43a2f3c2c9c1423f8894b20c903f9c4f 06173cd9de90424e94581c061318b91e X 0f70eb5d378140fa87e0875ad0307b32--06173cd9de90424e94581c061318b91e 06173cd9de90424e94581c061318b91e--1a8a9050f8b547fd97f4efcedc5aeee5 54a1d1685bb1499f88aa8a875420d2d1 X 06173cd9de90424e94581c061318b91e--54a1d1685bb1499f88aa8a875420d2d1 54a1d1685bb1499f88aa8a875420d2d1--617542123078428cb9fda7c8dbf0b0f8 54a1d1685bb1499f88aa8a875420d2d1--43a2f3c2c9c1423f8894b20c903f9c4f"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\nn_qubits = 2\nblock = chain(H(0), H(1))\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'00': 271, '10': 252, '01': 247, '11': 230})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'110': 30, '100': 28, '000': 27, '010': 15})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\nn_qubits = 3\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\nhamilt = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=[0.5, 0.2, 0.1],\ndetuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be indentical to the one obtained from the <code>edge</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\nzz_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=zz_terms,\ndetuning_strength=z_terms\n)\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(1)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(2)\n\u2514\u2500\u2500 [mul: -1.00000000000000] \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\nreg = Register.square(qubits_side=2)\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Custom Hamiltonian coefficients can also be added to the register beforehand using the <code>\"strength\"</code> key.</p> <pre><code>reg = Register.square(qubits_side = 2)\nfor i, edge in enumerate(reg.edges):\nreg.edges[edge][\"strength\"] = (0.5 * i) ** 2\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.0] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.250] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 2.250] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Alternatively, if the register already stores interaction or detuning strengths, it is possible to override them in the Hamiltonian creation by using <code>force_update = True</code>.</p>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments:</p> <pre><code>n_qubits = 3\nnn_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"c\",\ndetuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(1)\n\u2514\u2500\u2500 N(2)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(list(range(n_qubits)), n_qubits, replace=True)\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\ntensor([[2.5000e-01, 1.8747e-33],\n[1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\ntensor([[2.5000e-01, 4.4409e-16],\n[4.4409e-16, 4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\ntensor([[ 0.2540, -0.0092],\n[-0.0006, -0.0004]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9868+0.0000j, 0.0000-0.1621j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\nblock = RX(0, FeatureParameter(\"phi\"))\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n[0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8778+0.0000j, 0.0000-0.4791j],\n[0.9593+0.0000j, 0.0000-0.2825j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\nblock = chain(\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5086+0.0000j, 0.6844+0.0000j, 0.0000-0.3116j, 0.0000-0.4194j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\nblock = chain(\nkron(\nRX(0, phi/theta),\nRY(1, theta*2),\nRZ(2, sympy.cos(phi)),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi + theta),\nRY(1, theta**2),\nRZ(2, sympy.cos(phi)),\n),\nchain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_3c5e75af79104f4495fd58af67fea9c9 [* 2] cluster_fbeab31c0a7f4653933e3a75d8788f42 Rotations 4c3b1faed7a04006bc41ad274c1d288f 0 cd5dbc03701f40f69d490130f086d207 RX(phi/theta) 4c3b1faed7a04006bc41ad274c1d288f--cd5dbc03701f40f69d490130f086d207 536328e8616b4c5e86f89bafad5ae88c 1 a3e18faa1ac442f3b478231f09dcead0 RX(phi) cd5dbc03701f40f69d490130f086d207--a3e18faa1ac442f3b478231f09dcead0 3d6c3a9470214f14be484aa8c3088811 RX(phi) a3e18faa1ac442f3b478231f09dcead0--3d6c3a9470214f14be484aa8c3088811 e8e56acc2e6844a1b49ecf0ca2e7a2aa RX(phi + theta) 3d6c3a9470214f14be484aa8c3088811--e8e56acc2e6844a1b49ecf0ca2e7a2aa db76e3f505364aa695a2c09c28e5830e e8e56acc2e6844a1b49ecf0ca2e7a2aa--db76e3f505364aa695a2c09c28e5830e 5840c0c6d82346f2bf4deea5bad7d741 db76e3f505364aa695a2c09c28e5830e--5840c0c6d82346f2bf4deea5bad7d741 5def77dbbad5447ba74ceffa15f0d16d Z 5840c0c6d82346f2bf4deea5bad7d741--5def77dbbad5447ba74ceffa15f0d16d e407cb0a515840d5a1e2404c1dcabf1d 5def77dbbad5447ba74ceffa15f0d16d--e407cb0a515840d5a1e2404c1dcabf1d e723bb5efb5448b0aba170bb2cbc118f da641cb82fd342b79eecb07552fea009 RY(2*theta) 536328e8616b4c5e86f89bafad5ae88c--da641cb82fd342b79eecb07552fea009 b6c09429215f4886965d950c50f3bc54 2 8134599c2607424c991f5cc8f7456a13 RY(theta) da641cb82fd342b79eecb07552fea009--8134599c2607424c991f5cc8f7456a13 3368053f6c0f4037a4fcae01cde0adea RY(theta) 8134599c2607424c991f5cc8f7456a13--3368053f6c0f4037a4fcae01cde0adea 441bcb76640e4e149f437084878caacb RY(theta**2) 3368053f6c0f4037a4fcae01cde0adea--441bcb76640e4e149f437084878caacb 39711d1b96574e3ca67f2430e5d89c7f X 441bcb76640e4e149f437084878caacb--39711d1b96574e3ca67f2430e5d89c7f 39711d1b96574e3ca67f2430e5d89c7f--db76e3f505364aa695a2c09c28e5830e 0bc2b3cbce5c496f8b88f9f37071ae88 39711d1b96574e3ca67f2430e5d89c7f--0bc2b3cbce5c496f8b88f9f37071ae88 6ac1115d7db645a1862eb516922ab2d3 Z 0bc2b3cbce5c496f8b88f9f37071ae88--6ac1115d7db645a1862eb516922ab2d3 6ac1115d7db645a1862eb516922ab2d3--e723bb5efb5448b0aba170bb2cbc118f 5d81a45f5fa54efc95d0c9566b457ae6 d173aca830bb4c999b57fb03275dd4b4 RZ(cos(phi)) b6c09429215f4886965d950c50f3bc54--d173aca830bb4c999b57fb03275dd4b4 8a272059e8204fe99c6d2bfb22fc6e33 RZ(phi) d173aca830bb4c999b57fb03275dd4b4--8a272059e8204fe99c6d2bfb22fc6e33 f20223985bda44e091e6d04f3d5fcc8f RZ(phi) 8a272059e8204fe99c6d2bfb22fc6e33--f20223985bda44e091e6d04f3d5fcc8f 2b564444296540ebbf1d4e15c64e596f RZ(cos(phi)) f20223985bda44e091e6d04f3d5fcc8f--2b564444296540ebbf1d4e15c64e596f bbfec804cf204f32a1b09ce7ee22b217 2b564444296540ebbf1d4e15c64e596f--bbfec804cf204f32a1b09ce7ee22b217 a60eea8e73e94bb8b8edd8f8c8d949c8 X bbfec804cf204f32a1b09ce7ee22b217--a60eea8e73e94bb8b8edd8f8c8d949c8 a60eea8e73e94bb8b8edd8f8c8d949c8--0bc2b3cbce5c496f8b88f9f37071ae88 5e78f40098934be5ab981e8aad6033f6 Z a60eea8e73e94bb8b8edd8f8c8d949c8--5e78f40098934be5ab981e8aad6033f6 5e78f40098934be5ab981e8aad6033f6--5d81a45f5fa54efc95d0c9566b457ae6 <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\nblock = chain(\nkron(RX(0, theta), RY(1, theta)),\nkron(RX(0, phi), RY(1, phi)),\n)\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.6171]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.5703+0.0000j, 0.4950+0.0000j, 0.0000-0.4950j, 0.0000-0.4297j],\n[0.8421+0.0000j, 0.3647+0.0000j, 0.0000-0.3647j, 0.0000-0.1579j],\n[0.8410+0.0000j, 0.3656+0.0000j, 0.0000-0.3656j, 0.0000-0.1590j]],\ngrad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\nn_qubits = 4\ndepth = 2\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 78ccbe4ff072491fa979d887b052bb40 0 f8c997b9ae884fdd9f7f4b778a3f5b8c RX(theta\u2080) 78ccbe4ff072491fa979d887b052bb40--f8c997b9ae884fdd9f7f4b778a3f5b8c 7432f4e2a5084693a63b9177d30f6140 1 5d0d9db17d684b9cb5fa4cc1f97529a0 RY(theta\u2084) f8c997b9ae884fdd9f7f4b778a3f5b8c--5d0d9db17d684b9cb5fa4cc1f97529a0 782a577918df460ba0d6a02192bbc28f RX(theta\u2088) 5d0d9db17d684b9cb5fa4cc1f97529a0--782a577918df460ba0d6a02192bbc28f 36f354060b7e4486976335d00b42c034 782a577918df460ba0d6a02192bbc28f--36f354060b7e4486976335d00b42c034 4b0e194d2da943539f54d5b53ba0a86b 36f354060b7e4486976335d00b42c034--4b0e194d2da943539f54d5b53ba0a86b 81331c25fcf343c3996c677e7bf4a312 RX(theta\u2081\u2082) 4b0e194d2da943539f54d5b53ba0a86b--81331c25fcf343c3996c677e7bf4a312 6885b52d997344049a4a917bc11bb682 RY(theta\u2081\u2086) 81331c25fcf343c3996c677e7bf4a312--6885b52d997344049a4a917bc11bb682 6d29168f978146b397bbf7b63beed8f2 RX(theta\u2082\u2080) 6885b52d997344049a4a917bc11bb682--6d29168f978146b397bbf7b63beed8f2 f6d3c93916b04458894012ffd6b134f1 6d29168f978146b397bbf7b63beed8f2--f6d3c93916b04458894012ffd6b134f1 04f84e21891f423faa7546e09bdec101 f6d3c93916b04458894012ffd6b134f1--04f84e21891f423faa7546e09bdec101 0bc6fea1b7b3480d9ea10d8dcf7d55df 04f84e21891f423faa7546e09bdec101--0bc6fea1b7b3480d9ea10d8dcf7d55df b44f9fc7baf54fd8a8d42b5f708b06f1 f928b90f29424e0da6ae41d7b3ca56a5 RX(theta\u2081) 7432f4e2a5084693a63b9177d30f6140--f928b90f29424e0da6ae41d7b3ca56a5 290c553a1e2a4c309dbafcc54639ad25 2 93cee0a3f61b4d048c2e1c131c270621 RY(theta\u2085) f928b90f29424e0da6ae41d7b3ca56a5--93cee0a3f61b4d048c2e1c131c270621 85235df40f964184a3ca32172fbc2652 RX(theta\u2089) 93cee0a3f61b4d048c2e1c131c270621--85235df40f964184a3ca32172fbc2652 6b6c3de2dbc648b2a845d1a30a4a1b1a X 85235df40f964184a3ca32172fbc2652--6b6c3de2dbc648b2a845d1a30a4a1b1a 6b6c3de2dbc648b2a845d1a30a4a1b1a--36f354060b7e4486976335d00b42c034 34e8174119f241cda85ff646b27ae3f4 6b6c3de2dbc648b2a845d1a30a4a1b1a--34e8174119f241cda85ff646b27ae3f4 d1ca3c88478f47aca8b047958ff57cfe RX(theta\u2081\u2083) 34e8174119f241cda85ff646b27ae3f4--d1ca3c88478f47aca8b047958ff57cfe 636a0fe93e114224a910ef7a50a9ec95 RY(theta\u2081\u2087) d1ca3c88478f47aca8b047958ff57cfe--636a0fe93e114224a910ef7a50a9ec95 68d71b5d36c34d67b3b0039f7b9cac77 RX(theta\u2082\u2081) 636a0fe93e114224a910ef7a50a9ec95--68d71b5d36c34d67b3b0039f7b9cac77 fe712e475c804729922e3e8a15228be4 X 68d71b5d36c34d67b3b0039f7b9cac77--fe712e475c804729922e3e8a15228be4 fe712e475c804729922e3e8a15228be4--f6d3c93916b04458894012ffd6b134f1 05530519e5814151835a0d7ad9e204ff fe712e475c804729922e3e8a15228be4--05530519e5814151835a0d7ad9e204ff 05530519e5814151835a0d7ad9e204ff--b44f9fc7baf54fd8a8d42b5f708b06f1 69c771dfa7864e0bb791cd9dd786582b ee6fab71d5494fe58219843a6173d1f0 RX(theta\u2082) 290c553a1e2a4c309dbafcc54639ad25--ee6fab71d5494fe58219843a6173d1f0 650c9f9804594bc3a10729b947e3bbf6 3 31b3ee0e49364abb9306ad313fb568ba RY(theta\u2086) ee6fab71d5494fe58219843a6173d1f0--31b3ee0e49364abb9306ad313fb568ba 1c387c6bfd774cfd97fc445b737eb920 RX(theta\u2081\u2080) 31b3ee0e49364abb9306ad313fb568ba--1c387c6bfd774cfd97fc445b737eb920 297e746ed06b41708db7847d6dc93f4e 1c387c6bfd774cfd97fc445b737eb920--297e746ed06b41708db7847d6dc93f4e f96919dc353041d2b5e1d5d2bc4bfea3 X 297e746ed06b41708db7847d6dc93f4e--f96919dc353041d2b5e1d5d2bc4bfea3 f96919dc353041d2b5e1d5d2bc4bfea3--34e8174119f241cda85ff646b27ae3f4 1e971d49962549b4ada86156979df7ea RX(theta\u2081\u2084) f96919dc353041d2b5e1d5d2bc4bfea3--1e971d49962549b4ada86156979df7ea 616ed4212f044d12ac820ea250dce051 RY(theta\u2081\u2088) 1e971d49962549b4ada86156979df7ea--616ed4212f044d12ac820ea250dce051 d9cf7e2483774f299e30e9db66a341bf RX(theta\u2082\u2082) 616ed4212f044d12ac820ea250dce051--d9cf7e2483774f299e30e9db66a341bf 684bc1b782284773903477de13f58373 d9cf7e2483774f299e30e9db66a341bf--684bc1b782284773903477de13f58373 c5370c3dce5c409fbd7b88473bf353fc X 684bc1b782284773903477de13f58373--c5370c3dce5c409fbd7b88473bf353fc c5370c3dce5c409fbd7b88473bf353fc--05530519e5814151835a0d7ad9e204ff c5370c3dce5c409fbd7b88473bf353fc--69c771dfa7864e0bb791cd9dd786582b c54398777bf046c1ae1c5b9a2666b7d3 dc3a2631e0d54c06b4f225917cdbfd10 RX(theta\u2083) 650c9f9804594bc3a10729b947e3bbf6--dc3a2631e0d54c06b4f225917cdbfd10 c4c182f5a71341cfa9e308757dadea8e RY(theta\u2087) dc3a2631e0d54c06b4f225917cdbfd10--c4c182f5a71341cfa9e308757dadea8e d12b62576afb4da08cd4bba7f093fdf6 RX(theta\u2081\u2081) c4c182f5a71341cfa9e308757dadea8e--d12b62576afb4da08cd4bba7f093fdf6 cd12bda1966a468d9cd7a34c977ab14f X d12b62576afb4da08cd4bba7f093fdf6--cd12bda1966a468d9cd7a34c977ab14f cd12bda1966a468d9cd7a34c977ab14f--297e746ed06b41708db7847d6dc93f4e df805adbf177446f9b2db00755e5827c cd12bda1966a468d9cd7a34c977ab14f--df805adbf177446f9b2db00755e5827c 1dbaa73e765d42ffb3af3db94136a8c2 RX(theta\u2081\u2085) df805adbf177446f9b2db00755e5827c--1dbaa73e765d42ffb3af3db94136a8c2 d9d186afaf0b4899b41082e2d7b48997 RY(theta\u2081\u2089) 1dbaa73e765d42ffb3af3db94136a8c2--d9d186afaf0b4899b41082e2d7b48997 96087c78fd644f748aa75ac26e9a607a RX(theta\u2082\u2083) d9d186afaf0b4899b41082e2d7b48997--96087c78fd644f748aa75ac26e9a607a 171e59adf31a4dfca260a70b10fe5fca X 96087c78fd644f748aa75ac26e9a607a--171e59adf31a4dfca260a70b10fe5fca 171e59adf31a4dfca260a70b10fe5fca--684bc1b782284773903477de13f58373 1edaa45bc5df4db1b54ff75ee359c692 171e59adf31a4dfca260a70b10fe5fca--1edaa45bc5df4db1b54ff75ee359c692 1edaa45bc5df4db1b54ff75ee359c692--c54398777bf046c1ae1c5b9a2666b7d3 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_c1a7faa4f72546cfb204ea55812b98e0 HEA cluster_f8ed389815a74ea190a459b3ec2c779f HEA 867e9e0d34484ae295701942ef2c8f75 0 78fadf8e0a3d4ca7b935ef1b2ead3cce RX(theta\u2080) 867e9e0d34484ae295701942ef2c8f75--78fadf8e0a3d4ca7b935ef1b2ead3cce 75b00bd9a26e43efa39cfd68c05e01c2 1 f0ae3420bff2417684b40a0df4f3a28e RY(theta\u2084) 78fadf8e0a3d4ca7b935ef1b2ead3cce--f0ae3420bff2417684b40a0df4f3a28e 11103260d16e4bfa8b93c89a2de37b85 RX(theta\u2088) f0ae3420bff2417684b40a0df4f3a28e--11103260d16e4bfa8b93c89a2de37b85 9ffe669e25824cfba0be2fe3a5ff21d9 11103260d16e4bfa8b93c89a2de37b85--9ffe669e25824cfba0be2fe3a5ff21d9 177198df786644a5bdc79c3a5a3e2160 9ffe669e25824cfba0be2fe3a5ff21d9--177198df786644a5bdc79c3a5a3e2160 1ac9033d930041ae8a718d41edf000a0 RX(theta\u2081\u2082) 177198df786644a5bdc79c3a5a3e2160--1ac9033d930041ae8a718d41edf000a0 55c00bad361d4e8fb2d36d075c40760f RY(theta\u2081\u2086) 1ac9033d930041ae8a718d41edf000a0--55c00bad361d4e8fb2d36d075c40760f 862cb538f5f648cabb389680717e8fb2 RX(theta\u2082\u2080) 55c00bad361d4e8fb2d36d075c40760f--862cb538f5f648cabb389680717e8fb2 6c9e0bd995204242ad3ce01e61e4cf3d 862cb538f5f648cabb389680717e8fb2--6c9e0bd995204242ad3ce01e61e4cf3d 9d9ff0a61bb941b9bbdfd8e9a71ad2ec 6c9e0bd995204242ad3ce01e61e4cf3d--9d9ff0a61bb941b9bbdfd8e9a71ad2ec b763578e244d46e0923cc5d1ae52ab96 RX(theta\u2080) 9d9ff0a61bb941b9bbdfd8e9a71ad2ec--b763578e244d46e0923cc5d1ae52ab96 6fc16c167cac48eebf50f270f57b9b2a RY(theta\u2084) b763578e244d46e0923cc5d1ae52ab96--6fc16c167cac48eebf50f270f57b9b2a bf4d57c903604c4dbb4c21d67b05eaa5 RX(theta\u2088) 6fc16c167cac48eebf50f270f57b9b2a--bf4d57c903604c4dbb4c21d67b05eaa5 fef3fa7dd7bd4750a1c577f0cad35f2d bf4d57c903604c4dbb4c21d67b05eaa5--fef3fa7dd7bd4750a1c577f0cad35f2d 064d860fb42d49b3960a3bc3b4783b26 fef3fa7dd7bd4750a1c577f0cad35f2d--064d860fb42d49b3960a3bc3b4783b26 4e18131924934d479edade30aa000f87 RX(theta\u2081\u2082) 064d860fb42d49b3960a3bc3b4783b26--4e18131924934d479edade30aa000f87 f51dbf9b821646e68d66d0a352da1fa5 RY(theta\u2081\u2086) 4e18131924934d479edade30aa000f87--f51dbf9b821646e68d66d0a352da1fa5 cbbba78178ce412686736cd94dd00c9b RX(theta\u2082\u2080) f51dbf9b821646e68d66d0a352da1fa5--cbbba78178ce412686736cd94dd00c9b b6a32a5260dc4aeca968573b0b12d736 cbbba78178ce412686736cd94dd00c9b--b6a32a5260dc4aeca968573b0b12d736 a42f9bcd30d248f392dfa9c563c6f420 b6a32a5260dc4aeca968573b0b12d736--a42f9bcd30d248f392dfa9c563c6f420 8ad30cd83b4045459484cb6c8eb2dd75 a42f9bcd30d248f392dfa9c563c6f420--8ad30cd83b4045459484cb6c8eb2dd75 49c583a311714c078a4075dbb4f4fc01 8ec93071b4c94ebfbec2a9dd78fdaf0c RX(theta\u2081) 75b00bd9a26e43efa39cfd68c05e01c2--8ec93071b4c94ebfbec2a9dd78fdaf0c 87cd731babcd47d19029eff75b6b3d60 2 c823cbc3c0e2447ea6655ee56c86ad00 RY(theta\u2085) 8ec93071b4c94ebfbec2a9dd78fdaf0c--c823cbc3c0e2447ea6655ee56c86ad00 b64de5dddb0149dd9383a9bd87bf1591 RX(theta\u2089) c823cbc3c0e2447ea6655ee56c86ad00--b64de5dddb0149dd9383a9bd87bf1591 a0eeb32cb5904a999c5803a76a939394 X b64de5dddb0149dd9383a9bd87bf1591--a0eeb32cb5904a999c5803a76a939394 a0eeb32cb5904a999c5803a76a939394--9ffe669e25824cfba0be2fe3a5ff21d9 b109a7073987413dbf8ab60cd4128176 a0eeb32cb5904a999c5803a76a939394--b109a7073987413dbf8ab60cd4128176 1b58a9b8d7a04d879810212aaf6fbde9 RX(theta\u2081\u2083) b109a7073987413dbf8ab60cd4128176--1b58a9b8d7a04d879810212aaf6fbde9 50878e743f52480aa4d50ba4d6529446 RY(theta\u2081\u2087) 1b58a9b8d7a04d879810212aaf6fbde9--50878e743f52480aa4d50ba4d6529446 a2ae3461fc894863b8b82a112944cc64 RX(theta\u2082\u2081) 50878e743f52480aa4d50ba4d6529446--a2ae3461fc894863b8b82a112944cc64 9e2edd776da142d78484994cb756370f X a2ae3461fc894863b8b82a112944cc64--9e2edd776da142d78484994cb756370f 9e2edd776da142d78484994cb756370f--6c9e0bd995204242ad3ce01e61e4cf3d 01385c7c5d664f64bec04066fe20ed37 9e2edd776da142d78484994cb756370f--01385c7c5d664f64bec04066fe20ed37 94b552ceb2e94d39a2a6f01084223258 RX(theta\u2081) 01385c7c5d664f64bec04066fe20ed37--94b552ceb2e94d39a2a6f01084223258 7f6d0b845e56451a9870da1caac36d6f RY(theta\u2085) 94b552ceb2e94d39a2a6f01084223258--7f6d0b845e56451a9870da1caac36d6f 24239b493a394f30ba2a4771c1eb7652 RX(theta\u2089) 7f6d0b845e56451a9870da1caac36d6f--24239b493a394f30ba2a4771c1eb7652 73b330b092a7433598af2e91c1ae186a X 24239b493a394f30ba2a4771c1eb7652--73b330b092a7433598af2e91c1ae186a 73b330b092a7433598af2e91c1ae186a--fef3fa7dd7bd4750a1c577f0cad35f2d bac3a0774f744b3d9a24f1aa6fbb85f0 73b330b092a7433598af2e91c1ae186a--bac3a0774f744b3d9a24f1aa6fbb85f0 5b0283f79c4a4429bb7821be83c861a1 RX(theta\u2081\u2083) bac3a0774f744b3d9a24f1aa6fbb85f0--5b0283f79c4a4429bb7821be83c861a1 9f35f8b4906542fea5d336cdf8b55635 RY(theta\u2081\u2087) 5b0283f79c4a4429bb7821be83c861a1--9f35f8b4906542fea5d336cdf8b55635 316faba629974b68b63616c2f1eb954d RX(theta\u2082\u2081) 9f35f8b4906542fea5d336cdf8b55635--316faba629974b68b63616c2f1eb954d bebe18b985ff433ab9ab18b5f0b594fe X 316faba629974b68b63616c2f1eb954d--bebe18b985ff433ab9ab18b5f0b594fe bebe18b985ff433ab9ab18b5f0b594fe--b6a32a5260dc4aeca968573b0b12d736 52f6e7c495a04f64b3ccbc897a6e095c bebe18b985ff433ab9ab18b5f0b594fe--52f6e7c495a04f64b3ccbc897a6e095c 52f6e7c495a04f64b3ccbc897a6e095c--49c583a311714c078a4075dbb4f4fc01 1fb9357890074fbc81038e932dda074c 23b9f0291ca348dca083c015ef77b2e9 RX(theta\u2082) 87cd731babcd47d19029eff75b6b3d60--23b9f0291ca348dca083c015ef77b2e9 18d86baf14e749e29a4906c4e6360e80 3 4cc140180f1b4cd6a49b531d9eb2707d RY(theta\u2086) 23b9f0291ca348dca083c015ef77b2e9--4cc140180f1b4cd6a49b531d9eb2707d 452a3595d6e743ffb3b8630316ecef1e RX(theta\u2081\u2080) 4cc140180f1b4cd6a49b531d9eb2707d--452a3595d6e743ffb3b8630316ecef1e 5cbdd43c52b347209c90a236587b2175 452a3595d6e743ffb3b8630316ecef1e--5cbdd43c52b347209c90a236587b2175 38c6559eda4a442b965ec9e51e135af0 X 5cbdd43c52b347209c90a236587b2175--38c6559eda4a442b965ec9e51e135af0 38c6559eda4a442b965ec9e51e135af0--b109a7073987413dbf8ab60cd4128176 9e2125a2cf294b6598411be6b6585f26 RX(theta\u2081\u2084) 38c6559eda4a442b965ec9e51e135af0--9e2125a2cf294b6598411be6b6585f26 b4afdcdc82c247cb9843b52b50749f6d RY(theta\u2081\u2088) 9e2125a2cf294b6598411be6b6585f26--b4afdcdc82c247cb9843b52b50749f6d 5e126b408e8f4b63a787694cd2710c13 RX(theta\u2082\u2082) b4afdcdc82c247cb9843b52b50749f6d--5e126b408e8f4b63a787694cd2710c13 d341850780464cd88040e53b397c24eb 5e126b408e8f4b63a787694cd2710c13--d341850780464cd88040e53b397c24eb c77092c2e7b147aab9f325b300dcb49d X d341850780464cd88040e53b397c24eb--c77092c2e7b147aab9f325b300dcb49d c77092c2e7b147aab9f325b300dcb49d--01385c7c5d664f64bec04066fe20ed37 7d7200c2548c4a658781015ad645d3b1 RX(theta\u2082) c77092c2e7b147aab9f325b300dcb49d--7d7200c2548c4a658781015ad645d3b1 4854de072ee24dfa9c6820b5e519bb3a RY(theta\u2086) 7d7200c2548c4a658781015ad645d3b1--4854de072ee24dfa9c6820b5e519bb3a ad47fe46d46343e0971083c866392ced RX(theta\u2081\u2080) 4854de072ee24dfa9c6820b5e519bb3a--ad47fe46d46343e0971083c866392ced 2813caf35c964c91852504bc2db82be6 ad47fe46d46343e0971083c866392ced--2813caf35c964c91852504bc2db82be6 075a1bd3a38242f0aa5b6f7a783a6891 X 2813caf35c964c91852504bc2db82be6--075a1bd3a38242f0aa5b6f7a783a6891 075a1bd3a38242f0aa5b6f7a783a6891--bac3a0774f744b3d9a24f1aa6fbb85f0 3487466e766749e6a7845381afc2f7f1 RX(theta\u2081\u2084) 075a1bd3a38242f0aa5b6f7a783a6891--3487466e766749e6a7845381afc2f7f1 ad6757ac3a8342a5bb7484792ee9ab77 RY(theta\u2081\u2088) 3487466e766749e6a7845381afc2f7f1--ad6757ac3a8342a5bb7484792ee9ab77 84ad92fef686450b8ea05713a5c62d56 RX(theta\u2082\u2082) ad6757ac3a8342a5bb7484792ee9ab77--84ad92fef686450b8ea05713a5c62d56 368a165986ec424784173bd94e444032 84ad92fef686450b8ea05713a5c62d56--368a165986ec424784173bd94e444032 cc9d9a8caff745d6b2c332ef2ff3b448 X 368a165986ec424784173bd94e444032--cc9d9a8caff745d6b2c332ef2ff3b448 cc9d9a8caff745d6b2c332ef2ff3b448--52f6e7c495a04f64b3ccbc897a6e095c cc9d9a8caff745d6b2c332ef2ff3b448--1fb9357890074fbc81038e932dda074c aaa812e5b02046e6be28da91b6f43daf d5f28a921e8749768c2e520bb97a75b6 RX(theta\u2083) 18d86baf14e749e29a4906c4e6360e80--d5f28a921e8749768c2e520bb97a75b6 aba78a0c3f5940c1b24e96eeb837daf6 RY(theta\u2087) d5f28a921e8749768c2e520bb97a75b6--aba78a0c3f5940c1b24e96eeb837daf6 b582b62a7d2a4705be32df9b302740ff RX(theta\u2081\u2081) aba78a0c3f5940c1b24e96eeb837daf6--b582b62a7d2a4705be32df9b302740ff f6114daf53154befadb79be8eb465cb5 X b582b62a7d2a4705be32df9b302740ff--f6114daf53154befadb79be8eb465cb5 f6114daf53154befadb79be8eb465cb5--5cbdd43c52b347209c90a236587b2175 a863de42c98047f18836277fdcc1db39 f6114daf53154befadb79be8eb465cb5--a863de42c98047f18836277fdcc1db39 741c82a7ddbe48daade6f8220c601bc4 RX(theta\u2081\u2085) a863de42c98047f18836277fdcc1db39--741c82a7ddbe48daade6f8220c601bc4 f99f12399a4c421289729f94c9e608de RY(theta\u2081\u2089) 741c82a7ddbe48daade6f8220c601bc4--f99f12399a4c421289729f94c9e608de 0e9abcb4deaa415d81439aff2e78ff36 RX(theta\u2082\u2083) f99f12399a4c421289729f94c9e608de--0e9abcb4deaa415d81439aff2e78ff36 a5a34fb83cbe4449b3aa8ab4b38267df X 0e9abcb4deaa415d81439aff2e78ff36--a5a34fb83cbe4449b3aa8ab4b38267df a5a34fb83cbe4449b3aa8ab4b38267df--d341850780464cd88040e53b397c24eb abc87fa8470343d59dd39937f5cb1355 a5a34fb83cbe4449b3aa8ab4b38267df--abc87fa8470343d59dd39937f5cb1355 ebbfebeca9b54a01b7ac0fc808667574 RX(theta\u2083) abc87fa8470343d59dd39937f5cb1355--ebbfebeca9b54a01b7ac0fc808667574 b144b38c29984d3987a722aa5f6b7410 RY(theta\u2087) ebbfebeca9b54a01b7ac0fc808667574--b144b38c29984d3987a722aa5f6b7410 9b7cfe5081b4474a82c70602e86c31f5 RX(theta\u2081\u2081) b144b38c29984d3987a722aa5f6b7410--9b7cfe5081b4474a82c70602e86c31f5 5ec51fbb1c7e40dbabd067d95e0b8f6a X 9b7cfe5081b4474a82c70602e86c31f5--5ec51fbb1c7e40dbabd067d95e0b8f6a 5ec51fbb1c7e40dbabd067d95e0b8f6a--2813caf35c964c91852504bc2db82be6 e441cb737b6e415fbd43ed2238ef67b2 5ec51fbb1c7e40dbabd067d95e0b8f6a--e441cb737b6e415fbd43ed2238ef67b2 b3909253576447c3b3fb33980b16bb46 RX(theta\u2081\u2085) e441cb737b6e415fbd43ed2238ef67b2--b3909253576447c3b3fb33980b16bb46 47c24dc45bd948a2a53bf19011251304 RY(theta\u2081\u2089) b3909253576447c3b3fb33980b16bb46--47c24dc45bd948a2a53bf19011251304 12588b0f08be4d2ea8ea780defdecf8b RX(theta\u2082\u2083) 47c24dc45bd948a2a53bf19011251304--12588b0f08be4d2ea8ea780defdecf8b 12ee81c629e745c8b95fb1d9d302b59f X 12588b0f08be4d2ea8ea780defdecf8b--12ee81c629e745c8b95fb1d9d302b59f 12ee81c629e745c8b95fb1d9d302b59f--368a165986ec424784173bd94e444032 4b53c0b4e9da43dda5681cc1d40596c5 12ee81c629e745c8b95fb1d9d302b59f--4b53c0b4e9da43dda5681cc1d40596c5 4b53c0b4e9da43dda5681cc1d40596c5--aaa812e5b02046e6be28da91b6f43daf </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_28f31e5609844e37936ab6ca5cd3ce74 HEA cluster_054739ee7ad645dc962ffb578404ec18 HEA dc4c9fa7da0c4244abc9bba882766432 0 1083afa40a4449959f007a0412ddd1e4 RX(p1\u2080) dc4c9fa7da0c4244abc9bba882766432--1083afa40a4449959f007a0412ddd1e4 9425e0c7bd7b4e868d62d2ec43f19868 1 a4a51281418d4f778cb0be4546f99c02 RY(p1\u2084) 1083afa40a4449959f007a0412ddd1e4--a4a51281418d4f778cb0be4546f99c02 c1dbb765d4e44bfea2cd60cd3835e25d RX(p1\u2088) a4a51281418d4f778cb0be4546f99c02--c1dbb765d4e44bfea2cd60cd3835e25d da2c335c159b4b27a80cc20d9ecf782a c1dbb765d4e44bfea2cd60cd3835e25d--da2c335c159b4b27a80cc20d9ecf782a 3fa0b7798f3345729d98acaeae7345d7 da2c335c159b4b27a80cc20d9ecf782a--3fa0b7798f3345729d98acaeae7345d7 4f74e8cee7ca43a694e7d4d6540d5424 RX(p1\u2081\u2082) 3fa0b7798f3345729d98acaeae7345d7--4f74e8cee7ca43a694e7d4d6540d5424 4bc72f6d1e48416f88f8ed04b9e1dd0c RY(p1\u2081\u2086) 4f74e8cee7ca43a694e7d4d6540d5424--4bc72f6d1e48416f88f8ed04b9e1dd0c d0818cd3e7024a2fbbd998b7e75e2e7d RX(p1\u2082\u2080) 4bc72f6d1e48416f88f8ed04b9e1dd0c--d0818cd3e7024a2fbbd998b7e75e2e7d ba75e27a29a14f68932e4f27688e7c7a d0818cd3e7024a2fbbd998b7e75e2e7d--ba75e27a29a14f68932e4f27688e7c7a 9b00d7e4af9446978129ea5afe0e2ac5 ba75e27a29a14f68932e4f27688e7c7a--9b00d7e4af9446978129ea5afe0e2ac5 3eddee841fb24f60b4a7a45288104964 RX(p2\u2080) 9b00d7e4af9446978129ea5afe0e2ac5--3eddee841fb24f60b4a7a45288104964 24bb6701f2684ddbbeb9d9b5d926079a RY(p2\u2084) 3eddee841fb24f60b4a7a45288104964--24bb6701f2684ddbbeb9d9b5d926079a 20bf3cb7693b49289b075950a6575103 RX(p2\u2088) 24bb6701f2684ddbbeb9d9b5d926079a--20bf3cb7693b49289b075950a6575103 81cbc1e00b57438b89220002b263b988 20bf3cb7693b49289b075950a6575103--81cbc1e00b57438b89220002b263b988 bd51e959c35d45eb92955ea2a7398a6d 81cbc1e00b57438b89220002b263b988--bd51e959c35d45eb92955ea2a7398a6d ea275d375bac4414892d74263b85b329 RX(p2\u2081\u2082) bd51e959c35d45eb92955ea2a7398a6d--ea275d375bac4414892d74263b85b329 e7298177a53d4704b2d1d9a9eac4a228 RY(p2\u2081\u2086) ea275d375bac4414892d74263b85b329--e7298177a53d4704b2d1d9a9eac4a228 2b755f54705b4e10bfc88528346b42b4 RX(p2\u2082\u2080) e7298177a53d4704b2d1d9a9eac4a228--2b755f54705b4e10bfc88528346b42b4 bced6b45374f465390b3bdd193a23714 2b755f54705b4e10bfc88528346b42b4--bced6b45374f465390b3bdd193a23714 0c392da75c564cb289ca09f1be843ecb bced6b45374f465390b3bdd193a23714--0c392da75c564cb289ca09f1be843ecb ddb1ac28251c4542884c03aa7b1238a3 0c392da75c564cb289ca09f1be843ecb--ddb1ac28251c4542884c03aa7b1238a3 a01e51abb39c48f2bd194921df858c4e 3f717a2e519a4a9ea833293531cff8ee RX(p1\u2081) 9425e0c7bd7b4e868d62d2ec43f19868--3f717a2e519a4a9ea833293531cff8ee a9c1e1e6a031407f8539da36a282859a 2 d56b9145a34348e083e74cca05608845 RY(p1\u2085) 3f717a2e519a4a9ea833293531cff8ee--d56b9145a34348e083e74cca05608845 4e7edeace4af42b194c99905f27ae950 RX(p1\u2089) d56b9145a34348e083e74cca05608845--4e7edeace4af42b194c99905f27ae950 de9caa4e44d44335846f9ed3d0d8fbdc X 4e7edeace4af42b194c99905f27ae950--de9caa4e44d44335846f9ed3d0d8fbdc de9caa4e44d44335846f9ed3d0d8fbdc--da2c335c159b4b27a80cc20d9ecf782a 4c63579cc4254841a39e1d582d99d7c6 de9caa4e44d44335846f9ed3d0d8fbdc--4c63579cc4254841a39e1d582d99d7c6 a5741bcea78c486bbecf3a9760ba2297 RX(p1\u2081\u2083) 4c63579cc4254841a39e1d582d99d7c6--a5741bcea78c486bbecf3a9760ba2297 803d0025ffa34a76ab576d278469a9ce RY(p1\u2081\u2087) a5741bcea78c486bbecf3a9760ba2297--803d0025ffa34a76ab576d278469a9ce 6d78c0f42a9345f992b4132b4a669433 RX(p1\u2082\u2081) 803d0025ffa34a76ab576d278469a9ce--6d78c0f42a9345f992b4132b4a669433 44309d13d0a843ab869df202004cf2ff X 6d78c0f42a9345f992b4132b4a669433--44309d13d0a843ab869df202004cf2ff 44309d13d0a843ab869df202004cf2ff--ba75e27a29a14f68932e4f27688e7c7a 05e78b3f3ce041d4b14b7bed55855ba0 44309d13d0a843ab869df202004cf2ff--05e78b3f3ce041d4b14b7bed55855ba0 ccd9ff295ae24b47a53cd2180f6ad3fb RX(p2\u2081) 05e78b3f3ce041d4b14b7bed55855ba0--ccd9ff295ae24b47a53cd2180f6ad3fb 0ddc5927723b43d0a017b5b59c2d0dc1 RY(p2\u2085) ccd9ff295ae24b47a53cd2180f6ad3fb--0ddc5927723b43d0a017b5b59c2d0dc1 926b4496bdfc48c09a65982d7630b925 RX(p2\u2089) 0ddc5927723b43d0a017b5b59c2d0dc1--926b4496bdfc48c09a65982d7630b925 ae6f985fa7624750a0832e41b7592ba0 X 926b4496bdfc48c09a65982d7630b925--ae6f985fa7624750a0832e41b7592ba0 ae6f985fa7624750a0832e41b7592ba0--81cbc1e00b57438b89220002b263b988 d25e4a004e2d469896f082ab814d5f1b ae6f985fa7624750a0832e41b7592ba0--d25e4a004e2d469896f082ab814d5f1b bcbca67f2c31408ea0d62f81824a51fa RX(p2\u2081\u2083) d25e4a004e2d469896f082ab814d5f1b--bcbca67f2c31408ea0d62f81824a51fa 1171efcfbe0944aca6703d1586fe7bcf RY(p2\u2081\u2087) bcbca67f2c31408ea0d62f81824a51fa--1171efcfbe0944aca6703d1586fe7bcf 6d7eed4cece34dd2a27f8ab4319f143f RX(p2\u2082\u2081) 1171efcfbe0944aca6703d1586fe7bcf--6d7eed4cece34dd2a27f8ab4319f143f 5f4ccc8e19204e50a39bad0c745db7fa X 6d7eed4cece34dd2a27f8ab4319f143f--5f4ccc8e19204e50a39bad0c745db7fa 5f4ccc8e19204e50a39bad0c745db7fa--bced6b45374f465390b3bdd193a23714 585a362e6fb44965932b6604a3ad34c4 5f4ccc8e19204e50a39bad0c745db7fa--585a362e6fb44965932b6604a3ad34c4 585a362e6fb44965932b6604a3ad34c4--a01e51abb39c48f2bd194921df858c4e 344bc19e28c7470682ce8add79139a2d 68fd42cc4b504c2a8b96a2d1c17ae90c RX(p1\u2082) a9c1e1e6a031407f8539da36a282859a--68fd42cc4b504c2a8b96a2d1c17ae90c 9009f27c35714aa39cd27bab6c7fd0f1 3 a4f008af8027457f8f5dbcd448f38122 RY(p1\u2086) 68fd42cc4b504c2a8b96a2d1c17ae90c--a4f008af8027457f8f5dbcd448f38122 188af2ca8ee14181a0420b0f550ff36f RX(p1\u2081\u2080) a4f008af8027457f8f5dbcd448f38122--188af2ca8ee14181a0420b0f550ff36f eb72661b670e415881a7fa99f2e6a567 188af2ca8ee14181a0420b0f550ff36f--eb72661b670e415881a7fa99f2e6a567 4b76a2a3c6c548a7bfb0bfff92b25ec3 X eb72661b670e415881a7fa99f2e6a567--4b76a2a3c6c548a7bfb0bfff92b25ec3 4b76a2a3c6c548a7bfb0bfff92b25ec3--4c63579cc4254841a39e1d582d99d7c6 e480f9e5d22e440a88f554a56210347f RX(p1\u2081\u2084) 4b76a2a3c6c548a7bfb0bfff92b25ec3--e480f9e5d22e440a88f554a56210347f 9a568d21f0e74f4489e04733f123f26b RY(p1\u2081\u2088) e480f9e5d22e440a88f554a56210347f--9a568d21f0e74f4489e04733f123f26b 0d823681473a47638967f74b2281a167 RX(p1\u2082\u2082) 9a568d21f0e74f4489e04733f123f26b--0d823681473a47638967f74b2281a167 6d0fb181377e469892e2bd40008903c2 0d823681473a47638967f74b2281a167--6d0fb181377e469892e2bd40008903c2 ccde59b54887429280669bc05369bb21 X 6d0fb181377e469892e2bd40008903c2--ccde59b54887429280669bc05369bb21 ccde59b54887429280669bc05369bb21--05e78b3f3ce041d4b14b7bed55855ba0 8b485b3a1be34d95865f8cb70de75194 RX(p2\u2082) ccde59b54887429280669bc05369bb21--8b485b3a1be34d95865f8cb70de75194 ee102f91b9564476b8aea00fbbba0581 RY(p2\u2086) 8b485b3a1be34d95865f8cb70de75194--ee102f91b9564476b8aea00fbbba0581 2cfc3c70170441d297e25ae567330e2d RX(p2\u2081\u2080) ee102f91b9564476b8aea00fbbba0581--2cfc3c70170441d297e25ae567330e2d a7fb9fb0bfd9428cb640209146dd0db3 2cfc3c70170441d297e25ae567330e2d--a7fb9fb0bfd9428cb640209146dd0db3 0e98f758202d4d3494902d919c4c86d0 X a7fb9fb0bfd9428cb640209146dd0db3--0e98f758202d4d3494902d919c4c86d0 0e98f758202d4d3494902d919c4c86d0--d25e4a004e2d469896f082ab814d5f1b 2678325a5b4c44d8b6420ed50d7b9dce RX(p2\u2081\u2084) 0e98f758202d4d3494902d919c4c86d0--2678325a5b4c44d8b6420ed50d7b9dce dbe0769cc2f94062a1d22cfb155557cb RY(p2\u2081\u2088) 2678325a5b4c44d8b6420ed50d7b9dce--dbe0769cc2f94062a1d22cfb155557cb a22ec04d2fad4a44a0f3f3ac244dea4c RX(p2\u2082\u2082) dbe0769cc2f94062a1d22cfb155557cb--a22ec04d2fad4a44a0f3f3ac244dea4c c1207884ded44249874c801df4baaa16 a22ec04d2fad4a44a0f3f3ac244dea4c--c1207884ded44249874c801df4baaa16 ba9ee60d96164f2b952d233cf33d827a X c1207884ded44249874c801df4baaa16--ba9ee60d96164f2b952d233cf33d827a ba9ee60d96164f2b952d233cf33d827a--585a362e6fb44965932b6604a3ad34c4 ba9ee60d96164f2b952d233cf33d827a--344bc19e28c7470682ce8add79139a2d 92ece065b9454acea027484a54392d98 35007b8f49dd45aa95289bfdbf9c296c RX(p1\u2083) 9009f27c35714aa39cd27bab6c7fd0f1--35007b8f49dd45aa95289bfdbf9c296c 78c757730d3446d5be7720af140c7b5e RY(p1\u2087) 35007b8f49dd45aa95289bfdbf9c296c--78c757730d3446d5be7720af140c7b5e bc8b907581504cfa9bddd850271bce18 RX(p1\u2081\u2081) 78c757730d3446d5be7720af140c7b5e--bc8b907581504cfa9bddd850271bce18 1559714596c643bd899df09e9e437926 X bc8b907581504cfa9bddd850271bce18--1559714596c643bd899df09e9e437926 1559714596c643bd899df09e9e437926--eb72661b670e415881a7fa99f2e6a567 bb017b3669094ceaa9fa817d03616d15 1559714596c643bd899df09e9e437926--bb017b3669094ceaa9fa817d03616d15 ba200b87cf6445b2935307a0d574e97a RX(p1\u2081\u2085) bb017b3669094ceaa9fa817d03616d15--ba200b87cf6445b2935307a0d574e97a f34e1d04d6a64bfaa95881b31ce994e7 RY(p1\u2081\u2089) ba200b87cf6445b2935307a0d574e97a--f34e1d04d6a64bfaa95881b31ce994e7 069e79b384674cf3ab646a16ef423ec9 RX(p1\u2082\u2083) f34e1d04d6a64bfaa95881b31ce994e7--069e79b384674cf3ab646a16ef423ec9 94c0536499d94b42933acbc2b524c8f9 X 069e79b384674cf3ab646a16ef423ec9--94c0536499d94b42933acbc2b524c8f9 94c0536499d94b42933acbc2b524c8f9--6d0fb181377e469892e2bd40008903c2 cf63ac783e8b46c0a82eda7829b3d20c 94c0536499d94b42933acbc2b524c8f9--cf63ac783e8b46c0a82eda7829b3d20c 09b363e6da1e440caee6182f87cf84a5 RX(p2\u2083) cf63ac783e8b46c0a82eda7829b3d20c--09b363e6da1e440caee6182f87cf84a5 2b1ab8d000c646de989dfd042c903802 RY(p2\u2087) 09b363e6da1e440caee6182f87cf84a5--2b1ab8d000c646de989dfd042c903802 fb1155e5cd88451a81cf2e2ec2fae07c RX(p2\u2081\u2081) 2b1ab8d000c646de989dfd042c903802--fb1155e5cd88451a81cf2e2ec2fae07c e5e7e498e85745dab67f9378ac8be531 X fb1155e5cd88451a81cf2e2ec2fae07c--e5e7e498e85745dab67f9378ac8be531 e5e7e498e85745dab67f9378ac8be531--a7fb9fb0bfd9428cb640209146dd0db3 d5fd5d6f270745a5bfeb25469452a1f4 e5e7e498e85745dab67f9378ac8be531--d5fd5d6f270745a5bfeb25469452a1f4 554e0fc13be646499b6302525b8d57c4 RX(p2\u2081\u2085) d5fd5d6f270745a5bfeb25469452a1f4--554e0fc13be646499b6302525b8d57c4 71a0da834768451e9afaa439e9878f62 RY(p2\u2081\u2089) 554e0fc13be646499b6302525b8d57c4--71a0da834768451e9afaa439e9878f62 1bd3fcc8b1534dfcb7481960afe850d3 RX(p2\u2082\u2083) 71a0da834768451e9afaa439e9878f62--1bd3fcc8b1534dfcb7481960afe850d3 f7eaf4c4ae0144bc844c83d74a1e3bc5 X 1bd3fcc8b1534dfcb7481960afe850d3--f7eaf4c4ae0144bc844c83d74a1e3bc5 f7eaf4c4ae0144bc844c83d74a1e3bc5--c1207884ded44249874c801df4baaa16 94df4382f3064e5da2b530700b6dccaa f7eaf4c4ae0144bc844c83d74a1e3bc5--94df4382f3064e5da2b530700b6dccaa 94df4382f3064e5da2b530700b6dccaa--92ece065b9454acea027484a54392d98 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9406])), ('theta_0', tensor([0.7951])), ('theta_1', tensor([0.3345])), ('theta_10', tensor([0.8927])), ('theta_11', tensor([0.3210])), ('theta_12', tensor([0.3358])), ('theta_13', tensor([0.6445])), ('theta_14', tensor([0.1183])), ('theta_15', tensor([0.8274])), ('theta_16', tensor([0.6881])), ('theta_17', tensor([0.5928])), ('theta_18', tensor([0.2551])), ('theta_19', tensor([0.3500])), ('theta_2', tensor([0.3125])), ('theta_20', tensor([0.5327])), ('theta_21', tensor([0.0981])), ('theta_22', tensor([0.1385])), ('theta_23', tensor([0.6408])), ('theta_3', tensor([0.4979])), ('theta_4', tensor([0.4264])), ('theta_5', tensor([0.5154])), ('theta_6', tensor([0.6589])), ('theta_7', tensor([0.1994])), ('theta_8', tensor([0.9758])), ('theta_9', tensor([0.9689]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9396])), ('theta_0', tensor([0.7941])), ('theta_1', tensor([0.3335])), ('theta_10', tensor([0.8937])), ('theta_11', tensor([0.3200])), ('theta_12', tensor([0.3348])), ('theta_13', tensor([0.6435])), ('theta_14', tensor([0.1193])), ('theta_15', tensor([0.8264])), ('theta_16', tensor([0.6891])), ('theta_17', tensor([0.5918])), ('theta_18', tensor([0.2561])), ('theta_19', tensor([0.3510])), ('theta_2', tensor([0.3135])), ('theta_20', tensor([0.5317])), ('theta_21', tensor([0.0971])), ('theta_22', tensor([0.1395])), ('theta_23', tensor([0.6398])), ('theta_3', tensor([0.4969])), ('theta_4', tensor([0.4254])), ('theta_5', tensor([0.5144])), ('theta_6', tensor([0.6579])), ('theta_7', tensor([0.2004])), ('theta_8', tensor([0.9748])), ('theta_9', tensor([0.9679]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows to compose with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution with non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\nx = Parameter(\"x\")\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = QuantumCircuit(\n(operations): ModuleList(\n(0): QuantumCircuit(\n(operations): ModuleList(\n(0): ParametricPyQOperation(\n(operation): RX(qubits=(0,), n_qubits=2)\n)\n(1): ParametricPyQOperation(\n(operation): RX(qubits=(1,), n_qubits=2)\n)\n)\n)\n)\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9940+0.0000j,  0.0000-0.0774j,  0.0000-0.0774j, -0.0060+0.0000j],\n[ 0.8271+0.0000j,  0.0000-0.3781j,  0.0000-0.3781j, -0.1729+0.0000j],\n[ 0.9494+0.0000j,  0.0000-0.2191j,  0.0000-0.2191j, -0.0506+0.0000j]])\nxs = [Counter({'00': 98, '01': 1, '10': 1}), Counter({'00': 67, '01': 18, '10': 13, '11': 2}), Counter({'00': 86, '01': 7, '10': 6, '11': 1})]\nex = tensor([[0.9879],\n[0.6543],\n[0.8988]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9879, 0.9879],\n[0.6543, 0.6543],\n[0.8988, 0.8988]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the machine learning tools section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-10-17T16:40:07.974056 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code>:</p> <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2, 3)\nreg.draw(show=False)\n</code></pre> 2023-10-17T16:40:08.354063 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Arbitrarily shaped registers can be constructed by providing coordinates.</p> <p>Registers defined from coordinates</p> <p><code>Register</code> constructed via the <code>from_coordinates</code> method do not define edges in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\nreg = Register.from_coordinates(\n[(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\nreg.draw(show=False)\n</code></pre> 2023-10-17T16:40:08.459091 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>Qubits coordinates in Qadence are dimensionless but converted to the required unit when executed on a backend. For instance, Pulser uses \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often asssumed in simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interaction must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>It is possible to customize qubit interaction through the <code>add_interaction</code> method. In that case, <code>Register.coords</code> are accessible from the concrete graph:</p> <pre><code>print(f\"{reg.coords = }\")\n</code></pre> <pre><code>reg.coords = {0: (0.0, 0.0), 1: (0.0, 1.0), 2: (1.0, 0.0), 3: (1.0, 1.0), 4: (2.0, 0.0), 5: (2.0, 1.0)}\n</code></pre> <p>More details about their usage in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\nn_qubits = 4\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'01': 58, '00': 42})]\nSample in little endian = [Counter({'00': 52, '10': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'10': 58, '00': 42})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nCNOT matrix in little endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care for automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\nOn PyQTorch = [Counter({'00': 87, '01': 13})]\nOn Braket = [Counter({'00': 80, '01': 20})]\nOn Pulser = [Counter({'00': 87, '01': 13})]\nSame wavefunction order:\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9223+0.0000j, 0.0000-0.3865j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n# Check the normalization.\nassert is_normalized(state)\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\nstate = [0.21959765+0.97559053j 0.        +0.j         0.        +0.j\n0.        +0.j        ]\nProduct state corresponding to bitstring '01':\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n# Let's now prepare a circuit.\nn_qubits = 4\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_b2a6c26dbdf64fd4b00e5380f93930c2 Circuit block cluster_d8e287e3976b4f438f18262ef93e45d5 Prep block 820d31832a9d4dbaa66f146d8b403984 0 11d8281b3b214d3abd66b8d29f311a56 820d31832a9d4dbaa66f146d8b403984--11d8281b3b214d3abd66b8d29f311a56 eb706d54fffa41ee9add246cee12959d 1 4ebfe6b7664f48939c3626a36f4d166b RX(theta\u2080) 11d8281b3b214d3abd66b8d29f311a56--4ebfe6b7664f48939c3626a36f4d166b 9221bb8a2f5f43309f2fd47d52e3822d RY(theta\u2084) 4ebfe6b7664f48939c3626a36f4d166b--9221bb8a2f5f43309f2fd47d52e3822d fda12a8edc334e29bcf83ddc0d7bb22c RX(theta\u2088) 9221bb8a2f5f43309f2fd47d52e3822d--fda12a8edc334e29bcf83ddc0d7bb22c d94f4ea30c624235bccf5b13f7a8caf0 fda12a8edc334e29bcf83ddc0d7bb22c--d94f4ea30c624235bccf5b13f7a8caf0 d47f0bd5374e4930bb227d60034aa7e0 d94f4ea30c624235bccf5b13f7a8caf0--d47f0bd5374e4930bb227d60034aa7e0 ed3260f1ccd34ecb9fd3ec2ad3a02050 RX(theta\u2081\u2082) d47f0bd5374e4930bb227d60034aa7e0--ed3260f1ccd34ecb9fd3ec2ad3a02050 759f0f9c50ae4e31aea38e0b7f01052c RY(theta\u2081\u2086) ed3260f1ccd34ecb9fd3ec2ad3a02050--759f0f9c50ae4e31aea38e0b7f01052c 8942fab441354249abe85742f1ed7454 RX(theta\u2082\u2080) 759f0f9c50ae4e31aea38e0b7f01052c--8942fab441354249abe85742f1ed7454 d0acce4b19d64b4abe3b7b77fd4723d4 8942fab441354249abe85742f1ed7454--d0acce4b19d64b4abe3b7b77fd4723d4 472b3ff838844ffa997717a553ecf0e2 d0acce4b19d64b4abe3b7b77fd4723d4--472b3ff838844ffa997717a553ecf0e2 0d6c771d7d5b430e811f9e65e9444d6c 472b3ff838844ffa997717a553ecf0e2--0d6c771d7d5b430e811f9e65e9444d6c d8bedd372c234d0ba6c97ef82f7aa375 49a521e7ef584d4a8aa5ccabd5c7b716 eb706d54fffa41ee9add246cee12959d--49a521e7ef584d4a8aa5ccabd5c7b716 c2ae9ce2f50f47d3886257ac8b91a14f 2 1e7951661dca41959214b137634c074c RX(theta\u2081) 49a521e7ef584d4a8aa5ccabd5c7b716--1e7951661dca41959214b137634c074c a46e750a9dbf4dceaaee95606936ca85 RY(theta\u2085) 1e7951661dca41959214b137634c074c--a46e750a9dbf4dceaaee95606936ca85 7c5636755ce94dfd8430e78df1bac95a RX(theta\u2089) a46e750a9dbf4dceaaee95606936ca85--7c5636755ce94dfd8430e78df1bac95a 73716b629f004146ab9f84c204aea2b6 X 7c5636755ce94dfd8430e78df1bac95a--73716b629f004146ab9f84c204aea2b6 73716b629f004146ab9f84c204aea2b6--d94f4ea30c624235bccf5b13f7a8caf0 e3d55fffe1ab4184868a0e54b5b502d9 73716b629f004146ab9f84c204aea2b6--e3d55fffe1ab4184868a0e54b5b502d9 b19400da4f3f4fa4a2d4ca2de461d9d3 RX(theta\u2081\u2083) e3d55fffe1ab4184868a0e54b5b502d9--b19400da4f3f4fa4a2d4ca2de461d9d3 14735dfcf5b5418b978f39dc9b407e3e RY(theta\u2081\u2087) b19400da4f3f4fa4a2d4ca2de461d9d3--14735dfcf5b5418b978f39dc9b407e3e 49ea3879139a4951af7144146bac57fd RX(theta\u2082\u2081) 14735dfcf5b5418b978f39dc9b407e3e--49ea3879139a4951af7144146bac57fd eeced7fd594a4d30a8312e53e2ebf126 X 49ea3879139a4951af7144146bac57fd--eeced7fd594a4d30a8312e53e2ebf126 eeced7fd594a4d30a8312e53e2ebf126--d0acce4b19d64b4abe3b7b77fd4723d4 f1c81b95af444298b8d0a88158696cb5 eeced7fd594a4d30a8312e53e2ebf126--f1c81b95af444298b8d0a88158696cb5 f1c81b95af444298b8d0a88158696cb5--d8bedd372c234d0ba6c97ef82f7aa375 786df64f6c20453f91709677b256e414 f1b53c8a2c8e4e30994a47decde9d3f0 c2ae9ce2f50f47d3886257ac8b91a14f--f1b53c8a2c8e4e30994a47decde9d3f0 6f99cd072e5f460f97f8f59fff6c3397 3 d0ccdbf02e58477ebfc60661f8a17a62 RX(theta\u2082) f1b53c8a2c8e4e30994a47decde9d3f0--d0ccdbf02e58477ebfc60661f8a17a62 a4f701c367a74208943954fad096226c RY(theta\u2086) d0ccdbf02e58477ebfc60661f8a17a62--a4f701c367a74208943954fad096226c 194c551782ef46a4856cc04bb7a2f44c RX(theta\u2081\u2080) a4f701c367a74208943954fad096226c--194c551782ef46a4856cc04bb7a2f44c f0e78c47dc3e4add8e9e206b54b524ff 194c551782ef46a4856cc04bb7a2f44c--f0e78c47dc3e4add8e9e206b54b524ff a366e04f47aa43ef9b1b3cd3a31c3ced X f0e78c47dc3e4add8e9e206b54b524ff--a366e04f47aa43ef9b1b3cd3a31c3ced a366e04f47aa43ef9b1b3cd3a31c3ced--e3d55fffe1ab4184868a0e54b5b502d9 0ae5b39cd42b4f3c984ce0973f78c193 RX(theta\u2081\u2084) a366e04f47aa43ef9b1b3cd3a31c3ced--0ae5b39cd42b4f3c984ce0973f78c193 96918e3b7ed44b2b8812157423c1e35a RY(theta\u2081\u2088) 0ae5b39cd42b4f3c984ce0973f78c193--96918e3b7ed44b2b8812157423c1e35a 2680b796edd6458aa1a182bf281695ff RX(theta\u2082\u2082) 96918e3b7ed44b2b8812157423c1e35a--2680b796edd6458aa1a182bf281695ff c2c60f096b534f24b77844209bf6377e 2680b796edd6458aa1a182bf281695ff--c2c60f096b534f24b77844209bf6377e 17be9f5cdbac4b57b46267b8d4e42e0e X c2c60f096b534f24b77844209bf6377e--17be9f5cdbac4b57b46267b8d4e42e0e 17be9f5cdbac4b57b46267b8d4e42e0e--f1c81b95af444298b8d0a88158696cb5 17be9f5cdbac4b57b46267b8d4e42e0e--786df64f6c20453f91709677b256e414 6a9ece07573a441e98eb9cc14a627aad e3e6494842e04ac5b6fb54962270d56e X 6f99cd072e5f460f97f8f59fff6c3397--e3e6494842e04ac5b6fb54962270d56e 06641eaa25c847308dcf0af1f52edc88 RX(theta\u2083) e3e6494842e04ac5b6fb54962270d56e--06641eaa25c847308dcf0af1f52edc88 9b3bae6861ce4861aea521f3a1bfe6b6 RY(theta\u2087) 06641eaa25c847308dcf0af1f52edc88--9b3bae6861ce4861aea521f3a1bfe6b6 9f990fb106744f20a069947dd3e8ee9d RX(theta\u2081\u2081) 9b3bae6861ce4861aea521f3a1bfe6b6--9f990fb106744f20a069947dd3e8ee9d faf3e6e957614f31aea8a4ac3eeb0049 X 9f990fb106744f20a069947dd3e8ee9d--faf3e6e957614f31aea8a4ac3eeb0049 faf3e6e957614f31aea8a4ac3eeb0049--f0e78c47dc3e4add8e9e206b54b524ff 7273d4fc64874cef9409c742ccd3f70c faf3e6e957614f31aea8a4ac3eeb0049--7273d4fc64874cef9409c742ccd3f70c 8dc81683fa1d4710a05a71152e3842cb RX(theta\u2081\u2085) 7273d4fc64874cef9409c742ccd3f70c--8dc81683fa1d4710a05a71152e3842cb 308cb3ce5ecf49729bd39ef8866e4ce5 RY(theta\u2081\u2089) 8dc81683fa1d4710a05a71152e3842cb--308cb3ce5ecf49729bd39ef8866e4ce5 1ed05a6ba2e34b808a840a345232f761 RX(theta\u2082\u2083) 308cb3ce5ecf49729bd39ef8866e4ce5--1ed05a6ba2e34b808a840a345232f761 0af88a8da04243d9b50459d36385fcc1 X 1ed05a6ba2e34b808a840a345232f761--0af88a8da04243d9b50459d36385fcc1 0af88a8da04243d9b50459d36385fcc1--c2c60f096b534f24b77844209bf6377e c4f28775f104493eafd4e253f91cc272 0af88a8da04243d9b50459d36385fcc1--c4f28775f104493eafd4e253f91cc272 c4f28775f104493eafd4e253f91cc272--6a9ece07573a441e98eb9cc14a627aad  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\nn_qubits = 3\nbatch_size = 2\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = tensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j],\n[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j]])\nZero state = tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nRandom state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = tensor([[-0.4733+0.0588j, -0.3286+0.0288j, -0.0680+0.3754j, -0.3299-0.1679j,\n0.0818+0.2296j, -0.2771-0.2593j, -0.0508+0.0349j,  0.1995-0.3662j],\n[-0.2293+0.0824j, -0.0980-0.0311j, -0.0049-0.1667j,  0.5866+0.3335j,\n0.1787+0.1656j,  0.0792-0.1512j, -0.5753+0.0789j,  0.1434-0.0244j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\nn_qubits = 3\nuniform_block = uniform_block(n_qubits)\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\nproduct_block = product_block(\"100\")\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 CNOT(1,2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\nn_qubits = 3\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}