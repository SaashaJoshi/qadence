{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>For a high-level overview of Qadence features, check out our white paper.</p> <p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from qadence import X, Y, HamEvo, Register, product_state, sample, add, PI\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = PI / (2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from qadence import Register, AnalogRX, sample, PI\n\n# Global analog RX block.\nblock = AnalogRX(PI)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(PI))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 45, '01': 30, '10': 25})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@article{qadence2024pasqal,\n  title = {Qadence: a differentiable interface for digital-analog programs.},\n  author={Dominik Seitz and Niklas Heim and Jo\u00e3o P. Moutinho and Roland Guichard and Vytautas Abramavicius and Aleksander Wennersteen and Gert-Jan Both and Anton Quelle and Caroline de Groot and Gergana V. Velikova and Vincent E. Elfving and Mario Dagrada},\n  journal={arXiv:2401.09915},\n  url = {https://github.com/pasqal-io/qadence},\n  year = {2024}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    def _is_feature_param(p: Parameter) -&gt; bool:\n        return not p.trainable and not p.is_number\n\n    if observable is None:\n        self.inputs = list(filter(_is_feature_param, circuit.unique_parameters))\n    else:\n        uparams = unique_parameters(chain(circuit.block, *observable))\n        self.inputs = list(filter(_is_feature_param, uparams))\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/","title":"Advanced Tutorials","text":"<p>In this section, advanced programming concepts and implementations in Qadence are examplified.</p>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available via the PyQTorch or Horqrux backends</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> or <code>horqrux</code> backends are selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#adjoint-differentiation","title":"Adjoint Differentiation","text":"<p>Qadence also offers a memory-efficient, non-device compatible alternative to automatic differentation, called 'Adjoint Differentiation' <sup>4</sup> and allows for precisely calculating the gradients of variational parameters in O(P) time and using O(1) state-vectors. Adjoint Differentation is currently only supported by the Torch Engine and allows for first-order derivatives only.</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the differentiation modes can be selected via the <code>diff_mode</code> argument of the QuantumModel class. It either accepts a <code>DiffMode</code>(<code>DiffMode.GSPR</code>, <code>DiffMode.AD</code> or <code>DiffMode.ADJOINT</code>) or a string (<code>\"gpsr\"\"</code>, <code>\"ad\"</code> or <code>\"adjoint\"</code>). The code in the box below shows how to create <code>QuantumModel</code> instances with all available differentiation modes.</p> <pre><code>from qadence import (FeatureParameter, RX, Z, hea, chain,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# Define a symbolic parameter to differentiate with respect to\nx = FeatureParameter(\"x\")\n\nblock = chain(hea(n_qubits, 1), RX(0, x))\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD, ADJOINT and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_adjoint = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.ADJOINT)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# Create concrete values for the parameter we want to differentiate with respect to\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_adjoint = model_adjoint.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_adjoint = torch.autograd.grad(\n    exp_val_adjoint, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD ,ADJOINT and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_adjoint.detach().numpy(),\n           label=\"df/dx ADJOINT\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2024-02-01T16:33:02.973220 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence.engines.torch import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#low-level-differentiation-of-qadence-circuits-using-jax","title":"Low-level differentiation of qadence circuits using JAX","text":"<p>For users interested in using the <code>JAX</code> engine instead, we show how to run and differentiate qadence programs using the <code>horqrux</code> backend under qadence examples.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> <li> <p>Tyson et al., Efficient calculation of gradients in classical simulations of variational quantum algorithms \u21a9</p> </li> </ol>"},{"location":"advanced_tutorials/projectors/","title":"Projector blocks","text":"<p>This section introduces the <code>ProjectorBlock</code> as an implementation for the quantum mechanical projection operation onto the subspace spanned by \\(|a\\rangle\\): \\(\\mathbb{\\hat{P}}=|a\\rangle \\langle a|\\). It evaluates the outer product for bras and kets expressed as bitstrings for a given qubit support. They have to possess matching lengths.</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence.operations import Projector  # Projector as an operation.\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# As any block, the matrix representation can be retrieved.\nprojector_matrix = block_to_tensor(projector_block)\n</code></pre> <pre><code>projector matrix = tensor([[[0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\n</code></pre> <p>Other standard operations are expressed as projectors in Qadence. For instance, the number operator is the projector onto the 1-subspace, \\(N=|1\\rangle\\langle 1|\\).</p> <p>In fact, projectors can be used to compose any arbitrary operator. For example, the <code>CNOT</code> can be defined as \\(\\textrm{CNOT}(i,j)=|0\\rangle\\langle 0|_i\\otimes \\mathbb{I}_j+|1\\rangle\\langle 1|_i\\otimes X_j\\) and we can compare its matrix representation with the native one in Qadence:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import kron, I, X, CNOT\n\n# Define a projector for |0&gt; onto the qubit labelled 0.\nprojector0 = Projector(ket=\"0\", bra=\"0\", qubit_support=0)\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector1 = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# Construct the projector controlled CNOT.\nprojector_cnot = kron(projector0, I(1)) + kron(projector1, X(1))\n\n# Get the underlying unitary.\nprojector_cnot_matrix = block_to_tensor(projector_cnot)\n\n# Qadence CNOT unitary.\nqadence_cnot_matrix = block_to_tensor(CNOT(0,1))\n</code></pre> <pre><code>projector cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nqadence cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> <p>Another example is the canonical SWAP unitary that can be defined as \\(SWAP=|00\\rangle\\langle 00|+|01\\rangle\\langle 10|+|10\\rangle\\langle 01|+|11\\rangle\\langle 11|\\). Indeed, it can be shown that their matricial representations are again identical:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import SWAP\n\n# Define all projectors.\nprojector00 = Projector(ket=\"00\", bra=\"00\", qubit_support=(0, 1))\nprojector01 = Projector(ket=\"01\", bra=\"10\", qubit_support=(0, 1))\nprojector10 = Projector(ket=\"10\", bra=\"01\", qubit_support=(0, 1))\nprojector11 = Projector(ket=\"11\", bra=\"11\", qubit_support=(0, 1))\n\n# Construct the SWAP gate.\nprojector_swap = projector00 + projector10 + projector01 + projector11\n\n# Get the underlying unitary.\nprojector_swap_matrix = block_to_tensor(projector_swap)\n\n# Qadence SWAP unitary.\nqadence_swap_matrix = block_to_tensor(SWAP(0,1))\n</code></pre> <pre><code>projector swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]])\nqadence swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]], grad_fn=&lt;UnsafeViewBackward0&gt;)\n</code></pre> <p>Warning</p> <p>Projectors are non-unitary operators, only supported by the PyQTorch backend.</p> <p>To examplify this point, let's run some non-unitary computation involving projectors.</p> <pre><code>from qadence import chain, run\nfrom qadence.operations import H, CNOT\n\n# Define a projector for |1&gt; onto the qubit labelled 1.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=1)\n\n# Some non-unitary computation.\nnon_unitary_block = chain(H(0), CNOT(0,1), projector_block)\n\n# Projected wavefunction becomes unnormalized\nprojected_wf = run(non_unitary_block)  # Run on PyQTorch.\n</code></pre> <pre><code>projected_wf = tensor([[0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>supports_adjoint</code> <p>Does the backend support native adjoint differentation.</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p> <code>native_endianness</code> <p>The native endianness of the backend</p> <p> TYPE: <code>Endianness</code> </p> <code>engine</code> <p>The underlying (native) automatic differentiation engine of the backend.</p> <p> TYPE: <code>Engine</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: ArrayLike | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, InteractionBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine TORCH.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.TORCH, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine JAX.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.JAX, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = self.backend.expectation(circuit, observable, param_values, state)\n    else:\n        expectation = DifferentiableExpectation(\n            backend=self.backend,\n            circuit=circuit,\n            observable=observable,\n            param_values=param_values,\n            state=state,\n            measurement=measurement,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        ).psr()\n    return expectation\n</code></pre>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Qadence offers both a PyTorch and Jax differentiation engine.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are applied by implementing a custom <code>torch.autograd.Function</code> class for PyTorch and the <code>custom_vjp</code> in the Jax Engine, respectively.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> under <code>qadence.engines.torch.differentiable_expectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 975e9fb630194f998c7e303e03fcd4f7 0 98b66c154b78454eae8b261dd1a0d6d5 X 975e9fb630194f998c7e303e03fcd4f7--98b66c154b78454eae8b261dd1a0d6d5 623e4a962864440191a1f5b297b5ebd8 1 e9417827a7d846379322ea339e4de98d 98b66c154b78454eae8b261dd1a0d6d5--e9417827a7d846379322ea339e4de98d 1c251abf488040268a1ba82129744503 a85c88709452494686c6be2851f2f354 Y 623e4a962864440191a1f5b297b5ebd8--a85c88709452494686c6be2851f2f354 a85c88709452494686c6be2851f2f354--1c251abf488040268a1ba82129744503 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 d2456767f7524ce79acf6aeb72dd31d9 0 5da963bad738465f9e751aae846ad876 X d2456767f7524ce79acf6aeb72dd31d9--5da963bad738465f9e751aae846ad876 643466d3a1ea4dcaae7fa5b65e204d7c Y 5da963bad738465f9e751aae846ad876--643466d3a1ea4dcaae7fa5b65e204d7c 4254a6cb3fe04bdf88f9f3667b36919f 643466d3a1ea4dcaae7fa5b65e204d7c--4254a6cb3fe04bdf88f9f3667b36919f <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 0a6879c2056d4911888b7fa42bcc4e1b 0 acc3324157c84351866928ecb9bcb534 X 0a6879c2056d4911888b7fa42bcc4e1b--acc3324157c84351866928ecb9bcb534 7a892da641da499fb3e41ff9a5635589 1 94e3f8900160442681857c9e18644987 acc3324157c84351866928ecb9bcb534--94e3f8900160442681857c9e18644987 82a3aac0625a4cf19cd03a7e9b332491 94e3f8900160442681857c9e18644987--82a3aac0625a4cf19cd03a7e9b332491 f236344ab56542c499ee9fa616170c1e c639a8202a5448ad809f596d1e3aa428 7a892da641da499fb3e41ff9a5635589--c639a8202a5448ad809f596d1e3aa428 3122c24bb5b64cd8bf6d6e80c8c44cd4 Y c639a8202a5448ad809f596d1e3aa428--3122c24bb5b64cd8bf6d6e80c8c44cd4 3122c24bb5b64cd8bf6d6e80c8c44cd4--f236344ab56542c499ee9fa616170c1e <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_cce40fe5f60f439a8acbb966edbd05dc cbf3fc2cd0f543a388eb505255daf482 0 ae0c843482fb420fad1491ff82b8eeff cbf3fc2cd0f543a388eb505255daf482--ae0c843482fb420fad1491ff82b8eeff 102ea05d1088459baa1f94513d9356f1 1 9f015b0b108545f7a0a1a6756ee7479a ae0c843482fb420fad1491ff82b8eeff--9f015b0b108545f7a0a1a6756ee7479a 7c93267e44024b13a86af71814f21a4f 4ab4194972824cf09b618e6ea91d8f42 AddBlock 102ea05d1088459baa1f94513d9356f1--4ab4194972824cf09b618e6ea91d8f42 c0508a4f7a134272b48dcc8b4c5eb907 2 4ab4194972824cf09b618e6ea91d8f42--7c93267e44024b13a86af71814f21a4f 616c51dde1c44d9daec29b14a6d5ed97 2b10b05f67b141198bd8a0262a9baecc c0508a4f7a134272b48dcc8b4c5eb907--2b10b05f67b141198bd8a0262a9baecc 2b10b05f67b141198bd8a0262a9baecc--616c51dde1c44d9daec29b14a6d5ed97 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_a2966e43b8a942408458b4595ac714f0 cluster_704dfddf502741a6b65254ad08785a4f rx 0eb2fa1850fa46f099383748ce69807e 0 748ad1037ecd486d9209f9fe9aaabeb6 X 0eb2fa1850fa46f099383748ce69807e--748ad1037ecd486d9209f9fe9aaabeb6 7673c5251ae74306a62771b04ab43df5 1 2e1eafca55c4427e9d22c3a3c07399b9 748ad1037ecd486d9209f9fe9aaabeb6--2e1eafca55c4427e9d22c3a3c07399b9 3e6872d33e65449fb6618d5665af3e30 2e1eafca55c4427e9d22c3a3c07399b9--3e6872d33e65449fb6618d5665af3e30 2dfb840bfee746e1b8eda020cd5f6801 3e6872d33e65449fb6618d5665af3e30--2dfb840bfee746e1b8eda020cd5f6801 39578fc2d89146289f09a1df5cc70a34 eab4ae98eed9442bbfb35abc576f465d Y 7673c5251ae74306a62771b04ab43df5--eab4ae98eed9442bbfb35abc576f465d 44fbab3a0d6f42988398bfa263aaf362 2 880cf2d60e9b4d6d9cc090a4a4c1cd7a eab4ae98eed9442bbfb35abc576f465d--880cf2d60e9b4d6d9cc090a4a4c1cd7a c779a69785974b168825fd2588aa7816 HamEvo 880cf2d60e9b4d6d9cc090a4a4c1cd7a--c779a69785974b168825fd2588aa7816 c779a69785974b168825fd2588aa7816--39578fc2d89146289f09a1df5cc70a34 0755ad5eaa3e4752a1b8214b29a54dbf 79ad6aa0870843b894ecc360c3ceedab RX(x) 44fbab3a0d6f42988398bfa263aaf362--79ad6aa0870843b894ecc360c3ceedab a3eaaf77ee854b8391af1e425fba92e1 3 4fe46a1cb0074e7682decc4ea903182e 79ad6aa0870843b894ecc360c3ceedab--4fe46a1cb0074e7682decc4ea903182e 1b53c123e4264fb4b8619302fdca3fd5 t = 10 4fe46a1cb0074e7682decc4ea903182e--1b53c123e4264fb4b8619302fdca3fd5 1b53c123e4264fb4b8619302fdca3fd5--0755ad5eaa3e4752a1b8214b29a54dbf 88a4932813e64ad3998d818a3f1562f2 8dfad00c678f43909dfe8ed9afefed04 RX(0.5) a3eaaf77ee854b8391af1e425fba92e1--8dfad00c678f43909dfe8ed9afefed04 5ee6932cb2514513ac43885d39e7ee2a X 8dfad00c678f43909dfe8ed9afefed04--5ee6932cb2514513ac43885d39e7ee2a 5ee6932cb2514513ac43885d39e7ee2a--4fe46a1cb0074e7682decc4ea903182e cfc9e5e165be4555bd8f3cdf53dec92f 5ee6932cb2514513ac43885d39e7ee2a--cfc9e5e165be4555bd8f3cdf53dec92f cfc9e5e165be4555bd8f3cdf53dec92f--88a4932813e64ad3998d818a3f1562f2 <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_2fdf06a6c26740d2998487ca88f5faa8 HEA cluster_c9520587f8e743ab93ef44ed6022370b Tower Fourier FM 12c54c7cc9924afa82f52d03b2469a6e 0 b7242a4b5dca4d9ca7a384b3279d7c2b RX(1.0*phi) 12c54c7cc9924afa82f52d03b2469a6e--b7242a4b5dca4d9ca7a384b3279d7c2b 4fdb147bc96a4a23b2ae9ecc1b668067 1 dedbb4bfce4b4092b1b259f5bbd47652 RX(theta\u2080) b7242a4b5dca4d9ca7a384b3279d7c2b--dedbb4bfce4b4092b1b259f5bbd47652 163d4aa45e164104b754c6b473906eaa RY(theta\u2084) dedbb4bfce4b4092b1b259f5bbd47652--163d4aa45e164104b754c6b473906eaa 1eea000439694ce0ad154b380c1fb88f RX(theta\u2088) 163d4aa45e164104b754c6b473906eaa--1eea000439694ce0ad154b380c1fb88f cbebf1ca79da4ff196caf68d61151ea1 1eea000439694ce0ad154b380c1fb88f--cbebf1ca79da4ff196caf68d61151ea1 e438877a7ae6451086d4ef7d3cc9cb77 cbebf1ca79da4ff196caf68d61151ea1--e438877a7ae6451086d4ef7d3cc9cb77 fb95f07cf80c4c4099190dcf3d762852 RX(theta\u2081\u2082) e438877a7ae6451086d4ef7d3cc9cb77--fb95f07cf80c4c4099190dcf3d762852 5b535624eadb493393fc957167682766 RY(theta\u2081\u2086) fb95f07cf80c4c4099190dcf3d762852--5b535624eadb493393fc957167682766 4d00a26d3422455388d6958721b3c394 RX(theta\u2082\u2080) 5b535624eadb493393fc957167682766--4d00a26d3422455388d6958721b3c394 f2577348972a428abc7712ca05a8661d 4d00a26d3422455388d6958721b3c394--f2577348972a428abc7712ca05a8661d 80f812d332ab4f099b9adc93b6c29b70 f2577348972a428abc7712ca05a8661d--80f812d332ab4f099b9adc93b6c29b70 5df393af961f4191ae9b61ed54bcea8b 80f812d332ab4f099b9adc93b6c29b70--5df393af961f4191ae9b61ed54bcea8b bc0538e4aeca43ca8fd19e9acc6f714d 606a7bbe7baa4c5a82b82c69deadc3d0 RX(2.0*phi) 4fdb147bc96a4a23b2ae9ecc1b668067--606a7bbe7baa4c5a82b82c69deadc3d0 bf719c49338646c59e614569e4dcfd08 2 9f481faacea642839068cc9db7a2d082 RX(theta\u2081) 606a7bbe7baa4c5a82b82c69deadc3d0--9f481faacea642839068cc9db7a2d082 fcbff30ba5f84052ab4befe1581c095b RY(theta\u2085) 9f481faacea642839068cc9db7a2d082--fcbff30ba5f84052ab4befe1581c095b 9e24324b439d48358150b417a3ef3bd1 RX(theta\u2089) fcbff30ba5f84052ab4befe1581c095b--9e24324b439d48358150b417a3ef3bd1 f11cb107c4ec4cd99f662d9d4877764b X 9e24324b439d48358150b417a3ef3bd1--f11cb107c4ec4cd99f662d9d4877764b f11cb107c4ec4cd99f662d9d4877764b--cbebf1ca79da4ff196caf68d61151ea1 ff4f4820257a448ab7e9abaf3068b7d3 f11cb107c4ec4cd99f662d9d4877764b--ff4f4820257a448ab7e9abaf3068b7d3 4dcf72a2b24943b692fd7544edcee576 RX(theta\u2081\u2083) ff4f4820257a448ab7e9abaf3068b7d3--4dcf72a2b24943b692fd7544edcee576 e2fd79e110df4ba99457bcc05a01d61b RY(theta\u2081\u2087) 4dcf72a2b24943b692fd7544edcee576--e2fd79e110df4ba99457bcc05a01d61b cf9d26d653e24bf6b66d1c673d25af0f RX(theta\u2082\u2081) e2fd79e110df4ba99457bcc05a01d61b--cf9d26d653e24bf6b66d1c673d25af0f 97c7cdc345d8485f94e6608e43a514cc X cf9d26d653e24bf6b66d1c673d25af0f--97c7cdc345d8485f94e6608e43a514cc 97c7cdc345d8485f94e6608e43a514cc--f2577348972a428abc7712ca05a8661d 7150e7ec41444addb2ab532646b5b2f8 97c7cdc345d8485f94e6608e43a514cc--7150e7ec41444addb2ab532646b5b2f8 7150e7ec41444addb2ab532646b5b2f8--bc0538e4aeca43ca8fd19e9acc6f714d e68a60b0fff04d979c0f8735730fcff5 08561f0088774556bdf9cdcee9d9a5a5 RX(3.0*phi) bf719c49338646c59e614569e4dcfd08--08561f0088774556bdf9cdcee9d9a5a5 aa39f78ddad04639ac5d27b01e2f17c4 3 6e7af41136974e45a99fee411f44881a RX(theta\u2082) 08561f0088774556bdf9cdcee9d9a5a5--6e7af41136974e45a99fee411f44881a 8f89d2afea904a4693dc77e3807ce0c2 RY(theta\u2086) 6e7af41136974e45a99fee411f44881a--8f89d2afea904a4693dc77e3807ce0c2 716d544c43284c5284a59d489eb7f4fd RX(theta\u2081\u2080) 8f89d2afea904a4693dc77e3807ce0c2--716d544c43284c5284a59d489eb7f4fd b4be06f1bab54e379b7eb31dcd07c8f8 716d544c43284c5284a59d489eb7f4fd--b4be06f1bab54e379b7eb31dcd07c8f8 ae8c33d98aed49b6969beefbe94c5ff3 X b4be06f1bab54e379b7eb31dcd07c8f8--ae8c33d98aed49b6969beefbe94c5ff3 ae8c33d98aed49b6969beefbe94c5ff3--ff4f4820257a448ab7e9abaf3068b7d3 cf540057831b43948955f6be00ef6958 RX(theta\u2081\u2084) ae8c33d98aed49b6969beefbe94c5ff3--cf540057831b43948955f6be00ef6958 dad802c2beb1447b8eefd0506ff58ae9 RY(theta\u2081\u2088) cf540057831b43948955f6be00ef6958--dad802c2beb1447b8eefd0506ff58ae9 3f558ce6c9e44e49b7a9f08e3ce68115 RX(theta\u2082\u2082) dad802c2beb1447b8eefd0506ff58ae9--3f558ce6c9e44e49b7a9f08e3ce68115 9fca6fbf9aed4f8083c24075746ddcd1 3f558ce6c9e44e49b7a9f08e3ce68115--9fca6fbf9aed4f8083c24075746ddcd1 bda31928fd294aafa41ba5171e75ab6f X 9fca6fbf9aed4f8083c24075746ddcd1--bda31928fd294aafa41ba5171e75ab6f bda31928fd294aafa41ba5171e75ab6f--7150e7ec41444addb2ab532646b5b2f8 bda31928fd294aafa41ba5171e75ab6f--e68a60b0fff04d979c0f8735730fcff5 ddb41e3727eb4773b47207c19c01d00c caac9a11cc364775b66fa79d52e18e81 RX(4.0*phi) aa39f78ddad04639ac5d27b01e2f17c4--caac9a11cc364775b66fa79d52e18e81 f2458854fa92413ca9ca8896e8b426ab RX(theta\u2083) caac9a11cc364775b66fa79d52e18e81--f2458854fa92413ca9ca8896e8b426ab d729737b25f343da96f1104658df3378 RY(theta\u2087) f2458854fa92413ca9ca8896e8b426ab--d729737b25f343da96f1104658df3378 5ba3e36c631648e89c2b02bcad217f15 RX(theta\u2081\u2081) d729737b25f343da96f1104658df3378--5ba3e36c631648e89c2b02bcad217f15 2b60034df5c14da2b21b83b83a1a6d24 X 5ba3e36c631648e89c2b02bcad217f15--2b60034df5c14da2b21b83b83a1a6d24 2b60034df5c14da2b21b83b83a1a6d24--b4be06f1bab54e379b7eb31dcd07c8f8 a455df58ef3a4fe5bc11de151a126078 2b60034df5c14da2b21b83b83a1a6d24--a455df58ef3a4fe5bc11de151a126078 04d4545b85914cf8a10d833b7b4eff6d RX(theta\u2081\u2085) a455df58ef3a4fe5bc11de151a126078--04d4545b85914cf8a10d833b7b4eff6d 4dccf2106f9644108ae46f389fbfd589 RY(theta\u2081\u2089) 04d4545b85914cf8a10d833b7b4eff6d--4dccf2106f9644108ae46f389fbfd589 c58c37f3a7c84ad7b2d13eb2a8c0b71d RX(theta\u2082\u2083) 4dccf2106f9644108ae46f389fbfd589--c58c37f3a7c84ad7b2d13eb2a8c0b71d 9ff9ff21930240b2b46666f84be40d36 X c58c37f3a7c84ad7b2d13eb2a8c0b71d--9ff9ff21930240b2b46666f84be40d36 9ff9ff21930240b2b46666f84be40d36--9fca6fbf9aed4f8083c24075746ddcd1 682b5105d3d749378aa5782295c3bed3 9ff9ff21930240b2b46666f84be40d36--682b5105d3d749378aa5782295c3bed3 682b5105d3d749378aa5782295c3bed3--ddb41e3727eb4773b47207c19c01d00c <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_4e0663b43c4a4ec0b256c53bd797d2b9 Obs. cluster_0d5e7a7584324c9f84e1d0c0c7d6fcff cluster_e4cbe1910fc54fdd9c833003d9963693 HEA dabc0005d13342e98222a270444521c8 0 7977ce72819d44c5afef68d7c1a5b2fe RX(theta\u2080) dabc0005d13342e98222a270444521c8--7977ce72819d44c5afef68d7c1a5b2fe 3e3fcf87965642e1ad41d1d7ddb48efb 1 3c65dbd053c54bb49d640c1ea84bb5d6 RY(theta\u2083) 7977ce72819d44c5afef68d7c1a5b2fe--3c65dbd053c54bb49d640c1ea84bb5d6 fe3d285468b8437099372c2fd7ab1311 RX(theta\u2086) 3c65dbd053c54bb49d640c1ea84bb5d6--fe3d285468b8437099372c2fd7ab1311 8788fc2763684e91b8e09037cbdeae6c fe3d285468b8437099372c2fd7ab1311--8788fc2763684e91b8e09037cbdeae6c edd74cfc812e4f3282cac5d8cd7ddc56 8788fc2763684e91b8e09037cbdeae6c--edd74cfc812e4f3282cac5d8cd7ddc56 18ede7ad4da34aeb8afac30406dd83e7 RX(theta\u2089) edd74cfc812e4f3282cac5d8cd7ddc56--18ede7ad4da34aeb8afac30406dd83e7 6941e32a8eba4de7940b4180ee782a9a RY(theta\u2081\u2082) 18ede7ad4da34aeb8afac30406dd83e7--6941e32a8eba4de7940b4180ee782a9a bcce54d01eaa45cf8c6e61aaf4235355 RX(theta\u2081\u2085) 6941e32a8eba4de7940b4180ee782a9a--bcce54d01eaa45cf8c6e61aaf4235355 ac1937421fc34946be57f47579aa3020 bcce54d01eaa45cf8c6e61aaf4235355--ac1937421fc34946be57f47579aa3020 8dfef556c02d4b82bd5c485b36eade3f ac1937421fc34946be57f47579aa3020--8dfef556c02d4b82bd5c485b36eade3f eb99520f6aa442279145160333f36a10 8dfef556c02d4b82bd5c485b36eade3f--eb99520f6aa442279145160333f36a10 5a54d2ba1f874cc5bf06f9be30e0c0ed eb99520f6aa442279145160333f36a10--5a54d2ba1f874cc5bf06f9be30e0c0ed dc9cbd1fa90a41268fa09dea88729811 5c1aa502a705461d974f69160a7a6e2e RX(theta\u2081) 3e3fcf87965642e1ad41d1d7ddb48efb--5c1aa502a705461d974f69160a7a6e2e 5a2d5239626a4679a23e7911cbd0dda6 2 d52c13aeb1d54a49bfc42b9f19665e17 RY(theta\u2084) 5c1aa502a705461d974f69160a7a6e2e--d52c13aeb1d54a49bfc42b9f19665e17 750fb2159cfb427499f272fd2a577304 RX(theta\u2087) d52c13aeb1d54a49bfc42b9f19665e17--750fb2159cfb427499f272fd2a577304 e7affec99cbf46aab6e86519f91240fd X 750fb2159cfb427499f272fd2a577304--e7affec99cbf46aab6e86519f91240fd e7affec99cbf46aab6e86519f91240fd--8788fc2763684e91b8e09037cbdeae6c 4aa5ba43a58d4f18a434236feb3c5937 e7affec99cbf46aab6e86519f91240fd--4aa5ba43a58d4f18a434236feb3c5937 bc891fffcb034f21a93143e904479640 RX(theta\u2081\u2080) 4aa5ba43a58d4f18a434236feb3c5937--bc891fffcb034f21a93143e904479640 50e64a25a6ea41948b99720b577caeee RY(theta\u2081\u2083) bc891fffcb034f21a93143e904479640--50e64a25a6ea41948b99720b577caeee 2c21980e9aed4b8abe2d9e676ba69eec RX(theta\u2081\u2086) 50e64a25a6ea41948b99720b577caeee--2c21980e9aed4b8abe2d9e676ba69eec 52cc7ef0492147a1b7b912b2966b6ed3 X 2c21980e9aed4b8abe2d9e676ba69eec--52cc7ef0492147a1b7b912b2966b6ed3 52cc7ef0492147a1b7b912b2966b6ed3--ac1937421fc34946be57f47579aa3020 484f7e8ba41c4fb68f2ab19659ece007 52cc7ef0492147a1b7b912b2966b6ed3--484f7e8ba41c4fb68f2ab19659ece007 4ff51ece704449ba8fdf2b480e7f53c0 AddBlock 484f7e8ba41c4fb68f2ab19659ece007--4ff51ece704449ba8fdf2b480e7f53c0 4ff51ece704449ba8fdf2b480e7f53c0--dc9cbd1fa90a41268fa09dea88729811 d869d3442fe747a39bdb5c52e88cb279 bf2c4684b8f54b69b33344fd013f85c7 RX(theta\u2082) 5a2d5239626a4679a23e7911cbd0dda6--bf2c4684b8f54b69b33344fd013f85c7 1684e4d4c19747f3a496bd506cc22671 RY(theta\u2085) bf2c4684b8f54b69b33344fd013f85c7--1684e4d4c19747f3a496bd506cc22671 c73ae50ff7494a6b889b79f0909ddc1b RX(theta\u2088) 1684e4d4c19747f3a496bd506cc22671--c73ae50ff7494a6b889b79f0909ddc1b e11c43b156ee4aa6912fc2c5536ac875 c73ae50ff7494a6b889b79f0909ddc1b--e11c43b156ee4aa6912fc2c5536ac875 213803f050444b7ebbaea2f4d2cd7988 X e11c43b156ee4aa6912fc2c5536ac875--213803f050444b7ebbaea2f4d2cd7988 213803f050444b7ebbaea2f4d2cd7988--4aa5ba43a58d4f18a434236feb3c5937 3f7176915e39489a8cab88623b3512c2 RX(theta\u2081\u2081) 213803f050444b7ebbaea2f4d2cd7988--3f7176915e39489a8cab88623b3512c2 537e4468889f471598ffc5e16ed3425c RY(theta\u2081\u2084) 3f7176915e39489a8cab88623b3512c2--537e4468889f471598ffc5e16ed3425c 151bb920ce6548dcb044dde695aea9f8 RX(theta\u2081\u2087) 537e4468889f471598ffc5e16ed3425c--151bb920ce6548dcb044dde695aea9f8 8babd87fc8824205bc016412ee110c37 151bb920ce6548dcb044dde695aea9f8--8babd87fc8824205bc016412ee110c37 6d55d4c195dd4cf2b69d65477011c827 X 8babd87fc8824205bc016412ee110c37--6d55d4c195dd4cf2b69d65477011c827 6d55d4c195dd4cf2b69d65477011c827--484f7e8ba41c4fb68f2ab19659ece007 5d4af627eb1b4c81a143972988628954 6d55d4c195dd4cf2b69d65477011c827--5d4af627eb1b4c81a143972988628954 5d4af627eb1b4c81a143972988628954--d869d3442fe747a39bdb5c52e88cb279 <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 b09b4b65e72448e888a4d40e734a7c61 0 2d3014272ae240ddb8ac8da00900264a b09b4b65e72448e888a4d40e734a7c61--2d3014272ae240ddb8ac8da00900264a 1e9ee163ea6148ad9717bd05a3b82e78 1 87d37d7bdc6a49b2bfa323327471caa2 95ad3b7c52df46a1acfdb3b1654703c5 2d3014272ae240ddb8ac8da00900264a--95ad3b7c52df46a1acfdb3b1654703c5 954eaccec63b4fb78d107deda9fb4a0e 87d37d7bdc6a49b2bfa323327471caa2--954eaccec63b4fb78d107deda9fb4a0e 596cd67f7bbd46fc82df6be325264d79 61b720c3c7094ac88851498c7c24b062 954eaccec63b4fb78d107deda9fb4a0e--61b720c3c7094ac88851498c7c24b062 0715c0cbe8d94ee883ff1e6aa61b8555 596cd67f7bbd46fc82df6be325264d79--0715c0cbe8d94ee883ff1e6aa61b8555 b977962fa7d543168641394bc56c4c89 c4edb60a8bc74ee7a57af2e68b51e76f 1e9ee163ea6148ad9717bd05a3b82e78--c4edb60a8bc74ee7a57af2e68b51e76f f358e7e57bf544b88312c25a0faabbb2 2 c4edb60a8bc74ee7a57af2e68b51e76f--87d37d7bdc6a49b2bfa323327471caa2 32f3e2dc93314e259bf266180b75db30 95ad3b7c52df46a1acfdb3b1654703c5--32f3e2dc93314e259bf266180b75db30 d97b6afdfe1e4a35abfb8cc8738e70b7 32f3e2dc93314e259bf266180b75db30--d97b6afdfe1e4a35abfb8cc8738e70b7 d97b6afdfe1e4a35abfb8cc8738e70b7--b977962fa7d543168641394bc56c4c89 9276ab86a80b4d5f847826c96c7418db 614ba9591a35444b87cc4b885c132d6d f358e7e57bf544b88312c25a0faabbb2--614ba9591a35444b87cc4b885c132d6d 286e26dab4604b5fb0a721933ae17214 3 fdd1393d4f2a4606a79474dc00ef2300 614ba9591a35444b87cc4b885c132d6d--fdd1393d4f2a4606a79474dc00ef2300 bb46b4941159482f860a8c5cc0f6d6cd fdd1393d4f2a4606a79474dc00ef2300--bb46b4941159482f860a8c5cc0f6d6cd ccea621380a54f3ba2165c4c852b67ad bb46b4941159482f860a8c5cc0f6d6cd--ccea621380a54f3ba2165c4c852b67ad ccea621380a54f3ba2165c4c852b67ad--9276ab86a80b4d5f847826c96c7418db a536aed4b3ea464aab719beeff704201 35b33061e1e0456a86b400b88879a193 286e26dab4604b5fb0a721933ae17214--35b33061e1e0456a86b400b88879a193 80644202bd95406388e5de2d93b50028 35b33061e1e0456a86b400b88879a193--80644202bd95406388e5de2d93b50028 46488dffb04947b2a2c344b2f3eea823 80644202bd95406388e5de2d93b50028--46488dffb04947b2a2c344b2f3eea823 46488dffb04947b2a2c344b2f3eea823--596cd67f7bbd46fc82df6be325264d79 61b720c3c7094ac88851498c7c24b062--a536aed4b3ea464aab719beeff704201 <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 29bfa083a45c4ba18ba4dfe10125ec8e 0 5c5f1092a6664020b5db1eed1c8076ed 29bfa083a45c4ba18ba4dfe10125ec8e--5c5f1092a6664020b5db1eed1c8076ed bfb0c073e944497dae5710e44a0c2c37 1 061bdc8665024be18a8af3ab37e74225 5c5f1092a6664020b5db1eed1c8076ed--061bdc8665024be18a8af3ab37e74225 459325817e6d4bba8a6855ba18df8310 061bdc8665024be18a8af3ab37e74225--459325817e6d4bba8a6855ba18df8310 f71acefe480145b089fc5b43988f58ad 459325817e6d4bba8a6855ba18df8310--f71acefe480145b089fc5b43988f58ad 89f7830b4a804cc699defcb8e6c60ada d1d127a9609946c1bda425f66f662589 PHASE(0.5) bfb0c073e944497dae5710e44a0c2c37--d1d127a9609946c1bda425f66f662589 433ff64d02014124ac47a16d9964a432 2 d1d127a9609946c1bda425f66f662589--5c5f1092a6664020b5db1eed1c8076ed 78e0f1d575f94e90bc953b0fecb986f3 d1d127a9609946c1bda425f66f662589--78e0f1d575f94e90bc953b0fecb986f3 daabcb97bb754cdda39547e6625fc258 78e0f1d575f94e90bc953b0fecb986f3--daabcb97bb754cdda39547e6625fc258 daabcb97bb754cdda39547e6625fc258--89f7830b4a804cc699defcb8e6c60ada 07423a99c38a4e8b9eb2ea97f88048be f2de79490561430a987a4b30cfae11de 433ff64d02014124ac47a16d9964a432--f2de79490561430a987a4b30cfae11de 8b8b1beab46c4f2f9ab18c1376b01a3a 3 d5bb6c91bb1041c88a4f1bdd71ccdd88 PHASE(0.5) f2de79490561430a987a4b30cfae11de--d5bb6c91bb1041c88a4f1bdd71ccdd88 d5bb6c91bb1041c88a4f1bdd71ccdd88--061bdc8665024be18a8af3ab37e74225 7b2db619f8cf48dda5d7ef9a8d23b50d d5bb6c91bb1041c88a4f1bdd71ccdd88--7b2db619f8cf48dda5d7ef9a8d23b50d 7b2db619f8cf48dda5d7ef9a8d23b50d--07423a99c38a4e8b9eb2ea97f88048be 5a692d2d48ca45e7a974fe1ebd0deebc f5581d0d92634bed9a95068258ff1fde 8b8b1beab46c4f2f9ab18c1376b01a3a--f5581d0d92634bed9a95068258ff1fde 22e154255b284efe91054954e13f3f29 f5581d0d92634bed9a95068258ff1fde--22e154255b284efe91054954e13f3f29 c1eef41fb2d24f47ab5d772fd9cf5de9 PHASE(0.5) 22e154255b284efe91054954e13f3f29--c1eef41fb2d24f47ab5d772fd9cf5de9 c1eef41fb2d24f47ab5d772fd9cf5de9--459325817e6d4bba8a6855ba18df8310 c1eef41fb2d24f47ab5d772fd9cf5de9--5a692d2d48ca45e7a974fe1ebd0deebc"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from qadence import AnalogRot, PI\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = PI, # [rad/\u03bcs]\n    delta = PI, # [rad/\u03bcs]\n    phase = PI, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run, PI\nfrom qadence.analog.constants import C6_DICT\nfrom math import cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = PI\ndelta = PI\nphase = PI\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run, PI\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = PI\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>AnalogInteraction</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, AnalogInteraction, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = AnalogInteraction(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction, PI\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * PI * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * PI * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice, PI\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = PI)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>AnalogInteraction</code> operation initializes an <code>InteractionBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = QubitSupportType.GLOBAL</code>. However, composing blocks using <code>kron</code> with local qubit supports and different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, AnalogInteraction\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    AnalogInteraction(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    AnalogInteraction(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    AnalogInteraction(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2024-02-01T16:33:07.118753 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook, we solve a quadratic unconstrained binary optimization (QUBO) problem with Qadence. QUBOs are very popular combinatorial optimization problems with a wide range of applications. Here, we solve the problem using the QAOA <sup>1</sup> variational algorithm by embedding the QUBO problem weights onto a register as standard for neutral atom quantum devices.</p> <p>Additional background information on QUBOs can be found here, directly solved using the pulse-level interface Pulser.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: optimal register coordinates for embedding the QUBO problem <p>A basic ingredient for solving a QUBO problem with a neutral atom device is to embed the problem onto the atomic register. In short, embedding algorithms cast the problem onto a graph mapped onto the register by optimally finding atomic coordinates. A discussion on the embedding algorithms is beyond the scope of this tutorial and a simplified version taken from here is added below.</p> <p><pre><code>import numpy as np\nimport numpy.typing as npt\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom qadence import RydbergDevice\n\ndef qubo_register_coords(Q: np.ndarray, device: RydbergDevice) -&gt; list:\n    \"\"\"Compute coordinates for register.\"\"\"\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        interaction_coeff = device.rydberg_level\n        new_Q = squareform(interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <p>With the embedding routine under our belt, let's start by adding the required imports and ensure the reproducibility of this tutorial.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRX, AnalogRZ, chain\nfrom qadence.ml_tools import train_gradient_free, TrainConfig, num_parameters\nimport nevergrad as ng\nimport matplotlib.pyplot as plt\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted edges and a cost function to be optimized. The weighted edges are represented by a real-valued symmetric matrix <code>Q</code> which is used throughout the tutorial.</p> <pre><code># QUBO problem weights (real-value symmetric matrix)\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n\ndef loss(model: QuantumModel, *args) -&gt; tuple[float, dict]:\n    to_arr_fn = lambda bitstring: np.array(list(bitstring), dtype=int)\n    cost_fn = lambda arr: arr.T @ Q @ arr\n    samples = model.sample({}, n_shots=1000)[0]  # extract samples\n    cost_fn = sum(samples[key] * cost_fn(to_arr_fn(key)) for key in samples)\n    return cost_fn / sum(samples.values()), {}  # We return an optional metrics dict\n</code></pre> <p>The QAOA algorithm needs a variational quantum circuit with optimizable parameters. For that purpose, we use a fully analog circuit composed of two global rotations per layer on different axes of the Bloch sphere. The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian <sup>1</sup>. In this setting, the embedding is realized by the appropriate register coordinates and the resulting qubit interaction.</p> Rydberg level <p>The Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in the original tutorial, and set the device specifications with the updated Rydberg level.</p> <pre><code># Device specification and atomic register\ndevice = RydbergDevice(rydberg_level=70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q, device), device_specs=device\n)\n\n# Analog variational quantum circuit\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\ncircuit = QuantumCircuit(reg, block)\n</code></pre> <pre><code>\n</code></pre> <p>By feeding the circuit to a <code>QuantumModel</code> we can check the initial counts where no clear solution can be found:</p> <pre><code>model = QuantumModel(circuit)\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'01000': 197, '00001': 193, '00010': 189, '00100': 174, '10000': 169, '00000': 78})\n</code></pre> <p>Finally, we can proceed with the variational optimization. The cost function defined above is derived from bitstring computations and therefore non differentiable. We use Qadence ML facilities to run gradient-free optimizations using the <code>nevergrad</code> library.</p> <pre><code>config = TrainConfig(max_iter=100)\noptimizer = ng.optimizers.NGOpt(\n    budget=config.max_iter, parametrization=num_parameters(model)\n)\ntrain_gradient_free(model, None, optimizer, config, loss)\n\noptimal_counts = model.sample({}, n_shots=1000)[0]\n</code></pre>   optimal_count = Counter({'00100': 191, '10000': 190, '00001': 183, '01000': 181, '00010': 163, '00000': 92})    <p>Finally, let's plot the solution. The expected bitstrings are marked in red.</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings = [\"01011\", \"00111\"]\n\ndef plot_distribution(C, ax, title):\n    C = dict(sorted(C.items(), key=lambda item: item[1], reverse=True))\n    indexes = solution_bitstrings # QUBO solutions\n    color_dict = {key: \"r\" if key in indexes else \"g\" for key in C}\n    ax.set_xlabel(\"bitstrings\")\n    ax.set_ylabel(\"counts\")\n    ax.set_xticks([i for i in range(len(C.keys()))], C.keys(), rotation=90)\n    ax.bar(list(C.keys())[:20], list(C.values())[:20])\n    ax.set_title(title)\n\nfig, axs = plt.subplots(1, 2, figsize=(12, 4))\nplot_distribution(initial_counts, axs[0], \"Initial counts\")\nplot_distribution(optimal_counts, axs[1], \"Optimal counts\")\n</code></pre> 2024-02-01T16:33:08.825129 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/#references","title":"References","text":"<ol> <li> <p>Edward Farhi, Jeffrey Goldstone, Sam Gutmann, A Quantum Approximate Optimization Algorithm, arXiv:1411.4028 (2014) \u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo, PI\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = PI\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=PI,            # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_c01edc54794943779174bfc8d82cefec cluster_1956e29aad4c462888915dd134679c50 cluster_680eabf54da8445fb342837bc44bc9aa cluster_aea6501b0254492bb02329b9ec315e08 cluster_031c5f54ab0c4b8c9533a71d0b30f614 cluster_65de7fbb12464d5c90357a92070fe936 cluster_392180d2132d42ecb8a67add519ad80d 595106672bc14d66acfeb8ab82b73cbb 0 cc1488c7dad34beb84197191eb55a159 HamEvo 595106672bc14d66acfeb8ab82b73cbb--cc1488c7dad34beb84197191eb55a159 b1c66cb68a8341bc8b8d4cf872269ac6 1 dab8125d65b14f26a57a658f8277da29 HamEvo cc1488c7dad34beb84197191eb55a159--dab8125d65b14f26a57a658f8277da29 34b8ae51a7bf4a1aa353532664180aa8 HamEvo dab8125d65b14f26a57a658f8277da29--34b8ae51a7bf4a1aa353532664180aa8 73dfee07f4e14961bcdf1b84be5e6e7b X 34b8ae51a7bf4a1aa353532664180aa8--73dfee07f4e14961bcdf1b84be5e6e7b 2247ad30a716474c8414e22dc6e55b5f HamEvo 73dfee07f4e14961bcdf1b84be5e6e7b--2247ad30a716474c8414e22dc6e55b5f 571fd38cdebe4c978b5a5500ef9835ed HamEvo 2247ad30a716474c8414e22dc6e55b5f--571fd38cdebe4c978b5a5500ef9835ed 980cbc6ba2854b57b096f135268d0841 X 571fd38cdebe4c978b5a5500ef9835ed--980cbc6ba2854b57b096f135268d0841 d381f956a0804d7aa16dec78f45ca8b6 980cbc6ba2854b57b096f135268d0841--d381f956a0804d7aa16dec78f45ca8b6 fb9aedf762624c1ba2ededd10a82c78a HamEvo d381f956a0804d7aa16dec78f45ca8b6--fb9aedf762624c1ba2ededd10a82c78a e531f9f6db65413f9a167b30477171d1 HamEvo fb9aedf762624c1ba2ededd10a82c78a--e531f9f6db65413f9a167b30477171d1 bb248463dcd449c4b2990e89d158b5c3 e531f9f6db65413f9a167b30477171d1--bb248463dcd449c4b2990e89d158b5c3 fec117fc53b44f1ba27affcd1079a773 bb248463dcd449c4b2990e89d158b5c3--fec117fc53b44f1ba27affcd1079a773 bce83f4b05b24bd681f7a8489cf52d29 da0898a6bc46418f97ca769e46029fd3 t = -3.142 b1c66cb68a8341bc8b8d4cf872269ac6--da0898a6bc46418f97ca769e46029fd3 9d029c5d2f884fda93788f6511eb74dc 2 bb0e50ca55174d30bfb9077199d1e884 t = 3.142 da0898a6bc46418f97ca769e46029fd3--bb0e50ca55174d30bfb9077199d1e884 75f217d8277046f4993fcc8e542ead68 t = -3.142 bb0e50ca55174d30bfb9077199d1e884--75f217d8277046f4993fcc8e542ead68 ba0a6000c8a54804b57812bf7d1e1dec 75f217d8277046f4993fcc8e542ead68--ba0a6000c8a54804b57812bf7d1e1dec bf6400b0e913495780a321c244bb771d t = 1.571 ba0a6000c8a54804b57812bf7d1e1dec--bf6400b0e913495780a321c244bb771d bd4198c4e4e548ff8c1da6c4aabe3a0f t = 1.571 bf6400b0e913495780a321c244bb771d--bd4198c4e4e548ff8c1da6c4aabe3a0f d85033f6d30b4b9189b032124dd87def bd4198c4e4e548ff8c1da6c4aabe3a0f--d85033f6d30b4b9189b032124dd87def 1395f9666071401a9b0b5944db323155 X d85033f6d30b4b9189b032124dd87def--1395f9666071401a9b0b5944db323155 72f806241b3544369be81842da218377 t = 1.571 1395f9666071401a9b0b5944db323155--72f806241b3544369be81842da218377 b6f47eac814a409db8bfdb5cbd930fe5 t = 1.571 72f806241b3544369be81842da218377--b6f47eac814a409db8bfdb5cbd930fe5 cf251b1552d540ea8a3b48ec3b737d57 X b6f47eac814a409db8bfdb5cbd930fe5--cf251b1552d540ea8a3b48ec3b737d57 cf251b1552d540ea8a3b48ec3b737d57--bce83f4b05b24bd681f7a8489cf52d29 540d0ea7b030457cb3137c4f592ab552 b9fffb7d911c409bb5fa4e3109de851c 9d029c5d2f884fda93788f6511eb74dc--b9fffb7d911c409bb5fa4e3109de851c a27d8ba9e2a5450889f26d2b8e8d8afc b9fffb7d911c409bb5fa4e3109de851c--a27d8ba9e2a5450889f26d2b8e8d8afc c8b39a224d3040aeab88edf1229cd585 a27d8ba9e2a5450889f26d2b8e8d8afc--c8b39a224d3040aeab88edf1229cd585 3a834c78de8d4911addc380b4f04e4a2 X c8b39a224d3040aeab88edf1229cd585--3a834c78de8d4911addc380b4f04e4a2 781ccf2086a7434b976e31f05a247bef 3a834c78de8d4911addc380b4f04e4a2--781ccf2086a7434b976e31f05a247bef ba91c5ed1e4a4da8bf59d0dc0c598692 781ccf2086a7434b976e31f05a247bef--ba91c5ed1e4a4da8bf59d0dc0c598692 e6d0c82dc56f47579c0641eafcf52a99 X ba91c5ed1e4a4da8bf59d0dc0c598692--e6d0c82dc56f47579c0641eafcf52a99 afbc606504144edb951e889bb09c751f X e6d0c82dc56f47579c0641eafcf52a99--afbc606504144edb951e889bb09c751f 4a7ae97b5f1f459abef3d3608cceb7b7 afbc606504144edb951e889bb09c751f--4a7ae97b5f1f459abef3d3608cceb7b7 9a0d8d9257cd4935b2a06c0cac138bda 4a7ae97b5f1f459abef3d3608cceb7b7--9a0d8d9257cd4935b2a06c0cac138bda a9ebc23347134cfcb3c7a4991094a593 X 9a0d8d9257cd4935b2a06c0cac138bda--a9ebc23347134cfcb3c7a4991094a593 a9ebc23347134cfcb3c7a4991094a593--540d0ea7b030457cb3137c4f592ab552 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_8764d735d04d49ae8312771e068301b0 cluster_2e713df921b74d3d9eb8629b9ec6b26b e85b60249d0f41f0848e27286ffe0a31 0 36f13d844d7244e9a800934eeca84d84 X e85b60249d0f41f0848e27286ffe0a31--36f13d844d7244e9a800934eeca84d84 6b1d4b3576e24ff8987d7462cf497a40 1 08613032dc494bb9817db76050e6337a HamEvo 36f13d844d7244e9a800934eeca84d84--08613032dc494bb9817db76050e6337a 3f4f0ba8f1dc4c5c9dc2725bd77caa1e X 08613032dc494bb9817db76050e6337a--3f4f0ba8f1dc4c5c9dc2725bd77caa1e a7ace9a48ea74c269b21d3212ab92061 3f4f0ba8f1dc4c5c9dc2725bd77caa1e--a7ace9a48ea74c269b21d3212ab92061 2e7e7c6ea5974b84bc940248ec3fd17b HamEvo a7ace9a48ea74c269b21d3212ab92061--2e7e7c6ea5974b84bc940248ec3fd17b c9924481ae644ef4a4b7764530411d47 2e7e7c6ea5974b84bc940248ec3fd17b--c9924481ae644ef4a4b7764530411d47 5dc33185101d41ccb3d4471144c9b75e c9924481ae644ef4a4b7764530411d47--5dc33185101d41ccb3d4471144c9b75e 8eb3581744904ab18fab4b7714929095 07e8a190cd2a48af81d31c025efa9063 6b1d4b3576e24ff8987d7462cf497a40--07e8a190cd2a48af81d31c025efa9063 39a60eb18ea4424a8875499ac1aa8a57 2 fb974dd8dac444b1a8c40beeb09293a3 t = -0.500 07e8a190cd2a48af81d31c025efa9063--fb974dd8dac444b1a8c40beeb09293a3 fd6fa0a321994d90b9ddcd7d97e2a4f1 fb974dd8dac444b1a8c40beeb09293a3--fd6fa0a321994d90b9ddcd7d97e2a4f1 ac838f2b1df947bdbbc3ecd53ebc48df X fd6fa0a321994d90b9ddcd7d97e2a4f1--ac838f2b1df947bdbbc3ecd53ebc48df 7f25874cc0cc4bb0adbce827c85be4de t = -0.500 ac838f2b1df947bdbbc3ecd53ebc48df--7f25874cc0cc4bb0adbce827c85be4de c091122bd04340d3a92794bb792ce846 X 7f25874cc0cc4bb0adbce827c85be4de--c091122bd04340d3a92794bb792ce846 c091122bd04340d3a92794bb792ce846--8eb3581744904ab18fab4b7714929095 e4155e7245554f119fa6b3dd5ea30e35 f4683748c1b346a8b150ec589acc0923 X 39a60eb18ea4424a8875499ac1aa8a57--f4683748c1b346a8b150ec589acc0923 6025f9c6249746919006b5b94e52e727 f4683748c1b346a8b150ec589acc0923--6025f9c6249746919006b5b94e52e727 4822380c2ed54a39ba577db9bf6f5ba1 X 6025f9c6249746919006b5b94e52e727--4822380c2ed54a39ba577db9bf6f5ba1 1a4d767bed824424b64ca5b7be2355a7 X 4822380c2ed54a39ba577db9bf6f5ba1--1a4d767bed824424b64ca5b7be2355a7 e3107ce078f044ec93fbfe9d90d27967 1a4d767bed824424b64ca5b7be2355a7--e3107ce078f044ec93fbfe9d90d27967 053db3075b2d4b1c871abc1c4a5ee1d5 X e3107ce078f044ec93fbfe9d90d27967--053db3075b2d4b1c871abc1c4a5ee1d5 053db3075b2d4b1c871abc1c4a5ee1d5--e4155e7245554f119fa6b3dd5ea30e35 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_55d7d0ee415247d594bd9ec790b72af3 cluster_b9b0ae91ced5407780584c65435eecaa 1967b7b0a20d432d99cf0dd3ffb083d3 0 05f8f15411e143429b6b2beeba99a41e X 1967b7b0a20d432d99cf0dd3ffb083d3--05f8f15411e143429b6b2beeba99a41e d8bd7176a37d48158e07fac85d55fa1c 1 0b6ce24e2f9b4799878599a6f687af0e HamEvo 05f8f15411e143429b6b2beeba99a41e--0b6ce24e2f9b4799878599a6f687af0e 8bc3e8327ece4c8aa4aab678e514cc8b X 0b6ce24e2f9b4799878599a6f687af0e--8bc3e8327ece4c8aa4aab678e514cc8b 3bf4899b034a4e7da798406b58c0e41e 8bc3e8327ece4c8aa4aab678e514cc8b--3bf4899b034a4e7da798406b58c0e41e ee69871fa75b472bb633b9e2aa9bf628 HamEvo 3bf4899b034a4e7da798406b58c0e41e--ee69871fa75b472bb633b9e2aa9bf628 1bd22f0800744898a2bd1c1491fc6a9d ee69871fa75b472bb633b9e2aa9bf628--1bd22f0800744898a2bd1c1491fc6a9d 9fb9a46b750640a7be84df2d68c7fb07 1bd22f0800744898a2bd1c1491fc6a9d--9fb9a46b750640a7be84df2d68c7fb07 5436303dc78f44babee0600dc86da2bb 12f985483daa4ad780803bfe3292e8f0 d8bd7176a37d48158e07fac85d55fa1c--12f985483daa4ad780803bfe3292e8f0 30b792fd1b114dd78179f766639eb91f 2 f463907dc932460e891792fc01bd12fb t = -500.000000000000 12f985483daa4ad780803bfe3292e8f0--f463907dc932460e891792fc01bd12fb a7b7b828ce664e14bfe14f84366751dd f463907dc932460e891792fc01bd12fb--a7b7b828ce664e14bfe14f84366751dd dd54024c91c54ef8934f27208e5a7a04 X a7b7b828ce664e14bfe14f84366751dd--dd54024c91c54ef8934f27208e5a7a04 317b6f35ce3f425bb43854a36ec4321a t = -500.000000000000 dd54024c91c54ef8934f27208e5a7a04--317b6f35ce3f425bb43854a36ec4321a 8f9de433462d4a16a8cf2c3e2e7cab3c X 317b6f35ce3f425bb43854a36ec4321a--8f9de433462d4a16a8cf2c3e2e7cab3c 8f9de433462d4a16a8cf2c3e2e7cab3c--5436303dc78f44babee0600dc86da2bb 592b10dbfb0d4e5a846776da83b3410b 295001a8ac604cc4a61be943b9b7e9ac X 30b792fd1b114dd78179f766639eb91f--295001a8ac604cc4a61be943b9b7e9ac 8697a3dd297b4d8b92ce690bb8ae1838 295001a8ac604cc4a61be943b9b7e9ac--8697a3dd297b4d8b92ce690bb8ae1838 bdffd1eae8124b9b98f7a5588198981c X 8697a3dd297b4d8b92ce690bb8ae1838--bdffd1eae8124b9b98f7a5588198981c 8fbe411b574141168b84fd80afde7148 X bdffd1eae8124b9b98f7a5588198981c--8fbe411b574141168b84fd80afde7148 28c4a42413794d39a41ea8dd36610b5a 8fbe411b574141168b84fd80afde7148--28c4a42413794d39a41ea8dd36610b5a cadf6adb65c348e88923329f95020932 X 28c4a42413794d39a41ea8dd36610b5a--cadf6adb65c348e88923329f95020932 cadf6adb65c348e88923329f95020932--592b10dbfb0d4e5a846776da83b3410b <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>AnalogInteraction</code> An idle block to to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.19153186677421175, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel, PI\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 30, '11': 20})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2024-02-01T16:33:09.365149 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2024-02-01T16:33:09.715809 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 21, '10': 2})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>AnalogInteraction</code> and <code>AnalogRY</code> blocks together with appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, AnalogInteraction\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-PI / 2),\n        AnalogInteraction(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([PI / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2024-02-01T16:33:10.167304 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(PI/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2024-02-01T16:33:10.287350 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n    PI\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.0100])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.0106])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(PI)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.6974]) The trained function value:  tensor([[0.6974]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>InteractionBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, AnalogInteraction\n\nb = chain(AnalogInteraction(200), AnalogInteraction(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), AnalogInteraction(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `InteractionBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, AnalogInteraction\n\n    b = chain(AnalogInteraction(200), AnalogInteraction(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), AnalogInteraction(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.InteractionBlock","title":"<code>InteractionBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Free-evolution for the Hamiltonian interaction term of a register of qubits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct, use the <code>AnalogInteraction</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.1205+0.2779j, -0.4028-0.5196j, -0.6412+0.0323j, -0.2348-0.0933j],\n         [-0.1532-0.2579j,  0.3364+0.4789j, -0.6311-0.0889j, -0.3710+0.1539j],\n         [-0.2295-0.6436j, -0.0058-0.3170j,  0.1553+0.2692j, -0.3819-0.4360j],\n         [-0.0921-0.5856j, -0.2621-0.2365j, -0.1598-0.2440j,  0.4385+0.4966j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * PI),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None, param_prefix=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | Callable | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data provided comes from. Used to map input data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI). Used to map data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <code>param_prefix</code> <p>string prefix to create trainable parameters multiplying the feature parameter inside the feature-encoding function. Note that currently this does not take into account the domain of the feature-encoding function.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | Callable | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n    param_prefix: str | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data provided comes from. Used to map input data\n            to the correct domain of the feature-encoding function.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI).\n            Used to map data to the correct domain of the feature-encoding function.\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n        param_prefix: string prefix to create trainable parameters multiplying the feature parameter\n            inside the feature-encoding function. Note that currently this does not take into\n            account the domain of the feature-encoding function.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    # Backwards compatibility\n    fm_type, reupload_scaling = backwards_compatibility(fm_type, reupload_scaling)\n\n    scaled_fparam = fm_parameter_scaling(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    transform_func = fm_parameter_func(fm_type)\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    fparam = scaled_fparam\n    for i, qubit in enumerate(support):\n        if param_prefix is not None:\n            train_param = VariationalParameter(param_prefix + f\"_{i}\")\n            fparam = train_param * scaled_fparam\n        op_list.append(op(qubit, multiplier * rs_func(i) * transform_func(fparam)))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | Callable | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | Callable | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        if callable(interaction):\n            int_fn = interaction\n            try:\n                if not block_is_qubit_hamiltonian(interaction(0, 1)):\n                    raise ValueError(\"Custom interactions must be composed of Pauli operators.\")\n            except TypeError:\n                raise TypeError(\n                    \"Please use a custom interaction function signed with two integer parameters.\"\n                )\n        else:\n            int_fn = INTERACTION_DICT.get(interaction, None)  # type: ignore [arg-type]\n            if int_fn is None:\n                raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * PI / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fa96c20f6d0&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fa96c20dbd0&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, None)\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    data = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.3026, 0.2765]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n[tensor([0.6595, 0.0538, 0.8660, 0.8650, 0.0394]), tensor([0.2900, 0.3294, 0.6735, 0.3359, 0.2816]), tensor([0.4227, 0.3033, 0.5571, 0.8693, 0.4491])]\n[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run, PI\nimport torch\nhevo = HamEvo(generator=RX(0, PI), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.1384-3.6270e-17j, -0.5441+1.7335e-17j],\n        [ 1.2545-5.3697e-17j, -0.7574+3.2421e-17j]])\ntensor([[1.5091-0.7780j, 0.5771-0.9542j],\n        [1.4106-0.5384j, 0.5040-0.6605j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * PI / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * PI / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-PI / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = PI\n    omega = 0\n    duration = alpha / delta * 1000\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=0.0, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n\n    if omega == 0 and delta == 0:\n        raise ValueError(\"Parameters omega and delta cannot both be 0.\")\n\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    alpha = duration * h_norm / 1000\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogInteraction","title":"<code>AnalogInteraction(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Evolution of the interaction term for a register of qubits.</p> <p>Constructs a <code>InteractionBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to evolve the interaction for in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>InteractionBlock</code> is applied to. Can be either <code>\"global\"</code> to evolve the interaction block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>InteractionBlock</code> <p>a <code>InteractionBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogInteraction(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; InteractionBlock:\n    \"\"\"Evolution of the interaction term for a register of qubits.\n\n    Constructs a [`InteractionBlock`][qadence.blocks.analog.InteractionBlock].\n\n    Arguments:\n        duration: Time to evolve the interaction for in nanoseconds.\n        qubit_support: Qubits the `InteractionBlock` is applied to. Can be either\n            `\"global\"` to evolve the interaction block to all qubits or a tuple of integers.\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        a `InteractionBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return InteractionBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['638ba5c2-90f1-474a-82dc-aedc0ce98640', '576be343-dcc6-4905-8431-f6bdc0d8b377'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.9859993654159114\ntheta: trainable=True value=2.0\nexpr=x*y : {x, y}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.6903893734503416\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = make_differentiable(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False, engine=Engine.TORCH)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level.</p> <p>parameters or gate-level parameters. The constructed embedding function has the signature:</p> <pre><code> embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False, engine: Engine = Engine.TORCH\n) -&gt; tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType],]:\n    \"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*.\n\n    parameters or *gate-level* parameters. The constructed embedding function has the signature:\n\n         embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n    concretize_parameter = _concretize_parameter(engine)\n    if engine == Engine.TORCH:\n        cast_dtype = tensor\n    else:\n        from jax.numpy import array\n\n        cast_dtype = array\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, DifferentiableExpression] = {\n        expr: make_differentiable(expr=expr, engine=engine)\n        for expr in unique_expressions\n        if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n        embedded_params: dict[sympy.Expr, ArrayLike] = {}\n        for expr, fn in embeddings.items():\n            angle: ArrayLike\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: ParamDictType = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: ParamDictType\n    params = {\n        p.name: concretize_parameter(value=p.value, trainable=True) for p in trainable_symbols\n    }\n    params.update(\n        {\n            stringify(expr): concretize_parameter(value=evaluate(expr), trainable=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): cast_dtype(nparray(expr.tolist(), dtype=npcdouble))\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e5d15896-1069-446d-aa8a-808cddd4dfb8', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.6398639069137206'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e89d4570-4eb6-4abb-8591-41f1f9d82e12', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.4276945815961849'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e7d8a37a-5d42-4d48-b4f9-e32007055e4e', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.8742892845567309'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('217d7022-6890-437c-b93a-574705925a9e', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.41919975377010965'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('ce10054e-e473-4d2c-9eae-30863c64bef6', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6109177287180888'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('0ce2d2ae-7643-4ff5-9484-64bc4c6394df', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.37421788716051174'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5fd0b1a7-1c64-43d0-9ca7-ccded5865bd5', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9806087614373826'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('37bee10e-5612-4523-90fc-f758b4a01d75', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.1191298453974663'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('d4318190-6cb7-4278-92e7-56c3c57d1a68', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.2908857259376022'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('fcde380f-8c04-44ac-8961-30eee73061b5', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.43496561975352277'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('48acaf83-d93c-4afd-b238-f3306027e0e0', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.13952221070351867'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('75386285-c982-4be8-9cd1-f6a4303aeca8', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.230873635340905'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>11101110\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.3881-0.1329j,  0.2745-0.3881j, -0.2080+0.2140j,  0.6633-0.2767j]])\ntensor([[ 0.4505-0.6381j, -0.5101-0.3601j,  0.0000+0.0000j,  0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGINTERACTION","title":"<code>ANALOGINTERACTION = 'AnalogInteraction'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog interaction operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANGLE","title":"<code>ENTANGLE = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 78, '1000': 8, '0010': 5, '0100': 4, '0001': 1, '0101': 1, '1010': 1, '1101': 1, '1110': 1})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[-0.0018],\n        [-0.0004],\n        [ 0.0510],\n        [ 0.0049],\n        [ 0.0771],\n        [ 0.0133],\n        [-0.0328],\n        [-0.0192],\n        [ 0.0395],\n        [-0.0323]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4053],\n        [0.9018],\n        [0.9084],\n        [0.2606],\n        [0.9428]]), tensor([[0.3943],\n        [0.7844],\n        [0.7885],\n        [0.2577],\n        [0.8092]])], 'y2': [tensor([[0.4695],\n        [0.1881],\n        [0.6359],\n        [0.7454],\n        [0.2043]]), tensor([[0.4524],\n        [0.1870],\n        [0.5939],\n        [0.6783],\n        [0.2029]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2024-02-01T16:33:33.276152 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2024-02-01T16:33:33.884383 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_5bdd318a5eef49e0b0a4bac843a55891 mixing cluster_a88e1f0eb4384960a9f513a587205d8a cost cluster_96cacd70171b43d39b80408f67aff35d mixing cluster_d3f47bb011cc4ec0ba18bc2ba29c865e cost 3ed6e07b82a04c80a83fd6381b0bf4f4 0 f5cc339ef3a24f2bad4a4da67d706579 3ed6e07b82a04c80a83fd6381b0bf4f4--f5cc339ef3a24f2bad4a4da67d706579 2bd5636a4c8547d2abf59773f33fb58a 1 b62bec0327614d0386c4f2379b81ef87 f5cc339ef3a24f2bad4a4da67d706579--b62bec0327614d0386c4f2379b81ef87 7f9ba48430f84165b68fc01fd6db17e7 b62bec0327614d0386c4f2379b81ef87--7f9ba48430f84165b68fc01fd6db17e7 857a83632482439cbee5fffda6658dc0 7f9ba48430f84165b68fc01fd6db17e7--857a83632482439cbee5fffda6658dc0 9b05bacbb86f40498dbfcb986c5a397d 857a83632482439cbee5fffda6658dc0--9b05bacbb86f40498dbfcb986c5a397d 24dd3fb086b24acdabb5b6e69cb50d94 9b05bacbb86f40498dbfcb986c5a397d--24dd3fb086b24acdabb5b6e69cb50d94 834f8dd655e147c4984e4df22d90f781 24dd3fb086b24acdabb5b6e69cb50d94--834f8dd655e147c4984e4df22d90f781 ba1a0e9b46ac4b8f9c0402871ea53a2f 834f8dd655e147c4984e4df22d90f781--ba1a0e9b46ac4b8f9c0402871ea53a2f fe24f19063be46799df3dbb3389263e7 ba1a0e9b46ac4b8f9c0402871ea53a2f--fe24f19063be46799df3dbb3389263e7 005214f50a0e4be5a3df49fbbfe98cc1 fe24f19063be46799df3dbb3389263e7--005214f50a0e4be5a3df49fbbfe98cc1 ad1b022eccd04ae4a53069c0bdbf84a5 005214f50a0e4be5a3df49fbbfe98cc1--ad1b022eccd04ae4a53069c0bdbf84a5 040bb857269942ffbf6a6daa1e9a480e ad1b022eccd04ae4a53069c0bdbf84a5--040bb857269942ffbf6a6daa1e9a480e af21fca3fe924431a5a8e8b31b508307 040bb857269942ffbf6a6daa1e9a480e--af21fca3fe924431a5a8e8b31b508307 c01237e1c6f549e78e0616d38bf13ac3 af21fca3fe924431a5a8e8b31b508307--c01237e1c6f549e78e0616d38bf13ac3 ad7e7af933e14d4cbcad6799301b266b c01237e1c6f549e78e0616d38bf13ac3--ad7e7af933e14d4cbcad6799301b266b b99db0343e814f17a09a89a267d6c261 ad7e7af933e14d4cbcad6799301b266b--b99db0343e814f17a09a89a267d6c261 af4065fc01734a61ac5842db37eca834 b99db0343e814f17a09a89a267d6c261--af4065fc01734a61ac5842db37eca834 ceaf9634333b4fcd9c497216587daf88 af4065fc01734a61ac5842db37eca834--ceaf9634333b4fcd9c497216587daf88 c86bec9cdbde44c4b85285f7ab8eb6a4 ceaf9634333b4fcd9c497216587daf88--c86bec9cdbde44c4b85285f7ab8eb6a4 8b67a0ad05c442329b81f5fa05cf0778 c86bec9cdbde44c4b85285f7ab8eb6a4--8b67a0ad05c442329b81f5fa05cf0778 50e9a79b5f7a4553839f02c98258a390 8b67a0ad05c442329b81f5fa05cf0778--50e9a79b5f7a4553839f02c98258a390 097caf694e38426d8a025937f8f6bc39 50e9a79b5f7a4553839f02c98258a390--097caf694e38426d8a025937f8f6bc39 c6ab450ff0a240b69ef2458037a69b98 097caf694e38426d8a025937f8f6bc39--c6ab450ff0a240b69ef2458037a69b98 60db1370f5f04552ab572b70ce586620 c6ab450ff0a240b69ef2458037a69b98--60db1370f5f04552ab572b70ce586620 e66537bbf463497baed0b0d7adb02a03 60db1370f5f04552ab572b70ce586620--e66537bbf463497baed0b0d7adb02a03 1560b9d944704e0ba120a4a4379bb49b e66537bbf463497baed0b0d7adb02a03--1560b9d944704e0ba120a4a4379bb49b d5f13ee60a234d6cb4ca4d026b23359a 1560b9d944704e0ba120a4a4379bb49b--d5f13ee60a234d6cb4ca4d026b23359a f178e3a7803d4a60861a11d6ae5bf97e d5f13ee60a234d6cb4ca4d026b23359a--f178e3a7803d4a60861a11d6ae5bf97e 7a78b30fcc394ebab868ea1fb93e89fa f178e3a7803d4a60861a11d6ae5bf97e--7a78b30fcc394ebab868ea1fb93e89fa d80a15ebfcf24a879e716b2774ecb4d8 7a78b30fcc394ebab868ea1fb93e89fa--d80a15ebfcf24a879e716b2774ecb4d8 20f4f35723314649a8f8d2cde968ed9a d80a15ebfcf24a879e716b2774ecb4d8--20f4f35723314649a8f8d2cde968ed9a 6966b2ab49254780a7602e06203bc4ca 20f4f35723314649a8f8d2cde968ed9a--6966b2ab49254780a7602e06203bc4ca 6c9ef7ca644a4baebe22e7c5f928ae10 6966b2ab49254780a7602e06203bc4ca--6c9ef7ca644a4baebe22e7c5f928ae10 cd7d59d6e97c4745a0aee68e8f962e9d 6c9ef7ca644a4baebe22e7c5f928ae10--cd7d59d6e97c4745a0aee68e8f962e9d 8c40f20b91694aad86047fc70c261be0 cd7d59d6e97c4745a0aee68e8f962e9d--8c40f20b91694aad86047fc70c261be0 60638ed2d3454e868f4f517f26c05124 8c40f20b91694aad86047fc70c261be0--60638ed2d3454e868f4f517f26c05124 f80082318ea14e9fb137a22ddb6ae576 60638ed2d3454e868f4f517f26c05124--f80082318ea14e9fb137a22ddb6ae576 af9c4e9ec8e541ee9604a4b3e689eabe f80082318ea14e9fb137a22ddb6ae576--af9c4e9ec8e541ee9604a4b3e689eabe f34f9b0a50854f8aaaaf535737e82de2 af9c4e9ec8e541ee9604a4b3e689eabe--f34f9b0a50854f8aaaaf535737e82de2 9eab9a5ff6814448a071c548e2e04325 f34f9b0a50854f8aaaaf535737e82de2--9eab9a5ff6814448a071c548e2e04325 610662c8245240b5b4f647edad507ef4 9eab9a5ff6814448a071c548e2e04325--610662c8245240b5b4f647edad507ef4 b27d6f7889824887ab1031b2132db1c1 610662c8245240b5b4f647edad507ef4--b27d6f7889824887ab1031b2132db1c1 b67d885a5168403c8b2ed988f0691f2c b27d6f7889824887ab1031b2132db1c1--b67d885a5168403c8b2ed988f0691f2c ee492d17190b4021ba9683cc173f1068 b67d885a5168403c8b2ed988f0691f2c--ee492d17190b4021ba9683cc173f1068 65adf02b360647ebaf7b200b0e790019 ee492d17190b4021ba9683cc173f1068--65adf02b360647ebaf7b200b0e790019 f1c0e30bb2c84281822378b358dabda5 65adf02b360647ebaf7b200b0e790019--f1c0e30bb2c84281822378b358dabda5 bbc81d590c3c40838d926466f0619113 f1c0e30bb2c84281822378b358dabda5--bbc81d590c3c40838d926466f0619113 72406148ed6e492ab3d75df9c8bab57f bbc81d590c3c40838d926466f0619113--72406148ed6e492ab3d75df9c8bab57f f6cb8c82a1ce4b759062dacfdb4c53b0 72406148ed6e492ab3d75df9c8bab57f--f6cb8c82a1ce4b759062dacfdb4c53b0 037b28d169ca4bc080868cdc02f5589d f6cb8c82a1ce4b759062dacfdb4c53b0--037b28d169ca4bc080868cdc02f5589d 2eaa45f7824143cf82e23665f1638b3c 037b28d169ca4bc080868cdc02f5589d--2eaa45f7824143cf82e23665f1638b3c 81a3adec049540ea8b0ca723a0fcff51 2eaa45f7824143cf82e23665f1638b3c--81a3adec049540ea8b0ca723a0fcff51 46ab707981134c1ba1661c1ce4534479 81a3adec049540ea8b0ca723a0fcff51--46ab707981134c1ba1661c1ce4534479 b91114266de24d92acbad19f54921d4e 46ab707981134c1ba1661c1ce4534479--b91114266de24d92acbad19f54921d4e feb0c38e7ea245d084f14f5f69864f89 b91114266de24d92acbad19f54921d4e--feb0c38e7ea245d084f14f5f69864f89 964691be41a44cedaebe1b747fa672a6 feb0c38e7ea245d084f14f5f69864f89--964691be41a44cedaebe1b747fa672a6 837a22d1fc82487f96cfa639338db6fd 964691be41a44cedaebe1b747fa672a6--837a22d1fc82487f96cfa639338db6fd 5c0c9e1dd3f543a4a8796137be934617 837a22d1fc82487f96cfa639338db6fd--5c0c9e1dd3f543a4a8796137be934617 bb3908e8a28144c486c73aca1b844bdb 5c0c9e1dd3f543a4a8796137be934617--bb3908e8a28144c486c73aca1b844bdb 00699414b54e46be88585eeee524b806 bb3908e8a28144c486c73aca1b844bdb--00699414b54e46be88585eeee524b806 9264a31aa1ea4ddbac392f0a3fdc6992 00699414b54e46be88585eeee524b806--9264a31aa1ea4ddbac392f0a3fdc6992 1d3e8e2533794addb59a2058ef65fde9 9264a31aa1ea4ddbac392f0a3fdc6992--1d3e8e2533794addb59a2058ef65fde9 0a5dbca69e464da7903098e8c80e0777 1d3e8e2533794addb59a2058ef65fde9--0a5dbca69e464da7903098e8c80e0777 fbd20135a2404a09b27fe145ffe1b139 0a5dbca69e464da7903098e8c80e0777--fbd20135a2404a09b27fe145ffe1b139 4dd94c43cccb4978a67312b541a8a4b1 fbd20135a2404a09b27fe145ffe1b139--4dd94c43cccb4978a67312b541a8a4b1 aa49f480cf3841c49b0c1450a88ed3db 4dd94c43cccb4978a67312b541a8a4b1--aa49f480cf3841c49b0c1450a88ed3db 64780f5771ef412c87a6ad77f7d5a46b aa49f480cf3841c49b0c1450a88ed3db--64780f5771ef412c87a6ad77f7d5a46b 9257de9185684f739a476be1a34f4e09 64780f5771ef412c87a6ad77f7d5a46b--9257de9185684f739a476be1a34f4e09 e67dde142b3a45a8a15f426c6c0be1d1 9257de9185684f739a476be1a34f4e09--e67dde142b3a45a8a15f426c6c0be1d1 d6cf04cc8bea45e58349b1b423dfd97c e67dde142b3a45a8a15f426c6c0be1d1--d6cf04cc8bea45e58349b1b423dfd97c bcc87eb7c0514628ba048fa24fefe991 d6cf04cc8bea45e58349b1b423dfd97c--bcc87eb7c0514628ba048fa24fefe991 7c073880a235460193b588cde0509339 bcc87eb7c0514628ba048fa24fefe991--7c073880a235460193b588cde0509339 63853e6a04c44d5aab75343c3fe7d49a 7c073880a235460193b588cde0509339--63853e6a04c44d5aab75343c3fe7d49a 6a6092abfdfd41c4ac56c4c8e33f1a2a 63853e6a04c44d5aab75343c3fe7d49a--6a6092abfdfd41c4ac56c4c8e33f1a2a 86c6565703064b94bab5817d89eaf628 6a6092abfdfd41c4ac56c4c8e33f1a2a--86c6565703064b94bab5817d89eaf628 6408436668c54e1a8d73e50ad90ad915 86c6565703064b94bab5817d89eaf628--6408436668c54e1a8d73e50ad90ad915 1470079c58c14c8687da9f61ba343171 6408436668c54e1a8d73e50ad90ad915--1470079c58c14c8687da9f61ba343171 33eb09861bbc4a8a9596f6cb9ca84e7c 1470079c58c14c8687da9f61ba343171--33eb09861bbc4a8a9596f6cb9ca84e7c d4aec7f7e9474b2a8a20a68e267f383e 33eb09861bbc4a8a9596f6cb9ca84e7c--d4aec7f7e9474b2a8a20a68e267f383e 74589095e3024a5ea9ed2d3f3482b317 d4aec7f7e9474b2a8a20a68e267f383e--74589095e3024a5ea9ed2d3f3482b317 32b8f352512c4a34b62cc4a41c6c6e14 74589095e3024a5ea9ed2d3f3482b317--32b8f352512c4a34b62cc4a41c6c6e14 eb95eafbb1d045b08c9b523785f82ff7 32b8f352512c4a34b62cc4a41c6c6e14--eb95eafbb1d045b08c9b523785f82ff7 c2f0043506b7429db06691352692bca0 eb95eafbb1d045b08c9b523785f82ff7--c2f0043506b7429db06691352692bca0 d9d32abde22545908992d0fd3fd7081a c2f0043506b7429db06691352692bca0--d9d32abde22545908992d0fd3fd7081a 56057af3f82f44419816974a8663887f d9d32abde22545908992d0fd3fd7081a--56057af3f82f44419816974a8663887f 58ba0317b2b04a67847e752684047047 56057af3f82f44419816974a8663887f--58ba0317b2b04a67847e752684047047 b34d6555a2084687a058136f51ff62bb 58ba0317b2b04a67847e752684047047--b34d6555a2084687a058136f51ff62bb 52eb32af11914be9b817e73925216557 b34d6555a2084687a058136f51ff62bb--52eb32af11914be9b817e73925216557 a45ef8915461466ba8c4dfde76c1adad 52eb32af11914be9b817e73925216557--a45ef8915461466ba8c4dfde76c1adad 3a231594177449aabb603c6a3108a1ac a45ef8915461466ba8c4dfde76c1adad--3a231594177449aabb603c6a3108a1ac 6b2d02e67a414ca0b3542382fdb5a30a 3a231594177449aabb603c6a3108a1ac--6b2d02e67a414ca0b3542382fdb5a30a 5ffa05b838b04e989a9f5137fa3b9d5c 6b2d02e67a414ca0b3542382fdb5a30a--5ffa05b838b04e989a9f5137fa3b9d5c 96839ac13d1a42108e8c6aad1cffe28a 5ffa05b838b04e989a9f5137fa3b9d5c--96839ac13d1a42108e8c6aad1cffe28a 985842519ad642408dd74f9c478f0d69 96839ac13d1a42108e8c6aad1cffe28a--985842519ad642408dd74f9c478f0d69 ed288a38d7cb4c289a77eea78eae84e0 985842519ad642408dd74f9c478f0d69--ed288a38d7cb4c289a77eea78eae84e0 1d101ead4144440ebc55c5bfd3bdf9b9 ed288a38d7cb4c289a77eea78eae84e0--1d101ead4144440ebc55c5bfd3bdf9b9 2b0e097680014309b4ccacb1d8fdf03b 1d101ead4144440ebc55c5bfd3bdf9b9--2b0e097680014309b4ccacb1d8fdf03b 71e0e2f4b2054dd383ea4948b9a820c0 2b0e097680014309b4ccacb1d8fdf03b--71e0e2f4b2054dd383ea4948b9a820c0 a1c02aa8de3c4202bf34ff4b2af0a5a9 71e0e2f4b2054dd383ea4948b9a820c0--a1c02aa8de3c4202bf34ff4b2af0a5a9 17f0ec87635e4a0c89734086a916be66 a1c02aa8de3c4202bf34ff4b2af0a5a9--17f0ec87635e4a0c89734086a916be66 356e55be87bc4393a6a6009bc5eccfa2 17f0ec87635e4a0c89734086a916be66--356e55be87bc4393a6a6009bc5eccfa2 f2490e25f0a8458b8c68fcac803c1499 356e55be87bc4393a6a6009bc5eccfa2--f2490e25f0a8458b8c68fcac803c1499 bdd1d9901d78425cb69cfa7ed7a03494 f2490e25f0a8458b8c68fcac803c1499--bdd1d9901d78425cb69cfa7ed7a03494 84bf6dd8c9a74e1d8f5b454b14c8182b bdd1d9901d78425cb69cfa7ed7a03494--84bf6dd8c9a74e1d8f5b454b14c8182b 5ae9c655e996440483d392aceaef2f9d 84bf6dd8c9a74e1d8f5b454b14c8182b--5ae9c655e996440483d392aceaef2f9d 5ad140e05672491188ed302b5918f9e0 5ae9c655e996440483d392aceaef2f9d--5ad140e05672491188ed302b5918f9e0 0dc65f07ea604b429a15e98825d12c2f RX(b00) 5ad140e05672491188ed302b5918f9e0--0dc65f07ea604b429a15e98825d12c2f 89074792cc3d4b25af1c1afe536969d0 0dc65f07ea604b429a15e98825d12c2f--89074792cc3d4b25af1c1afe536969d0 d0d1c27b084e447ea34971b14fd388fc 89074792cc3d4b25af1c1afe536969d0--d0d1c27b084e447ea34971b14fd388fc cb0dc7479a3c432a9ddc3f2c09f824f3 d0d1c27b084e447ea34971b14fd388fc--cb0dc7479a3c432a9ddc3f2c09f824f3 9ec5c7d1054047459b4725a67cf0bda6 cb0dc7479a3c432a9ddc3f2c09f824f3--9ec5c7d1054047459b4725a67cf0bda6 b53736ad5c974dbaa3240268b442687a 9ec5c7d1054047459b4725a67cf0bda6--b53736ad5c974dbaa3240268b442687a 508a78569f9b4d6ca98c25859d1ff871 b53736ad5c974dbaa3240268b442687a--508a78569f9b4d6ca98c25859d1ff871 8c43a682ef474100b486c63dc51ccf9b 508a78569f9b4d6ca98c25859d1ff871--8c43a682ef474100b486c63dc51ccf9b dd17c893e0664cdcb8bf4f1ec39cc8b2 8c43a682ef474100b486c63dc51ccf9b--dd17c893e0664cdcb8bf4f1ec39cc8b2 09eedc2fb3bb404fb8e34cf411857a34 dd17c893e0664cdcb8bf4f1ec39cc8b2--09eedc2fb3bb404fb8e34cf411857a34 c6d5eea3f3854289bdc3fed7d86030a2 09eedc2fb3bb404fb8e34cf411857a34--c6d5eea3f3854289bdc3fed7d86030a2 e7de1bfec40e47039ff7cf23c827e7b6 c6d5eea3f3854289bdc3fed7d86030a2--e7de1bfec40e47039ff7cf23c827e7b6 7e9053cc9a1a4812a8cf080096de773d e7de1bfec40e47039ff7cf23c827e7b6--7e9053cc9a1a4812a8cf080096de773d d7b852a58fbd48a68301a6f1d5aecc57 7e9053cc9a1a4812a8cf080096de773d--d7b852a58fbd48a68301a6f1d5aecc57 72a5e7fd32c643a88d4ea0fbcc0919c5 d7b852a58fbd48a68301a6f1d5aecc57--72a5e7fd32c643a88d4ea0fbcc0919c5 8116b84329d840018d44f5273c85b914 72a5e7fd32c643a88d4ea0fbcc0919c5--8116b84329d840018d44f5273c85b914 1eb0e59eb0424cf58c668c309debd5a2 8116b84329d840018d44f5273c85b914--1eb0e59eb0424cf58c668c309debd5a2 b25c79075ebd495f92425923d204122e 1eb0e59eb0424cf58c668c309debd5a2--b25c79075ebd495f92425923d204122e e2241d6177004f52aa68d90d09a57660 b25c79075ebd495f92425923d204122e--e2241d6177004f52aa68d90d09a57660 2420ed86c75e4ffc8248007f215c421f e2241d6177004f52aa68d90d09a57660--2420ed86c75e4ffc8248007f215c421f 4f0b25565b1a4921b830c8489d214ed5 2420ed86c75e4ffc8248007f215c421f--4f0b25565b1a4921b830c8489d214ed5 fa8094beeb2747a59a62bd311a8f50c2 4f0b25565b1a4921b830c8489d214ed5--fa8094beeb2747a59a62bd311a8f50c2 5e3cc91d23d74bf6a63a9552b0ad8e47 fa8094beeb2747a59a62bd311a8f50c2--5e3cc91d23d74bf6a63a9552b0ad8e47 5a92ed8a71564c16a8a9254255a97e21 5e3cc91d23d74bf6a63a9552b0ad8e47--5a92ed8a71564c16a8a9254255a97e21 981e7fe77d364656b73e1b4386f5c4ab 5a92ed8a71564c16a8a9254255a97e21--981e7fe77d364656b73e1b4386f5c4ab 7c5251bd41564099b322cd3122adcb3b 981e7fe77d364656b73e1b4386f5c4ab--7c5251bd41564099b322cd3122adcb3b 58b15fa42a344c728ba66e73ab2eb734 7c5251bd41564099b322cd3122adcb3b--58b15fa42a344c728ba66e73ab2eb734 3a66557668714b8c8c3be38757245772 58b15fa42a344c728ba66e73ab2eb734--3a66557668714b8c8c3be38757245772 0a8164c5dd3b4a778eb43ef769ab7e26 3a66557668714b8c8c3be38757245772--0a8164c5dd3b4a778eb43ef769ab7e26 a4656d9273fc482da1f2613785afa07c 0a8164c5dd3b4a778eb43ef769ab7e26--a4656d9273fc482da1f2613785afa07c b13f0aee841846d881d3ab63cdec33eb a4656d9273fc482da1f2613785afa07c--b13f0aee841846d881d3ab63cdec33eb 08fefb318d6b4d518a3b044f5780b605 b13f0aee841846d881d3ab63cdec33eb--08fefb318d6b4d518a3b044f5780b605 195440ac79c9476296a0290d72a67266 08fefb318d6b4d518a3b044f5780b605--195440ac79c9476296a0290d72a67266 b35381a489e74088a53fea81ea072d96 195440ac79c9476296a0290d72a67266--b35381a489e74088a53fea81ea072d96 86277654f5b74c499f16f6cbbf31b220 b35381a489e74088a53fea81ea072d96--86277654f5b74c499f16f6cbbf31b220 f073fa5cf36e444996850451fd5b6870 86277654f5b74c499f16f6cbbf31b220--f073fa5cf36e444996850451fd5b6870 19edbef053c44ccf96ffe2eb05eca69a f073fa5cf36e444996850451fd5b6870--19edbef053c44ccf96ffe2eb05eca69a 5219c64b47f8405ab8a4fa07c59641b3 19edbef053c44ccf96ffe2eb05eca69a--5219c64b47f8405ab8a4fa07c59641b3 d23dfd278a3b43bca605bf2802083dec 5219c64b47f8405ab8a4fa07c59641b3--d23dfd278a3b43bca605bf2802083dec 9ccdc87d358a44b4aacea3d2cd89f26a d23dfd278a3b43bca605bf2802083dec--9ccdc87d358a44b4aacea3d2cd89f26a de77287c40df4c6ba26c21927ef313ec 9ccdc87d358a44b4aacea3d2cd89f26a--de77287c40df4c6ba26c21927ef313ec 0b8f3faffe2d4a66bb4a43a923bf68f1 de77287c40df4c6ba26c21927ef313ec--0b8f3faffe2d4a66bb4a43a923bf68f1 311e56d5bd4244328704dec1f3a3ec9b 0b8f3faffe2d4a66bb4a43a923bf68f1--311e56d5bd4244328704dec1f3a3ec9b b6dea430d7ed45ad8d9411a7dd7a8ebe 311e56d5bd4244328704dec1f3a3ec9b--b6dea430d7ed45ad8d9411a7dd7a8ebe 1dc39c7caa074588888bb14b975b1c18 b6dea430d7ed45ad8d9411a7dd7a8ebe--1dc39c7caa074588888bb14b975b1c18 1aba52d2baf94ff38238fb709f9920a8 1dc39c7caa074588888bb14b975b1c18--1aba52d2baf94ff38238fb709f9920a8 de8c9f2a89d7454e96bd5a28334ce721 1aba52d2baf94ff38238fb709f9920a8--de8c9f2a89d7454e96bd5a28334ce721 2c1095ea5184459a90436c8f0ba3f792 de8c9f2a89d7454e96bd5a28334ce721--2c1095ea5184459a90436c8f0ba3f792 5b534cd83502443992475c0579a0f2de 2c1095ea5184459a90436c8f0ba3f792--5b534cd83502443992475c0579a0f2de 287b3d80462c4096b835e17f5d6cd8ba 5b534cd83502443992475c0579a0f2de--287b3d80462c4096b835e17f5d6cd8ba 8b796825c2ff48bcbf10cbd7fef60e2c 287b3d80462c4096b835e17f5d6cd8ba--8b796825c2ff48bcbf10cbd7fef60e2c 51389c0e3a554a3e8530b4d8417ae158 8b796825c2ff48bcbf10cbd7fef60e2c--51389c0e3a554a3e8530b4d8417ae158 a4c95bc7d22e4d5ca772e25c2562faa8 51389c0e3a554a3e8530b4d8417ae158--a4c95bc7d22e4d5ca772e25c2562faa8 c85dd7ade17f4d5bafb34ec693ffa26b a4c95bc7d22e4d5ca772e25c2562faa8--c85dd7ade17f4d5bafb34ec693ffa26b 99ee511f46514c20a8f56320d6504b58 c85dd7ade17f4d5bafb34ec693ffa26b--99ee511f46514c20a8f56320d6504b58 7fd5b9cc75a04a8fa0a6dc64c7df0074 99ee511f46514c20a8f56320d6504b58--7fd5b9cc75a04a8fa0a6dc64c7df0074 2019fb3106fa4afa9caf6469c88a9423 7fd5b9cc75a04a8fa0a6dc64c7df0074--2019fb3106fa4afa9caf6469c88a9423 6d3759270ddb4c4786f8c7d8b0408bdb 2019fb3106fa4afa9caf6469c88a9423--6d3759270ddb4c4786f8c7d8b0408bdb c5a0546c250c4a69a99e085af8c29c6e 6d3759270ddb4c4786f8c7d8b0408bdb--c5a0546c250c4a69a99e085af8c29c6e d8e93cbaa9b644b19016d9c57b414a72 c5a0546c250c4a69a99e085af8c29c6e--d8e93cbaa9b644b19016d9c57b414a72 ac97f77fe2c34efc957197908bfd709f d8e93cbaa9b644b19016d9c57b414a72--ac97f77fe2c34efc957197908bfd709f d33b5e89b9094702bc01a336202ecd8e ac97f77fe2c34efc957197908bfd709f--d33b5e89b9094702bc01a336202ecd8e 23ed7ed529e546c7905ec04018a816ec d33b5e89b9094702bc01a336202ecd8e--23ed7ed529e546c7905ec04018a816ec 8a58586535824671a0db5450a304e29f 23ed7ed529e546c7905ec04018a816ec--8a58586535824671a0db5450a304e29f 6fafac9dbc4241c3862bfc3573ae8bd7 8a58586535824671a0db5450a304e29f--6fafac9dbc4241c3862bfc3573ae8bd7 19a560c92c264473aece318a02e315e8 6fafac9dbc4241c3862bfc3573ae8bd7--19a560c92c264473aece318a02e315e8 f0250697f33846b68e9973c9f6458470 19a560c92c264473aece318a02e315e8--f0250697f33846b68e9973c9f6458470 23b3ea2dc3d04566b9e61bd3937868f6 f0250697f33846b68e9973c9f6458470--23b3ea2dc3d04566b9e61bd3937868f6 f34f9ddffb074a448f9cca494d61a457 23b3ea2dc3d04566b9e61bd3937868f6--f34f9ddffb074a448f9cca494d61a457 859da1f256d349d897f0cb27e2be2d23 f34f9ddffb074a448f9cca494d61a457--859da1f256d349d897f0cb27e2be2d23 589698b0a6d9476db20eea526a7f655e 859da1f256d349d897f0cb27e2be2d23--589698b0a6d9476db20eea526a7f655e 482df90b876a4e68be870a910684b5ca 589698b0a6d9476db20eea526a7f655e--482df90b876a4e68be870a910684b5ca 5e3714c90d9e4aa292a4985d863be886 482df90b876a4e68be870a910684b5ca--5e3714c90d9e4aa292a4985d863be886 26e5320e4e344adf87721899903b4090 5e3714c90d9e4aa292a4985d863be886--26e5320e4e344adf87721899903b4090 4f1b5d7e596948a88077a4d65b5057d4 26e5320e4e344adf87721899903b4090--4f1b5d7e596948a88077a4d65b5057d4 a43168e9f7a84a1cb3360305aac8ab96 4f1b5d7e596948a88077a4d65b5057d4--a43168e9f7a84a1cb3360305aac8ab96 caab25ca85c943cdbd9048737fc183d1 a43168e9f7a84a1cb3360305aac8ab96--caab25ca85c943cdbd9048737fc183d1 bea5e41da83641239bb5cfe902664b75 caab25ca85c943cdbd9048737fc183d1--bea5e41da83641239bb5cfe902664b75 0fcb31266b124831ad1e5ee255d80c2d bea5e41da83641239bb5cfe902664b75--0fcb31266b124831ad1e5ee255d80c2d 08b4b7f2febd48b585a6336e0bbf5c34 0fcb31266b124831ad1e5ee255d80c2d--08b4b7f2febd48b585a6336e0bbf5c34 d8b71e47323b4e4ab15951be3b94b380 08b4b7f2febd48b585a6336e0bbf5c34--d8b71e47323b4e4ab15951be3b94b380 4e5483c8a7874c1bb60eaab3e32f4541 d8b71e47323b4e4ab15951be3b94b380--4e5483c8a7874c1bb60eaab3e32f4541 068b125e1eb44741b4a1dd5a7c13b3b4 4e5483c8a7874c1bb60eaab3e32f4541--068b125e1eb44741b4a1dd5a7c13b3b4 32d7001073f34be3b530f94685ce8f4b 068b125e1eb44741b4a1dd5a7c13b3b4--32d7001073f34be3b530f94685ce8f4b 2391768286a945e49b44fe23f53fcd57 32d7001073f34be3b530f94685ce8f4b--2391768286a945e49b44fe23f53fcd57 7040b3fa71ce493cb9f1328cbfac704b 2391768286a945e49b44fe23f53fcd57--7040b3fa71ce493cb9f1328cbfac704b f39aa538df05462595fbaa7d9677ebe6 7040b3fa71ce493cb9f1328cbfac704b--f39aa538df05462595fbaa7d9677ebe6 9a79649782c04b0280c73a9a6981dc84 f39aa538df05462595fbaa7d9677ebe6--9a79649782c04b0280c73a9a6981dc84 4bea8a9c796b48d59ad578e524c37432 9a79649782c04b0280c73a9a6981dc84--4bea8a9c796b48d59ad578e524c37432 6136a81757eb4d41a8a84e5163d664fe 4bea8a9c796b48d59ad578e524c37432--6136a81757eb4d41a8a84e5163d664fe 5fc3c0ef2b804a37aa2949ed3ec08479 6136a81757eb4d41a8a84e5163d664fe--5fc3c0ef2b804a37aa2949ed3ec08479 c93e1b343e4345c89ff6d272805b100c 5fc3c0ef2b804a37aa2949ed3ec08479--c93e1b343e4345c89ff6d272805b100c 3ed4ce8952bf4652a864df683af33213 c93e1b343e4345c89ff6d272805b100c--3ed4ce8952bf4652a864df683af33213 3c525518960f47da8563b124502a3bfc 3ed4ce8952bf4652a864df683af33213--3c525518960f47da8563b124502a3bfc f64f82cbf9b0484d8429cb9a67cd15fb 3c525518960f47da8563b124502a3bfc--f64f82cbf9b0484d8429cb9a67cd15fb 5439d4d3144f415ba2d5facdb634bd1b f64f82cbf9b0484d8429cb9a67cd15fb--5439d4d3144f415ba2d5facdb634bd1b 75b238c795114680b0d5f6c215cbc1ae 5439d4d3144f415ba2d5facdb634bd1b--75b238c795114680b0d5f6c215cbc1ae 34112cf2b11746acbc26df65c5b6a36e 75b238c795114680b0d5f6c215cbc1ae--34112cf2b11746acbc26df65c5b6a36e dae63ea05d6e440b87ae4ac2768a3655 34112cf2b11746acbc26df65c5b6a36e--dae63ea05d6e440b87ae4ac2768a3655 cbb335b2d7be47148ba1155a6383dcca dae63ea05d6e440b87ae4ac2768a3655--cbb335b2d7be47148ba1155a6383dcca 9b6701fbe5654dd79052c4ed4269e10b cbb335b2d7be47148ba1155a6383dcca--9b6701fbe5654dd79052c4ed4269e10b 24e55611f6d7402e9f22745e890b0a63 9b6701fbe5654dd79052c4ed4269e10b--24e55611f6d7402e9f22745e890b0a63 d16c04544e1d4c178f255321b1a78a63 24e55611f6d7402e9f22745e890b0a63--d16c04544e1d4c178f255321b1a78a63 c1b7cba787d24e4da9bdbfc314e83c70 d16c04544e1d4c178f255321b1a78a63--c1b7cba787d24e4da9bdbfc314e83c70 d34e31ce31964f7386f0f3db842f390f c1b7cba787d24e4da9bdbfc314e83c70--d34e31ce31964f7386f0f3db842f390f 758697b60d9a498995ede9440c9a352d d34e31ce31964f7386f0f3db842f390f--758697b60d9a498995ede9440c9a352d ded16c82c05c4e528111fd308dfa7e2b 758697b60d9a498995ede9440c9a352d--ded16c82c05c4e528111fd308dfa7e2b c38affc5732f43849edf60a17bf0644c RX(b10) ded16c82c05c4e528111fd308dfa7e2b--c38affc5732f43849edf60a17bf0644c 6c1c1080437f4fb3b514a0e087c65f4b c38affc5732f43849edf60a17bf0644c--6c1c1080437f4fb3b514a0e087c65f4b 89f87f654132415dbcb137305a3f8089 01595c803d2841b2a6952173970c3a74 X 2bd5636a4c8547d2abf59773f33fb58a--01595c803d2841b2a6952173970c3a74 656c796db81a429283c2802aa7ba3122 2 01595c803d2841b2a6952173970c3a74--f5cc339ef3a24f2bad4a4da67d706579 3774f68e7976468b8725983ce6d15454 01595c803d2841b2a6952173970c3a74--3774f68e7976468b8725983ce6d15454 058bcfef1f844efe9440be5cc98e0f65 3774f68e7976468b8725983ce6d15454--058bcfef1f844efe9440be5cc98e0f65 0ef32c8287f9408a92b511a4e4a63bae 058bcfef1f844efe9440be5cc98e0f65--0ef32c8287f9408a92b511a4e4a63bae e30ac7dccfbc4b63a6ceef527fc4af81 0ef32c8287f9408a92b511a4e4a63bae--e30ac7dccfbc4b63a6ceef527fc4af81 63434b289839429a916849c5f8fc71d4 e30ac7dccfbc4b63a6ceef527fc4af81--63434b289839429a916849c5f8fc71d4 4a10ae50d6aa47fe879dbf0cd00f702c 63434b289839429a916849c5f8fc71d4--4a10ae50d6aa47fe879dbf0cd00f702c a79619c0d0c0482da5f675089d530498 4a10ae50d6aa47fe879dbf0cd00f702c--a79619c0d0c0482da5f675089d530498 e7d4674fcb3e45f8a08e912540f34be5 a79619c0d0c0482da5f675089d530498--e7d4674fcb3e45f8a08e912540f34be5 ee16b129002045c3aff9c8c82a2dc903 e7d4674fcb3e45f8a08e912540f34be5--ee16b129002045c3aff9c8c82a2dc903 bccfaf6bc4f54495b511305223ef6980 ee16b129002045c3aff9c8c82a2dc903--bccfaf6bc4f54495b511305223ef6980 e2794bd2cda149138b645515afecab3f bccfaf6bc4f54495b511305223ef6980--e2794bd2cda149138b645515afecab3f 80961b2da334470a80f8c30f129ef7b5 e2794bd2cda149138b645515afecab3f--80961b2da334470a80f8c30f129ef7b5 6536407a7bea48dc9ea65c8ca47a3fdd 80961b2da334470a80f8c30f129ef7b5--6536407a7bea48dc9ea65c8ca47a3fdd c8f67217ffce472c9aacca1dbf0e92e5 X 6536407a7bea48dc9ea65c8ca47a3fdd--c8f67217ffce472c9aacca1dbf0e92e5 c8f67217ffce472c9aacca1dbf0e92e5--ad7e7af933e14d4cbcad6799301b266b 9d0074d8bf304b30ae33b7f90fdac765 X c8f67217ffce472c9aacca1dbf0e92e5--9d0074d8bf304b30ae33b7f90fdac765 9d0074d8bf304b30ae33b7f90fdac765--b99db0343e814f17a09a89a267d6c261 5e909a2ba52249868205a3ca890b3665 9d0074d8bf304b30ae33b7f90fdac765--5e909a2ba52249868205a3ca890b3665 94c55c7b22b8476bb9022ab75c374962 5e909a2ba52249868205a3ca890b3665--94c55c7b22b8476bb9022ab75c374962 040dfb9234854f04b033f08618075690 94c55c7b22b8476bb9022ab75c374962--040dfb9234854f04b033f08618075690 e3b63132b4b14fa9ac2fb188545372ee X 040dfb9234854f04b033f08618075690--e3b63132b4b14fa9ac2fb188545372ee e3b63132b4b14fa9ac2fb188545372ee--8b67a0ad05c442329b81f5fa05cf0778 0ca770df25ce48948f9a14d03ab94bbe X e3b63132b4b14fa9ac2fb188545372ee--0ca770df25ce48948f9a14d03ab94bbe 0ca770df25ce48948f9a14d03ab94bbe--50e9a79b5f7a4553839f02c98258a390 776243f3ed394a859b45340e7154803a 0ca770df25ce48948f9a14d03ab94bbe--776243f3ed394a859b45340e7154803a 0df2a21ba1374d3daea3c8653bd8d8e1 776243f3ed394a859b45340e7154803a--0df2a21ba1374d3daea3c8653bd8d8e1 74ea215f05214ff8becb3fc4a56d10fa 0df2a21ba1374d3daea3c8653bd8d8e1--74ea215f05214ff8becb3fc4a56d10fa 17a25f5277e245939a0293159ae669c3 74ea215f05214ff8becb3fc4a56d10fa--17a25f5277e245939a0293159ae669c3 352887d3ae834cb284677fda6c409408 17a25f5277e245939a0293159ae669c3--352887d3ae834cb284677fda6c409408 00b5ffbad3d343d6a93f3f165dbd7ed7 X 352887d3ae834cb284677fda6c409408--00b5ffbad3d343d6a93f3f165dbd7ed7 00b5ffbad3d343d6a93f3f165dbd7ed7--d5f13ee60a234d6cb4ca4d026b23359a f11a3150268e488faf443e05a62de9af X 00b5ffbad3d343d6a93f3f165dbd7ed7--f11a3150268e488faf443e05a62de9af f11a3150268e488faf443e05a62de9af--f178e3a7803d4a60861a11d6ae5bf97e 87698286d98b42698658b3fe9048b05c f11a3150268e488faf443e05a62de9af--87698286d98b42698658b3fe9048b05c 810310bae1074d88985be2db899072ab 87698286d98b42698658b3fe9048b05c--810310bae1074d88985be2db899072ab c77fd7d4d1404d159f47ad1ee5c2b1e5 810310bae1074d88985be2db899072ab--c77fd7d4d1404d159f47ad1ee5c2b1e5 a54293c61cda433180fd2e0778ab03fc c77fd7d4d1404d159f47ad1ee5c2b1e5--a54293c61cda433180fd2e0778ab03fc 1a457bbfa86f404d90119c208d456702 a54293c61cda433180fd2e0778ab03fc--1a457bbfa86f404d90119c208d456702 e0ec719024b1407ca941fb29c03020fa 1a457bbfa86f404d90119c208d456702--e0ec719024b1407ca941fb29c03020fa 76ab1459577d42999db6858557df2f94 e0ec719024b1407ca941fb29c03020fa--76ab1459577d42999db6858557df2f94 fa51bdbaf3484062b44936040eee8e6a X 76ab1459577d42999db6858557df2f94--fa51bdbaf3484062b44936040eee8e6a fa51bdbaf3484062b44936040eee8e6a--60638ed2d3454e868f4f517f26c05124 6ae9369953d94b1883d1fd5685658d2d X fa51bdbaf3484062b44936040eee8e6a--6ae9369953d94b1883d1fd5685658d2d 6ae9369953d94b1883d1fd5685658d2d--f80082318ea14e9fb137a22ddb6ae576 37aa5764be1444dea4df362742994983 6ae9369953d94b1883d1fd5685658d2d--37aa5764be1444dea4df362742994983 b775a3d0e821472886461180f94ed793 37aa5764be1444dea4df362742994983--b775a3d0e821472886461180f94ed793 485aa1eaf5434120b7dcf44de3be967b b775a3d0e821472886461180f94ed793--485aa1eaf5434120b7dcf44de3be967b ae3173ced23b4ae8825313190f80e999 485aa1eaf5434120b7dcf44de3be967b--ae3173ced23b4ae8825313190f80e999 501d183f63484c39870e624a256a339d ae3173ced23b4ae8825313190f80e999--501d183f63484c39870e624a256a339d 56ced50d2b5a444aaf769c5e967ef49b 501d183f63484c39870e624a256a339d--56ced50d2b5a444aaf769c5e967ef49b 3d7d30f7cbfe4edd90a52e97d00e16ff 56ced50d2b5a444aaf769c5e967ef49b--3d7d30f7cbfe4edd90a52e97d00e16ff 5a38b39b26e84c2f9593bdca98dddbd8 3d7d30f7cbfe4edd90a52e97d00e16ff--5a38b39b26e84c2f9593bdca98dddbd8 230ef8414d134a9ca9b50e42a09d51d3 5a38b39b26e84c2f9593bdca98dddbd8--230ef8414d134a9ca9b50e42a09d51d3 8bb5eef0459b4e1d90cd67d7e946d2a1 230ef8414d134a9ca9b50e42a09d51d3--8bb5eef0459b4e1d90cd67d7e946d2a1 3298e264e44c41f5adf823195bd513aa 8bb5eef0459b4e1d90cd67d7e946d2a1--3298e264e44c41f5adf823195bd513aa 51f960c87278475cad5999d159636340 X 3298e264e44c41f5adf823195bd513aa--51f960c87278475cad5999d159636340 51f960c87278475cad5999d159636340--f6cb8c82a1ce4b759062dacfdb4c53b0 75c6a4eed02940bc97863cc628e84d82 51f960c87278475cad5999d159636340--75c6a4eed02940bc97863cc628e84d82 d5f8b1ab4a9849ab9c4f115005cb396e 75c6a4eed02940bc97863cc628e84d82--d5f8b1ab4a9849ab9c4f115005cb396e a2d5234e5c9e40f1ab512a8cae9c97b3 d5f8b1ab4a9849ab9c4f115005cb396e--a2d5234e5c9e40f1ab512a8cae9c97b3 7fb0e33b10a04a0e80a4a764457daa68 a2d5234e5c9e40f1ab512a8cae9c97b3--7fb0e33b10a04a0e80a4a764457daa68 e6cd122aed90477481a8021cfb9e11d1 7fb0e33b10a04a0e80a4a764457daa68--e6cd122aed90477481a8021cfb9e11d1 2255d2fdd93b499884d963ffff161cc8 e6cd122aed90477481a8021cfb9e11d1--2255d2fdd93b499884d963ffff161cc8 17fd25c734ec4cc498c61775b3466ac3 2255d2fdd93b499884d963ffff161cc8--17fd25c734ec4cc498c61775b3466ac3 2c3c8386ca804fe2978892928d205067 17fd25c734ec4cc498c61775b3466ac3--2c3c8386ca804fe2978892928d205067 9ac100765a864b0c9f778c8ed324335d 2c3c8386ca804fe2978892928d205067--9ac100765a864b0c9f778c8ed324335d 4e1835909b7042c2aab71f479db33343 9ac100765a864b0c9f778c8ed324335d--4e1835909b7042c2aab71f479db33343 edcbae40b47f45bd8947a2715c23c150 4e1835909b7042c2aab71f479db33343--edcbae40b47f45bd8947a2715c23c150 99ed6cf6c1ea41cf930806bd9068878f edcbae40b47f45bd8947a2715c23c150--99ed6cf6c1ea41cf930806bd9068878f 847dea9cb6674334bc051f441d358726 99ed6cf6c1ea41cf930806bd9068878f--847dea9cb6674334bc051f441d358726 119cd8571b0c4f41909ce142a130e886 847dea9cb6674334bc051f441d358726--119cd8571b0c4f41909ce142a130e886 315d46b2a142453e9ada6f4fd5c6c5de 119cd8571b0c4f41909ce142a130e886--315d46b2a142453e9ada6f4fd5c6c5de cf130e7842224a41a59428358648a63b 315d46b2a142453e9ada6f4fd5c6c5de--cf130e7842224a41a59428358648a63b 61f23bfec6354695b7515b3275c710bf cf130e7842224a41a59428358648a63b--61f23bfec6354695b7515b3275c710bf f4a15c4d023b4514ac46e6ced4439149 61f23bfec6354695b7515b3275c710bf--f4a15c4d023b4514ac46e6ced4439149 760f06a21e6041358c33f3b6d5fb8375 f4a15c4d023b4514ac46e6ced4439149--760f06a21e6041358c33f3b6d5fb8375 4f6c2f2ff3cd47b9940852d5a5bf0c6f 760f06a21e6041358c33f3b6d5fb8375--4f6c2f2ff3cd47b9940852d5a5bf0c6f 4103d24e31e9409abb3ebf751eb57b88 4f6c2f2ff3cd47b9940852d5a5bf0c6f--4103d24e31e9409abb3ebf751eb57b88 26fb0dc30d5d4a8f8073e1d07bedf06c 4103d24e31e9409abb3ebf751eb57b88--26fb0dc30d5d4a8f8073e1d07bedf06c 18fd1c0923c64381aed79b0b0520c1c9 26fb0dc30d5d4a8f8073e1d07bedf06c--18fd1c0923c64381aed79b0b0520c1c9 8a65f700c58b4f63a7a4f19669c40096 18fd1c0923c64381aed79b0b0520c1c9--8a65f700c58b4f63a7a4f19669c40096 c027c4bf365248a29d6f878563e2348f 8a65f700c58b4f63a7a4f19669c40096--c027c4bf365248a29d6f878563e2348f 435a23bb97554ca0b71491b39766169b c027c4bf365248a29d6f878563e2348f--435a23bb97554ca0b71491b39766169b 884c4ca187c1448b895aac3cade0afb7 435a23bb97554ca0b71491b39766169b--884c4ca187c1448b895aac3cade0afb7 ddf6398948614e62a3e8d963dd8e9d8e 884c4ca187c1448b895aac3cade0afb7--ddf6398948614e62a3e8d963dd8e9d8e 2f64141178f14a4a8c573e901465cbb4 ddf6398948614e62a3e8d963dd8e9d8e--2f64141178f14a4a8c573e901465cbb4 26cdd87a9ad04477b8c615c0e3617b63 2f64141178f14a4a8c573e901465cbb4--26cdd87a9ad04477b8c615c0e3617b63 d1083edf4ec042a2b3eda8023afce682 26cdd87a9ad04477b8c615c0e3617b63--d1083edf4ec042a2b3eda8023afce682 e4f1942f931c40b1befe8d7a20073f1c d1083edf4ec042a2b3eda8023afce682--e4f1942f931c40b1befe8d7a20073f1c 306d64ba82c143b8a19bf05f19cb0301 e4f1942f931c40b1befe8d7a20073f1c--306d64ba82c143b8a19bf05f19cb0301 1a1e8d30dc694f3c983ba9331d91c3b2 306d64ba82c143b8a19bf05f19cb0301--1a1e8d30dc694f3c983ba9331d91c3b2 c6fa96c1e7ea49b98507cf9908e696cd 1a1e8d30dc694f3c983ba9331d91c3b2--c6fa96c1e7ea49b98507cf9908e696cd b6c9117af39f47df89f2cf2a4c835199 c6fa96c1e7ea49b98507cf9908e696cd--b6c9117af39f47df89f2cf2a4c835199 e08bf6168ec94d29b647bf558fe84070 b6c9117af39f47df89f2cf2a4c835199--e08bf6168ec94d29b647bf558fe84070 362e1d1cdc0f41d581951ee5825596e3 e08bf6168ec94d29b647bf558fe84070--362e1d1cdc0f41d581951ee5825596e3 7b10197006fe45e2af63a0a28521f241 362e1d1cdc0f41d581951ee5825596e3--7b10197006fe45e2af63a0a28521f241 93cf077903d845258da59f67b3131ccb 7b10197006fe45e2af63a0a28521f241--93cf077903d845258da59f67b3131ccb 9ca2172a8383415da1bd5ab44aeae1ae 93cf077903d845258da59f67b3131ccb--9ca2172a8383415da1bd5ab44aeae1ae 7bbf2edfc88f41aa8c080b3e42c386a4 9ca2172a8383415da1bd5ab44aeae1ae--7bbf2edfc88f41aa8c080b3e42c386a4 2e4fecd89127483caa2aa89927c43f01 7bbf2edfc88f41aa8c080b3e42c386a4--2e4fecd89127483caa2aa89927c43f01 b35c5221a17942638b2d889809395122 2e4fecd89127483caa2aa89927c43f01--b35c5221a17942638b2d889809395122 a9543f82e3af453581edc209553e9526 b35c5221a17942638b2d889809395122--a9543f82e3af453581edc209553e9526 cda9869156864ea99c2e1d18b0704c36 a9543f82e3af453581edc209553e9526--cda9869156864ea99c2e1d18b0704c36 993fce8c09384addb39ff5db001ee34c cda9869156864ea99c2e1d18b0704c36--993fce8c09384addb39ff5db001ee34c 99b30aece39248249d81f0d3e6c6d78a 993fce8c09384addb39ff5db001ee34c--99b30aece39248249d81f0d3e6c6d78a 436ae6014d0b4bbebb24c090bf8573dd 99b30aece39248249d81f0d3e6c6d78a--436ae6014d0b4bbebb24c090bf8573dd a8f9501bba7d4b95949fd57dd2a095b4 436ae6014d0b4bbebb24c090bf8573dd--a8f9501bba7d4b95949fd57dd2a095b4 35ad51026b78417a8459bf8949010e51 a8f9501bba7d4b95949fd57dd2a095b4--35ad51026b78417a8459bf8949010e51 4247bf4fdf2649efac23d2adc1a63acd 35ad51026b78417a8459bf8949010e51--4247bf4fdf2649efac23d2adc1a63acd d9e7871857f04478b7a07de474f3a91e 4247bf4fdf2649efac23d2adc1a63acd--d9e7871857f04478b7a07de474f3a91e 48faa72b3f0240fba7ec4779d6032d41 d9e7871857f04478b7a07de474f3a91e--48faa72b3f0240fba7ec4779d6032d41 25fabf3609af40f89c1fbe3e9e5c6c28 48faa72b3f0240fba7ec4779d6032d41--25fabf3609af40f89c1fbe3e9e5c6c28 1ebfade1be864f19841d8a25c3d0a1a3 25fabf3609af40f89c1fbe3e9e5c6c28--1ebfade1be864f19841d8a25c3d0a1a3 a3b47e9fff134d299012a41f0851bbf7 1ebfade1be864f19841d8a25c3d0a1a3--a3b47e9fff134d299012a41f0851bbf7 37a2288dbe9649f88bbac9eea8bde7dc RX(b01) a3b47e9fff134d299012a41f0851bbf7--37a2288dbe9649f88bbac9eea8bde7dc ace95c418bb843ca8d86557cc5033710 X 37a2288dbe9649f88bbac9eea8bde7dc--ace95c418bb843ca8d86557cc5033710 ace95c418bb843ca8d86557cc5033710--89074792cc3d4b25af1c1afe536969d0 5c3f20549c75405e9e6ce0197ec56ede ace95c418bb843ca8d86557cc5033710--5c3f20549c75405e9e6ce0197ec56ede 1155dd95bc8341989c96d08defefee19 5c3f20549c75405e9e6ce0197ec56ede--1155dd95bc8341989c96d08defefee19 97b34a3138014e4483ad1e59ed1c0f0d 1155dd95bc8341989c96d08defefee19--97b34a3138014e4483ad1e59ed1c0f0d 415a7e1e5ae44a8a90780011fbd78353 97b34a3138014e4483ad1e59ed1c0f0d--415a7e1e5ae44a8a90780011fbd78353 06f61d3136344810902b2d80067b6b74 415a7e1e5ae44a8a90780011fbd78353--06f61d3136344810902b2d80067b6b74 5266966224104045b42514cc10bc2199 06f61d3136344810902b2d80067b6b74--5266966224104045b42514cc10bc2199 b703ddc3829247d18d914fab355e6129 5266966224104045b42514cc10bc2199--b703ddc3829247d18d914fab355e6129 bf36b11b307841c2922491e2eadaf1ae b703ddc3829247d18d914fab355e6129--bf36b11b307841c2922491e2eadaf1ae 7f1bab8f40584dc9a50933335d53c137 bf36b11b307841c2922491e2eadaf1ae--7f1bab8f40584dc9a50933335d53c137 0e210b4c459f4964bef6a1141ea309db 7f1bab8f40584dc9a50933335d53c137--0e210b4c459f4964bef6a1141ea309db 3fc923114a5a478892b36f7464b43b65 0e210b4c459f4964bef6a1141ea309db--3fc923114a5a478892b36f7464b43b65 a0b7c37fd6e949848e89d913c3a4a5fe 3fc923114a5a478892b36f7464b43b65--a0b7c37fd6e949848e89d913c3a4a5fe e16730f616054d4e9bb9a10c98dc3ec5 a0b7c37fd6e949848e89d913c3a4a5fe--e16730f616054d4e9bb9a10c98dc3ec5 04acd59604d14e0d922c21f96f07f185 X e16730f616054d4e9bb9a10c98dc3ec5--04acd59604d14e0d922c21f96f07f185 04acd59604d14e0d922c21f96f07f185--8116b84329d840018d44f5273c85b914 23a7c59053e64637b1230f763a37e7ec X 04acd59604d14e0d922c21f96f07f185--23a7c59053e64637b1230f763a37e7ec 23a7c59053e64637b1230f763a37e7ec--1eb0e59eb0424cf58c668c309debd5a2 0f6a9896f16d48b9b7236c08bd6dd297 23a7c59053e64637b1230f763a37e7ec--0f6a9896f16d48b9b7236c08bd6dd297 6bb88b4757044b699abbc573b1a9701f 0f6a9896f16d48b9b7236c08bd6dd297--6bb88b4757044b699abbc573b1a9701f aa0104f9d90d4f1f8689d3dee58ba125 6bb88b4757044b699abbc573b1a9701f--aa0104f9d90d4f1f8689d3dee58ba125 9f099c8a4df747debd0756a13a770f29 X aa0104f9d90d4f1f8689d3dee58ba125--9f099c8a4df747debd0756a13a770f29 9f099c8a4df747debd0756a13a770f29--4f0b25565b1a4921b830c8489d214ed5 cc08e00904844b94bf353606a26e255f X 9f099c8a4df747debd0756a13a770f29--cc08e00904844b94bf353606a26e255f cc08e00904844b94bf353606a26e255f--fa8094beeb2747a59a62bd311a8f50c2 0c559f6411034708ac9ca5ec229ff767 cc08e00904844b94bf353606a26e255f--0c559f6411034708ac9ca5ec229ff767 9208c12a7d41451cb9b4fa26ceb83b0b 0c559f6411034708ac9ca5ec229ff767--9208c12a7d41451cb9b4fa26ceb83b0b 99d545d0834c4028b770e30d1c61d256 9208c12a7d41451cb9b4fa26ceb83b0b--99d545d0834c4028b770e30d1c61d256 82e43fecfe4a46c4ad0fe3e059e5df9b 99d545d0834c4028b770e30d1c61d256--82e43fecfe4a46c4ad0fe3e059e5df9b ac7c4bc9b1eb49fcb08c56deaa497200 82e43fecfe4a46c4ad0fe3e059e5df9b--ac7c4bc9b1eb49fcb08c56deaa497200 5cd0f8daf5334623a98d3ea1f3ae3f9f X ac7c4bc9b1eb49fcb08c56deaa497200--5cd0f8daf5334623a98d3ea1f3ae3f9f 5cd0f8daf5334623a98d3ea1f3ae3f9f--3a66557668714b8c8c3be38757245772 cf3f43029ca1410286c067b44c45a972 X 5cd0f8daf5334623a98d3ea1f3ae3f9f--cf3f43029ca1410286c067b44c45a972 cf3f43029ca1410286c067b44c45a972--0a8164c5dd3b4a778eb43ef769ab7e26 ed11f528f8d44a66ae0b5229d4045071 cf3f43029ca1410286c067b44c45a972--ed11f528f8d44a66ae0b5229d4045071 9e9a323a7b8444f7b0e6baf05ccb4501 ed11f528f8d44a66ae0b5229d4045071--9e9a323a7b8444f7b0e6baf05ccb4501 2e3ee37bca9f487e9fbd37345369aa60 9e9a323a7b8444f7b0e6baf05ccb4501--2e3ee37bca9f487e9fbd37345369aa60 89189f7d6ba340cc9b450ae27662efe5 2e3ee37bca9f487e9fbd37345369aa60--89189f7d6ba340cc9b450ae27662efe5 aeec9db1a1224ec08a543300e8ec7cd0 89189f7d6ba340cc9b450ae27662efe5--aeec9db1a1224ec08a543300e8ec7cd0 a8cb91e8db4f447d98c45cd76894f406 aeec9db1a1224ec08a543300e8ec7cd0--a8cb91e8db4f447d98c45cd76894f406 654be7d7f5334c29919e68dea53b57a9 a8cb91e8db4f447d98c45cd76894f406--654be7d7f5334c29919e68dea53b57a9 f1bb3816ec194009844b8caf3843e385 X 654be7d7f5334c29919e68dea53b57a9--f1bb3816ec194009844b8caf3843e385 f1bb3816ec194009844b8caf3843e385--19edbef053c44ccf96ffe2eb05eca69a fcf7717d8cc14f54aef35b7b58ba93a5 X f1bb3816ec194009844b8caf3843e385--fcf7717d8cc14f54aef35b7b58ba93a5 fcf7717d8cc14f54aef35b7b58ba93a5--5219c64b47f8405ab8a4fa07c59641b3 00e6327241d5405a8c4f0e2f9d4f2ecc fcf7717d8cc14f54aef35b7b58ba93a5--00e6327241d5405a8c4f0e2f9d4f2ecc 8ecab696655e4bf1b42949eefad6f25c 00e6327241d5405a8c4f0e2f9d4f2ecc--8ecab696655e4bf1b42949eefad6f25c ff036744259046af90bfae8efca65a44 8ecab696655e4bf1b42949eefad6f25c--ff036744259046af90bfae8efca65a44 80729b02dac1460e8abfca8032334907 ff036744259046af90bfae8efca65a44--80729b02dac1460e8abfca8032334907 960ad06a238144cd985981de17ae3a6f 80729b02dac1460e8abfca8032334907--960ad06a238144cd985981de17ae3a6f 7f66a010c2c54049809feec3d07261ce 960ad06a238144cd985981de17ae3a6f--7f66a010c2c54049809feec3d07261ce c58cb56f717c445f84811b553efefc0f 7f66a010c2c54049809feec3d07261ce--c58cb56f717c445f84811b553efefc0f a2df166bb9dd4928a8b695a3520cdc0f c58cb56f717c445f84811b553efefc0f--a2df166bb9dd4928a8b695a3520cdc0f 1cb29e546787444bad4232a8ccbf1e1e a2df166bb9dd4928a8b695a3520cdc0f--1cb29e546787444bad4232a8ccbf1e1e 8e18604eba254fca94ec4243ea1ff247 1cb29e546787444bad4232a8ccbf1e1e--8e18604eba254fca94ec4243ea1ff247 242f9c33dc144fc0bb290a12945158b1 8e18604eba254fca94ec4243ea1ff247--242f9c33dc144fc0bb290a12945158b1 6dc2dcf7c1da4787865a586922e75483 X 242f9c33dc144fc0bb290a12945158b1--6dc2dcf7c1da4787865a586922e75483 6dc2dcf7c1da4787865a586922e75483--287b3d80462c4096b835e17f5d6cd8ba 5515bc35761f4e3fbac7f417e93b1635 6dc2dcf7c1da4787865a586922e75483--5515bc35761f4e3fbac7f417e93b1635 4a84f5e088c74b7bbae578f94bd425b4 5515bc35761f4e3fbac7f417e93b1635--4a84f5e088c74b7bbae578f94bd425b4 fc915bd7486a4e8aa54ab93b01023020 4a84f5e088c74b7bbae578f94bd425b4--fc915bd7486a4e8aa54ab93b01023020 4435c151e1f6433aa9b9bd3cbac223ae fc915bd7486a4e8aa54ab93b01023020--4435c151e1f6433aa9b9bd3cbac223ae 0bc669b8081d49709070ca6f1b43a0d2 4435c151e1f6433aa9b9bd3cbac223ae--0bc669b8081d49709070ca6f1b43a0d2 aba98a0f0e144b989ea5a493fa202331 0bc669b8081d49709070ca6f1b43a0d2--aba98a0f0e144b989ea5a493fa202331 de5b7e22fddc442c9351a50c68fc527f aba98a0f0e144b989ea5a493fa202331--de5b7e22fddc442c9351a50c68fc527f 1eac245a7d6e40b58461fea71eee6464 de5b7e22fddc442c9351a50c68fc527f--1eac245a7d6e40b58461fea71eee6464 240b819a31a7444a9f90b827896ed2a0 1eac245a7d6e40b58461fea71eee6464--240b819a31a7444a9f90b827896ed2a0 817f9b18ba6b4f4fbb49ed744625bedc 240b819a31a7444a9f90b827896ed2a0--817f9b18ba6b4f4fbb49ed744625bedc edf5fdc3f3b24c0c8bc794d19222472d 817f9b18ba6b4f4fbb49ed744625bedc--edf5fdc3f3b24c0c8bc794d19222472d a01abb071a53480ba87d255cd05e86cb edf5fdc3f3b24c0c8bc794d19222472d--a01abb071a53480ba87d255cd05e86cb 468fd812fad24e5689b39269d26ce2c4 a01abb071a53480ba87d255cd05e86cb--468fd812fad24e5689b39269d26ce2c4 8c8c9c926d484ffca3d1091c86f1bd60 468fd812fad24e5689b39269d26ce2c4--8c8c9c926d484ffca3d1091c86f1bd60 dfa3e444c2964f49bb8feec60b9d0d2b 8c8c9c926d484ffca3d1091c86f1bd60--dfa3e444c2964f49bb8feec60b9d0d2b 5b6207801e15418286c9d644f0956c25 dfa3e444c2964f49bb8feec60b9d0d2b--5b6207801e15418286c9d644f0956c25 b943e45755b14a0b8df02bdb874ef0cc 5b6207801e15418286c9d644f0956c25--b943e45755b14a0b8df02bdb874ef0cc ac119576ccc8432ab02f810e455ae734 b943e45755b14a0b8df02bdb874ef0cc--ac119576ccc8432ab02f810e455ae734 700b2e084ef540d99bdd7689b41b9c9f ac119576ccc8432ab02f810e455ae734--700b2e084ef540d99bdd7689b41b9c9f c249343a209341cf9a64c91d4d2c968a 700b2e084ef540d99bdd7689b41b9c9f--c249343a209341cf9a64c91d4d2c968a 3746958a992f4df6854656281695bd68 c249343a209341cf9a64c91d4d2c968a--3746958a992f4df6854656281695bd68 0925a113dc1a45f19c63808905090d2a 3746958a992f4df6854656281695bd68--0925a113dc1a45f19c63808905090d2a 904334d943284fb5b96b8982012984b9 0925a113dc1a45f19c63808905090d2a--904334d943284fb5b96b8982012984b9 e974195f1888420da5d7f8fe14016273 904334d943284fb5b96b8982012984b9--e974195f1888420da5d7f8fe14016273 504db49c367f44039ca412a7387cbe00 e974195f1888420da5d7f8fe14016273--504db49c367f44039ca412a7387cbe00 01c67a082dd44003916a0e85dca190fa 504db49c367f44039ca412a7387cbe00--01c67a082dd44003916a0e85dca190fa 00bab9180f5a438b8ba5afc3377c594c 01c67a082dd44003916a0e85dca190fa--00bab9180f5a438b8ba5afc3377c594c ad6aa7f5721b444783392aa5d4bc1731 00bab9180f5a438b8ba5afc3377c594c--ad6aa7f5721b444783392aa5d4bc1731 ee791ba879254514bfecef2fc682bbef ad6aa7f5721b444783392aa5d4bc1731--ee791ba879254514bfecef2fc682bbef b811f8ce6f14445690af792f6c0acd01 ee791ba879254514bfecef2fc682bbef--b811f8ce6f14445690af792f6c0acd01 d8b4ea6be84e45739ddb3fc0a7823927 b811f8ce6f14445690af792f6c0acd01--d8b4ea6be84e45739ddb3fc0a7823927 0891d44b7a5c49f5b1d4b13d6bb110e9 d8b4ea6be84e45739ddb3fc0a7823927--0891d44b7a5c49f5b1d4b13d6bb110e9 7885f8944786438ea78ecbc99cad3536 0891d44b7a5c49f5b1d4b13d6bb110e9--7885f8944786438ea78ecbc99cad3536 215203681eed40e48bcbdd41e349d481 7885f8944786438ea78ecbc99cad3536--215203681eed40e48bcbdd41e349d481 262378dfaa1d47e99907d4aa354a30bf 215203681eed40e48bcbdd41e349d481--262378dfaa1d47e99907d4aa354a30bf 56d7841414334cd1b640ea256ca8d060 262378dfaa1d47e99907d4aa354a30bf--56d7841414334cd1b640ea256ca8d060 a73c5411372e4132894911b5906b620f 56d7841414334cd1b640ea256ca8d060--a73c5411372e4132894911b5906b620f 81d94cd84836458d96d8c393fd8bd1d1 a73c5411372e4132894911b5906b620f--81d94cd84836458d96d8c393fd8bd1d1 60c2bcb8c0d84f74be000a21360f6ac7 81d94cd84836458d96d8c393fd8bd1d1--60c2bcb8c0d84f74be000a21360f6ac7 4847fdd5b29f49c4b89d15f5c092a758 60c2bcb8c0d84f74be000a21360f6ac7--4847fdd5b29f49c4b89d15f5c092a758 069be569911b4ed3bc2d0d66c24ba568 4847fdd5b29f49c4b89d15f5c092a758--069be569911b4ed3bc2d0d66c24ba568 319b918d47f249d8beac10de07496a39 069be569911b4ed3bc2d0d66c24ba568--319b918d47f249d8beac10de07496a39 9edaddf5c3da4c61b01b3e5fc1be6456 319b918d47f249d8beac10de07496a39--9edaddf5c3da4c61b01b3e5fc1be6456 6249db76b4a34d809c28dfb9c7db7f95 9edaddf5c3da4c61b01b3e5fc1be6456--6249db76b4a34d809c28dfb9c7db7f95 0d93afa25a3e4a47b4fb5da160ea0b40 6249db76b4a34d809c28dfb9c7db7f95--0d93afa25a3e4a47b4fb5da160ea0b40 66d57b693d474b6f8b85f4f15929b1aa 0d93afa25a3e4a47b4fb5da160ea0b40--66d57b693d474b6f8b85f4f15929b1aa 4d3c0ff889e54af3ab81b1ea7d493303 66d57b693d474b6f8b85f4f15929b1aa--4d3c0ff889e54af3ab81b1ea7d493303 013f25503e6b4cf79d45682686732c57 4d3c0ff889e54af3ab81b1ea7d493303--013f25503e6b4cf79d45682686732c57 4204f4e28a0343dcb4e2f9abb72a018d 013f25503e6b4cf79d45682686732c57--4204f4e28a0343dcb4e2f9abb72a018d 0e52cf1fc8ba4800a1e03c080d2f7017 4204f4e28a0343dcb4e2f9abb72a018d--0e52cf1fc8ba4800a1e03c080d2f7017 9e64bd877cb749a28af7610746e66553 0e52cf1fc8ba4800a1e03c080d2f7017--9e64bd877cb749a28af7610746e66553 cc11b4d98c2d4fa18a1cc66ad8e9708c 9e64bd877cb749a28af7610746e66553--cc11b4d98c2d4fa18a1cc66ad8e9708c c6e6b4ea8c71492ea6c023ec9d3a44ea cc11b4d98c2d4fa18a1cc66ad8e9708c--c6e6b4ea8c71492ea6c023ec9d3a44ea 6ee69d4d0ee048a4a720adb26420c6cf c6e6b4ea8c71492ea6c023ec9d3a44ea--6ee69d4d0ee048a4a720adb26420c6cf 003d9c8bfa114bf291903435550f6a82 6ee69d4d0ee048a4a720adb26420c6cf--003d9c8bfa114bf291903435550f6a82 9b5179362e6f47b0b3c61746025f8819 003d9c8bfa114bf291903435550f6a82--9b5179362e6f47b0b3c61746025f8819 bd59666ccd394684a61b77e1fca6168d 9b5179362e6f47b0b3c61746025f8819--bd59666ccd394684a61b77e1fca6168d ed672f6ae90744149efb9d4d38b6eb5f RX(b11) bd59666ccd394684a61b77e1fca6168d--ed672f6ae90744149efb9d4d38b6eb5f ed672f6ae90744149efb9d4d38b6eb5f--89f87f654132415dbcb137305a3f8089 44d8634226a54498a29f4bb1c4517cfc 1f51ad7eb95644289195ee0b39ea5841 656c796db81a429283c2802aa7ba3122--1f51ad7eb95644289195ee0b39ea5841 73eb1afb4b7b4b0d8ae4846be0cf687a 3 3b8fd7fc83e94a5a8ee00262eab43ed5 X 1f51ad7eb95644289195ee0b39ea5841--3b8fd7fc83e94a5a8ee00262eab43ed5 3b8fd7fc83e94a5a8ee00262eab43ed5--3774f68e7976468b8725983ce6d15454 5b4bd076dd5a4d6881a0357142b78fab 3b8fd7fc83e94a5a8ee00262eab43ed5--5b4bd076dd5a4d6881a0357142b78fab b885b81dba4247ba8598001deab43874 5b4bd076dd5a4d6881a0357142b78fab--b885b81dba4247ba8598001deab43874 9618033dfd5643f099000145318e4c99 b885b81dba4247ba8598001deab43874--9618033dfd5643f099000145318e4c99 af9a91f9e9f047349f85190d50cc2672 9618033dfd5643f099000145318e4c99--af9a91f9e9f047349f85190d50cc2672 630b18c41a4f48af992b213706eb32db af9a91f9e9f047349f85190d50cc2672--630b18c41a4f48af992b213706eb32db f30868e22eab473ead93e2724931bc1c 630b18c41a4f48af992b213706eb32db--f30868e22eab473ead93e2724931bc1c 58f715c4dd1a4842a0b3a4718965bc1c f30868e22eab473ead93e2724931bc1c--58f715c4dd1a4842a0b3a4718965bc1c eeb16044940f4540bd8367cdd6b23a70 58f715c4dd1a4842a0b3a4718965bc1c--eeb16044940f4540bd8367cdd6b23a70 433eff54c44b48cca62ec99927049949 eeb16044940f4540bd8367cdd6b23a70--433eff54c44b48cca62ec99927049949 0e27dfa7f15a49c9b63e8767eff6610d 433eff54c44b48cca62ec99927049949--0e27dfa7f15a49c9b63e8767eff6610d e6b39309a8874ea7bef86d0c7f5eb348 0e27dfa7f15a49c9b63e8767eff6610d--e6b39309a8874ea7bef86d0c7f5eb348 28bce5dcd31d415493efef887b946392 X e6b39309a8874ea7bef86d0c7f5eb348--28bce5dcd31d415493efef887b946392 28bce5dcd31d415493efef887b946392--6536407a7bea48dc9ea65c8ca47a3fdd e17ac93865f8440fb0456e38d49df4b8 28bce5dcd31d415493efef887b946392--e17ac93865f8440fb0456e38d49df4b8 08f8c08ee6f2448c89dedde6574d303a e17ac93865f8440fb0456e38d49df4b8--08f8c08ee6f2448c89dedde6574d303a 013247ea3ba9430db1a960cce66b194b X 08f8c08ee6f2448c89dedde6574d303a--013247ea3ba9430db1a960cce66b194b 013247ea3ba9430db1a960cce66b194b--5e909a2ba52249868205a3ca890b3665 bb5b64303d25494fab3419d5477a3227 RZ(-1.0*g0) 013247ea3ba9430db1a960cce66b194b--bb5b64303d25494fab3419d5477a3227 583fb178a7d84ec1bf803b460d9eccb8 X bb5b64303d25494fab3419d5477a3227--583fb178a7d84ec1bf803b460d9eccb8 583fb178a7d84ec1bf803b460d9eccb8--040dfb9234854f04b033f08618075690 ccca0d45875145c08c909b56816942d9 583fb178a7d84ec1bf803b460d9eccb8--ccca0d45875145c08c909b56816942d9 cbd1ef59360d4308b5a8332be2beb8e9 ccca0d45875145c08c909b56816942d9--cbd1ef59360d4308b5a8332be2beb8e9 2c10fd1740a34da683b641c06ac80592 X cbd1ef59360d4308b5a8332be2beb8e9--2c10fd1740a34da683b641c06ac80592 2c10fd1740a34da683b641c06ac80592--776243f3ed394a859b45340e7154803a a719b3680c354c20ae2a665f3b8caa7f 2c10fd1740a34da683b641c06ac80592--a719b3680c354c20ae2a665f3b8caa7f 0bb1d705244d4197a0e406e18f84c8b8 a719b3680c354c20ae2a665f3b8caa7f--0bb1d705244d4197a0e406e18f84c8b8 c947b59c793943a48277d6690ad382f0 0bb1d705244d4197a0e406e18f84c8b8--c947b59c793943a48277d6690ad382f0 66ca77859c0e402b93604f577b2dc3af X c947b59c793943a48277d6690ad382f0--66ca77859c0e402b93604f577b2dc3af 66ca77859c0e402b93604f577b2dc3af--352887d3ae834cb284677fda6c409408 dd830345ad2046bb942d09d37486bf85 66ca77859c0e402b93604f577b2dc3af--dd830345ad2046bb942d09d37486bf85 1fa153501eda458c8f5aa040a602c5e2 dd830345ad2046bb942d09d37486bf85--1fa153501eda458c8f5aa040a602c5e2 12fca8231fcd4d72b32071c82107f3c5 X 1fa153501eda458c8f5aa040a602c5e2--12fca8231fcd4d72b32071c82107f3c5 12fca8231fcd4d72b32071c82107f3c5--87698286d98b42698658b3fe9048b05c 82a8c16e5ba44559b5bd6a536c6c41f3 12fca8231fcd4d72b32071c82107f3c5--82a8c16e5ba44559b5bd6a536c6c41f3 3556ea6c93a2419d888542c523a8b1d0 82a8c16e5ba44559b5bd6a536c6c41f3--3556ea6c93a2419d888542c523a8b1d0 0df60a1bbe474d95a6c48121e833f401 3556ea6c93a2419d888542c523a8b1d0--0df60a1bbe474d95a6c48121e833f401 a0df6bb08f80443ab42db0065a7cc973 0df60a1bbe474d95a6c48121e833f401--a0df6bb08f80443ab42db0065a7cc973 e7fcf255621f48ddabb11f06b03a987b a0df6bb08f80443ab42db0065a7cc973--e7fcf255621f48ddabb11f06b03a987b a74498247b8b4ba0876e94c6d6eb1c0a X e7fcf255621f48ddabb11f06b03a987b--a74498247b8b4ba0876e94c6d6eb1c0a a74498247b8b4ba0876e94c6d6eb1c0a--76ab1459577d42999db6858557df2f94 054d8afe460a488893e94887b0b41a38 a74498247b8b4ba0876e94c6d6eb1c0a--054d8afe460a488893e94887b0b41a38 37d6bab78a9a4c9d9cd9944c10db1b1f 054d8afe460a488893e94887b0b41a38--37d6bab78a9a4c9d9cd9944c10db1b1f 947f3578b6584337a2712c25da5b4da4 X 37d6bab78a9a4c9d9cd9944c10db1b1f--947f3578b6584337a2712c25da5b4da4 947f3578b6584337a2712c25da5b4da4--37aa5764be1444dea4df362742994983 d705872230ef4ce4acecee0044bb4782 947f3578b6584337a2712c25da5b4da4--d705872230ef4ce4acecee0044bb4782 355b5186cb794b7eabe611e71ae2b6cf d705872230ef4ce4acecee0044bb4782--355b5186cb794b7eabe611e71ae2b6cf 7d9a6a9f1f854d7dba95823efb077b2d 355b5186cb794b7eabe611e71ae2b6cf--7d9a6a9f1f854d7dba95823efb077b2d 6eb88823d69046a8b673a31ac441d565 7d9a6a9f1f854d7dba95823efb077b2d--6eb88823d69046a8b673a31ac441d565 eaa7e7aa1b7e4512a206ab9a979730f4 6eb88823d69046a8b673a31ac441d565--eaa7e7aa1b7e4512a206ab9a979730f4 c71c0ed3723746c3bb5526bd16fa7962 eaa7e7aa1b7e4512a206ab9a979730f4--c71c0ed3723746c3bb5526bd16fa7962 d71b636623a8441fa1686a6b4acfcf5f c71c0ed3723746c3bb5526bd16fa7962--d71b636623a8441fa1686a6b4acfcf5f d5663e55983746198ec1bb123ff1dd1d d71b636623a8441fa1686a6b4acfcf5f--d5663e55983746198ec1bb123ff1dd1d 95a795bd2faf41ec87a318760c735acb d5663e55983746198ec1bb123ff1dd1d--95a795bd2faf41ec87a318760c735acb 6ab609eaccea4bcf9ff2a073363116a3 X 95a795bd2faf41ec87a318760c735acb--6ab609eaccea4bcf9ff2a073363116a3 6ab609eaccea4bcf9ff2a073363116a3--3298e264e44c41f5adf823195bd513aa 744809044685461990df395422510f8f 6ab609eaccea4bcf9ff2a073363116a3--744809044685461990df395422510f8f 800eca42327d46dbbe95a43abc7306af X 744809044685461990df395422510f8f--800eca42327d46dbbe95a43abc7306af 800eca42327d46dbbe95a43abc7306af--75c6a4eed02940bc97863cc628e84d82 f6c39bfff7dc463c83f8edb85a4f17f8 RZ(-1.0*g0) 800eca42327d46dbbe95a43abc7306af--f6c39bfff7dc463c83f8edb85a4f17f8 31b368a422ab44e89f39d366d2d014c9 X f6c39bfff7dc463c83f8edb85a4f17f8--31b368a422ab44e89f39d366d2d014c9 31b368a422ab44e89f39d366d2d014c9--a2d5234e5c9e40f1ab512a8cae9c97b3 004455027c78464f818af42685c31989 X 31b368a422ab44e89f39d366d2d014c9--004455027c78464f818af42685c31989 004455027c78464f818af42685c31989--7fb0e33b10a04a0e80a4a764457daa68 9ee8b86a1dfe4377827e9bb708aadd5d 004455027c78464f818af42685c31989--9ee8b86a1dfe4377827e9bb708aadd5d b2bb82a76bb642f4815e2910ff9a93c7 9ee8b86a1dfe4377827e9bb708aadd5d--b2bb82a76bb642f4815e2910ff9a93c7 61d88cf2bea945aa9d5ce0a67e9d54d7 b2bb82a76bb642f4815e2910ff9a93c7--61d88cf2bea945aa9d5ce0a67e9d54d7 143abca9d7f6456aa0341dcab775a305 X 61d88cf2bea945aa9d5ce0a67e9d54d7--143abca9d7f6456aa0341dcab775a305 143abca9d7f6456aa0341dcab775a305--2c3c8386ca804fe2978892928d205067 ca7dd889ec1045fcb42fcda4c0538da7 X 143abca9d7f6456aa0341dcab775a305--ca7dd889ec1045fcb42fcda4c0538da7 ca7dd889ec1045fcb42fcda4c0538da7--9ac100765a864b0c9f778c8ed324335d 0f17d08c182c43b49fb12bdb8bf7669b ca7dd889ec1045fcb42fcda4c0538da7--0f17d08c182c43b49fb12bdb8bf7669b 16dcbe8aef654ecf88a0320507ebb750 0f17d08c182c43b49fb12bdb8bf7669b--16dcbe8aef654ecf88a0320507ebb750 1f19460b7c6649e8b475c9076e642e11 16dcbe8aef654ecf88a0320507ebb750--1f19460b7c6649e8b475c9076e642e11 5c4cec55d27b441dacdd4532fa95d64a 1f19460b7c6649e8b475c9076e642e11--5c4cec55d27b441dacdd4532fa95d64a a47f2fa860914c76b72bb727633781aa 5c4cec55d27b441dacdd4532fa95d64a--a47f2fa860914c76b72bb727633781aa 6b6c79059a7a4d2d966aa792d49917a6 X a47f2fa860914c76b72bb727633781aa--6b6c79059a7a4d2d966aa792d49917a6 6b6c79059a7a4d2d966aa792d49917a6--315d46b2a142453e9ada6f4fd5c6c5de 9398401f53c744b0b52679f94397a664 X 6b6c79059a7a4d2d966aa792d49917a6--9398401f53c744b0b52679f94397a664 9398401f53c744b0b52679f94397a664--cf130e7842224a41a59428358648a63b 2be92e22728549bebb629165b20b7ce0 9398401f53c744b0b52679f94397a664--2be92e22728549bebb629165b20b7ce0 ad899c3a6a8147c4adb28df787682e73 2be92e22728549bebb629165b20b7ce0--ad899c3a6a8147c4adb28df787682e73 3a9528b8a0bf44ca845eadc6999a7287 ad899c3a6a8147c4adb28df787682e73--3a9528b8a0bf44ca845eadc6999a7287 5e435b7a937447729b2f777e97d38ffc 3a9528b8a0bf44ca845eadc6999a7287--5e435b7a937447729b2f777e97d38ffc 3581b273edc54cfca216943fbd088e34 5e435b7a937447729b2f777e97d38ffc--3581b273edc54cfca216943fbd088e34 d35a688284bf4e68b9aa72fdf9b37cd7 3581b273edc54cfca216943fbd088e34--d35a688284bf4e68b9aa72fdf9b37cd7 73f9e22f35d5475f98170476de07e195 d35a688284bf4e68b9aa72fdf9b37cd7--73f9e22f35d5475f98170476de07e195 2213c7076529492da7c96760dafef3f7 X 73f9e22f35d5475f98170476de07e195--2213c7076529492da7c96760dafef3f7 2213c7076529492da7c96760dafef3f7--8a65f700c58b4f63a7a4f19669c40096 092b5eba33384e91a74b03de70d36dfc X 2213c7076529492da7c96760dafef3f7--092b5eba33384e91a74b03de70d36dfc 092b5eba33384e91a74b03de70d36dfc--c027c4bf365248a29d6f878563e2348f f26950a9b4bd47188de440f288222e76 092b5eba33384e91a74b03de70d36dfc--f26950a9b4bd47188de440f288222e76 98a599f4a5854f579ddeb8f071741f40 f26950a9b4bd47188de440f288222e76--98a599f4a5854f579ddeb8f071741f40 91b299b4cfd943c18627619b33daf5d1 98a599f4a5854f579ddeb8f071741f40--91b299b4cfd943c18627619b33daf5d1 980f07335c2447009f250288eef06989 91b299b4cfd943c18627619b33daf5d1--980f07335c2447009f250288eef06989 1bcb1eabc7564c33bf7453668e8ae091 980f07335c2447009f250288eef06989--1bcb1eabc7564c33bf7453668e8ae091 03cd4682706a45cca625b957c3f62ad3 1bcb1eabc7564c33bf7453668e8ae091--03cd4682706a45cca625b957c3f62ad3 3953919ce8024a94944e09e7f3f9dde6 03cd4682706a45cca625b957c3f62ad3--3953919ce8024a94944e09e7f3f9dde6 063d11995d06452496f62fe8470b2767 3953919ce8024a94944e09e7f3f9dde6--063d11995d06452496f62fe8470b2767 1776659afc994ec2a6883a1b7f0b8670 063d11995d06452496f62fe8470b2767--1776659afc994ec2a6883a1b7f0b8670 61cde2afecfd458c890b9ccef7c9e6b0 X 1776659afc994ec2a6883a1b7f0b8670--61cde2afecfd458c890b9ccef7c9e6b0 61cde2afecfd458c890b9ccef7c9e6b0--c6fa96c1e7ea49b98507cf9908e696cd 4e8395633f864c17a1e192e7a0bb4074 61cde2afecfd458c890b9ccef7c9e6b0--4e8395633f864c17a1e192e7a0bb4074 50dbf3a7ab2f488b86d6adfb44e57be8 4e8395633f864c17a1e192e7a0bb4074--50dbf3a7ab2f488b86d6adfb44e57be8 b2086f6819664d0f9c8517d6dccbccbf 50dbf3a7ab2f488b86d6adfb44e57be8--b2086f6819664d0f9c8517d6dccbccbf 14f46c0c0dcc4236bb105303a38fdf93 b2086f6819664d0f9c8517d6dccbccbf--14f46c0c0dcc4236bb105303a38fdf93 147aa91ab9fe4a34bffa1330bf60e816 14f46c0c0dcc4236bb105303a38fdf93--147aa91ab9fe4a34bffa1330bf60e816 8b3f351deb0f46578c54279fc80bdf86 147aa91ab9fe4a34bffa1330bf60e816--8b3f351deb0f46578c54279fc80bdf86 744709f475af4b6da2d0bb43e618f37c 8b3f351deb0f46578c54279fc80bdf86--744709f475af4b6da2d0bb43e618f37c f2ef769981f24cce94ad6222685b3e82 744709f475af4b6da2d0bb43e618f37c--f2ef769981f24cce94ad6222685b3e82 ebc4c53c1e8c4a06a4ef6e87aed8f27b f2ef769981f24cce94ad6222685b3e82--ebc4c53c1e8c4a06a4ef6e87aed8f27b d0394b2a02654e9a9828aa552a096c75 ebc4c53c1e8c4a06a4ef6e87aed8f27b--d0394b2a02654e9a9828aa552a096c75 ed1d8a1673a8426db79321fd39f5a0b2 d0394b2a02654e9a9828aa552a096c75--ed1d8a1673a8426db79321fd39f5a0b2 91bcea52f5bf4bd6b0b9cf669a60eb14 ed1d8a1673a8426db79321fd39f5a0b2--91bcea52f5bf4bd6b0b9cf669a60eb14 af53ff15ff8448e8ae1cad1f7d33e6f8 91bcea52f5bf4bd6b0b9cf669a60eb14--af53ff15ff8448e8ae1cad1f7d33e6f8 da3eef4828124e16ac7c12188c989102 af53ff15ff8448e8ae1cad1f7d33e6f8--da3eef4828124e16ac7c12188c989102 111f6204dfb941a98a5602d47dae0b4d da3eef4828124e16ac7c12188c989102--111f6204dfb941a98a5602d47dae0b4d 7a4f2d2bfc5b4f209a339dae7bab0db3 111f6204dfb941a98a5602d47dae0b4d--7a4f2d2bfc5b4f209a339dae7bab0db3 98b1775850304d3db77533a7cace9f18 7a4f2d2bfc5b4f209a339dae7bab0db3--98b1775850304d3db77533a7cace9f18 926a059a070f4a8fb5c304ebf4ea853a 98b1775850304d3db77533a7cace9f18--926a059a070f4a8fb5c304ebf4ea853a befc0e30b04b4a3c9025c493dc28cb53 926a059a070f4a8fb5c304ebf4ea853a--befc0e30b04b4a3c9025c493dc28cb53 7c8cbe92788f4765bc698f96e2e3049b befc0e30b04b4a3c9025c493dc28cb53--7c8cbe92788f4765bc698f96e2e3049b 5e4357da2d084f8fb3bb3b9602f88ccb 7c8cbe92788f4765bc698f96e2e3049b--5e4357da2d084f8fb3bb3b9602f88ccb a2119405fbb84977a228ea6d60689bee 5e4357da2d084f8fb3bb3b9602f88ccb--a2119405fbb84977a228ea6d60689bee 5f26333d86254da19136408856af2886 RX(b02) a2119405fbb84977a228ea6d60689bee--5f26333d86254da19136408856af2886 2a2a3a2ffdcc4e3b8b4fb1416bf20abe 5f26333d86254da19136408856af2886--2a2a3a2ffdcc4e3b8b4fb1416bf20abe 33a102de411d4103a1e171783db79125 X 2a2a3a2ffdcc4e3b8b4fb1416bf20abe--33a102de411d4103a1e171783db79125 33a102de411d4103a1e171783db79125--5c3f20549c75405e9e6ce0197ec56ede b841da10daf44287a6b6276cddf09c3b 33a102de411d4103a1e171783db79125--b841da10daf44287a6b6276cddf09c3b e734d4ec9ec844ea8f019ecbf2f4be93 b841da10daf44287a6b6276cddf09c3b--e734d4ec9ec844ea8f019ecbf2f4be93 d7309117b4444594a3999ae9e842ba25 e734d4ec9ec844ea8f019ecbf2f4be93--d7309117b4444594a3999ae9e842ba25 9d3d969b3c1d41e2921c0f0a11546f61 d7309117b4444594a3999ae9e842ba25--9d3d969b3c1d41e2921c0f0a11546f61 63ef33392070456da322bab69cfe1303 9d3d969b3c1d41e2921c0f0a11546f61--63ef33392070456da322bab69cfe1303 a9bf79446c864fc88978374f47501e7e 63ef33392070456da322bab69cfe1303--a9bf79446c864fc88978374f47501e7e e8af95d53adf49b19a6a861b3f2a1468 a9bf79446c864fc88978374f47501e7e--e8af95d53adf49b19a6a861b3f2a1468 a97e0a03e3f9477599dac99ae84b3c01 e8af95d53adf49b19a6a861b3f2a1468--a97e0a03e3f9477599dac99ae84b3c01 aa8755a6cbdc41ae93bec47a8307d048 a97e0a03e3f9477599dac99ae84b3c01--aa8755a6cbdc41ae93bec47a8307d048 986d5fc38d91412eb8798fbe3e49760d aa8755a6cbdc41ae93bec47a8307d048--986d5fc38d91412eb8798fbe3e49760d 9f9a07543360489ab47386bb4d5f8eaf 986d5fc38d91412eb8798fbe3e49760d--9f9a07543360489ab47386bb4d5f8eaf ee7ae8083aac4c62af27ffbb899814a7 X 9f9a07543360489ab47386bb4d5f8eaf--ee7ae8083aac4c62af27ffbb899814a7 ee7ae8083aac4c62af27ffbb899814a7--e16730f616054d4e9bb9a10c98dc3ec5 67c54ffc784c43159743c96f01049600 ee7ae8083aac4c62af27ffbb899814a7--67c54ffc784c43159743c96f01049600 0ea4d7bf7615498a9df8d7c12e7bde86 67c54ffc784c43159743c96f01049600--0ea4d7bf7615498a9df8d7c12e7bde86 307ad2ccb426417c8e2a0d917747510e X 0ea4d7bf7615498a9df8d7c12e7bde86--307ad2ccb426417c8e2a0d917747510e 307ad2ccb426417c8e2a0d917747510e--0f6a9896f16d48b9b7236c08bd6dd297 0f29f45821dd4e93a6c051c476da4019 RZ(-1.0*g1) 307ad2ccb426417c8e2a0d917747510e--0f29f45821dd4e93a6c051c476da4019 1354d5c76b614b91b20021ddead54727 X 0f29f45821dd4e93a6c051c476da4019--1354d5c76b614b91b20021ddead54727 1354d5c76b614b91b20021ddead54727--aa0104f9d90d4f1f8689d3dee58ba125 3e638f8b963d4f45abe6ccf0fcb736b9 1354d5c76b614b91b20021ddead54727--3e638f8b963d4f45abe6ccf0fcb736b9 3790c87330634225aa34c0d1d31f06cb 3e638f8b963d4f45abe6ccf0fcb736b9--3790c87330634225aa34c0d1d31f06cb 0d1797cb3eef4dbb89ced4ffd75eaffb X 3790c87330634225aa34c0d1d31f06cb--0d1797cb3eef4dbb89ced4ffd75eaffb 0d1797cb3eef4dbb89ced4ffd75eaffb--0c559f6411034708ac9ca5ec229ff767 a2f2b2acc917487098d297a2805e57aa 0d1797cb3eef4dbb89ced4ffd75eaffb--a2f2b2acc917487098d297a2805e57aa 256c3597b5644e5b99962684dbc39efe a2f2b2acc917487098d297a2805e57aa--256c3597b5644e5b99962684dbc39efe d8d18721aaaa4a7fa9252db93c0de517 256c3597b5644e5b99962684dbc39efe--d8d18721aaaa4a7fa9252db93c0de517 efbdf65d071945b3bd1dae21e6d456ac X d8d18721aaaa4a7fa9252db93c0de517--efbdf65d071945b3bd1dae21e6d456ac efbdf65d071945b3bd1dae21e6d456ac--ac7c4bc9b1eb49fcb08c56deaa497200 bc543274c84345339ef58d49bc0726ea efbdf65d071945b3bd1dae21e6d456ac--bc543274c84345339ef58d49bc0726ea fbfd5bbba8f748d19e2c1b15c6ad79f4 bc543274c84345339ef58d49bc0726ea--fbfd5bbba8f748d19e2c1b15c6ad79f4 0f78ccf1d5134ab09c3b4b9e99df2af2 X fbfd5bbba8f748d19e2c1b15c6ad79f4--0f78ccf1d5134ab09c3b4b9e99df2af2 0f78ccf1d5134ab09c3b4b9e99df2af2--ed11f528f8d44a66ae0b5229d4045071 110b1f266b0d44cd97de12ba90a5a333 0f78ccf1d5134ab09c3b4b9e99df2af2--110b1f266b0d44cd97de12ba90a5a333 79185f340f504f8c9fd86534b14078ed 110b1f266b0d44cd97de12ba90a5a333--79185f340f504f8c9fd86534b14078ed db466f9a1f3641b28d626c73a1a8b576 79185f340f504f8c9fd86534b14078ed--db466f9a1f3641b28d626c73a1a8b576 e629dee063d34719bd9bd31f07cee40a db466f9a1f3641b28d626c73a1a8b576--e629dee063d34719bd9bd31f07cee40a 9224656ad92d4bb49b27bb7b93cb6f8e e629dee063d34719bd9bd31f07cee40a--9224656ad92d4bb49b27bb7b93cb6f8e 9b0e415e06214c3c9631d7c31a58b472 X 9224656ad92d4bb49b27bb7b93cb6f8e--9b0e415e06214c3c9631d7c31a58b472 9b0e415e06214c3c9631d7c31a58b472--654be7d7f5334c29919e68dea53b57a9 a0dc319bbe784994a51e9bf189c242ff 9b0e415e06214c3c9631d7c31a58b472--a0dc319bbe784994a51e9bf189c242ff cb434c2d68594ade8334a9706827d443 a0dc319bbe784994a51e9bf189c242ff--cb434c2d68594ade8334a9706827d443 7fd10c9ef18747fba1b90410b605ad03 X cb434c2d68594ade8334a9706827d443--7fd10c9ef18747fba1b90410b605ad03 7fd10c9ef18747fba1b90410b605ad03--00e6327241d5405a8c4f0e2f9d4f2ecc ed8538f9730347f0b4f09d65d4b7c5dc 7fd10c9ef18747fba1b90410b605ad03--ed8538f9730347f0b4f09d65d4b7c5dc 39575dc9018449729cd2cd30ce935e99 ed8538f9730347f0b4f09d65d4b7c5dc--39575dc9018449729cd2cd30ce935e99 575e2f53d09243aba00621a83ea8abe1 39575dc9018449729cd2cd30ce935e99--575e2f53d09243aba00621a83ea8abe1 d069273e72d94170b7549d61fc78376a 575e2f53d09243aba00621a83ea8abe1--d069273e72d94170b7549d61fc78376a 64e309a805d844dcb9219764a79c7765 d069273e72d94170b7549d61fc78376a--64e309a805d844dcb9219764a79c7765 3ba355d7d91841d8a670deb1d5111790 64e309a805d844dcb9219764a79c7765--3ba355d7d91841d8a670deb1d5111790 8b1d508d9a2547f9814fdf1340b9d0d0 3ba355d7d91841d8a670deb1d5111790--8b1d508d9a2547f9814fdf1340b9d0d0 7956c5fc277b46c6b9d98733cbffe2ce 8b1d508d9a2547f9814fdf1340b9d0d0--7956c5fc277b46c6b9d98733cbffe2ce 7ee1cacaaba64bc586893f093a22b080 7956c5fc277b46c6b9d98733cbffe2ce--7ee1cacaaba64bc586893f093a22b080 c918f46081d143c483b1ad47f9e67bc9 X 7ee1cacaaba64bc586893f093a22b080--c918f46081d143c483b1ad47f9e67bc9 c918f46081d143c483b1ad47f9e67bc9--242f9c33dc144fc0bb290a12945158b1 ef5784b224d5418aa3bc9089d64dc4bc c918f46081d143c483b1ad47f9e67bc9--ef5784b224d5418aa3bc9089d64dc4bc c0763a1f79534267bb991b904f6bd5e3 X ef5784b224d5418aa3bc9089d64dc4bc--c0763a1f79534267bb991b904f6bd5e3 c0763a1f79534267bb991b904f6bd5e3--5515bc35761f4e3fbac7f417e93b1635 31b56ed50aff4d2a90f38a11444336ee RZ(-1.0*g1) c0763a1f79534267bb991b904f6bd5e3--31b56ed50aff4d2a90f38a11444336ee 9490230247e24d7c8a65924fabd540da X 31b56ed50aff4d2a90f38a11444336ee--9490230247e24d7c8a65924fabd540da 9490230247e24d7c8a65924fabd540da--fc915bd7486a4e8aa54ab93b01023020 db393b3c9c894912a9e13829b6219194 X 9490230247e24d7c8a65924fabd540da--db393b3c9c894912a9e13829b6219194 db393b3c9c894912a9e13829b6219194--4435c151e1f6433aa9b9bd3cbac223ae d9acf9806bdb4b6d90dc968edc02cf2c db393b3c9c894912a9e13829b6219194--d9acf9806bdb4b6d90dc968edc02cf2c 8fbc21cb186242edb92e16731a5e5e48 d9acf9806bdb4b6d90dc968edc02cf2c--8fbc21cb186242edb92e16731a5e5e48 81fce33623294e66b9bed49038d02abb 8fbc21cb186242edb92e16731a5e5e48--81fce33623294e66b9bed49038d02abb 860b49f4199d4ce19ab1fc429f1a89d8 X 81fce33623294e66b9bed49038d02abb--860b49f4199d4ce19ab1fc429f1a89d8 860b49f4199d4ce19ab1fc429f1a89d8--1eac245a7d6e40b58461fea71eee6464 ede99cad9f2b4f30ad9503cd3ef18740 X 860b49f4199d4ce19ab1fc429f1a89d8--ede99cad9f2b4f30ad9503cd3ef18740 ede99cad9f2b4f30ad9503cd3ef18740--240b819a31a7444a9f90b827896ed2a0 d6146024975e45a884304f6e2e2ebb02 ede99cad9f2b4f30ad9503cd3ef18740--d6146024975e45a884304f6e2e2ebb02 427666a759d340dd8f6420ec01c45032 d6146024975e45a884304f6e2e2ebb02--427666a759d340dd8f6420ec01c45032 40fb82bf69fe47c09be851c65cb16e05 427666a759d340dd8f6420ec01c45032--40fb82bf69fe47c09be851c65cb16e05 e577c947e48147a6b6cabe17af506708 40fb82bf69fe47c09be851c65cb16e05--e577c947e48147a6b6cabe17af506708 194ea22709b548d5b916e1d95bc0fd25 e577c947e48147a6b6cabe17af506708--194ea22709b548d5b916e1d95bc0fd25 92e76cd9e9804dddb0755ef5764326f4 X 194ea22709b548d5b916e1d95bc0fd25--92e76cd9e9804dddb0755ef5764326f4 92e76cd9e9804dddb0755ef5764326f4--dfa3e444c2964f49bb8feec60b9d0d2b cdcdad2d55074f15820329dd1bfb7ad4 X 92e76cd9e9804dddb0755ef5764326f4--cdcdad2d55074f15820329dd1bfb7ad4 cdcdad2d55074f15820329dd1bfb7ad4--5b6207801e15418286c9d644f0956c25 2c97cf593b834ab5a23d83b4edfc81d7 cdcdad2d55074f15820329dd1bfb7ad4--2c97cf593b834ab5a23d83b4edfc81d7 d780aa30051a497ea1e9a597f2274426 2c97cf593b834ab5a23d83b4edfc81d7--d780aa30051a497ea1e9a597f2274426 5fa21d2700054ce0a4f6c2ce8dc1dd61 d780aa30051a497ea1e9a597f2274426--5fa21d2700054ce0a4f6c2ce8dc1dd61 91e572a868dc43e396064752aad62f9c 5fa21d2700054ce0a4f6c2ce8dc1dd61--91e572a868dc43e396064752aad62f9c 1cd7e765c6924469b82e38e0ce36340f 91e572a868dc43e396064752aad62f9c--1cd7e765c6924469b82e38e0ce36340f ce5c34bfe13c4316ade9b7bed445b848 1cd7e765c6924469b82e38e0ce36340f--ce5c34bfe13c4316ade9b7bed445b848 3b5cf0ba11f04d7591df5ef1981b6221 ce5c34bfe13c4316ade9b7bed445b848--3b5cf0ba11f04d7591df5ef1981b6221 d2d5a2312cd24ea4931cdad3f10da730 X 3b5cf0ba11f04d7591df5ef1981b6221--d2d5a2312cd24ea4931cdad3f10da730 d2d5a2312cd24ea4931cdad3f10da730--e974195f1888420da5d7f8fe14016273 634afe14b9114b5db53420fff7c5705e X d2d5a2312cd24ea4931cdad3f10da730--634afe14b9114b5db53420fff7c5705e 634afe14b9114b5db53420fff7c5705e--504db49c367f44039ca412a7387cbe00 a5568d9dffe34f68965f5cae4a4bcf08 634afe14b9114b5db53420fff7c5705e--a5568d9dffe34f68965f5cae4a4bcf08 ad41ec64416f457a827cfe9c06048e16 a5568d9dffe34f68965f5cae4a4bcf08--ad41ec64416f457a827cfe9c06048e16 588df38e489248aeb9d6321a6ef3831f ad41ec64416f457a827cfe9c06048e16--588df38e489248aeb9d6321a6ef3831f 8c5c2c165e5342fc901aacf6d568fd25 588df38e489248aeb9d6321a6ef3831f--8c5c2c165e5342fc901aacf6d568fd25 3bf3725b5f004c22b875f6e00756268f 8c5c2c165e5342fc901aacf6d568fd25--3bf3725b5f004c22b875f6e00756268f da1dafb2c3cd4489926e082adcffe00b 3bf3725b5f004c22b875f6e00756268f--da1dafb2c3cd4489926e082adcffe00b 196fe4201be14505bb998a33abb87464 da1dafb2c3cd4489926e082adcffe00b--196fe4201be14505bb998a33abb87464 5083430edbe841e5b9ad7e223a1446f3 196fe4201be14505bb998a33abb87464--5083430edbe841e5b9ad7e223a1446f3 195f4384603f4fa9b314086624b73b78 5083430edbe841e5b9ad7e223a1446f3--195f4384603f4fa9b314086624b73b78 51a7b73a86ff40c18bc5daef53e332ad X 195f4384603f4fa9b314086624b73b78--51a7b73a86ff40c18bc5daef53e332ad 51a7b73a86ff40c18bc5daef53e332ad--262378dfaa1d47e99907d4aa354a30bf 3d126378750a45c5be787ad209ee67e4 51a7b73a86ff40c18bc5daef53e332ad--3d126378750a45c5be787ad209ee67e4 9f37a0a9445c44d082081aee2fca1ebb 3d126378750a45c5be787ad209ee67e4--9f37a0a9445c44d082081aee2fca1ebb 9f034d182fc64b5a834a3be3cb1da651 9f37a0a9445c44d082081aee2fca1ebb--9f034d182fc64b5a834a3be3cb1da651 9b6322c504514f1fb87c4b7a20377ed4 9f034d182fc64b5a834a3be3cb1da651--9b6322c504514f1fb87c4b7a20377ed4 3c1076ce8ef94482bef60ca264dadcc3 9b6322c504514f1fb87c4b7a20377ed4--3c1076ce8ef94482bef60ca264dadcc3 1abcff0613ab4a6d8b661ea148aa0723 3c1076ce8ef94482bef60ca264dadcc3--1abcff0613ab4a6d8b661ea148aa0723 fde97da768a243aaa1e3d5c19fc99e68 1abcff0613ab4a6d8b661ea148aa0723--fde97da768a243aaa1e3d5c19fc99e68 281b28a0122e4402a2f247934af6a3b6 fde97da768a243aaa1e3d5c19fc99e68--281b28a0122e4402a2f247934af6a3b6 3e147f0f5af240ccbc70bd4e1c957890 281b28a0122e4402a2f247934af6a3b6--3e147f0f5af240ccbc70bd4e1c957890 1fc67ea3499e45eaa043ca4ba04b55c4 3e147f0f5af240ccbc70bd4e1c957890--1fc67ea3499e45eaa043ca4ba04b55c4 5526d2a8d363449d96df7b2eec2179d6 1fc67ea3499e45eaa043ca4ba04b55c4--5526d2a8d363449d96df7b2eec2179d6 db9584c466924572b8aad4ec11f92dcc 5526d2a8d363449d96df7b2eec2179d6--db9584c466924572b8aad4ec11f92dcc 4b3ab333ac674fb0ae215bcb0125d599 db9584c466924572b8aad4ec11f92dcc--4b3ab333ac674fb0ae215bcb0125d599 05a0a451c56d42e6a06f29a23b6e0047 4b3ab333ac674fb0ae215bcb0125d599--05a0a451c56d42e6a06f29a23b6e0047 cc4fd7b867064a20a40e2ab957c2c43f 05a0a451c56d42e6a06f29a23b6e0047--cc4fd7b867064a20a40e2ab957c2c43f d591deb7c808411eb62f6cee412d6ae6 cc4fd7b867064a20a40e2ab957c2c43f--d591deb7c808411eb62f6cee412d6ae6 af3b58571fcf4863872f82f01310cc03 d591deb7c808411eb62f6cee412d6ae6--af3b58571fcf4863872f82f01310cc03 1e570e3e3ba649029f4fcec18d240357 af3b58571fcf4863872f82f01310cc03--1e570e3e3ba649029f4fcec18d240357 b1f8074cdfef45de996f446cd6bbe8d4 1e570e3e3ba649029f4fcec18d240357--b1f8074cdfef45de996f446cd6bbe8d4 f64742e05e1d46ec889645439022e5a4 b1f8074cdfef45de996f446cd6bbe8d4--f64742e05e1d46ec889645439022e5a4 aabacbd59263441c9b8ea564b6016d81 f64742e05e1d46ec889645439022e5a4--aabacbd59263441c9b8ea564b6016d81 d4cd1452a47e43028eecd4321c9b72d1 aabacbd59263441c9b8ea564b6016d81--d4cd1452a47e43028eecd4321c9b72d1 88db17f9c9704403969b9c05f9792bc0 RX(b12) d4cd1452a47e43028eecd4321c9b72d1--88db17f9c9704403969b9c05f9792bc0 88db17f9c9704403969b9c05f9792bc0--44d8634226a54498a29f4bb1c4517cfc 9f782d457bb448f0b5133c5ae9377873 40456f79399144fd98dfe857ea1f2344 73eb1afb4b7b4b0d8ae4846be0cf687a--40456f79399144fd98dfe857ea1f2344 169fe3bc1310417aa37ba6987b2138c9 4 829dc22d671f4db184827b8e8a77d285 40456f79399144fd98dfe857ea1f2344--829dc22d671f4db184827b8e8a77d285 46403fbee0d54ff699083459655390fc X 829dc22d671f4db184827b8e8a77d285--46403fbee0d54ff699083459655390fc 46403fbee0d54ff699083459655390fc--5b4bd076dd5a4d6881a0357142b78fab 22643ad32c7941119677de261a283874 46403fbee0d54ff699083459655390fc--22643ad32c7941119677de261a283874 ea74290f828e4e05a3c99c19ce0880bd 22643ad32c7941119677de261a283874--ea74290f828e4e05a3c99c19ce0880bd 09faa49e191a4ff1ad85668cf2d11870 ea74290f828e4e05a3c99c19ce0880bd--09faa49e191a4ff1ad85668cf2d11870 1ac2148759ab44d386256c626fca33af 09faa49e191a4ff1ad85668cf2d11870--1ac2148759ab44d386256c626fca33af 2ef3b4306e33492487a8e26de695a808 1ac2148759ab44d386256c626fca33af--2ef3b4306e33492487a8e26de695a808 0809dd77e68b41a3b585a31e0dcdfcff 2ef3b4306e33492487a8e26de695a808--0809dd77e68b41a3b585a31e0dcdfcff 3f3819c8f5de4c2192b60d84dfadfcc4 0809dd77e68b41a3b585a31e0dcdfcff--3f3819c8f5de4c2192b60d84dfadfcc4 cb05e912831b4e87a65f712b8ce97146 3f3819c8f5de4c2192b60d84dfadfcc4--cb05e912831b4e87a65f712b8ce97146 631e7176f873451b807abeeac3f61b03 cb05e912831b4e87a65f712b8ce97146--631e7176f873451b807abeeac3f61b03 4e512618b23140bd929dd16d10b777c9 X 631e7176f873451b807abeeac3f61b03--4e512618b23140bd929dd16d10b777c9 4e512618b23140bd929dd16d10b777c9--e6b39309a8874ea7bef86d0c7f5eb348 227f0e0e23284107a86ad1962d0abb8b 4e512618b23140bd929dd16d10b777c9--227f0e0e23284107a86ad1962d0abb8b 1b1cd244e0004cdb9f31e7bfef72d0db 227f0e0e23284107a86ad1962d0abb8b--1b1cd244e0004cdb9f31e7bfef72d0db 4e141bc15bba49a68b7003da6da39432 1b1cd244e0004cdb9f31e7bfef72d0db--4e141bc15bba49a68b7003da6da39432 c61e5c8789ad42008435e2b704214a57 4e141bc15bba49a68b7003da6da39432--c61e5c8789ad42008435e2b704214a57 d6c1689dab274768903fb55399627398 c61e5c8789ad42008435e2b704214a57--d6c1689dab274768903fb55399627398 46c21bbb22ff462eaa176784d65fd29d d6c1689dab274768903fb55399627398--46c21bbb22ff462eaa176784d65fd29d 431b3ffbf8eb4e93a18b6e9185a399cc 46c21bbb22ff462eaa176784d65fd29d--431b3ffbf8eb4e93a18b6e9185a399cc 51f6444875984390be9b4c97437e0a72 431b3ffbf8eb4e93a18b6e9185a399cc--51f6444875984390be9b4c97437e0a72 953ee69ba89f4feaa138b105c478d232 51f6444875984390be9b4c97437e0a72--953ee69ba89f4feaa138b105c478d232 8111464377424a7b80f73fed73c4c5fc X 953ee69ba89f4feaa138b105c478d232--8111464377424a7b80f73fed73c4c5fc 8111464377424a7b80f73fed73c4c5fc--a719b3680c354c20ae2a665f3b8caa7f a284d5296dab467e8d84f106d03b1daf RZ(-1.0*g0) 8111464377424a7b80f73fed73c4c5fc--a284d5296dab467e8d84f106d03b1daf a42f8be7ca684912a0001a5e0aaed4b7 X a284d5296dab467e8d84f106d03b1daf--a42f8be7ca684912a0001a5e0aaed4b7 a42f8be7ca684912a0001a5e0aaed4b7--c947b59c793943a48277d6690ad382f0 f7d0c95b4acb466a8deed45aab028da0 a42f8be7ca684912a0001a5e0aaed4b7--f7d0c95b4acb466a8deed45aab028da0 5baca4a111124869846a6fd7c10f5164 f7d0c95b4acb466a8deed45aab028da0--5baca4a111124869846a6fd7c10f5164 20c867fc1ae34b2abcb8468d71e9b84e 5baca4a111124869846a6fd7c10f5164--20c867fc1ae34b2abcb8468d71e9b84e c7086cbddd8143bf8f28049657c6d9ab 20c867fc1ae34b2abcb8468d71e9b84e--c7086cbddd8143bf8f28049657c6d9ab 51f739f51e6a45a8bb7976a8b4a65cd1 X c7086cbddd8143bf8f28049657c6d9ab--51f739f51e6a45a8bb7976a8b4a65cd1 51f739f51e6a45a8bb7976a8b4a65cd1--82a8c16e5ba44559b5bd6a536c6c41f3 67078aa85d4145c5a579df04c568ce14 51f739f51e6a45a8bb7976a8b4a65cd1--67078aa85d4145c5a579df04c568ce14 701f29f7f56940fdb304a57a7a93ff99 67078aa85d4145c5a579df04c568ce14--701f29f7f56940fdb304a57a7a93ff99 4a124412be7a4ee68fa641578a0d4424 701f29f7f56940fdb304a57a7a93ff99--4a124412be7a4ee68fa641578a0d4424 b230a20e0c794cff83c84df22e1269bb X 4a124412be7a4ee68fa641578a0d4424--b230a20e0c794cff83c84df22e1269bb b230a20e0c794cff83c84df22e1269bb--e7fcf255621f48ddabb11f06b03a987b a0dee0440d9b43e9bbfb7d11451bef81 b230a20e0c794cff83c84df22e1269bb--a0dee0440d9b43e9bbfb7d11451bef81 8012634b626f41879d77b5d53b5be910 a0dee0440d9b43e9bbfb7d11451bef81--8012634b626f41879d77b5d53b5be910 1fa324e0a4004a208bd74917e1415d78 8012634b626f41879d77b5d53b5be910--1fa324e0a4004a208bd74917e1415d78 5d36aa1b3ac04d9b8720e322d87c9f30 1fa324e0a4004a208bd74917e1415d78--5d36aa1b3ac04d9b8720e322d87c9f30 eaa0cb0aad7e478cb8411e919c264a95 X 5d36aa1b3ac04d9b8720e322d87c9f30--eaa0cb0aad7e478cb8411e919c264a95 eaa0cb0aad7e478cb8411e919c264a95--d705872230ef4ce4acecee0044bb4782 22c0664859ad41fca5ec3ccbfa5ab813 eaa0cb0aad7e478cb8411e919c264a95--22c0664859ad41fca5ec3ccbfa5ab813 97224e41626e4fedbb43dee594c00a3a 22c0664859ad41fca5ec3ccbfa5ab813--97224e41626e4fedbb43dee594c00a3a b85f8cb00e334cb5aafa2ef0ac8828a0 97224e41626e4fedbb43dee594c00a3a--b85f8cb00e334cb5aafa2ef0ac8828a0 1e8a8055acae405780b8a695a3126d69 b85f8cb00e334cb5aafa2ef0ac8828a0--1e8a8055acae405780b8a695a3126d69 9a42c8b5c92245a79ba28f1b8bafc24d 1e8a8055acae405780b8a695a3126d69--9a42c8b5c92245a79ba28f1b8bafc24d 433d9b583ba84d499ff91f899d3c6c12 9a42c8b5c92245a79ba28f1b8bafc24d--433d9b583ba84d499ff91f899d3c6c12 bb9df07216eb4beebff47720e555d557 433d9b583ba84d499ff91f899d3c6c12--bb9df07216eb4beebff47720e555d557 819c7821428e4bd8b35e6db1aa200619 X bb9df07216eb4beebff47720e555d557--819c7821428e4bd8b35e6db1aa200619 819c7821428e4bd8b35e6db1aa200619--95a795bd2faf41ec87a318760c735acb 840f1ce5ddc84b9ba20880eb158b342b 819c7821428e4bd8b35e6db1aa200619--840f1ce5ddc84b9ba20880eb158b342b 03e76551a6814dba8511e7a9a2418a11 840f1ce5ddc84b9ba20880eb158b342b--03e76551a6814dba8511e7a9a2418a11 3b74de4661f440d1a121e52714371d97 03e76551a6814dba8511e7a9a2418a11--3b74de4661f440d1a121e52714371d97 497e67419496460a8e4b04d7153c000e 3b74de4661f440d1a121e52714371d97--497e67419496460a8e4b04d7153c000e 7cec1fdfdab34ceab97a22f0b937db4a 497e67419496460a8e4b04d7153c000e--7cec1fdfdab34ceab97a22f0b937db4a 96923b4d8c9d47698438b456648baadc 7cec1fdfdab34ceab97a22f0b937db4a--96923b4d8c9d47698438b456648baadc cc4088ffc941414b8e9595f95bc2db21 X 96923b4d8c9d47698438b456648baadc--cc4088ffc941414b8e9595f95bc2db21 cc4088ffc941414b8e9595f95bc2db21--9ee8b86a1dfe4377827e9bb708aadd5d 7a3fd4084d974fc582828b754ba4353a RZ(-1.0*g0) cc4088ffc941414b8e9595f95bc2db21--7a3fd4084d974fc582828b754ba4353a b73d0593e8fd4250a40167d9203f238b X 7a3fd4084d974fc582828b754ba4353a--b73d0593e8fd4250a40167d9203f238b b73d0593e8fd4250a40167d9203f238b--61d88cf2bea945aa9d5ce0a67e9d54d7 3153fb153e6b45909aa0aefdb6e97019 b73d0593e8fd4250a40167d9203f238b--3153fb153e6b45909aa0aefdb6e97019 e42ac5b1f1994edb977b18b8801c4dfa 3153fb153e6b45909aa0aefdb6e97019--e42ac5b1f1994edb977b18b8801c4dfa 58f38f4062d3439990d3650c7036a6f4 X e42ac5b1f1994edb977b18b8801c4dfa--58f38f4062d3439990d3650c7036a6f4 58f38f4062d3439990d3650c7036a6f4--0f17d08c182c43b49fb12bdb8bf7669b d4acd17fa09047d3accd77c7028afd37 58f38f4062d3439990d3650c7036a6f4--d4acd17fa09047d3accd77c7028afd37 70b6321e40b341acb79d9f9f521cb377 d4acd17fa09047d3accd77c7028afd37--70b6321e40b341acb79d9f9f521cb377 8e1dbcc2f7b944a3891b40bc22939186 70b6321e40b341acb79d9f9f521cb377--8e1dbcc2f7b944a3891b40bc22939186 78b283073f224b16bb2e1cf56af0833d X 8e1dbcc2f7b944a3891b40bc22939186--78b283073f224b16bb2e1cf56af0833d 78b283073f224b16bb2e1cf56af0833d--a47f2fa860914c76b72bb727633781aa 70cd50fd083e4a26b8c1a0f64ea42e2a 78b283073f224b16bb2e1cf56af0833d--70cd50fd083e4a26b8c1a0f64ea42e2a 6461670213174bc2a320c797467212ea 70cd50fd083e4a26b8c1a0f64ea42e2a--6461670213174bc2a320c797467212ea 1e3c8bffb4dc44c191dbccc97e961862 X 6461670213174bc2a320c797467212ea--1e3c8bffb4dc44c191dbccc97e961862 1e3c8bffb4dc44c191dbccc97e961862--2be92e22728549bebb629165b20b7ce0 c97b7115aa494a3e83edcad2af32b8c6 1e3c8bffb4dc44c191dbccc97e961862--c97b7115aa494a3e83edcad2af32b8c6 a73050a8d3404ee89d02f9ca96e2c40e c97b7115aa494a3e83edcad2af32b8c6--a73050a8d3404ee89d02f9ca96e2c40e dbf5315404d846429387a4010476627a a73050a8d3404ee89d02f9ca96e2c40e--dbf5315404d846429387a4010476627a 8b764c04d1b74794a034b6a5c5c393ca dbf5315404d846429387a4010476627a--8b764c04d1b74794a034b6a5c5c393ca a8f9a582b4a2406c9d545365583c9216 8b764c04d1b74794a034b6a5c5c393ca--a8f9a582b4a2406c9d545365583c9216 396aabbf97cf45969122e8014cf54964 X a8f9a582b4a2406c9d545365583c9216--396aabbf97cf45969122e8014cf54964 396aabbf97cf45969122e8014cf54964--73f9e22f35d5475f98170476de07e195 872d1bc5aa8245788d859bc4340da4f8 396aabbf97cf45969122e8014cf54964--872d1bc5aa8245788d859bc4340da4f8 c760767defb5474385b50ceeb6f223fe 872d1bc5aa8245788d859bc4340da4f8--c760767defb5474385b50ceeb6f223fe 04d4be3c76c7479f997669a4f7dc5b42 X c760767defb5474385b50ceeb6f223fe--04d4be3c76c7479f997669a4f7dc5b42 04d4be3c76c7479f997669a4f7dc5b42--f26950a9b4bd47188de440f288222e76 4782592456c74d798200af956abbaed6 04d4be3c76c7479f997669a4f7dc5b42--4782592456c74d798200af956abbaed6 f2fd7fa60a5240c8a61ac00005eb3323 4782592456c74d798200af956abbaed6--f2fd7fa60a5240c8a61ac00005eb3323 5958d5c75e924d108459ab8c6291a936 f2fd7fa60a5240c8a61ac00005eb3323--5958d5c75e924d108459ab8c6291a936 0e355e434132489d8e91052726f0b903 5958d5c75e924d108459ab8c6291a936--0e355e434132489d8e91052726f0b903 2c44c3dad58c4c5b9ee31d650cfdf5d0 0e355e434132489d8e91052726f0b903--2c44c3dad58c4c5b9ee31d650cfdf5d0 73d7afb046f34c46b638bc941405e207 2c44c3dad58c4c5b9ee31d650cfdf5d0--73d7afb046f34c46b638bc941405e207 29fabfb0fe374e2c8f9695028dc5f520 73d7afb046f34c46b638bc941405e207--29fabfb0fe374e2c8f9695028dc5f520 eb2f7a375a1244da910f22892996eea3 X 29fabfb0fe374e2c8f9695028dc5f520--eb2f7a375a1244da910f22892996eea3 eb2f7a375a1244da910f22892996eea3--1776659afc994ec2a6883a1b7f0b8670 fb2f7b752e9248f3863fdb9696c8db49 eb2f7a375a1244da910f22892996eea3--fb2f7b752e9248f3863fdb9696c8db49 172d55eb99f548b58c33404ba169e9e6 fb2f7b752e9248f3863fdb9696c8db49--172d55eb99f548b58c33404ba169e9e6 da2d918466794154bedbabff51608dd0 172d55eb99f548b58c33404ba169e9e6--da2d918466794154bedbabff51608dd0 b830e379d4ff4248b9e364c4cb3f2683 da2d918466794154bedbabff51608dd0--b830e379d4ff4248b9e364c4cb3f2683 90ddbc2eeb324c4e89a35ea4938610a5 b830e379d4ff4248b9e364c4cb3f2683--90ddbc2eeb324c4e89a35ea4938610a5 c6cd00b6f8cb41f58903e0acee922e8d 90ddbc2eeb324c4e89a35ea4938610a5--c6cd00b6f8cb41f58903e0acee922e8d 438ade11fdd7411a9138c9621128212a c6cd00b6f8cb41f58903e0acee922e8d--438ade11fdd7411a9138c9621128212a 802e77d20f9547ca8a38cf35a3e4f4e8 438ade11fdd7411a9138c9621128212a--802e77d20f9547ca8a38cf35a3e4f4e8 947e8e6dbb1a4e99865812609ea4460e 802e77d20f9547ca8a38cf35a3e4f4e8--947e8e6dbb1a4e99865812609ea4460e a7d9d3c761dd47c086ece3e41e7e70cb 947e8e6dbb1a4e99865812609ea4460e--a7d9d3c761dd47c086ece3e41e7e70cb 6bb5a400fa454ba68ba71547092eecea a7d9d3c761dd47c086ece3e41e7e70cb--6bb5a400fa454ba68ba71547092eecea 8ec6837e868b4f8cb4d0b7d1c5e68fc9 6bb5a400fa454ba68ba71547092eecea--8ec6837e868b4f8cb4d0b7d1c5e68fc9 2dec7a9ce8fa468da63a830703923d79 8ec6837e868b4f8cb4d0b7d1c5e68fc9--2dec7a9ce8fa468da63a830703923d79 1a353cc3e84a446385209d26836e71a1 2dec7a9ce8fa468da63a830703923d79--1a353cc3e84a446385209d26836e71a1 cfe4c8ced97546769084385edecd3bef 1a353cc3e84a446385209d26836e71a1--cfe4c8ced97546769084385edecd3bef 8c9d928979b94de2bf3b3af0189dae8c cfe4c8ced97546769084385edecd3bef--8c9d928979b94de2bf3b3af0189dae8c a7510ce516c142f3a83798a35d35eef0 8c9d928979b94de2bf3b3af0189dae8c--a7510ce516c142f3a83798a35d35eef0 3b41baf75d604fc58f467f0932699f6f a7510ce516c142f3a83798a35d35eef0--3b41baf75d604fc58f467f0932699f6f f7a1ab36813047b99671d7fb4724962b 3b41baf75d604fc58f467f0932699f6f--f7a1ab36813047b99671d7fb4724962b 1c267267f62d4724950db57f9dd370a9 f7a1ab36813047b99671d7fb4724962b--1c267267f62d4724950db57f9dd370a9 a23eda91f8d7433389601e7ff1fd9c22 1c267267f62d4724950db57f9dd370a9--a23eda91f8d7433389601e7ff1fd9c22 00fd512d37274089b1e2362726af1bef a23eda91f8d7433389601e7ff1fd9c22--00fd512d37274089b1e2362726af1bef b9b46ca1a63a4c3eb5a97e6052e0eed6 00fd512d37274089b1e2362726af1bef--b9b46ca1a63a4c3eb5a97e6052e0eed6 d4b67e26fd2c4d02995ee9575cd49ee0 RX(b03) b9b46ca1a63a4c3eb5a97e6052e0eed6--d4b67e26fd2c4d02995ee9575cd49ee0 3e26b24488124fa0953b1a719bdeeac7 d4b67e26fd2c4d02995ee9575cd49ee0--3e26b24488124fa0953b1a719bdeeac7 5035485b7dd9410fbb6df4b71a14e91d 3e26b24488124fa0953b1a719bdeeac7--5035485b7dd9410fbb6df4b71a14e91d ac9499126d63450dac8441f982921b20 X 5035485b7dd9410fbb6df4b71a14e91d--ac9499126d63450dac8441f982921b20 ac9499126d63450dac8441f982921b20--b841da10daf44287a6b6276cddf09c3b ad033711027d4a28ad8c953cb38fe42d ac9499126d63450dac8441f982921b20--ad033711027d4a28ad8c953cb38fe42d de8731503784412bb23cbab8e19e3a4a ad033711027d4a28ad8c953cb38fe42d--de8731503784412bb23cbab8e19e3a4a cd0c78ff0265490e991f1368159accf5 de8731503784412bb23cbab8e19e3a4a--cd0c78ff0265490e991f1368159accf5 8b87a1fe0bcc4ab8a3fa018b536a145d cd0c78ff0265490e991f1368159accf5--8b87a1fe0bcc4ab8a3fa018b536a145d d1f951fddbb04cc99892efb1f3682b71 8b87a1fe0bcc4ab8a3fa018b536a145d--d1f951fddbb04cc99892efb1f3682b71 7604f26e80c74a4ab81f8a6bc3b73f2f d1f951fddbb04cc99892efb1f3682b71--7604f26e80c74a4ab81f8a6bc3b73f2f 6cfe5c023dd64bc1aacff02cebd2db36 7604f26e80c74a4ab81f8a6bc3b73f2f--6cfe5c023dd64bc1aacff02cebd2db36 32c7e4d90e48425d9296fd509134f10b 6cfe5c023dd64bc1aacff02cebd2db36--32c7e4d90e48425d9296fd509134f10b 7df295f2e4ae4d90a7b08b53d479925c 32c7e4d90e48425d9296fd509134f10b--7df295f2e4ae4d90a7b08b53d479925c 125af17859fb475d996954d0d52370c4 X 7df295f2e4ae4d90a7b08b53d479925c--125af17859fb475d996954d0d52370c4 125af17859fb475d996954d0d52370c4--9f9a07543360489ab47386bb4d5f8eaf 84b611c598fe4f0e8142e0d358fc0e39 125af17859fb475d996954d0d52370c4--84b611c598fe4f0e8142e0d358fc0e39 867e31ed9e804e519e847cf14795d40f 84b611c598fe4f0e8142e0d358fc0e39--867e31ed9e804e519e847cf14795d40f d3cc48bc8ba441c5b67af0bf5ad75a90 867e31ed9e804e519e847cf14795d40f--d3cc48bc8ba441c5b67af0bf5ad75a90 697fa52a083048a99ed0d2101aa321dd d3cc48bc8ba441c5b67af0bf5ad75a90--697fa52a083048a99ed0d2101aa321dd 375b14239d5e4e7f85d951195a892b9f 697fa52a083048a99ed0d2101aa321dd--375b14239d5e4e7f85d951195a892b9f e108ebdf83404e1eb049be33ec7aeaf9 375b14239d5e4e7f85d951195a892b9f--e108ebdf83404e1eb049be33ec7aeaf9 114259be06894f5b87a077cc5845e988 e108ebdf83404e1eb049be33ec7aeaf9--114259be06894f5b87a077cc5845e988 61917527ba704301819d7b83fc2444f5 114259be06894f5b87a077cc5845e988--61917527ba704301819d7b83fc2444f5 fbab7b602f3347b2a02ee8fc23390add 61917527ba704301819d7b83fc2444f5--fbab7b602f3347b2a02ee8fc23390add a0cfaa855afb42dd8bc3582b4eb357e7 X fbab7b602f3347b2a02ee8fc23390add--a0cfaa855afb42dd8bc3582b4eb357e7 a0cfaa855afb42dd8bc3582b4eb357e7--a2f2b2acc917487098d297a2805e57aa 5cafe3b4ad9e4982a72b4f666a93ed07 RZ(-1.0*g1) a0cfaa855afb42dd8bc3582b4eb357e7--5cafe3b4ad9e4982a72b4f666a93ed07 6a8355508c49492ca26e99ac5055dd97 X 5cafe3b4ad9e4982a72b4f666a93ed07--6a8355508c49492ca26e99ac5055dd97 6a8355508c49492ca26e99ac5055dd97--d8d18721aaaa4a7fa9252db93c0de517 c06f9a75ac7e4213803cab480b0dadd4 6a8355508c49492ca26e99ac5055dd97--c06f9a75ac7e4213803cab480b0dadd4 290944f3679148769e7b506773f677e9 c06f9a75ac7e4213803cab480b0dadd4--290944f3679148769e7b506773f677e9 63770ccb45974522aa8721f3f25d49b4 290944f3679148769e7b506773f677e9--63770ccb45974522aa8721f3f25d49b4 85899cc6e0b746a6a031a42b754946f9 63770ccb45974522aa8721f3f25d49b4--85899cc6e0b746a6a031a42b754946f9 d8c1adc5ce7a4fa698173c1a5dd087f2 X 85899cc6e0b746a6a031a42b754946f9--d8c1adc5ce7a4fa698173c1a5dd087f2 d8c1adc5ce7a4fa698173c1a5dd087f2--110b1f266b0d44cd97de12ba90a5a333 ed06dd2b461949bfb299b8b248dbf49b d8c1adc5ce7a4fa698173c1a5dd087f2--ed06dd2b461949bfb299b8b248dbf49b c37f0fce64064719b03f0eeb52da8e03 ed06dd2b461949bfb299b8b248dbf49b--c37f0fce64064719b03f0eeb52da8e03 c261b5a10c2046aa84c3a24d9f327c5d c37f0fce64064719b03f0eeb52da8e03--c261b5a10c2046aa84c3a24d9f327c5d bcdb2614f23546ccbf5cdcab9e4f7ca7 X c261b5a10c2046aa84c3a24d9f327c5d--bcdb2614f23546ccbf5cdcab9e4f7ca7 bcdb2614f23546ccbf5cdcab9e4f7ca7--9224656ad92d4bb49b27bb7b93cb6f8e 4bbeace45a7c454e90b430efb3edb11d bcdb2614f23546ccbf5cdcab9e4f7ca7--4bbeace45a7c454e90b430efb3edb11d 15a397e59b974467840be0c99407a5b3 4bbeace45a7c454e90b430efb3edb11d--15a397e59b974467840be0c99407a5b3 1cda2a68c1e54cec8032815b66b12b09 15a397e59b974467840be0c99407a5b3--1cda2a68c1e54cec8032815b66b12b09 71255f51b4a246cdbf7e75fc7eaa8bc5 1cda2a68c1e54cec8032815b66b12b09--71255f51b4a246cdbf7e75fc7eaa8bc5 1eeefa77917244ea858d8039f89a2036 X 71255f51b4a246cdbf7e75fc7eaa8bc5--1eeefa77917244ea858d8039f89a2036 1eeefa77917244ea858d8039f89a2036--ed8538f9730347f0b4f09d65d4b7c5dc 81b21ed18c354e499e2735b8485b44f7 1eeefa77917244ea858d8039f89a2036--81b21ed18c354e499e2735b8485b44f7 ab2a781c52dd4e2189a4a1934952034c 81b21ed18c354e499e2735b8485b44f7--ab2a781c52dd4e2189a4a1934952034c 42130276c2284d09989177e8a298c7a4 ab2a781c52dd4e2189a4a1934952034c--42130276c2284d09989177e8a298c7a4 978dee43329e472881817703e4072a7c 42130276c2284d09989177e8a298c7a4--978dee43329e472881817703e4072a7c 8a0eaf2eb28144ca9f5f1c75d5b7e6a2 978dee43329e472881817703e4072a7c--8a0eaf2eb28144ca9f5f1c75d5b7e6a2 84b20fbaa8ff4febb025bf596b5a953e 8a0eaf2eb28144ca9f5f1c75d5b7e6a2--84b20fbaa8ff4febb025bf596b5a953e 72ad6852a7ce4adeba6e7f102d5d6fd3 84b20fbaa8ff4febb025bf596b5a953e--72ad6852a7ce4adeba6e7f102d5d6fd3 6b554a01052141fc98308c2a17fb34a8 X 72ad6852a7ce4adeba6e7f102d5d6fd3--6b554a01052141fc98308c2a17fb34a8 6b554a01052141fc98308c2a17fb34a8--7ee1cacaaba64bc586893f093a22b080 b832cefe289746e7a4e99e32a30c79fb 6b554a01052141fc98308c2a17fb34a8--b832cefe289746e7a4e99e32a30c79fb 0f22a72caef4457b9e88628728641cdb b832cefe289746e7a4e99e32a30c79fb--0f22a72caef4457b9e88628728641cdb 302dfedbc52942659e5e760ec3fa8822 0f22a72caef4457b9e88628728641cdb--302dfedbc52942659e5e760ec3fa8822 daabcb8345204dec9b346f96018636c1 302dfedbc52942659e5e760ec3fa8822--daabcb8345204dec9b346f96018636c1 c0b7095e9d364f19a701832cdc3d5b05 daabcb8345204dec9b346f96018636c1--c0b7095e9d364f19a701832cdc3d5b05 6c423777b7d447f2b3f2b5d680890ad0 c0b7095e9d364f19a701832cdc3d5b05--6c423777b7d447f2b3f2b5d680890ad0 7f1a8ffe29514390b6c7f26987a378cd X 6c423777b7d447f2b3f2b5d680890ad0--7f1a8ffe29514390b6c7f26987a378cd 7f1a8ffe29514390b6c7f26987a378cd--d9acf9806bdb4b6d90dc968edc02cf2c 83fdde409b0d43618656c7b80e868695 RZ(-1.0*g1) 7f1a8ffe29514390b6c7f26987a378cd--83fdde409b0d43618656c7b80e868695 a2adf392973449ae93ee1b1e0535df50 X 83fdde409b0d43618656c7b80e868695--a2adf392973449ae93ee1b1e0535df50 a2adf392973449ae93ee1b1e0535df50--81fce33623294e66b9bed49038d02abb df62697fe2e74ff58cbec361dfb1696d a2adf392973449ae93ee1b1e0535df50--df62697fe2e74ff58cbec361dfb1696d 80e672b1ad39438c893f354185c06a2b df62697fe2e74ff58cbec361dfb1696d--80e672b1ad39438c893f354185c06a2b 3869320718cb4b95a77afae7b63b1988 X 80e672b1ad39438c893f354185c06a2b--3869320718cb4b95a77afae7b63b1988 3869320718cb4b95a77afae7b63b1988--d6146024975e45a884304f6e2e2ebb02 677dbf2d5be34bbaa82a9ba332303d51 3869320718cb4b95a77afae7b63b1988--677dbf2d5be34bbaa82a9ba332303d51 5eb224404a324e76a213bc18e7d05960 677dbf2d5be34bbaa82a9ba332303d51--5eb224404a324e76a213bc18e7d05960 08f0c3c612084dc09f32caf012ba1e2b 5eb224404a324e76a213bc18e7d05960--08f0c3c612084dc09f32caf012ba1e2b 3017a7271563426ca6b24a27c1d07e56 X 08f0c3c612084dc09f32caf012ba1e2b--3017a7271563426ca6b24a27c1d07e56 3017a7271563426ca6b24a27c1d07e56--194ea22709b548d5b916e1d95bc0fd25 b94b1a020c3f40fcb34e196f6fb88be7 3017a7271563426ca6b24a27c1d07e56--b94b1a020c3f40fcb34e196f6fb88be7 19c61c7603c9416db5bdb37890d42ca0 b94b1a020c3f40fcb34e196f6fb88be7--19c61c7603c9416db5bdb37890d42ca0 11b14e2446f346beaa93fd7b2ea284c9 X 19c61c7603c9416db5bdb37890d42ca0--11b14e2446f346beaa93fd7b2ea284c9 11b14e2446f346beaa93fd7b2ea284c9--2c97cf593b834ab5a23d83b4edfc81d7 4603fb4d393d44b1aaf12d2e15f226bc 11b14e2446f346beaa93fd7b2ea284c9--4603fb4d393d44b1aaf12d2e15f226bc 062f2fc3b55146139d52efc382f05378 4603fb4d393d44b1aaf12d2e15f226bc--062f2fc3b55146139d52efc382f05378 a35d76f82f4043f1b25eb5ea7568c424 062f2fc3b55146139d52efc382f05378--a35d76f82f4043f1b25eb5ea7568c424 bfbd7d07edda4c619beb5cfeb06388cf a35d76f82f4043f1b25eb5ea7568c424--bfbd7d07edda4c619beb5cfeb06388cf 7b02d7aca37c43e0bb2450e04e0b180f bfbd7d07edda4c619beb5cfeb06388cf--7b02d7aca37c43e0bb2450e04e0b180f 7f50c860648f42d3b504a31683a2f99d X 7b02d7aca37c43e0bb2450e04e0b180f--7f50c860648f42d3b504a31683a2f99d 7f50c860648f42d3b504a31683a2f99d--3b5cf0ba11f04d7591df5ef1981b6221 bf04d454b9a74d5b818645af1b2bd37c 7f50c860648f42d3b504a31683a2f99d--bf04d454b9a74d5b818645af1b2bd37c e6d035bc63fe4d3c8dea79f58db6e84d bf04d454b9a74d5b818645af1b2bd37c--e6d035bc63fe4d3c8dea79f58db6e84d 5befe488ba65480cb2cdb268db5ec660 X e6d035bc63fe4d3c8dea79f58db6e84d--5befe488ba65480cb2cdb268db5ec660 5befe488ba65480cb2cdb268db5ec660--a5568d9dffe34f68965f5cae4a4bcf08 d987598aadea465fb240c039124a98bb 5befe488ba65480cb2cdb268db5ec660--d987598aadea465fb240c039124a98bb 3db500922e1d44bea8cc46c876a785b3 d987598aadea465fb240c039124a98bb--3db500922e1d44bea8cc46c876a785b3 4f6c84ab38d64e3492fdcdda3c5c8077 3db500922e1d44bea8cc46c876a785b3--4f6c84ab38d64e3492fdcdda3c5c8077 350ef0f141d945739cb6dc0dd125d7a3 4f6c84ab38d64e3492fdcdda3c5c8077--350ef0f141d945739cb6dc0dd125d7a3 506015968f1a47d580807c5920f45f72 350ef0f141d945739cb6dc0dd125d7a3--506015968f1a47d580807c5920f45f72 a5566e502d5040af9ea6973ff048d127 506015968f1a47d580807c5920f45f72--a5566e502d5040af9ea6973ff048d127 63972cdc3f174242b04795ee3bc50f4b a5566e502d5040af9ea6973ff048d127--63972cdc3f174242b04795ee3bc50f4b 792a9da8894e44d5b3ac8ef16cd8dc17 X 63972cdc3f174242b04795ee3bc50f4b--792a9da8894e44d5b3ac8ef16cd8dc17 792a9da8894e44d5b3ac8ef16cd8dc17--195f4384603f4fa9b314086624b73b78 818f7d5cee1f4dc9a8c0db2c89501249 792a9da8894e44d5b3ac8ef16cd8dc17--818f7d5cee1f4dc9a8c0db2c89501249 4b843a745fe541838a0720aa5c7d38ee 818f7d5cee1f4dc9a8c0db2c89501249--4b843a745fe541838a0720aa5c7d38ee 5412f7bd02d14c368b8fa551d64c06b9 4b843a745fe541838a0720aa5c7d38ee--5412f7bd02d14c368b8fa551d64c06b9 921e19e549fe4b729ace30ea0243cd13 5412f7bd02d14c368b8fa551d64c06b9--921e19e549fe4b729ace30ea0243cd13 6ee59083a87d4415a217345885d50f4b 921e19e549fe4b729ace30ea0243cd13--6ee59083a87d4415a217345885d50f4b 184f8b080d8149e69b722ce425912a15 6ee59083a87d4415a217345885d50f4b--184f8b080d8149e69b722ce425912a15 66d9ec4a099443b99a56eb514a6e6dcd 184f8b080d8149e69b722ce425912a15--66d9ec4a099443b99a56eb514a6e6dcd 9328fbb9f3a14bddbc2d540ec3d40eac 66d9ec4a099443b99a56eb514a6e6dcd--9328fbb9f3a14bddbc2d540ec3d40eac eeaa7f4f29d94c34a5409c4191f284bb 9328fbb9f3a14bddbc2d540ec3d40eac--eeaa7f4f29d94c34a5409c4191f284bb 1e0300f1cd5f4cbda2b44a1c67b66202 eeaa7f4f29d94c34a5409c4191f284bb--1e0300f1cd5f4cbda2b44a1c67b66202 4b9723f4dcdc4d32a3f4a657eb6e9372 1e0300f1cd5f4cbda2b44a1c67b66202--4b9723f4dcdc4d32a3f4a657eb6e9372 e20268097a5b47338f9a5ea17da4bfcf 4b9723f4dcdc4d32a3f4a657eb6e9372--e20268097a5b47338f9a5ea17da4bfcf 017da00959ec4980a8b3b8852f852ce0 e20268097a5b47338f9a5ea17da4bfcf--017da00959ec4980a8b3b8852f852ce0 072b9025859a41b1aa0e142c158a84b8 017da00959ec4980a8b3b8852f852ce0--072b9025859a41b1aa0e142c158a84b8 c9c1dd9e97344c9fac7df343130de019 072b9025859a41b1aa0e142c158a84b8--c9c1dd9e97344c9fac7df343130de019 3f7b4976804c4016860b185354b04606 c9c1dd9e97344c9fac7df343130de019--3f7b4976804c4016860b185354b04606 e79ba50472c1403bbf112aad23393fc7 3f7b4976804c4016860b185354b04606--e79ba50472c1403bbf112aad23393fc7 231cebf93d7945059141be807c8ed078 e79ba50472c1403bbf112aad23393fc7--231cebf93d7945059141be807c8ed078 a86a48303e1f4fe3bbbf9e75eb0812dd 231cebf93d7945059141be807c8ed078--a86a48303e1f4fe3bbbf9e75eb0812dd 436038bbd55d464eb6e140a055ca42af a86a48303e1f4fe3bbbf9e75eb0812dd--436038bbd55d464eb6e140a055ca42af 7d9f02970fee4248879084a40709d303 436038bbd55d464eb6e140a055ca42af--7d9f02970fee4248879084a40709d303 05acb359e8ce4a76886a4fde1bd06de9 7d9f02970fee4248879084a40709d303--05acb359e8ce4a76886a4fde1bd06de9 c0be32c316bc444eb8727795c339465d 05acb359e8ce4a76886a4fde1bd06de9--c0be32c316bc444eb8727795c339465d b5cb11359f8a49ad8589e7c788cfa708 RX(b13) c0be32c316bc444eb8727795c339465d--b5cb11359f8a49ad8589e7c788cfa708 b5cb11359f8a49ad8589e7c788cfa708--9f782d457bb448f0b5133c5ae9377873 44ea356f5bc940aba501690d74ebc287 12d6005b10624a1195b84619ec896743 169fe3bc1310417aa37ba6987b2138c9--12d6005b10624a1195b84619ec896743 769f8c1b7c8d471382a86153b331b2e6 5 150a1f5771074d7f9625f3214f26155b 12d6005b10624a1195b84619ec896743--150a1f5771074d7f9625f3214f26155b cb9de45a760c417eb0544b0c74b761af 150a1f5771074d7f9625f3214f26155b--cb9de45a760c417eb0544b0c74b761af 7b8b50888756454ba0ad8f3acfa2eed6 X cb9de45a760c417eb0544b0c74b761af--7b8b50888756454ba0ad8f3acfa2eed6 7b8b50888756454ba0ad8f3acfa2eed6--22643ad32c7941119677de261a283874 7d0da1de47304722a72e637f00b689b4 7b8b50888756454ba0ad8f3acfa2eed6--7d0da1de47304722a72e637f00b689b4 25151dcb93f64b75a431bd988d1a4a83 7d0da1de47304722a72e637f00b689b4--25151dcb93f64b75a431bd988d1a4a83 463d00e2d7d642609ac6b8f0662f8bbb 25151dcb93f64b75a431bd988d1a4a83--463d00e2d7d642609ac6b8f0662f8bbb 3a4e97c30684486491d7a23236ec785c 463d00e2d7d642609ac6b8f0662f8bbb--3a4e97c30684486491d7a23236ec785c a40c4c4c81544201b118d5978b2c97b5 3a4e97c30684486491d7a23236ec785c--a40c4c4c81544201b118d5978b2c97b5 4568ac56094d4aab92ed3e8cab4d5e45 a40c4c4c81544201b118d5978b2c97b5--4568ac56094d4aab92ed3e8cab4d5e45 f0766c83dba84668b83806937d635b39 4568ac56094d4aab92ed3e8cab4d5e45--f0766c83dba84668b83806937d635b39 385b98a27cdc448db09a7e2bb1975fb2 X f0766c83dba84668b83806937d635b39--385b98a27cdc448db09a7e2bb1975fb2 385b98a27cdc448db09a7e2bb1975fb2--631e7176f873451b807abeeac3f61b03 4b891bae050d4edba55f98c246824a62 385b98a27cdc448db09a7e2bb1975fb2--4b891bae050d4edba55f98c246824a62 8507c36c49854c9cbabcf22247818f13 4b891bae050d4edba55f98c246824a62--8507c36c49854c9cbabcf22247818f13 fe6890949fad4c1985f96d7c727c8e5d 8507c36c49854c9cbabcf22247818f13--fe6890949fad4c1985f96d7c727c8e5d 0d280e144b0a479da514022170c4b547 fe6890949fad4c1985f96d7c727c8e5d--0d280e144b0a479da514022170c4b547 93719185786c431aa852848e1e2d9730 0d280e144b0a479da514022170c4b547--93719185786c431aa852848e1e2d9730 8725063dfc114828887262537cc604ae 93719185786c431aa852848e1e2d9730--8725063dfc114828887262537cc604ae cca849f255f54af38477ca60f535e3a1 8725063dfc114828887262537cc604ae--cca849f255f54af38477ca60f535e3a1 a58e7d7d0a9b4490b32e1214b81344c6 cca849f255f54af38477ca60f535e3a1--a58e7d7d0a9b4490b32e1214b81344c6 a70cebb9f4bf403f8de4e99f68c66bd8 a58e7d7d0a9b4490b32e1214b81344c6--a70cebb9f4bf403f8de4e99f68c66bd8 1857d6b8927d49479dfaedfc0c9f9b08 a70cebb9f4bf403f8de4e99f68c66bd8--1857d6b8927d49479dfaedfc0c9f9b08 b83a5ccd35884bc3b4ee1a601551532d 1857d6b8927d49479dfaedfc0c9f9b08--b83a5ccd35884bc3b4ee1a601551532d b1f7e6f8d4c24eb6b39710a011bb7d0e b83a5ccd35884bc3b4ee1a601551532d--b1f7e6f8d4c24eb6b39710a011bb7d0e 9ce406292ec54fd6ba03d7841adb79ed b1f7e6f8d4c24eb6b39710a011bb7d0e--9ce406292ec54fd6ba03d7841adb79ed 3645326701e34280a4ffc044d1e45fb6 9ce406292ec54fd6ba03d7841adb79ed--3645326701e34280a4ffc044d1e45fb6 8468a853999146e0bd2f39649176790a 3645326701e34280a4ffc044d1e45fb6--8468a853999146e0bd2f39649176790a 7043d1a710454ef894b120acd9301616 8468a853999146e0bd2f39649176790a--7043d1a710454ef894b120acd9301616 c1f8a44a241b43bebc72823606b3770c 7043d1a710454ef894b120acd9301616--c1f8a44a241b43bebc72823606b3770c 3d7979e6a69e413ca5a0c73bec9b3d44 c1f8a44a241b43bebc72823606b3770c--3d7979e6a69e413ca5a0c73bec9b3d44 3c9818fe3c7844ce930fdf5ecb7718ea X 3d7979e6a69e413ca5a0c73bec9b3d44--3c9818fe3c7844ce930fdf5ecb7718ea 3c9818fe3c7844ce930fdf5ecb7718ea--67078aa85d4145c5a579df04c568ce14 9e359a96f57d459cb6adeae9badc1230 RZ(-1.0*g0) 3c9818fe3c7844ce930fdf5ecb7718ea--9e359a96f57d459cb6adeae9badc1230 7bb3731b8dba4eda84ff3c3eda56a439 X 9e359a96f57d459cb6adeae9badc1230--7bb3731b8dba4eda84ff3c3eda56a439 7bb3731b8dba4eda84ff3c3eda56a439--4a124412be7a4ee68fa641578a0d4424 4ac0922fce234eb8b3cb9e73b18fab4a 7bb3731b8dba4eda84ff3c3eda56a439--4ac0922fce234eb8b3cb9e73b18fab4a 3c0be278f5574161b6b0d6a27e0f31a6 4ac0922fce234eb8b3cb9e73b18fab4a--3c0be278f5574161b6b0d6a27e0f31a6 3839dd6534dc4357aa6b6c21c5e18d47 3c0be278f5574161b6b0d6a27e0f31a6--3839dd6534dc4357aa6b6c21c5e18d47 ee77035459944304a7f689945815922e 3839dd6534dc4357aa6b6c21c5e18d47--ee77035459944304a7f689945815922e 3570cc916fba4a9fac301365fef4aae1 ee77035459944304a7f689945815922e--3570cc916fba4a9fac301365fef4aae1 08dc954643734a65a2ef59d301c21f37 3570cc916fba4a9fac301365fef4aae1--08dc954643734a65a2ef59d301c21f37 eb01b526ba4545509352e34c55f7aff7 X 08dc954643734a65a2ef59d301c21f37--eb01b526ba4545509352e34c55f7aff7 eb01b526ba4545509352e34c55f7aff7--22c0664859ad41fca5ec3ccbfa5ab813 88aaabab8ef044938f505faa362ec00c eb01b526ba4545509352e34c55f7aff7--88aaabab8ef044938f505faa362ec00c cd0b02b60fc34c508eff5c42fc27f7a2 88aaabab8ef044938f505faa362ec00c--cd0b02b60fc34c508eff5c42fc27f7a2 f0360d9b0a6a45b89bdd693e7c88c7ca cd0b02b60fc34c508eff5c42fc27f7a2--f0360d9b0a6a45b89bdd693e7c88c7ca 697886a84aaf497990b655a214b70656 f0360d9b0a6a45b89bdd693e7c88c7ca--697886a84aaf497990b655a214b70656 d22067144bc747f396c6c0d9e84cb3ad 697886a84aaf497990b655a214b70656--d22067144bc747f396c6c0d9e84cb3ad 82d755a60f284e4c92a4bf73be6086c9 X d22067144bc747f396c6c0d9e84cb3ad--82d755a60f284e4c92a4bf73be6086c9 82d755a60f284e4c92a4bf73be6086c9--bb9df07216eb4beebff47720e555d557 9e334935901c4cdeb6b0f9d25bdba316 82d755a60f284e4c92a4bf73be6086c9--9e334935901c4cdeb6b0f9d25bdba316 c21e5278453a426294e5f7cfb8b3c345 9e334935901c4cdeb6b0f9d25bdba316--c21e5278453a426294e5f7cfb8b3c345 e42a3f31df084d9ea5ad66cb2e8c2f95 c21e5278453a426294e5f7cfb8b3c345--e42a3f31df084d9ea5ad66cb2e8c2f95 b766a0312018437c8e68b64b9afb243f e42a3f31df084d9ea5ad66cb2e8c2f95--b766a0312018437c8e68b64b9afb243f 828252481aff4c43a3d708d8b7a3959c b766a0312018437c8e68b64b9afb243f--828252481aff4c43a3d708d8b7a3959c 74c87618eb49459d9a07c27c13a9ffff 828252481aff4c43a3d708d8b7a3959c--74c87618eb49459d9a07c27c13a9ffff 5c9ccf1131d642829ca05727117ba1a0 74c87618eb49459d9a07c27c13a9ffff--5c9ccf1131d642829ca05727117ba1a0 76b16c621a21417a938f0724d59dd919 5c9ccf1131d642829ca05727117ba1a0--76b16c621a21417a938f0724d59dd919 9284b720909d46f79df9cd9aac7eab2e 76b16c621a21417a938f0724d59dd919--9284b720909d46f79df9cd9aac7eab2e b7f65e40fbbb489b8aec041d9790ac8c 9284b720909d46f79df9cd9aac7eab2e--b7f65e40fbbb489b8aec041d9790ac8c 13cd9e3421ad4824b3a1c3a4d5a4bb73 b7f65e40fbbb489b8aec041d9790ac8c--13cd9e3421ad4824b3a1c3a4d5a4bb73 949e50f1c3604e30b03446976600611f 13cd9e3421ad4824b3a1c3a4d5a4bb73--949e50f1c3604e30b03446976600611f 8ce9a38d856a4c58b7f9950c7202e8c2 949e50f1c3604e30b03446976600611f--8ce9a38d856a4c58b7f9950c7202e8c2 fa2ca83dcda0433ea233e1537293e907 X 8ce9a38d856a4c58b7f9950c7202e8c2--fa2ca83dcda0433ea233e1537293e907 fa2ca83dcda0433ea233e1537293e907--d4acd17fa09047d3accd77c7028afd37 dfc998e2910947bab7f84168d89b1b65 RZ(-1.0*g0) fa2ca83dcda0433ea233e1537293e907--dfc998e2910947bab7f84168d89b1b65 7cb8d8184a614299982925e931ae0f07 X dfc998e2910947bab7f84168d89b1b65--7cb8d8184a614299982925e931ae0f07 7cb8d8184a614299982925e931ae0f07--8e1dbcc2f7b944a3891b40bc22939186 bd789fb01ea941aeb1f60a08eb939d9e 7cb8d8184a614299982925e931ae0f07--bd789fb01ea941aeb1f60a08eb939d9e 571d6708d14141649b100fd4a4fbaa88 bd789fb01ea941aeb1f60a08eb939d9e--571d6708d14141649b100fd4a4fbaa88 5d26ffea966e41d0ba88ca1d69bdaf79 571d6708d14141649b100fd4a4fbaa88--5d26ffea966e41d0ba88ca1d69bdaf79 93c2a78b57eb4d18b1bc90cbbd1a1a06 5d26ffea966e41d0ba88ca1d69bdaf79--93c2a78b57eb4d18b1bc90cbbd1a1a06 edde4d7dba1f4ff8b1ccfc26f325e5a5 X 93c2a78b57eb4d18b1bc90cbbd1a1a06--edde4d7dba1f4ff8b1ccfc26f325e5a5 edde4d7dba1f4ff8b1ccfc26f325e5a5--c97b7115aa494a3e83edcad2af32b8c6 510ef5adc41d4c1e94ba7f33db858ba6 edde4d7dba1f4ff8b1ccfc26f325e5a5--510ef5adc41d4c1e94ba7f33db858ba6 bdaf3fe290444797a669bf13b72ba298 510ef5adc41d4c1e94ba7f33db858ba6--bdaf3fe290444797a669bf13b72ba298 65f2621118bd4b4a865bdebc5f7cbd90 bdaf3fe290444797a669bf13b72ba298--65f2621118bd4b4a865bdebc5f7cbd90 d7a171978a8f4c0a81993adefeeea2d8 X 65f2621118bd4b4a865bdebc5f7cbd90--d7a171978a8f4c0a81993adefeeea2d8 d7a171978a8f4c0a81993adefeeea2d8--a8f9a582b4a2406c9d545365583c9216 67dccaced72b415fa74b9bd9ce30dfd9 d7a171978a8f4c0a81993adefeeea2d8--67dccaced72b415fa74b9bd9ce30dfd9 2efecbc451ce418fa3e96d13bfa88f1e 67dccaced72b415fa74b9bd9ce30dfd9--2efecbc451ce418fa3e96d13bfa88f1e 612a6564eb3e4f8b9389f1fe58d13f90 2efecbc451ce418fa3e96d13bfa88f1e--612a6564eb3e4f8b9389f1fe58d13f90 844700e4e5294b7cbb950cc686b17f32 612a6564eb3e4f8b9389f1fe58d13f90--844700e4e5294b7cbb950cc686b17f32 d955a0d7811f442392c1b1f686294c55 X 844700e4e5294b7cbb950cc686b17f32--d955a0d7811f442392c1b1f686294c55 d955a0d7811f442392c1b1f686294c55--4782592456c74d798200af956abbaed6 f03848e0ae0a492aacb6b72026f1dc8f d955a0d7811f442392c1b1f686294c55--f03848e0ae0a492aacb6b72026f1dc8f 510a3bf28ea04ba0a1275c6be1e4b484 f03848e0ae0a492aacb6b72026f1dc8f--510a3bf28ea04ba0a1275c6be1e4b484 645a8c581a674b93a993bbb175c1cf11 510a3bf28ea04ba0a1275c6be1e4b484--645a8c581a674b93a993bbb175c1cf11 e6452a1f086f4bad8616f1070c82cc04 645a8c581a674b93a993bbb175c1cf11--e6452a1f086f4bad8616f1070c82cc04 fef2e0280c11454796ce3ba449e90656 e6452a1f086f4bad8616f1070c82cc04--fef2e0280c11454796ce3ba449e90656 c8f8d5af754a49668b81057f579ef3ff X fef2e0280c11454796ce3ba449e90656--c8f8d5af754a49668b81057f579ef3ff c8f8d5af754a49668b81057f579ef3ff--29fabfb0fe374e2c8f9695028dc5f520 a8609f4fccb94c758244df9849d38293 c8f8d5af754a49668b81057f579ef3ff--a8609f4fccb94c758244df9849d38293 5f4076abe3ae49678d6024787d3ebf6f a8609f4fccb94c758244df9849d38293--5f4076abe3ae49678d6024787d3ebf6f b397ac13d3444301a5566f1025463d91 X 5f4076abe3ae49678d6024787d3ebf6f--b397ac13d3444301a5566f1025463d91 b397ac13d3444301a5566f1025463d91--172d55eb99f548b58c33404ba169e9e6 29bc29e7fd574c9686198a215cdb5b50 b397ac13d3444301a5566f1025463d91--29bc29e7fd574c9686198a215cdb5b50 0799db94b1784cdcadb6262940d5a6ec 29bc29e7fd574c9686198a215cdb5b50--0799db94b1784cdcadb6262940d5a6ec 8946b3cbb22b44139b4dcea1824dcdaa 0799db94b1784cdcadb6262940d5a6ec--8946b3cbb22b44139b4dcea1824dcdaa b167124d71f240559c46a9c058ebb4b0 X 8946b3cbb22b44139b4dcea1824dcdaa--b167124d71f240559c46a9c058ebb4b0 b167124d71f240559c46a9c058ebb4b0--c6cd00b6f8cb41f58903e0acee922e8d 4ebee154c6ab4b45b4a52084f09cb598 X b167124d71f240559c46a9c058ebb4b0--4ebee154c6ab4b45b4a52084f09cb598 4ebee154c6ab4b45b4a52084f09cb598--438ade11fdd7411a9138c9621128212a 953b9ca816514db7bac04d5ce3654f44 4ebee154c6ab4b45b4a52084f09cb598--953b9ca816514db7bac04d5ce3654f44 1d2634a017a24d5f828c73599167c9e0 953b9ca816514db7bac04d5ce3654f44--1d2634a017a24d5f828c73599167c9e0 606f73dfcf3b4e01aeb1f8ed375e139f 1d2634a017a24d5f828c73599167c9e0--606f73dfcf3b4e01aeb1f8ed375e139f b9c09daedb65477cb247a1ea83ed5ae5 606f73dfcf3b4e01aeb1f8ed375e139f--b9c09daedb65477cb247a1ea83ed5ae5 70650a4b31e74169a915b410786d7924 b9c09daedb65477cb247a1ea83ed5ae5--70650a4b31e74169a915b410786d7924 0a89c38ecb1d49b09d9bd797068d9ad9 X 70650a4b31e74169a915b410786d7924--0a89c38ecb1d49b09d9bd797068d9ad9 0a89c38ecb1d49b09d9bd797068d9ad9--2dec7a9ce8fa468da63a830703923d79 e38fa421322f4f7fba33b408cbfb7959 0a89c38ecb1d49b09d9bd797068d9ad9--e38fa421322f4f7fba33b408cbfb7959 213e0718c78a44d7a3d590bde643d486 e38fa421322f4f7fba33b408cbfb7959--213e0718c78a44d7a3d590bde643d486 ff7be9c39dee4dddb97e41349ad8944b 213e0718c78a44d7a3d590bde643d486--ff7be9c39dee4dddb97e41349ad8944b 0a72c3a98e054182b835de560e71746d ff7be9c39dee4dddb97e41349ad8944b--0a72c3a98e054182b835de560e71746d c2f66833037441fdb5f158a3c2660b61 0a72c3a98e054182b835de560e71746d--c2f66833037441fdb5f158a3c2660b61 08d7ff7a783f4dd2807056283f27a249 c2f66833037441fdb5f158a3c2660b61--08d7ff7a783f4dd2807056283f27a249 b3b49c051ff64097bd563b23b1c03cc7 08d7ff7a783f4dd2807056283f27a249--b3b49c051ff64097bd563b23b1c03cc7 bc362ea798b24aa9bc9c0da0e3149499 b3b49c051ff64097bd563b23b1c03cc7--bc362ea798b24aa9bc9c0da0e3149499 8b57674f5c1f42ea940553fc41626536 bc362ea798b24aa9bc9c0da0e3149499--8b57674f5c1f42ea940553fc41626536 c873bcbdc85f4fc9aa6c08a67c2e85d3 8b57674f5c1f42ea940553fc41626536--c873bcbdc85f4fc9aa6c08a67c2e85d3 29a8af99a05e4a2fa4886b74a1b5cdfc RX(b04) c873bcbdc85f4fc9aa6c08a67c2e85d3--29a8af99a05e4a2fa4886b74a1b5cdfc 942f81c9377147d1aa8c60689e77bf0a 29a8af99a05e4a2fa4886b74a1b5cdfc--942f81c9377147d1aa8c60689e77bf0a bd43d54baeb5496aa940e0ab9ef12a5c 942f81c9377147d1aa8c60689e77bf0a--bd43d54baeb5496aa940e0ab9ef12a5c 30c5165dc5634f74a0fcb83dfee0ceb0 bd43d54baeb5496aa940e0ab9ef12a5c--30c5165dc5634f74a0fcb83dfee0ceb0 8a1c6a8191594566add3e2cd7ea98eb7 X 30c5165dc5634f74a0fcb83dfee0ceb0--8a1c6a8191594566add3e2cd7ea98eb7 8a1c6a8191594566add3e2cd7ea98eb7--ad033711027d4a28ad8c953cb38fe42d 34f3fc9d474a47968af11c1ea6d4fa18 8a1c6a8191594566add3e2cd7ea98eb7--34f3fc9d474a47968af11c1ea6d4fa18 2b81d9ab62824a9f84ce5f82148d7fc2 34f3fc9d474a47968af11c1ea6d4fa18--2b81d9ab62824a9f84ce5f82148d7fc2 de255c6519054d349aef31c18833d960 2b81d9ab62824a9f84ce5f82148d7fc2--de255c6519054d349aef31c18833d960 c74ff0374c2b4ca3a4f3318d3e390ccb de255c6519054d349aef31c18833d960--c74ff0374c2b4ca3a4f3318d3e390ccb 4573e1060558492fb553c06a543c028a c74ff0374c2b4ca3a4f3318d3e390ccb--4573e1060558492fb553c06a543c028a 5ab981636c13420a8271745f9a093db4 4573e1060558492fb553c06a543c028a--5ab981636c13420a8271745f9a093db4 ae6509ec3a204a6e9fd90d9353d5138f 5ab981636c13420a8271745f9a093db4--ae6509ec3a204a6e9fd90d9353d5138f 62148e15fc1441f4b1d892d0ca9308c1 X ae6509ec3a204a6e9fd90d9353d5138f--62148e15fc1441f4b1d892d0ca9308c1 62148e15fc1441f4b1d892d0ca9308c1--7df295f2e4ae4d90a7b08b53d479925c 53c9268b6ea149b59efa94e0b071df95 62148e15fc1441f4b1d892d0ca9308c1--53c9268b6ea149b59efa94e0b071df95 f0d4fab1900f4da5ba751261514a483b 53c9268b6ea149b59efa94e0b071df95--f0d4fab1900f4da5ba751261514a483b 082d4b71a00044e394959cc6aef307f7 f0d4fab1900f4da5ba751261514a483b--082d4b71a00044e394959cc6aef307f7 2bdbc9f9df8f4747888d54f4eed16f5b 082d4b71a00044e394959cc6aef307f7--2bdbc9f9df8f4747888d54f4eed16f5b b867b118ca954df0bf5b92adcbea2a31 2bdbc9f9df8f4747888d54f4eed16f5b--b867b118ca954df0bf5b92adcbea2a31 cbb0bcde91404cb393955fa3094c456b b867b118ca954df0bf5b92adcbea2a31--cbb0bcde91404cb393955fa3094c456b cf8a965005a24336ac7f6b915d3508d7 cbb0bcde91404cb393955fa3094c456b--cf8a965005a24336ac7f6b915d3508d7 69b5c2580a8449baac7915d6ac027cdc cf8a965005a24336ac7f6b915d3508d7--69b5c2580a8449baac7915d6ac027cdc 1c3c9fcfdbea476fba6c1cb360b1af67 69b5c2580a8449baac7915d6ac027cdc--1c3c9fcfdbea476fba6c1cb360b1af67 14065809792342f598c31624efe001a1 1c3c9fcfdbea476fba6c1cb360b1af67--14065809792342f598c31624efe001a1 2a8846fb881e46e0b0a965f7764b8c53 14065809792342f598c31624efe001a1--2a8846fb881e46e0b0a965f7764b8c53 a2ff106f0a6c42e384a78ab1de0a2c06 2a8846fb881e46e0b0a965f7764b8c53--a2ff106f0a6c42e384a78ab1de0a2c06 eda7a57cb16246db980b6bd087f6415b a2ff106f0a6c42e384a78ab1de0a2c06--eda7a57cb16246db980b6bd087f6415b b4e28de77b12409b93a579e2dac0d91c eda7a57cb16246db980b6bd087f6415b--b4e28de77b12409b93a579e2dac0d91c f5d0416bb4f947278a0250327404fefa b4e28de77b12409b93a579e2dac0d91c--f5d0416bb4f947278a0250327404fefa d149ffccf4e84d7e93d7bbba8ccc9f13 f5d0416bb4f947278a0250327404fefa--d149ffccf4e84d7e93d7bbba8ccc9f13 8ef21e8a7479495a966ab5ae66555b26 d149ffccf4e84d7e93d7bbba8ccc9f13--8ef21e8a7479495a966ab5ae66555b26 1b7b8ed2967e4e58bd769a6622c29694 8ef21e8a7479495a966ab5ae66555b26--1b7b8ed2967e4e58bd769a6622c29694 c450285da7f64f1d8ff1501e58eaa3f2 X 1b7b8ed2967e4e58bd769a6622c29694--c450285da7f64f1d8ff1501e58eaa3f2 c450285da7f64f1d8ff1501e58eaa3f2--ed06dd2b461949bfb299b8b248dbf49b fbdb56c215d7471f9fc66d0c9919ee56 RZ(-1.0*g1) c450285da7f64f1d8ff1501e58eaa3f2--fbdb56c215d7471f9fc66d0c9919ee56 7e4d975b96794289b1f62059a9e21087 X fbdb56c215d7471f9fc66d0c9919ee56--7e4d975b96794289b1f62059a9e21087 7e4d975b96794289b1f62059a9e21087--c261b5a10c2046aa84c3a24d9f327c5d 8cd63cf0d4754e1b94fd3901961382a6 7e4d975b96794289b1f62059a9e21087--8cd63cf0d4754e1b94fd3901961382a6 43aaae6b49714868b16b0dc998a77d6a 8cd63cf0d4754e1b94fd3901961382a6--43aaae6b49714868b16b0dc998a77d6a c692e8884f554d83af1fa1fbe5823c80 43aaae6b49714868b16b0dc998a77d6a--c692e8884f554d83af1fa1fbe5823c80 2e8a449b978c43648374669ea46ff8ca c692e8884f554d83af1fa1fbe5823c80--2e8a449b978c43648374669ea46ff8ca ad9b20b553144d879afdfa499f838462 2e8a449b978c43648374669ea46ff8ca--ad9b20b553144d879afdfa499f838462 07079c52063c4c5c92d91f325f8565ad ad9b20b553144d879afdfa499f838462--07079c52063c4c5c92d91f325f8565ad c12d17170d2347528a05ac51b98693c7 X 07079c52063c4c5c92d91f325f8565ad--c12d17170d2347528a05ac51b98693c7 c12d17170d2347528a05ac51b98693c7--81b21ed18c354e499e2735b8485b44f7 04a03c666f89458c951bc00234b1aafe c12d17170d2347528a05ac51b98693c7--04a03c666f89458c951bc00234b1aafe 2483480cfc28410a9f4ca9d8d47d6865 04a03c666f89458c951bc00234b1aafe--2483480cfc28410a9f4ca9d8d47d6865 7648bbdab4e84b1fb13497d87a32dff7 2483480cfc28410a9f4ca9d8d47d6865--7648bbdab4e84b1fb13497d87a32dff7 11436696b2884c278a458a037ee86d24 7648bbdab4e84b1fb13497d87a32dff7--11436696b2884c278a458a037ee86d24 9502cc39a00d45f78c659cd8474c58bd 11436696b2884c278a458a037ee86d24--9502cc39a00d45f78c659cd8474c58bd 921e06ceb8554e34a537f28b71d134c3 X 9502cc39a00d45f78c659cd8474c58bd--921e06ceb8554e34a537f28b71d134c3 921e06ceb8554e34a537f28b71d134c3--72ad6852a7ce4adeba6e7f102d5d6fd3 6be707cd95f6482f9d6b80f3d835c92f 921e06ceb8554e34a537f28b71d134c3--6be707cd95f6482f9d6b80f3d835c92f cfd0fd1c47fd42aca0842d234de3240b 6be707cd95f6482f9d6b80f3d835c92f--cfd0fd1c47fd42aca0842d234de3240b f10a585311c94caf9b0d7ac3e2cd9198 cfd0fd1c47fd42aca0842d234de3240b--f10a585311c94caf9b0d7ac3e2cd9198 2d49465e638a469783ef4a93ff291aa3 f10a585311c94caf9b0d7ac3e2cd9198--2d49465e638a469783ef4a93ff291aa3 8f9e8e77cd274ef68fb163fdbabf8d73 2d49465e638a469783ef4a93ff291aa3--8f9e8e77cd274ef68fb163fdbabf8d73 446d9a91a47d4e249abdcaa3f3e9b2a7 8f9e8e77cd274ef68fb163fdbabf8d73--446d9a91a47d4e249abdcaa3f3e9b2a7 4d6d6c60838343af840e78e4328c0202 446d9a91a47d4e249abdcaa3f3e9b2a7--4d6d6c60838343af840e78e4328c0202 1ab0ed2edb7546beb9e490f0cffa9a2c 4d6d6c60838343af840e78e4328c0202--1ab0ed2edb7546beb9e490f0cffa9a2c 28d02eccec9d41678af0b1daff0ff0aa 1ab0ed2edb7546beb9e490f0cffa9a2c--28d02eccec9d41678af0b1daff0ff0aa 3a04515682b84b88a7bc0f7321ce01fc 28d02eccec9d41678af0b1daff0ff0aa--3a04515682b84b88a7bc0f7321ce01fc 01b36d5664a24886902082ade31e588c 3a04515682b84b88a7bc0f7321ce01fc--01b36d5664a24886902082ade31e588c aedcb21693984953952c6465986e2d87 01b36d5664a24886902082ade31e588c--aedcb21693984953952c6465986e2d87 becf5c0b047f493791e7cee6e1bbae56 aedcb21693984953952c6465986e2d87--becf5c0b047f493791e7cee6e1bbae56 b16ab6acd8744859a9bc193d3bd0f6aa X becf5c0b047f493791e7cee6e1bbae56--b16ab6acd8744859a9bc193d3bd0f6aa b16ab6acd8744859a9bc193d3bd0f6aa--677dbf2d5be34bbaa82a9ba332303d51 1c4f737780cd4be2881a71d0ec1e4e06 RZ(-1.0*g1) b16ab6acd8744859a9bc193d3bd0f6aa--1c4f737780cd4be2881a71d0ec1e4e06 cb344fac074849cdba9a88d42b05ff1c X 1c4f737780cd4be2881a71d0ec1e4e06--cb344fac074849cdba9a88d42b05ff1c cb344fac074849cdba9a88d42b05ff1c--08f0c3c612084dc09f32caf012ba1e2b 925f940b74634d5faed7b9bf616ea189 cb344fac074849cdba9a88d42b05ff1c--925f940b74634d5faed7b9bf616ea189 9309c20ccc10466baa3e40a6bf248a59 925f940b74634d5faed7b9bf616ea189--9309c20ccc10466baa3e40a6bf248a59 055c437819f14c8bb94d2753d38feb72 9309c20ccc10466baa3e40a6bf248a59--055c437819f14c8bb94d2753d38feb72 f5da2ceecca54d33b454610384fed2f7 055c437819f14c8bb94d2753d38feb72--f5da2ceecca54d33b454610384fed2f7 facbac3a1a5b474a80b02c0b36f2f84b X f5da2ceecca54d33b454610384fed2f7--facbac3a1a5b474a80b02c0b36f2f84b facbac3a1a5b474a80b02c0b36f2f84b--4603fb4d393d44b1aaf12d2e15f226bc 77a7105456984dc58e16bb288cccffb8 facbac3a1a5b474a80b02c0b36f2f84b--77a7105456984dc58e16bb288cccffb8 b7c363a3666848888fbedd80a56e4b45 77a7105456984dc58e16bb288cccffb8--b7c363a3666848888fbedd80a56e4b45 151ba5553ffb4f96b6e2579b9b3e600b b7c363a3666848888fbedd80a56e4b45--151ba5553ffb4f96b6e2579b9b3e600b dcbc16e458ee4a43a2ff76b7d0b841c4 X 151ba5553ffb4f96b6e2579b9b3e600b--dcbc16e458ee4a43a2ff76b7d0b841c4 dcbc16e458ee4a43a2ff76b7d0b841c4--7b02d7aca37c43e0bb2450e04e0b180f 7e652d54dd9c4cbda2647437eef2d96d dcbc16e458ee4a43a2ff76b7d0b841c4--7e652d54dd9c4cbda2647437eef2d96d 756d0f2ce59e40d58373715b27494b44 7e652d54dd9c4cbda2647437eef2d96d--756d0f2ce59e40d58373715b27494b44 82e8d648c8424815b87a2f647580a529 756d0f2ce59e40d58373715b27494b44--82e8d648c8424815b87a2f647580a529 06178cffe3cd4af98f2541ad995bb528 82e8d648c8424815b87a2f647580a529--06178cffe3cd4af98f2541ad995bb528 0ccd04fc89e5443fbbbbd2d5348f4452 X 06178cffe3cd4af98f2541ad995bb528--0ccd04fc89e5443fbbbbd2d5348f4452 0ccd04fc89e5443fbbbbd2d5348f4452--d987598aadea465fb240c039124a98bb 243e5ee2c6684a1ea6975a991d13624b 0ccd04fc89e5443fbbbbd2d5348f4452--243e5ee2c6684a1ea6975a991d13624b 51f63a61e596465697e5b8300850ce23 243e5ee2c6684a1ea6975a991d13624b--51f63a61e596465697e5b8300850ce23 4193b71ef4ea445e88da0083eb74aa7e 51f63a61e596465697e5b8300850ce23--4193b71ef4ea445e88da0083eb74aa7e 2339c174974c48af877bd30b0f3f06fe 4193b71ef4ea445e88da0083eb74aa7e--2339c174974c48af877bd30b0f3f06fe db802e81be134feabb71550bdffbb91a 2339c174974c48af877bd30b0f3f06fe--db802e81be134feabb71550bdffbb91a bec43b956ace4f469e09cca1556f30bc X db802e81be134feabb71550bdffbb91a--bec43b956ace4f469e09cca1556f30bc bec43b956ace4f469e09cca1556f30bc--63972cdc3f174242b04795ee3bc50f4b 1cfc9fba6cf344ee9ec8095692cf4d26 bec43b956ace4f469e09cca1556f30bc--1cfc9fba6cf344ee9ec8095692cf4d26 fd3865b0c596494993c3614374cc948b 1cfc9fba6cf344ee9ec8095692cf4d26--fd3865b0c596494993c3614374cc948b e053c275d0ba4072a67169e5c1008005 X fd3865b0c596494993c3614374cc948b--e053c275d0ba4072a67169e5c1008005 e053c275d0ba4072a67169e5c1008005--4b843a745fe541838a0720aa5c7d38ee 3099577d331c4a5794040fa98947fb7d e053c275d0ba4072a67169e5c1008005--3099577d331c4a5794040fa98947fb7d af267dc007524b5dbe7f7c261b99c5f3 3099577d331c4a5794040fa98947fb7d--af267dc007524b5dbe7f7c261b99c5f3 54ec49a1c0ad438ea81d00643e457e63 af267dc007524b5dbe7f7c261b99c5f3--54ec49a1c0ad438ea81d00643e457e63 7ea64b3b33a7434687155af85f8dbc18 X 54ec49a1c0ad438ea81d00643e457e63--7ea64b3b33a7434687155af85f8dbc18 7ea64b3b33a7434687155af85f8dbc18--184f8b080d8149e69b722ce425912a15 7a7d75ea4a0b4e1389ff0d8dec3e7427 X 7ea64b3b33a7434687155af85f8dbc18--7a7d75ea4a0b4e1389ff0d8dec3e7427 7a7d75ea4a0b4e1389ff0d8dec3e7427--66d9ec4a099443b99a56eb514a6e6dcd c2a751384ed14f60892a26f8ddddc341 7a7d75ea4a0b4e1389ff0d8dec3e7427--c2a751384ed14f60892a26f8ddddc341 477f569829394ce2b79c8264b017ecef c2a751384ed14f60892a26f8ddddc341--477f569829394ce2b79c8264b017ecef 7b547424ba6f4dd9abf9c8491b2cffa9 477f569829394ce2b79c8264b017ecef--7b547424ba6f4dd9abf9c8491b2cffa9 faffd2ef77da41cf8bf5643291ef62b7 7b547424ba6f4dd9abf9c8491b2cffa9--faffd2ef77da41cf8bf5643291ef62b7 62f5a1e18bfc4870a0f76dea41d99e41 faffd2ef77da41cf8bf5643291ef62b7--62f5a1e18bfc4870a0f76dea41d99e41 7a9d13a21bdb44b08305b92c8049f85d X 62f5a1e18bfc4870a0f76dea41d99e41--7a9d13a21bdb44b08305b92c8049f85d 7a9d13a21bdb44b08305b92c8049f85d--017da00959ec4980a8b3b8852f852ce0 4a711a88d80f4bfba411109bd135422c 7a9d13a21bdb44b08305b92c8049f85d--4a711a88d80f4bfba411109bd135422c 91dfb5320a2e4184ba38faa7eaeb206f 4a711a88d80f4bfba411109bd135422c--91dfb5320a2e4184ba38faa7eaeb206f 1bfba4b8d8bb404097a643631ab56300 91dfb5320a2e4184ba38faa7eaeb206f--1bfba4b8d8bb404097a643631ab56300 49808bdbb7ac46ffb3b6c38668fac631 1bfba4b8d8bb404097a643631ab56300--49808bdbb7ac46ffb3b6c38668fac631 2a0888e5b13447838324b9e37de8c856 49808bdbb7ac46ffb3b6c38668fac631--2a0888e5b13447838324b9e37de8c856 c5767d7bfa4b4771aaf310dbd3dffa1f 2a0888e5b13447838324b9e37de8c856--c5767d7bfa4b4771aaf310dbd3dffa1f 98ee8f43c7a945cb87ef36f0f8ce4df6 c5767d7bfa4b4771aaf310dbd3dffa1f--98ee8f43c7a945cb87ef36f0f8ce4df6 5fd3726044584736b6b5ab4f30ede9be 98ee8f43c7a945cb87ef36f0f8ce4df6--5fd3726044584736b6b5ab4f30ede9be 0b0ca9862bf5452e8c8b46b3b9ac0ffb 5fd3726044584736b6b5ab4f30ede9be--0b0ca9862bf5452e8c8b46b3b9ac0ffb 62fc9febacbb40ed80a784a6e27d5dfc 0b0ca9862bf5452e8c8b46b3b9ac0ffb--62fc9febacbb40ed80a784a6e27d5dfc 98db86b9050242c4bad7321b7964577a RX(b14) 62fc9febacbb40ed80a784a6e27d5dfc--98db86b9050242c4bad7321b7964577a 98db86b9050242c4bad7321b7964577a--44ea356f5bc940aba501690d74ebc287 f0861a976904469c846ddb8f11c5fc06 3608fc2d1a764f2dbeea1710b6227d7f 769f8c1b7c8d471382a86153b331b2e6--3608fc2d1a764f2dbeea1710b6227d7f e89b2789a8cb40b296790f30bf4acde8 6 b20d8a97fba145918437a3821d1e132b 3608fc2d1a764f2dbeea1710b6227d7f--b20d8a97fba145918437a3821d1e132b ea8fc170f2c745fcadec9803f8ffe3b8 b20d8a97fba145918437a3821d1e132b--ea8fc170f2c745fcadec9803f8ffe3b8 5ac67c5620cd4131b8865a0b6abf6832 ea8fc170f2c745fcadec9803f8ffe3b8--5ac67c5620cd4131b8865a0b6abf6832 f21467e4a37e4da89ec4ee0c2dd7941b X 5ac67c5620cd4131b8865a0b6abf6832--f21467e4a37e4da89ec4ee0c2dd7941b f21467e4a37e4da89ec4ee0c2dd7941b--7d0da1de47304722a72e637f00b689b4 4d604249b49a4b89bc65740b37091407 f21467e4a37e4da89ec4ee0c2dd7941b--4d604249b49a4b89bc65740b37091407 50c0062e5f0f4dd0813e68b95db2c7e9 4d604249b49a4b89bc65740b37091407--50c0062e5f0f4dd0813e68b95db2c7e9 22588b71772647fa8baaec1b1f07a654 50c0062e5f0f4dd0813e68b95db2c7e9--22588b71772647fa8baaec1b1f07a654 f21c077a2804412d91810cc14dfb6f1b 22588b71772647fa8baaec1b1f07a654--f21c077a2804412d91810cc14dfb6f1b 5aa4659175794024bfa1572092a7c354 f21c077a2804412d91810cc14dfb6f1b--5aa4659175794024bfa1572092a7c354 a69a1334aff94db0aa0b7a4fcb3d8814 X 5aa4659175794024bfa1572092a7c354--a69a1334aff94db0aa0b7a4fcb3d8814 a69a1334aff94db0aa0b7a4fcb3d8814--f0766c83dba84668b83806937d635b39 6470b84b475045bc8b2f87a761958989 a69a1334aff94db0aa0b7a4fcb3d8814--6470b84b475045bc8b2f87a761958989 49e94f9dbf274d8fb0529eb2fde907c5 6470b84b475045bc8b2f87a761958989--49e94f9dbf274d8fb0529eb2fde907c5 43accbc158fe430fb0eb73237027618d 49e94f9dbf274d8fb0529eb2fde907c5--43accbc158fe430fb0eb73237027618d 95fe9acc50dc463ba8a35718a468d2ab 43accbc158fe430fb0eb73237027618d--95fe9acc50dc463ba8a35718a468d2ab d4fe1f466c574c96a7ccd79dc0f3b722 95fe9acc50dc463ba8a35718a468d2ab--d4fe1f466c574c96a7ccd79dc0f3b722 4e06e91e0d68448790b8cfd788a5a949 d4fe1f466c574c96a7ccd79dc0f3b722--4e06e91e0d68448790b8cfd788a5a949 8894c8fd6b4d45fab126ca00b4ed8159 4e06e91e0d68448790b8cfd788a5a949--8894c8fd6b4d45fab126ca00b4ed8159 8c0dba62847341d9ab1c79a64d2cb16d 8894c8fd6b4d45fab126ca00b4ed8159--8c0dba62847341d9ab1c79a64d2cb16d 8b069cd43be54fa0abad9221a9379246 8c0dba62847341d9ab1c79a64d2cb16d--8b069cd43be54fa0abad9221a9379246 fd8899f8475b4f57b4eb111918718877 8b069cd43be54fa0abad9221a9379246--fd8899f8475b4f57b4eb111918718877 fe8f7bfa655946f2be9cb47241d72392 fd8899f8475b4f57b4eb111918718877--fe8f7bfa655946f2be9cb47241d72392 1c784e2daba941189b19f5d4646cd492 fe8f7bfa655946f2be9cb47241d72392--1c784e2daba941189b19f5d4646cd492 457b40c50e7c4c74ace7fad33ac6d63f 1c784e2daba941189b19f5d4646cd492--457b40c50e7c4c74ace7fad33ac6d63f 54dc2c539f4a4a348d643dc4e2d4c7a3 457b40c50e7c4c74ace7fad33ac6d63f--54dc2c539f4a4a348d643dc4e2d4c7a3 a1d33833a9c345ac9c2ae7504463d860 54dc2c539f4a4a348d643dc4e2d4c7a3--a1d33833a9c345ac9c2ae7504463d860 3eb5fa7b805e4c9b8baf58b5dbda3aab a1d33833a9c345ac9c2ae7504463d860--3eb5fa7b805e4c9b8baf58b5dbda3aab 260df7ab647a44f0abb4884177c5e5cd 3eb5fa7b805e4c9b8baf58b5dbda3aab--260df7ab647a44f0abb4884177c5e5cd 973ae68eb99d4635af4cb6e5ffcc3aae 260df7ab647a44f0abb4884177c5e5cd--973ae68eb99d4635af4cb6e5ffcc3aae 0eb3d92ea0124b38a6c345c3c9def448 973ae68eb99d4635af4cb6e5ffcc3aae--0eb3d92ea0124b38a6c345c3c9def448 19e2fd294c3c4b29bef9f06b45124287 0eb3d92ea0124b38a6c345c3c9def448--19e2fd294c3c4b29bef9f06b45124287 70a489fc1ddf4f55a556d3f702f0c048 19e2fd294c3c4b29bef9f06b45124287--70a489fc1ddf4f55a556d3f702f0c048 0c7903a8073e4966bbe2a7c1a6f54f0e 70a489fc1ddf4f55a556d3f702f0c048--0c7903a8073e4966bbe2a7c1a6f54f0e ede56de18dda45b3925b8fed7870702f 0c7903a8073e4966bbe2a7c1a6f54f0e--ede56de18dda45b3925b8fed7870702f 4dde83bb3ff74901abddcd487f426636 ede56de18dda45b3925b8fed7870702f--4dde83bb3ff74901abddcd487f426636 afdb6ae83d1e40168bf35653a666da10 4dde83bb3ff74901abddcd487f426636--afdb6ae83d1e40168bf35653a666da10 d1866d87c300462bb9b45b4239a9d3be afdb6ae83d1e40168bf35653a666da10--d1866d87c300462bb9b45b4239a9d3be 139f5515c6c14798883f241eca513d84 d1866d87c300462bb9b45b4239a9d3be--139f5515c6c14798883f241eca513d84 45836d3960b94043abab865953162939 139f5515c6c14798883f241eca513d84--45836d3960b94043abab865953162939 3a459386dc714c0aabeff62e043a13de 45836d3960b94043abab865953162939--3a459386dc714c0aabeff62e043a13de 62d68a97bd674993b976ca45ea7b8b75 X 3a459386dc714c0aabeff62e043a13de--62d68a97bd674993b976ca45ea7b8b75 62d68a97bd674993b976ca45ea7b8b75--88aaabab8ef044938f505faa362ec00c 84dd88a9e91942d0bbf54ea89405927d 62d68a97bd674993b976ca45ea7b8b75--84dd88a9e91942d0bbf54ea89405927d fe62ac593be24839a4555e8cd41bd1ac 84dd88a9e91942d0bbf54ea89405927d--fe62ac593be24839a4555e8cd41bd1ac 29ab9c857ecf4653ac39b7be2dac45ff fe62ac593be24839a4555e8cd41bd1ac--29ab9c857ecf4653ac39b7be2dac45ff 5ee1993a5fe24691aa81cf4dd3434ddd X 29ab9c857ecf4653ac39b7be2dac45ff--5ee1993a5fe24691aa81cf4dd3434ddd 5ee1993a5fe24691aa81cf4dd3434ddd--d22067144bc747f396c6c0d9e84cb3ad 06727f08a3c047328da3b3930e1e161c 5ee1993a5fe24691aa81cf4dd3434ddd--06727f08a3c047328da3b3930e1e161c 012a463ec8024ca6b19f69cba2c7a553 06727f08a3c047328da3b3930e1e161c--012a463ec8024ca6b19f69cba2c7a553 dba882c123f9472a92f3acc8668b4217 012a463ec8024ca6b19f69cba2c7a553--dba882c123f9472a92f3acc8668b4217 dbb6f8473d004f69992d012861a70b1b dba882c123f9472a92f3acc8668b4217--dbb6f8473d004f69992d012861a70b1b 213a5e8181fe4830880101ce1b9c1a43 dbb6f8473d004f69992d012861a70b1b--213a5e8181fe4830880101ce1b9c1a43 d8247826afbe405fbc7a176bdd30b7f9 213a5e8181fe4830880101ce1b9c1a43--d8247826afbe405fbc7a176bdd30b7f9 1a900dffd45948b0968ad64a61923f73 d8247826afbe405fbc7a176bdd30b7f9--1a900dffd45948b0968ad64a61923f73 2a88487324004529a6f146f7d18b2697 1a900dffd45948b0968ad64a61923f73--2a88487324004529a6f146f7d18b2697 320d8cdb77834b17b741b8db8965696a 2a88487324004529a6f146f7d18b2697--320d8cdb77834b17b741b8db8965696a 99fe313881ef4d8e987ddcd25cb44ad7 320d8cdb77834b17b741b8db8965696a--99fe313881ef4d8e987ddcd25cb44ad7 ffdb00dc63b04fc08e3b28fffc046265 99fe313881ef4d8e987ddcd25cb44ad7--ffdb00dc63b04fc08e3b28fffc046265 098f053fba9f4baf9b309f6e15bc3b28 ffdb00dc63b04fc08e3b28fffc046265--098f053fba9f4baf9b309f6e15bc3b28 8db502851c254db7b4183a0806ae420b 098f053fba9f4baf9b309f6e15bc3b28--8db502851c254db7b4183a0806ae420b 90024cd042204232bc09ebbcce17fc12 8db502851c254db7b4183a0806ae420b--90024cd042204232bc09ebbcce17fc12 75dcf4f626824c7ab05325c60a3c8c7d 90024cd042204232bc09ebbcce17fc12--75dcf4f626824c7ab05325c60a3c8c7d 594fe726267a4e8588efeb93d6e1d81f 75dcf4f626824c7ab05325c60a3c8c7d--594fe726267a4e8588efeb93d6e1d81f f55b03ba410e4624b6c338df6f69d072 594fe726267a4e8588efeb93d6e1d81f--f55b03ba410e4624b6c338df6f69d072 2831985e64f444ae8a11c873c1c508f3 f55b03ba410e4624b6c338df6f69d072--2831985e64f444ae8a11c873c1c508f3 ef09acb92f1a473c8e02406cd42e27ed 2831985e64f444ae8a11c873c1c508f3--ef09acb92f1a473c8e02406cd42e27ed 05b8c0f806374e54ba459d70185ce5c8 ef09acb92f1a473c8e02406cd42e27ed--05b8c0f806374e54ba459d70185ce5c8 fee62662061f4729b0d68ea5ee713cb5 05b8c0f806374e54ba459d70185ce5c8--fee62662061f4729b0d68ea5ee713cb5 b0201972ee4b416ab390556d07a2fc0f fee62662061f4729b0d68ea5ee713cb5--b0201972ee4b416ab390556d07a2fc0f 6ac8d8fda1434e4db61476a5d09bcb35 X b0201972ee4b416ab390556d07a2fc0f--6ac8d8fda1434e4db61476a5d09bcb35 6ac8d8fda1434e4db61476a5d09bcb35--510ef5adc41d4c1e94ba7f33db858ba6 d09af885142f4c3b8ba87d4007bd0560 RZ(-1.0*g0) 6ac8d8fda1434e4db61476a5d09bcb35--d09af885142f4c3b8ba87d4007bd0560 4f214e153697441f83c4c592cd68829d X d09af885142f4c3b8ba87d4007bd0560--4f214e153697441f83c4c592cd68829d 4f214e153697441f83c4c592cd68829d--65f2621118bd4b4a865bdebc5f7cbd90 4256ca62f270431c8b8a0a0b67ecff39 4f214e153697441f83c4c592cd68829d--4256ca62f270431c8b8a0a0b67ecff39 69745f8d115e45d490a8d7bc485416ef 4256ca62f270431c8b8a0a0b67ecff39--69745f8d115e45d490a8d7bc485416ef d37c91c78a4243c584788e226d3d752a 69745f8d115e45d490a8d7bc485416ef--d37c91c78a4243c584788e226d3d752a 65ae5508133b433598398565f1d45805 d37c91c78a4243c584788e226d3d752a--65ae5508133b433598398565f1d45805 4647f8a297a5410c9ef65b46510fc8f7 65ae5508133b433598398565f1d45805--4647f8a297a5410c9ef65b46510fc8f7 9520deae424a435eb69c05c469225469 4647f8a297a5410c9ef65b46510fc8f7--9520deae424a435eb69c05c469225469 3f52808181074eff9b717a071d5914f4 X 9520deae424a435eb69c05c469225469--3f52808181074eff9b717a071d5914f4 3f52808181074eff9b717a071d5914f4--f03848e0ae0a492aacb6b72026f1dc8f 0837a32c7b064059bb14485d30503d21 3f52808181074eff9b717a071d5914f4--0837a32c7b064059bb14485d30503d21 3952c3928cad40238746553210e7d7e6 0837a32c7b064059bb14485d30503d21--3952c3928cad40238746553210e7d7e6 832ef333682e441687480249b7e371da 3952c3928cad40238746553210e7d7e6--832ef333682e441687480249b7e371da fb31586dbd11403d985958b2cf1104e5 X 832ef333682e441687480249b7e371da--fb31586dbd11403d985958b2cf1104e5 fb31586dbd11403d985958b2cf1104e5--fef2e0280c11454796ce3ba449e90656 66c1d110dee8450f9238a34ee210fc30 fb31586dbd11403d985958b2cf1104e5--66c1d110dee8450f9238a34ee210fc30 4e0c180f8d93435f9859bbcbee581147 66c1d110dee8450f9238a34ee210fc30--4e0c180f8d93435f9859bbcbee581147 46b9b15474ba4ae8abf2cc9c0f3111ca 4e0c180f8d93435f9859bbcbee581147--46b9b15474ba4ae8abf2cc9c0f3111ca 21ae967e481448eaba9ecd6b675c0d6f 46b9b15474ba4ae8abf2cc9c0f3111ca--21ae967e481448eaba9ecd6b675c0d6f 32ade1e29a324ed5a4f515acc4a135c2 X 21ae967e481448eaba9ecd6b675c0d6f--32ade1e29a324ed5a4f515acc4a135c2 32ade1e29a324ed5a4f515acc4a135c2--29bc29e7fd574c9686198a215cdb5b50 944195f410ea4b56a38ff0cc5d70790b RZ(-1.0*g0) 32ade1e29a324ed5a4f515acc4a135c2--944195f410ea4b56a38ff0cc5d70790b 26aaff5364784b29a195d60fb7eca379 X 944195f410ea4b56a38ff0cc5d70790b--26aaff5364784b29a195d60fb7eca379 26aaff5364784b29a195d60fb7eca379--8946b3cbb22b44139b4dcea1824dcdaa dbb776de6e9e4c93b67a9fe199f54fe5 26aaff5364784b29a195d60fb7eca379--dbb776de6e9e4c93b67a9fe199f54fe5 cea0e3016d164f4ebd5eaa362b4990ba dbb776de6e9e4c93b67a9fe199f54fe5--cea0e3016d164f4ebd5eaa362b4990ba b9f5820a791c4a91a3c8ceba70266abc X cea0e3016d164f4ebd5eaa362b4990ba--b9f5820a791c4a91a3c8ceba70266abc b9f5820a791c4a91a3c8ceba70266abc--953b9ca816514db7bac04d5ce3654f44 c05ff34f0a804427b9701535d3361248 b9f5820a791c4a91a3c8ceba70266abc--c05ff34f0a804427b9701535d3361248 0478773aa17748d094bce769ea1c8e03 c05ff34f0a804427b9701535d3361248--0478773aa17748d094bce769ea1c8e03 5d3d5c1b2f9241e09826d0d3409b7a6a 0478773aa17748d094bce769ea1c8e03--5d3d5c1b2f9241e09826d0d3409b7a6a 6647b5b1df0a48c59c1841eb63744c4e X 5d3d5c1b2f9241e09826d0d3409b7a6a--6647b5b1df0a48c59c1841eb63744c4e 6647b5b1df0a48c59c1841eb63744c4e--70650a4b31e74169a915b410786d7924 1fd5751c97114612a978acb8be262bcd 6647b5b1df0a48c59c1841eb63744c4e--1fd5751c97114612a978acb8be262bcd 9289efa3f97c41968a42c6ba7f1b1423 X 1fd5751c97114612a978acb8be262bcd--9289efa3f97c41968a42c6ba7f1b1423 9289efa3f97c41968a42c6ba7f1b1423--e38fa421322f4f7fba33b408cbfb7959 d4a6ef939a5d442fa98370efcba0234b 9289efa3f97c41968a42c6ba7f1b1423--d4a6ef939a5d442fa98370efcba0234b 963c1fc3da1544df86662fc99ebd6ee5 d4a6ef939a5d442fa98370efcba0234b--963c1fc3da1544df86662fc99ebd6ee5 b231c07dd7e1449aa475c2a6e95ee932 963c1fc3da1544df86662fc99ebd6ee5--b231c07dd7e1449aa475c2a6e95ee932 448482aac6b14a4da1dc2d9b73561eb9 b231c07dd7e1449aa475c2a6e95ee932--448482aac6b14a4da1dc2d9b73561eb9 df63500017314e36b040ae2c54610de7 448482aac6b14a4da1dc2d9b73561eb9--df63500017314e36b040ae2c54610de7 ec3233db43cf4e0c9d3eff850aa60315 X df63500017314e36b040ae2c54610de7--ec3233db43cf4e0c9d3eff850aa60315 ec3233db43cf4e0c9d3eff850aa60315--b3b49c051ff64097bd563b23b1c03cc7 68a626485e3140c083181c725cf66280 ec3233db43cf4e0c9d3eff850aa60315--68a626485e3140c083181c725cf66280 6bb0d8940db94db09dd5b3696c590e42 68a626485e3140c083181c725cf66280--6bb0d8940db94db09dd5b3696c590e42 3ba5d4725ce84c889d2cd1b66862ac63 6bb0d8940db94db09dd5b3696c590e42--3ba5d4725ce84c889d2cd1b66862ac63 cf116038691346e78256ddd02389a9c0 RX(b05) 3ba5d4725ce84c889d2cd1b66862ac63--cf116038691346e78256ddd02389a9c0 bd1b6d6913be4b469c5e9c81de8880fb cf116038691346e78256ddd02389a9c0--bd1b6d6913be4b469c5e9c81de8880fb b97397d0eed84b82830104312068db2a bd1b6d6913be4b469c5e9c81de8880fb--b97397d0eed84b82830104312068db2a 92c65fe1f6a4493fa9f14449b8283c9e b97397d0eed84b82830104312068db2a--92c65fe1f6a4493fa9f14449b8283c9e eb785c89e1464d3f908271324eda7712 92c65fe1f6a4493fa9f14449b8283c9e--eb785c89e1464d3f908271324eda7712 9d0c0d722d654616852cfad1c7131b3a X eb785c89e1464d3f908271324eda7712--9d0c0d722d654616852cfad1c7131b3a 9d0c0d722d654616852cfad1c7131b3a--34f3fc9d474a47968af11c1ea6d4fa18 ec478709fc8a4158822e7ce81b2ee415 9d0c0d722d654616852cfad1c7131b3a--ec478709fc8a4158822e7ce81b2ee415 59cbbaabb51544d5a2377aa31d6fabf7 ec478709fc8a4158822e7ce81b2ee415--59cbbaabb51544d5a2377aa31d6fabf7 a97423e51d434ea08de18fd8c6a80a21 59cbbaabb51544d5a2377aa31d6fabf7--a97423e51d434ea08de18fd8c6a80a21 9573bc30391a463083abcd10113e22c1 a97423e51d434ea08de18fd8c6a80a21--9573bc30391a463083abcd10113e22c1 b200061dbf0f4004bff75cb18a86a27d 9573bc30391a463083abcd10113e22c1--b200061dbf0f4004bff75cb18a86a27d f57c0e5b6a194e2d920659bf9ee49d2c X b200061dbf0f4004bff75cb18a86a27d--f57c0e5b6a194e2d920659bf9ee49d2c f57c0e5b6a194e2d920659bf9ee49d2c--ae6509ec3a204a6e9fd90d9353d5138f b61b123ebb0741f89ea0f87460a186a9 f57c0e5b6a194e2d920659bf9ee49d2c--b61b123ebb0741f89ea0f87460a186a9 b4a39352bf354453a36d1818084659bc b61b123ebb0741f89ea0f87460a186a9--b4a39352bf354453a36d1818084659bc d013b5cf4fb94d9989bfe13e683413ba b4a39352bf354453a36d1818084659bc--d013b5cf4fb94d9989bfe13e683413ba 9fff46841b194069988be775ef9afea2 d013b5cf4fb94d9989bfe13e683413ba--9fff46841b194069988be775ef9afea2 853a4faab7ef4715b3709413554892e2 9fff46841b194069988be775ef9afea2--853a4faab7ef4715b3709413554892e2 9142ffa1fba84b6492465de1656d4b18 853a4faab7ef4715b3709413554892e2--9142ffa1fba84b6492465de1656d4b18 18032a87b0ab48fd945c3729ac8cc454 9142ffa1fba84b6492465de1656d4b18--18032a87b0ab48fd945c3729ac8cc454 ddeb729d39f44bf0b1eed636b48fd430 18032a87b0ab48fd945c3729ac8cc454--ddeb729d39f44bf0b1eed636b48fd430 636459ac7c8e4e10992c60d0f8e8d887 ddeb729d39f44bf0b1eed636b48fd430--636459ac7c8e4e10992c60d0f8e8d887 5849c538548d40c4800c71541c8eb467 636459ac7c8e4e10992c60d0f8e8d887--5849c538548d40c4800c71541c8eb467 d8128b12a8cb41e891ef05917dd79738 5849c538548d40c4800c71541c8eb467--d8128b12a8cb41e891ef05917dd79738 e9e37cb6016d4fd19fc91b4a6b97798b d8128b12a8cb41e891ef05917dd79738--e9e37cb6016d4fd19fc91b4a6b97798b 78c67f1bf3b24d2ba72e2aaa29a311ea e9e37cb6016d4fd19fc91b4a6b97798b--78c67f1bf3b24d2ba72e2aaa29a311ea 8b45f2e4ad2a42f294dcb95915e1f3ad 78c67f1bf3b24d2ba72e2aaa29a311ea--8b45f2e4ad2a42f294dcb95915e1f3ad 82faa4b466c74479b7aaaa9f22f1d7b0 8b45f2e4ad2a42f294dcb95915e1f3ad--82faa4b466c74479b7aaaa9f22f1d7b0 60bb7a9e753247ab9e8de737535ad00e 82faa4b466c74479b7aaaa9f22f1d7b0--60bb7a9e753247ab9e8de737535ad00e d9afd0d368be4361b9f3ffceac7a0f01 60bb7a9e753247ab9e8de737535ad00e--d9afd0d368be4361b9f3ffceac7a0f01 46efc3fe976843e6b443bf9e2ef9834a d9afd0d368be4361b9f3ffceac7a0f01--46efc3fe976843e6b443bf9e2ef9834a 2a132692d79f47658c2f1f64ef98b165 46efc3fe976843e6b443bf9e2ef9834a--2a132692d79f47658c2f1f64ef98b165 35e44469c4274fe1ae9a51b4272e4da8 2a132692d79f47658c2f1f64ef98b165--35e44469c4274fe1ae9a51b4272e4da8 9d9a0c358d4246a6b32ffcd7f1377598 35e44469c4274fe1ae9a51b4272e4da8--9d9a0c358d4246a6b32ffcd7f1377598 869d0e38cd804a21a5be56098935c57e 9d9a0c358d4246a6b32ffcd7f1377598--869d0e38cd804a21a5be56098935c57e 239ecddddd734004bf86096847a6b222 869d0e38cd804a21a5be56098935c57e--239ecddddd734004bf86096847a6b222 80c57c5062604f24978a18402293e86d 239ecddddd734004bf86096847a6b222--80c57c5062604f24978a18402293e86d 3b5d2d41b9944a39a119b636459ecf96 80c57c5062604f24978a18402293e86d--3b5d2d41b9944a39a119b636459ecf96 e703a36dd7b445fa962f61e22bd27963 3b5d2d41b9944a39a119b636459ecf96--e703a36dd7b445fa962f61e22bd27963 3c4e191a6ef34bb38e061b1b13ab2d88 e703a36dd7b445fa962f61e22bd27963--3c4e191a6ef34bb38e061b1b13ab2d88 9476689e85c04078be2b0b8e3d7ccdb2 3c4e191a6ef34bb38e061b1b13ab2d88--9476689e85c04078be2b0b8e3d7ccdb2 2e92588d1f7b4c66825700e565ed4162 9476689e85c04078be2b0b8e3d7ccdb2--2e92588d1f7b4c66825700e565ed4162 794124030a214eeea5065a4d2acad017 X 2e92588d1f7b4c66825700e565ed4162--794124030a214eeea5065a4d2acad017 794124030a214eeea5065a4d2acad017--04a03c666f89458c951bc00234b1aafe 4dbefa8b436847b2972ee35a3cdaae73 794124030a214eeea5065a4d2acad017--4dbefa8b436847b2972ee35a3cdaae73 0b13cb333c14474793c1f46c4f59abb8 4dbefa8b436847b2972ee35a3cdaae73--0b13cb333c14474793c1f46c4f59abb8 7870d1112d2a4a88824e86a3c89e6964 0b13cb333c14474793c1f46c4f59abb8--7870d1112d2a4a88824e86a3c89e6964 15ed70bc2e814fd3b6a674751ecb8c11 X 7870d1112d2a4a88824e86a3c89e6964--15ed70bc2e814fd3b6a674751ecb8c11 15ed70bc2e814fd3b6a674751ecb8c11--9502cc39a00d45f78c659cd8474c58bd b8a1b43c859046f7b946404d6bad346c 15ed70bc2e814fd3b6a674751ecb8c11--b8a1b43c859046f7b946404d6bad346c fb3ab8ea49d445a0bafdf1f2bdd67261 b8a1b43c859046f7b946404d6bad346c--fb3ab8ea49d445a0bafdf1f2bdd67261 13e0a75b4ddf40e787bd82a3d189f864 fb3ab8ea49d445a0bafdf1f2bdd67261--13e0a75b4ddf40e787bd82a3d189f864 713f5a44a0d043a9b4ed3374702df980 13e0a75b4ddf40e787bd82a3d189f864--713f5a44a0d043a9b4ed3374702df980 d3c5d9ffb2e94ea2a0f140848c9626f0 713f5a44a0d043a9b4ed3374702df980--d3c5d9ffb2e94ea2a0f140848c9626f0 8707899cac064eb7874aaa798f8d1b62 d3c5d9ffb2e94ea2a0f140848c9626f0--8707899cac064eb7874aaa798f8d1b62 1a6ff74f89684a909f4f85230c8e4ac8 8707899cac064eb7874aaa798f8d1b62--1a6ff74f89684a909f4f85230c8e4ac8 4be4b2a9485f4771b338a93b2a15bb8e 1a6ff74f89684a909f4f85230c8e4ac8--4be4b2a9485f4771b338a93b2a15bb8e c7d4b0a9bb9d46e1afaa942726f2613f 4be4b2a9485f4771b338a93b2a15bb8e--c7d4b0a9bb9d46e1afaa942726f2613f fb94cd47b1c14ff3a7d5900d15a0a6e2 c7d4b0a9bb9d46e1afaa942726f2613f--fb94cd47b1c14ff3a7d5900d15a0a6e2 ae1b9b37a4d243f5b88fd18579d4d2b4 fb94cd47b1c14ff3a7d5900d15a0a6e2--ae1b9b37a4d243f5b88fd18579d4d2b4 671bd6bcde89449799535230221053db ae1b9b37a4d243f5b88fd18579d4d2b4--671bd6bcde89449799535230221053db 1688082d6f374f14bc5fb2dc1e2de1b7 671bd6bcde89449799535230221053db--1688082d6f374f14bc5fb2dc1e2de1b7 7d8531ad6b17445297706b9cff0ec7f1 1688082d6f374f14bc5fb2dc1e2de1b7--7d8531ad6b17445297706b9cff0ec7f1 c4abc1f2de8341a498454d502fb19e99 7d8531ad6b17445297706b9cff0ec7f1--c4abc1f2de8341a498454d502fb19e99 440ed0ad550349df8ff3771bc1e644af c4abc1f2de8341a498454d502fb19e99--440ed0ad550349df8ff3771bc1e644af 447b2aa9071647fa9d41834ba6aab8c1 440ed0ad550349df8ff3771bc1e644af--447b2aa9071647fa9d41834ba6aab8c1 eab7588a2e2343019b8828325e11423a 447b2aa9071647fa9d41834ba6aab8c1--eab7588a2e2343019b8828325e11423a 3c09839d91e649238c6895c6b8f6114e eab7588a2e2343019b8828325e11423a--3c09839d91e649238c6895c6b8f6114e 1a566fad4fbf495d94a0b8ffe15356f9 3c09839d91e649238c6895c6b8f6114e--1a566fad4fbf495d94a0b8ffe15356f9 51d084543bee491088b34805f0fed923 1a566fad4fbf495d94a0b8ffe15356f9--51d084543bee491088b34805f0fed923 3fd43d9f7a694a5690fdcf7cc696346c 51d084543bee491088b34805f0fed923--3fd43d9f7a694a5690fdcf7cc696346c 224b4523ac5e4960b2bfb903603f430a X 3fd43d9f7a694a5690fdcf7cc696346c--224b4523ac5e4960b2bfb903603f430a 224b4523ac5e4960b2bfb903603f430a--77a7105456984dc58e16bb288cccffb8 a0d5a7652439457dafc1b46447f06dc4 RZ(-1.0*g1) 224b4523ac5e4960b2bfb903603f430a--a0d5a7652439457dafc1b46447f06dc4 c0215a8428ec423a9612ce3657a28680 X a0d5a7652439457dafc1b46447f06dc4--c0215a8428ec423a9612ce3657a28680 c0215a8428ec423a9612ce3657a28680--151ba5553ffb4f96b6e2579b9b3e600b 1344855714b8452c95a21f7a033a4161 c0215a8428ec423a9612ce3657a28680--1344855714b8452c95a21f7a033a4161 90ce3a7826174b3ca8540714c32c8cfe 1344855714b8452c95a21f7a033a4161--90ce3a7826174b3ca8540714c32c8cfe a00dcaebf1b14efcb6578458ad5c0528 90ce3a7826174b3ca8540714c32c8cfe--a00dcaebf1b14efcb6578458ad5c0528 bf104eb96af24cb1872b496bb9b4a1ec a00dcaebf1b14efcb6578458ad5c0528--bf104eb96af24cb1872b496bb9b4a1ec 74e35bf614034d35aec9714b2c1943e5 bf104eb96af24cb1872b496bb9b4a1ec--74e35bf614034d35aec9714b2c1943e5 2114b890e0b3483c8232e8895d3093c6 74e35bf614034d35aec9714b2c1943e5--2114b890e0b3483c8232e8895d3093c6 108c27a5ea66418eb669dc90d1354f4d X 2114b890e0b3483c8232e8895d3093c6--108c27a5ea66418eb669dc90d1354f4d 108c27a5ea66418eb669dc90d1354f4d--243e5ee2c6684a1ea6975a991d13624b 6e5df0ae708744909014ae694595295b 108c27a5ea66418eb669dc90d1354f4d--6e5df0ae708744909014ae694595295b 9a88af41efca45a4925eef7fbbcda303 6e5df0ae708744909014ae694595295b--9a88af41efca45a4925eef7fbbcda303 5bb75366dd4f47e5960825c8492134bf 9a88af41efca45a4925eef7fbbcda303--5bb75366dd4f47e5960825c8492134bf ec48b559d66f455e9b96d4eea9cf05c6 X 5bb75366dd4f47e5960825c8492134bf--ec48b559d66f455e9b96d4eea9cf05c6 ec48b559d66f455e9b96d4eea9cf05c6--db802e81be134feabb71550bdffbb91a 8f481d6e561240c789e3e1541477491a ec48b559d66f455e9b96d4eea9cf05c6--8f481d6e561240c789e3e1541477491a c4ebc64e6ece427b809bd8fddef7525a 8f481d6e561240c789e3e1541477491a--c4ebc64e6ece427b809bd8fddef7525a 158c1c88398645f58efac317180121bc c4ebc64e6ece427b809bd8fddef7525a--158c1c88398645f58efac317180121bc d46726107248414da385d6feb375de27 158c1c88398645f58efac317180121bc--d46726107248414da385d6feb375de27 a444b61da0024e56bccebb4bcf8e2efb X d46726107248414da385d6feb375de27--a444b61da0024e56bccebb4bcf8e2efb a444b61da0024e56bccebb4bcf8e2efb--3099577d331c4a5794040fa98947fb7d bdfe764f46204e77a0ab442e553331d7 RZ(-1.0*g1) a444b61da0024e56bccebb4bcf8e2efb--bdfe764f46204e77a0ab442e553331d7 c150bec3a84e467ab7ee8571af7d24a0 X bdfe764f46204e77a0ab442e553331d7--c150bec3a84e467ab7ee8571af7d24a0 c150bec3a84e467ab7ee8571af7d24a0--54ec49a1c0ad438ea81d00643e457e63 f20077c63eb146159b7e0ce879227647 c150bec3a84e467ab7ee8571af7d24a0--f20077c63eb146159b7e0ce879227647 c3f375c12f37446e9d5eefed8e8b7cba f20077c63eb146159b7e0ce879227647--c3f375c12f37446e9d5eefed8e8b7cba 602eba9b54dd46d2929f8cdd6c581ce8 X c3f375c12f37446e9d5eefed8e8b7cba--602eba9b54dd46d2929f8cdd6c581ce8 602eba9b54dd46d2929f8cdd6c581ce8--c2a751384ed14f60892a26f8ddddc341 be6911cedb6c4cfd83fdb9143d1abc83 602eba9b54dd46d2929f8cdd6c581ce8--be6911cedb6c4cfd83fdb9143d1abc83 6b015b02d8464dfa994c8b0ca132de7c be6911cedb6c4cfd83fdb9143d1abc83--6b015b02d8464dfa994c8b0ca132de7c ed72e9706c8b4e22a722f3bab13c68c3 6b015b02d8464dfa994c8b0ca132de7c--ed72e9706c8b4e22a722f3bab13c68c3 e75d9efe757f4c288a8047648a4b0984 X ed72e9706c8b4e22a722f3bab13c68c3--e75d9efe757f4c288a8047648a4b0984 e75d9efe757f4c288a8047648a4b0984--62f5a1e18bfc4870a0f76dea41d99e41 457dfa8d5f97478b830e7c8a6ae2c1c7 e75d9efe757f4c288a8047648a4b0984--457dfa8d5f97478b830e7c8a6ae2c1c7 76dcd47b36e640fb99ca190e672479bd X 457dfa8d5f97478b830e7c8a6ae2c1c7--76dcd47b36e640fb99ca190e672479bd 76dcd47b36e640fb99ca190e672479bd--4a711a88d80f4bfba411109bd135422c 96de067859a54aceb02df215579693bc 76dcd47b36e640fb99ca190e672479bd--96de067859a54aceb02df215579693bc 251d7cc5aac940088f682fc911047fec 96de067859a54aceb02df215579693bc--251d7cc5aac940088f682fc911047fec ffad73744285422284220fd95f7512d9 251d7cc5aac940088f682fc911047fec--ffad73744285422284220fd95f7512d9 d06849392bed4d799968a956a0eea7f0 ffad73744285422284220fd95f7512d9--d06849392bed4d799968a956a0eea7f0 6cb6067456934a738503f51f2b9c4823 d06849392bed4d799968a956a0eea7f0--6cb6067456934a738503f51f2b9c4823 89c6f05268884796a6d5fedf5ed3b65c X 6cb6067456934a738503f51f2b9c4823--89c6f05268884796a6d5fedf5ed3b65c 89c6f05268884796a6d5fedf5ed3b65c--98ee8f43c7a945cb87ef36f0f8ce4df6 62f23973a9e14bf9bac01dfdba4406bc 89c6f05268884796a6d5fedf5ed3b65c--62f23973a9e14bf9bac01dfdba4406bc 0349eef5a1934a368962bd85972bd669 62f23973a9e14bf9bac01dfdba4406bc--0349eef5a1934a368962bd85972bd669 b61eb3d1432145b39ed1f710bdcde245 0349eef5a1934a368962bd85972bd669--b61eb3d1432145b39ed1f710bdcde245 0852d50d0a8c4003b46c0dde3628789e RX(b15) b61eb3d1432145b39ed1f710bdcde245--0852d50d0a8c4003b46c0dde3628789e 0852d50d0a8c4003b46c0dde3628789e--f0861a976904469c846ddb8f11c5fc06 5a2fee1da62442d99e8aa2f0cf07534f 4ee61a27debf43de9d526320d01af2a6 e89b2789a8cb40b296790f30bf4acde8--4ee61a27debf43de9d526320d01af2a6 0a900ac1369d4916bc481d6d917e6d86 7 bfc00998f7f040f2941221921be72d2d 4ee61a27debf43de9d526320d01af2a6--bfc00998f7f040f2941221921be72d2d 22a04f5fd02c4171be229d47d0d0a1eb bfc00998f7f040f2941221921be72d2d--22a04f5fd02c4171be229d47d0d0a1eb 89517025b1c843b2a942791edc13ce2c 22a04f5fd02c4171be229d47d0d0a1eb--89517025b1c843b2a942791edc13ce2c e534c4f80eb845fca2e0e5879b8e4468 89517025b1c843b2a942791edc13ce2c--e534c4f80eb845fca2e0e5879b8e4468 4fecf24675a342ccbf3e4f65a307e782 X e534c4f80eb845fca2e0e5879b8e4468--4fecf24675a342ccbf3e4f65a307e782 4fecf24675a342ccbf3e4f65a307e782--4d604249b49a4b89bc65740b37091407 08938a54542545259a4f01ae05133726 4fecf24675a342ccbf3e4f65a307e782--08938a54542545259a4f01ae05133726 9091c4073ede41f2b416e22102177f63 08938a54542545259a4f01ae05133726--9091c4073ede41f2b416e22102177f63 d9b6803f4b6c4e30bd363c85ebe2e54c 9091c4073ede41f2b416e22102177f63--d9b6803f4b6c4e30bd363c85ebe2e54c 2fb031f3dddf46f98d6f51217303f46b X d9b6803f4b6c4e30bd363c85ebe2e54c--2fb031f3dddf46f98d6f51217303f46b 2fb031f3dddf46f98d6f51217303f46b--5aa4659175794024bfa1572092a7c354 023f33a374d944219a3e21e4d87b48d2 2fb031f3dddf46f98d6f51217303f46b--023f33a374d944219a3e21e4d87b48d2 ef864ae249b241b59c7acab11439364f 023f33a374d944219a3e21e4d87b48d2--ef864ae249b241b59c7acab11439364f 66e0923a5a1e485fbb4b375ab89b302a ef864ae249b241b59c7acab11439364f--66e0923a5a1e485fbb4b375ab89b302a 8c21d3acaefc425abaf48160fe963098 66e0923a5a1e485fbb4b375ab89b302a--8c21d3acaefc425abaf48160fe963098 bd048bd351c046dd98a4883c11364e9c 8c21d3acaefc425abaf48160fe963098--bd048bd351c046dd98a4883c11364e9c ab82e7f255994d839d28da8dca1f7bca bd048bd351c046dd98a4883c11364e9c--ab82e7f255994d839d28da8dca1f7bca ca12806bb1254bd58ed6ad3ad295e337 ab82e7f255994d839d28da8dca1f7bca--ca12806bb1254bd58ed6ad3ad295e337 2148768dd5a94aceb19f94953ca0e8ec ca12806bb1254bd58ed6ad3ad295e337--2148768dd5a94aceb19f94953ca0e8ec b5eec02db5954360968cd2ecc20e7904 2148768dd5a94aceb19f94953ca0e8ec--b5eec02db5954360968cd2ecc20e7904 231fbc5522734d14835f41ed32a05f23 b5eec02db5954360968cd2ecc20e7904--231fbc5522734d14835f41ed32a05f23 05cc74d88adb481991f4cf1ec303031c 231fbc5522734d14835f41ed32a05f23--05cc74d88adb481991f4cf1ec303031c 09cf8759ff814d4cacb92fe956476086 05cc74d88adb481991f4cf1ec303031c--09cf8759ff814d4cacb92fe956476086 a8fccd25dac84d02a8f8d971cc593139 09cf8759ff814d4cacb92fe956476086--a8fccd25dac84d02a8f8d971cc593139 185bc85fa4f1435da280b63230bfaddd a8fccd25dac84d02a8f8d971cc593139--185bc85fa4f1435da280b63230bfaddd fa09a78f36dc418db72054993c73c59c 185bc85fa4f1435da280b63230bfaddd--fa09a78f36dc418db72054993c73c59c 5fe567fb8e474fb7ab097d7ec2140c02 fa09a78f36dc418db72054993c73c59c--5fe567fb8e474fb7ab097d7ec2140c02 4b4a9ba6ffba4c7283ca9234c7154530 5fe567fb8e474fb7ab097d7ec2140c02--4b4a9ba6ffba4c7283ca9234c7154530 7f514ca313e44606a34175ff08d134c6 4b4a9ba6ffba4c7283ca9234c7154530--7f514ca313e44606a34175ff08d134c6 833dbc1c556e43b7936014bea2c02dee 7f514ca313e44606a34175ff08d134c6--833dbc1c556e43b7936014bea2c02dee 6752a11f1b9b4533a54a63ab0f0c093a 833dbc1c556e43b7936014bea2c02dee--6752a11f1b9b4533a54a63ab0f0c093a 620e7260f65245b5b4c581da647b5bc0 6752a11f1b9b4533a54a63ab0f0c093a--620e7260f65245b5b4c581da647b5bc0 bc29c924b19c4bc5a19d1d3cb09aa001 620e7260f65245b5b4c581da647b5bc0--bc29c924b19c4bc5a19d1d3cb09aa001 39552952ab0f4ab79b675e768eb29d20 bc29c924b19c4bc5a19d1d3cb09aa001--39552952ab0f4ab79b675e768eb29d20 4707f938960640c8a0bed6eae1fe45c3 39552952ab0f4ab79b675e768eb29d20--4707f938960640c8a0bed6eae1fe45c3 46e9d71a79af48c781506d833e35f9e6 4707f938960640c8a0bed6eae1fe45c3--46e9d71a79af48c781506d833e35f9e6 1921e2e997904f0a820791d8efea17df 46e9d71a79af48c781506d833e35f9e6--1921e2e997904f0a820791d8efea17df 3b2b704371d442fc876f28a52c8735ff 1921e2e997904f0a820791d8efea17df--3b2b704371d442fc876f28a52c8735ff d281f5d7de0641b9a2e38e4cf36d2359 3b2b704371d442fc876f28a52c8735ff--d281f5d7de0641b9a2e38e4cf36d2359 0b6c00ac60f342539d7c79d0b6c0319f d281f5d7de0641b9a2e38e4cf36d2359--0b6c00ac60f342539d7c79d0b6c0319f 6e7169c996e8469cae0da456c95cd31b 0b6c00ac60f342539d7c79d0b6c0319f--6e7169c996e8469cae0da456c95cd31b 5ad2546309ff4048b2964249e919a31a 6e7169c996e8469cae0da456c95cd31b--5ad2546309ff4048b2964249e919a31a 37de31bd8c73404dbfb45deb6aa4d906 X 5ad2546309ff4048b2964249e919a31a--37de31bd8c73404dbfb45deb6aa4d906 37de31bd8c73404dbfb45deb6aa4d906--84dd88a9e91942d0bbf54ea89405927d 5fd2e4f3f9894f21a1e819ac76c3a408 RZ(-1.0*g0) 37de31bd8c73404dbfb45deb6aa4d906--5fd2e4f3f9894f21a1e819ac76c3a408 4f59fb0691544908a70221bb001fd1d2 X 5fd2e4f3f9894f21a1e819ac76c3a408--4f59fb0691544908a70221bb001fd1d2 4f59fb0691544908a70221bb001fd1d2--29ab9c857ecf4653ac39b7be2dac45ff 59ac776298224a408178b12095811f6b 4f59fb0691544908a70221bb001fd1d2--59ac776298224a408178b12095811f6b ad1a6f75fc144f1dad598fd771eb206b 59ac776298224a408178b12095811f6b--ad1a6f75fc144f1dad598fd771eb206b c0f503000bcc4d7483267e7f79a8a6b3 ad1a6f75fc144f1dad598fd771eb206b--c0f503000bcc4d7483267e7f79a8a6b3 d7b316c7066640dcb25b036f2e0b085d c0f503000bcc4d7483267e7f79a8a6b3--d7b316c7066640dcb25b036f2e0b085d 7176262907cf427bb3220347f757049c d7b316c7066640dcb25b036f2e0b085d--7176262907cf427bb3220347f757049c 91d1113d300a4349bc8ce4d9f653f6d6 7176262907cf427bb3220347f757049c--91d1113d300a4349bc8ce4d9f653f6d6 b9acf42c1e6a4fc091832803eaf10b02 91d1113d300a4349bc8ce4d9f653f6d6--b9acf42c1e6a4fc091832803eaf10b02 0592371623ca435ca4c5e54f0beaeed6 b9acf42c1e6a4fc091832803eaf10b02--0592371623ca435ca4c5e54f0beaeed6 bd2a88a1a7684ec99c066477a9b9d458 0592371623ca435ca4c5e54f0beaeed6--bd2a88a1a7684ec99c066477a9b9d458 feba220d0c524c1e978abcdbbaf7aacc bd2a88a1a7684ec99c066477a9b9d458--feba220d0c524c1e978abcdbbaf7aacc d4e1ab7d1b8746a89f39fccf78070258 feba220d0c524c1e978abcdbbaf7aacc--d4e1ab7d1b8746a89f39fccf78070258 728fcdd2c7f3407a84f4f7ea77df15cb d4e1ab7d1b8746a89f39fccf78070258--728fcdd2c7f3407a84f4f7ea77df15cb 8fcd6d4962af4e3a9f449e7412afbd33 728fcdd2c7f3407a84f4f7ea77df15cb--8fcd6d4962af4e3a9f449e7412afbd33 a94b55d0735a48bdb01199616b7a4b1a 8fcd6d4962af4e3a9f449e7412afbd33--a94b55d0735a48bdb01199616b7a4b1a 3cdc81e9860f49a5ba2dd18214fde803 a94b55d0735a48bdb01199616b7a4b1a--3cdc81e9860f49a5ba2dd18214fde803 8f7b0827f2fc4696a8d27a4efd44110f 3cdc81e9860f49a5ba2dd18214fde803--8f7b0827f2fc4696a8d27a4efd44110f 3a34f1053d224764931195998f02c5f6 8f7b0827f2fc4696a8d27a4efd44110f--3a34f1053d224764931195998f02c5f6 a2927588bb9c435a87035380bb058f45 3a34f1053d224764931195998f02c5f6--a2927588bb9c435a87035380bb058f45 bd15b79213924624b44344d478b65023 a2927588bb9c435a87035380bb058f45--bd15b79213924624b44344d478b65023 3b9d75d127b440ec862afeecba8fe690 bd15b79213924624b44344d478b65023--3b9d75d127b440ec862afeecba8fe690 8f29c267af9d42d38e87d274103646f4 3b9d75d127b440ec862afeecba8fe690--8f29c267af9d42d38e87d274103646f4 395989d7da5a4b598e35ba399fe12216 8f29c267af9d42d38e87d274103646f4--395989d7da5a4b598e35ba399fe12216 3ea8a972d2724c118e14afaa18cf75ac 395989d7da5a4b598e35ba399fe12216--3ea8a972d2724c118e14afaa18cf75ac 66e25508242c49e8a3b227b9e4a21e9b 3ea8a972d2724c118e14afaa18cf75ac--66e25508242c49e8a3b227b9e4a21e9b 2413c8e51ea74171a07b5291746c8a80 66e25508242c49e8a3b227b9e4a21e9b--2413c8e51ea74171a07b5291746c8a80 5b27681c187d46778dc30d102fa312a4 2413c8e51ea74171a07b5291746c8a80--5b27681c187d46778dc30d102fa312a4 7222ba87c761441a8cfa2a53f03f8000 5b27681c187d46778dc30d102fa312a4--7222ba87c761441a8cfa2a53f03f8000 372341ade49841eeaa48aa2b43370a72 7222ba87c761441a8cfa2a53f03f8000--372341ade49841eeaa48aa2b43370a72 2cc441af7d8f41ddb53026c43d7422a0 372341ade49841eeaa48aa2b43370a72--2cc441af7d8f41ddb53026c43d7422a0 3a49909246b84ede8ea2bc4ce14373a9 2cc441af7d8f41ddb53026c43d7422a0--3a49909246b84ede8ea2bc4ce14373a9 5eecb2a8a24b47129856b7eceadfdf69 3a49909246b84ede8ea2bc4ce14373a9--5eecb2a8a24b47129856b7eceadfdf69 c68664699e014c1a9e20339c17552f62 5eecb2a8a24b47129856b7eceadfdf69--c68664699e014c1a9e20339c17552f62 90f5d48675c9449c8004732c22ae71ef c68664699e014c1a9e20339c17552f62--90f5d48675c9449c8004732c22ae71ef 38a0650f17c443fab7b113975ab6eb1b X 90f5d48675c9449c8004732c22ae71ef--38a0650f17c443fab7b113975ab6eb1b 38a0650f17c443fab7b113975ab6eb1b--0837a32c7b064059bb14485d30503d21 22d88f03983d437b847750b16f85fa59 RZ(-1.0*g0) 38a0650f17c443fab7b113975ab6eb1b--22d88f03983d437b847750b16f85fa59 63d0423cc6ea4f35ab54b13517d7173f X 22d88f03983d437b847750b16f85fa59--63d0423cc6ea4f35ab54b13517d7173f 63d0423cc6ea4f35ab54b13517d7173f--832ef333682e441687480249b7e371da 58fe424bcae94c2b800ebeb96a485ef4 63d0423cc6ea4f35ab54b13517d7173f--58fe424bcae94c2b800ebeb96a485ef4 10c93ed3a9804fa9bc989f1b065eb43b 58fe424bcae94c2b800ebeb96a485ef4--10c93ed3a9804fa9bc989f1b065eb43b 021e319a66494eda947265739c7f2139 10c93ed3a9804fa9bc989f1b065eb43b--021e319a66494eda947265739c7f2139 5eaa15ca775548deb9cd354a237b830a 021e319a66494eda947265739c7f2139--5eaa15ca775548deb9cd354a237b830a 06b49deabe4f4501ad142758e7e05386 5eaa15ca775548deb9cd354a237b830a--06b49deabe4f4501ad142758e7e05386 546b75c4d24d45f898071a250fb64986 06b49deabe4f4501ad142758e7e05386--546b75c4d24d45f898071a250fb64986 68cda95717a14e6db1b45ea771dc27c5 546b75c4d24d45f898071a250fb64986--68cda95717a14e6db1b45ea771dc27c5 50a7e7dc22db405aa4d419a7909d4cea 68cda95717a14e6db1b45ea771dc27c5--50a7e7dc22db405aa4d419a7909d4cea 2f914443e3964395b795ee04415a3636 50a7e7dc22db405aa4d419a7909d4cea--2f914443e3964395b795ee04415a3636 5216392f74694c1bbcdf36828c4b433b 2f914443e3964395b795ee04415a3636--5216392f74694c1bbcdf36828c4b433b 02c380443b7d4743b6975029d2cd5693 5216392f74694c1bbcdf36828c4b433b--02c380443b7d4743b6975029d2cd5693 89817e54592c44e0acad9714c34329cf X 02c380443b7d4743b6975029d2cd5693--89817e54592c44e0acad9714c34329cf 89817e54592c44e0acad9714c34329cf--c05ff34f0a804427b9701535d3361248 4b37c9969e644dd28fb96dd684173bdf RZ(-1.0*g0) 89817e54592c44e0acad9714c34329cf--4b37c9969e644dd28fb96dd684173bdf f023f297d1464e69a5229fb992d0f1ea X 4b37c9969e644dd28fb96dd684173bdf--f023f297d1464e69a5229fb992d0f1ea f023f297d1464e69a5229fb992d0f1ea--5d3d5c1b2f9241e09826d0d3409b7a6a 526a0cb180094032ad93d73e99d9d9e7 f023f297d1464e69a5229fb992d0f1ea--526a0cb180094032ad93d73e99d9d9e7 b4d7397f49e74377ac4127db11504afd 526a0cb180094032ad93d73e99d9d9e7--b4d7397f49e74377ac4127db11504afd cc8e35ba52794233a78ef574c45333c3 b4d7397f49e74377ac4127db11504afd--cc8e35ba52794233a78ef574c45333c3 8640b26ee68e4379ab4bc3e5aa64c051 X cc8e35ba52794233a78ef574c45333c3--8640b26ee68e4379ab4bc3e5aa64c051 8640b26ee68e4379ab4bc3e5aa64c051--d4a6ef939a5d442fa98370efcba0234b 6093430d8a5042dfbeb2614cdcbb541b 8640b26ee68e4379ab4bc3e5aa64c051--6093430d8a5042dfbeb2614cdcbb541b cbaf85163c1d4860915c07ff045fdcae 6093430d8a5042dfbeb2614cdcbb541b--cbaf85163c1d4860915c07ff045fdcae ef0ee6618f2d4df9929ee7ffcea733a9 cbaf85163c1d4860915c07ff045fdcae--ef0ee6618f2d4df9929ee7ffcea733a9 dad3f1499d17414bb941c5573ab5efea X ef0ee6618f2d4df9929ee7ffcea733a9--dad3f1499d17414bb941c5573ab5efea dad3f1499d17414bb941c5573ab5efea--df63500017314e36b040ae2c54610de7 d6ba457bd9544abc99aa89361ed3d1f0 dad3f1499d17414bb941c5573ab5efea--d6ba457bd9544abc99aa89361ed3d1f0 c83af02ec1fd4702a56f0ce6148a6f3a X d6ba457bd9544abc99aa89361ed3d1f0--c83af02ec1fd4702a56f0ce6148a6f3a c83af02ec1fd4702a56f0ce6148a6f3a--68a626485e3140c083181c725cf66280 92f210689a004a7b9db6c756ebd97e8e RZ(-1.0*g0) c83af02ec1fd4702a56f0ce6148a6f3a--92f210689a004a7b9db6c756ebd97e8e a158ca7415964df2954d31773a380344 X 92f210689a004a7b9db6c756ebd97e8e--a158ca7415964df2954d31773a380344 a158ca7415964df2954d31773a380344--3ba5d4725ce84c889d2cd1b66862ac63 6f673cf2ee58445f91fd43a6b2ab188a RX(b06) a158ca7415964df2954d31773a380344--6f673cf2ee58445f91fd43a6b2ab188a 3df81a66351747c2a5d5feffac5af97f 6f673cf2ee58445f91fd43a6b2ab188a--3df81a66351747c2a5d5feffac5af97f b6f1399197204dc5855fffdc80b8e5ea 3df81a66351747c2a5d5feffac5af97f--b6f1399197204dc5855fffdc80b8e5ea 3b07e53e2cb54095872cdd54b1383157 b6f1399197204dc5855fffdc80b8e5ea--3b07e53e2cb54095872cdd54b1383157 210f779c78a3495bbcc90949600058d9 3b07e53e2cb54095872cdd54b1383157--210f779c78a3495bbcc90949600058d9 6ba975bc713640f18fbd51323cb5f96d 210f779c78a3495bbcc90949600058d9--6ba975bc713640f18fbd51323cb5f96d d10c859c80ed4663b04f25ed2f87742a X 6ba975bc713640f18fbd51323cb5f96d--d10c859c80ed4663b04f25ed2f87742a d10c859c80ed4663b04f25ed2f87742a--ec478709fc8a4158822e7ce81b2ee415 9d5f8f1cb5dc4b699b87ca5b36e84f87 d10c859c80ed4663b04f25ed2f87742a--9d5f8f1cb5dc4b699b87ca5b36e84f87 6cf05ee7ece548fba91d46b182ee7b7e 9d5f8f1cb5dc4b699b87ca5b36e84f87--6cf05ee7ece548fba91d46b182ee7b7e fa333fd625f647bd881642c00bf46f55 6cf05ee7ece548fba91d46b182ee7b7e--fa333fd625f647bd881642c00bf46f55 301e27dfc6fe401abf5c64dc26db0c41 X fa333fd625f647bd881642c00bf46f55--301e27dfc6fe401abf5c64dc26db0c41 301e27dfc6fe401abf5c64dc26db0c41--b200061dbf0f4004bff75cb18a86a27d cb8c37ba74a945abb671169b7f71d20a 301e27dfc6fe401abf5c64dc26db0c41--cb8c37ba74a945abb671169b7f71d20a a3a7d3cc0c464194b94837ff8c8da9b4 cb8c37ba74a945abb671169b7f71d20a--a3a7d3cc0c464194b94837ff8c8da9b4 91f150d3e6de45e2a0320f038c7bc4a1 a3a7d3cc0c464194b94837ff8c8da9b4--91f150d3e6de45e2a0320f038c7bc4a1 09d311245c9742c9b04c7cf021871763 91f150d3e6de45e2a0320f038c7bc4a1--09d311245c9742c9b04c7cf021871763 af06caa657234039bc8058c815584f0f 09d311245c9742c9b04c7cf021871763--af06caa657234039bc8058c815584f0f c813b947b18c458099b3636cd60c2d40 af06caa657234039bc8058c815584f0f--c813b947b18c458099b3636cd60c2d40 695a51ccfb2f483492516880d314fd77 c813b947b18c458099b3636cd60c2d40--695a51ccfb2f483492516880d314fd77 2f7da0c2a9874b99a1f2f203f6a36287 695a51ccfb2f483492516880d314fd77--2f7da0c2a9874b99a1f2f203f6a36287 f037f69907884047a2a45408d917e21a 2f7da0c2a9874b99a1f2f203f6a36287--f037f69907884047a2a45408d917e21a 4f18971d411f4eb283612746ef8b9240 f037f69907884047a2a45408d917e21a--4f18971d411f4eb283612746ef8b9240 2a9dcc0c1b5d4a5db7825d03e3d9e8c0 4f18971d411f4eb283612746ef8b9240--2a9dcc0c1b5d4a5db7825d03e3d9e8c0 c621c2a1fd8d464992a071b70724ad18 2a9dcc0c1b5d4a5db7825d03e3d9e8c0--c621c2a1fd8d464992a071b70724ad18 83478c206bcb49999e1f29abbd31554f c621c2a1fd8d464992a071b70724ad18--83478c206bcb49999e1f29abbd31554f 06ca67e24920458e9e72d6b6ef285e1a 83478c206bcb49999e1f29abbd31554f--06ca67e24920458e9e72d6b6ef285e1a 583a7f238c57423ab1ecd3acf81e80a9 06ca67e24920458e9e72d6b6ef285e1a--583a7f238c57423ab1ecd3acf81e80a9 74e12469b7e5439781381dbda8de56de 583a7f238c57423ab1ecd3acf81e80a9--74e12469b7e5439781381dbda8de56de f72b17f196ac4447a0f09fc866eaa26d 74e12469b7e5439781381dbda8de56de--f72b17f196ac4447a0f09fc866eaa26d 961aaba00d1c4b5bab0fa961e4bac19c f72b17f196ac4447a0f09fc866eaa26d--961aaba00d1c4b5bab0fa961e4bac19c fb9f5ea86df740b89016fd40b604fc26 961aaba00d1c4b5bab0fa961e4bac19c--fb9f5ea86df740b89016fd40b604fc26 8322435c7db745f4b603c3d1bb7c4deb fb9f5ea86df740b89016fd40b604fc26--8322435c7db745f4b603c3d1bb7c4deb 40c850262b054d2c883aeddd042745fa 8322435c7db745f4b603c3d1bb7c4deb--40c850262b054d2c883aeddd042745fa fad3d8faf1434f9c864c48b3e06a07d3 40c850262b054d2c883aeddd042745fa--fad3d8faf1434f9c864c48b3e06a07d3 1924fcac8cc2498c9f68725cf4ccd433 fad3d8faf1434f9c864c48b3e06a07d3--1924fcac8cc2498c9f68725cf4ccd433 49ab53eccc6c42aaa205d98b6493c52d 1924fcac8cc2498c9f68725cf4ccd433--49ab53eccc6c42aaa205d98b6493c52d 1537c4ef593d4610ab57ca186ba934a3 49ab53eccc6c42aaa205d98b6493c52d--1537c4ef593d4610ab57ca186ba934a3 9966e954f2b24bbaba27fec285e82b02 1537c4ef593d4610ab57ca186ba934a3--9966e954f2b24bbaba27fec285e82b02 b7e4d8f6eb2c445aa5e8d07ba7f666cc 9966e954f2b24bbaba27fec285e82b02--b7e4d8f6eb2c445aa5e8d07ba7f666cc 8db225760f2a48f589a00af0d0aad426 b7e4d8f6eb2c445aa5e8d07ba7f666cc--8db225760f2a48f589a00af0d0aad426 c0fe2af95cf44a839db58f31359d7da9 8db225760f2a48f589a00af0d0aad426--c0fe2af95cf44a839db58f31359d7da9 8cfec4aa07db478598bae53b5e6d4cf4 c0fe2af95cf44a839db58f31359d7da9--8cfec4aa07db478598bae53b5e6d4cf4 0b6e4734862341b788097dd4fa0047f3 8cfec4aa07db478598bae53b5e6d4cf4--0b6e4734862341b788097dd4fa0047f3 5445aab6a3d84f35b40d5fd5cedde264 X 0b6e4734862341b788097dd4fa0047f3--5445aab6a3d84f35b40d5fd5cedde264 5445aab6a3d84f35b40d5fd5cedde264--4dbefa8b436847b2972ee35a3cdaae73 3e344e5edd6f484eb4c28518fb5c7488 RZ(-1.0*g1) 5445aab6a3d84f35b40d5fd5cedde264--3e344e5edd6f484eb4c28518fb5c7488 42cb5be64b384cb487e401d1854285dd X 3e344e5edd6f484eb4c28518fb5c7488--42cb5be64b384cb487e401d1854285dd 42cb5be64b384cb487e401d1854285dd--7870d1112d2a4a88824e86a3c89e6964 0cd73b1ba4374a0ca031fd8ca521aebb 42cb5be64b384cb487e401d1854285dd--0cd73b1ba4374a0ca031fd8ca521aebb b957896bf08c4d818a0736cca7de44fa 0cd73b1ba4374a0ca031fd8ca521aebb--b957896bf08c4d818a0736cca7de44fa a978e932f567461099736ccd756a32d1 b957896bf08c4d818a0736cca7de44fa--a978e932f567461099736ccd756a32d1 f7667e8bea5442e1a43088462ad3bfa6 a978e932f567461099736ccd756a32d1--f7667e8bea5442e1a43088462ad3bfa6 d5da6095b0744218bfd21a085672dd80 f7667e8bea5442e1a43088462ad3bfa6--d5da6095b0744218bfd21a085672dd80 d0a4011cca1c4506b5b705e70f933eda d5da6095b0744218bfd21a085672dd80--d0a4011cca1c4506b5b705e70f933eda e8791931222b4d029b1b9aee784c3687 d0a4011cca1c4506b5b705e70f933eda--e8791931222b4d029b1b9aee784c3687 9e741b68a56543658395300ae17e059f e8791931222b4d029b1b9aee784c3687--9e741b68a56543658395300ae17e059f 1639ffd75ed24db6a3d261e1dadc5122 9e741b68a56543658395300ae17e059f--1639ffd75ed24db6a3d261e1dadc5122 4caf575ae0774a68a5c675dfb1ba50f9 1639ffd75ed24db6a3d261e1dadc5122--4caf575ae0774a68a5c675dfb1ba50f9 13402ccd97b546e29a84f5dca45529b0 4caf575ae0774a68a5c675dfb1ba50f9--13402ccd97b546e29a84f5dca45529b0 e4927f7ace544560b704f8c00de1af82 13402ccd97b546e29a84f5dca45529b0--e4927f7ace544560b704f8c00de1af82 4d0b5f83f02d46059e37b7060e9a71d5 e4927f7ace544560b704f8c00de1af82--4d0b5f83f02d46059e37b7060e9a71d5 ec2a2a4ad67b44fd86b78232a713ccf3 4d0b5f83f02d46059e37b7060e9a71d5--ec2a2a4ad67b44fd86b78232a713ccf3 a48d80395c0e432ca73c3ab74f41509a ec2a2a4ad67b44fd86b78232a713ccf3--a48d80395c0e432ca73c3ab74f41509a 87668ff16ff34e62bfccb74005489cf5 a48d80395c0e432ca73c3ab74f41509a--87668ff16ff34e62bfccb74005489cf5 915e53a11552431e8845a09ee45ba02c 87668ff16ff34e62bfccb74005489cf5--915e53a11552431e8845a09ee45ba02c 0ae30f3ce80e4fe7a89b7552967488de 915e53a11552431e8845a09ee45ba02c--0ae30f3ce80e4fe7a89b7552967488de 9f8f69561e7645b4b3977a64697f63ef 0ae30f3ce80e4fe7a89b7552967488de--9f8f69561e7645b4b3977a64697f63ef ba7dc2dfab214434822b8fa8c05648ba 9f8f69561e7645b4b3977a64697f63ef--ba7dc2dfab214434822b8fa8c05648ba 05b81332faad44919c0f167262c8b0f1 ba7dc2dfab214434822b8fa8c05648ba--05b81332faad44919c0f167262c8b0f1 6714f54c97454cb48d38c51e1c7deb59 05b81332faad44919c0f167262c8b0f1--6714f54c97454cb48d38c51e1c7deb59 62b62390f77741b1a5291f4f2aa9e73d 6714f54c97454cb48d38c51e1c7deb59--62b62390f77741b1a5291f4f2aa9e73d 4e34a9c8cdb043c48e8b2cf8559da921 62b62390f77741b1a5291f4f2aa9e73d--4e34a9c8cdb043c48e8b2cf8559da921 9a9de2a4c5014d62befa699f058451bc 4e34a9c8cdb043c48e8b2cf8559da921--9a9de2a4c5014d62befa699f058451bc 61f50c3825c04afea046ff390258e40c 9a9de2a4c5014d62befa699f058451bc--61f50c3825c04afea046ff390258e40c a6917832ba814889893d22062197f571 61f50c3825c04afea046ff390258e40c--a6917832ba814889893d22062197f571 5b6f037bfc414d9e83349baf4136f8bb a6917832ba814889893d22062197f571--5b6f037bfc414d9e83349baf4136f8bb f5c8bf8b8c834f37ac51c052aa9d6116 5b6f037bfc414d9e83349baf4136f8bb--f5c8bf8b8c834f37ac51c052aa9d6116 6aaa505412e54cd4ab7c90cdf54ceba4 f5c8bf8b8c834f37ac51c052aa9d6116--6aaa505412e54cd4ab7c90cdf54ceba4 94fd8cacbbbe49e6a9da449de82f2699 6aaa505412e54cd4ab7c90cdf54ceba4--94fd8cacbbbe49e6a9da449de82f2699 5bcdc2248fa4485983a5c9350f1d4dce 94fd8cacbbbe49e6a9da449de82f2699--5bcdc2248fa4485983a5c9350f1d4dce 62a01462736d409a932b0d582a5c045f 5bcdc2248fa4485983a5c9350f1d4dce--62a01462736d409a932b0d582a5c045f 67647f78b0a44493ba17af2038d8832f X 62a01462736d409a932b0d582a5c045f--67647f78b0a44493ba17af2038d8832f 67647f78b0a44493ba17af2038d8832f--6e5df0ae708744909014ae694595295b e72989045be94bed8621a275bb598088 RZ(-1.0*g1) 67647f78b0a44493ba17af2038d8832f--e72989045be94bed8621a275bb598088 32fb86ce5145421c8449f33bc6a89f94 X e72989045be94bed8621a275bb598088--32fb86ce5145421c8449f33bc6a89f94 32fb86ce5145421c8449f33bc6a89f94--5bb75366dd4f47e5960825c8492134bf d2f8a007a39549198719a88745bcb88e 32fb86ce5145421c8449f33bc6a89f94--d2f8a007a39549198719a88745bcb88e 757c1e0279fe40138d76dffddbb39c08 d2f8a007a39549198719a88745bcb88e--757c1e0279fe40138d76dffddbb39c08 81eaf0601dbf4de692a2e6ed1db13309 757c1e0279fe40138d76dffddbb39c08--81eaf0601dbf4de692a2e6ed1db13309 f81720e43d2f44b28ca798758c3c3d31 81eaf0601dbf4de692a2e6ed1db13309--f81720e43d2f44b28ca798758c3c3d31 d3620278dc61491fa72c236a794bb3f6 f81720e43d2f44b28ca798758c3c3d31--d3620278dc61491fa72c236a794bb3f6 cc5c0944407842808e2406470a769789 d3620278dc61491fa72c236a794bb3f6--cc5c0944407842808e2406470a769789 c732558a10714224be404438e6c821b2 cc5c0944407842808e2406470a769789--c732558a10714224be404438e6c821b2 8a96f9a637c8422f8c675fc342a12f36 c732558a10714224be404438e6c821b2--8a96f9a637c8422f8c675fc342a12f36 4785f7c25a6b44a0bc0212b4a5c39588 8a96f9a637c8422f8c675fc342a12f36--4785f7c25a6b44a0bc0212b4a5c39588 b052c3bcd68a4980afedc0553132b942 4785f7c25a6b44a0bc0212b4a5c39588--b052c3bcd68a4980afedc0553132b942 4d14be55db87433394e0194db52cda67 b052c3bcd68a4980afedc0553132b942--4d14be55db87433394e0194db52cda67 2a0e97ed09cd453dbd3740f266799914 X 4d14be55db87433394e0194db52cda67--2a0e97ed09cd453dbd3740f266799914 2a0e97ed09cd453dbd3740f266799914--be6911cedb6c4cfd83fdb9143d1abc83 07a8c052c22246b28d7cf48a0fc3c803 RZ(-1.0*g1) 2a0e97ed09cd453dbd3740f266799914--07a8c052c22246b28d7cf48a0fc3c803 8bd9b522a10f4b17b4e40bc552e6b760 X 07a8c052c22246b28d7cf48a0fc3c803--8bd9b522a10f4b17b4e40bc552e6b760 8bd9b522a10f4b17b4e40bc552e6b760--ed72e9706c8b4e22a722f3bab13c68c3 5b8fcdde26ca4748a72e1514b9c73920 8bd9b522a10f4b17b4e40bc552e6b760--5b8fcdde26ca4748a72e1514b9c73920 2e95a36569f74ac7a7626c9da0309103 5b8fcdde26ca4748a72e1514b9c73920--2e95a36569f74ac7a7626c9da0309103 4b51ed933194455898ca4683649bb0e0 2e95a36569f74ac7a7626c9da0309103--4b51ed933194455898ca4683649bb0e0 a2bb2bd5caf8455f9a33df4d9d516880 X 4b51ed933194455898ca4683649bb0e0--a2bb2bd5caf8455f9a33df4d9d516880 a2bb2bd5caf8455f9a33df4d9d516880--96de067859a54aceb02df215579693bc 2fe0d31799224294ba21779fafe6649c a2bb2bd5caf8455f9a33df4d9d516880--2fe0d31799224294ba21779fafe6649c dbe54af23354463ca83f614f47ff1319 2fe0d31799224294ba21779fafe6649c--dbe54af23354463ca83f614f47ff1319 64210f20464f4ab3ad0955413acbeed6 dbe54af23354463ca83f614f47ff1319--64210f20464f4ab3ad0955413acbeed6 e2c0abf6fa254f139dd734ff94fdc177 X 64210f20464f4ab3ad0955413acbeed6--e2c0abf6fa254f139dd734ff94fdc177 e2c0abf6fa254f139dd734ff94fdc177--6cb6067456934a738503f51f2b9c4823 0608163de15946649338499e37edd0db e2c0abf6fa254f139dd734ff94fdc177--0608163de15946649338499e37edd0db c21ab1c67adf40338507cddee4eb9c45 X 0608163de15946649338499e37edd0db--c21ab1c67adf40338507cddee4eb9c45 c21ab1c67adf40338507cddee4eb9c45--62f23973a9e14bf9bac01dfdba4406bc 3b7f9206b21e42058fdc9ce0fab578e3 RZ(-1.0*g1) c21ab1c67adf40338507cddee4eb9c45--3b7f9206b21e42058fdc9ce0fab578e3 882a987d20db40999cfad2cb358743a1 X 3b7f9206b21e42058fdc9ce0fab578e3--882a987d20db40999cfad2cb358743a1 882a987d20db40999cfad2cb358743a1--b61eb3d1432145b39ed1f710bdcde245 79a387e4dac04080a4c87ee9f99b5224 RX(b16) 882a987d20db40999cfad2cb358743a1--79a387e4dac04080a4c87ee9f99b5224 79a387e4dac04080a4c87ee9f99b5224--5a2fee1da62442d99e8aa2f0cf07534f 3987a32961f44d2f99a53bbddae6d21b 50408e9748f44c43aee7ee6ed1b2680c 0a900ac1369d4916bc481d6d917e6d86--50408e9748f44c43aee7ee6ed1b2680c 220d99c7db6d49458fd2145d483a76c1 50408e9748f44c43aee7ee6ed1b2680c--220d99c7db6d49458fd2145d483a76c1 deb3993ebcc14a70b0de618cde460b45 220d99c7db6d49458fd2145d483a76c1--deb3993ebcc14a70b0de618cde460b45 2c7c9dbf4fe04b74846d60b159147059 deb3993ebcc14a70b0de618cde460b45--2c7c9dbf4fe04b74846d60b159147059 8a9446da141943bea0008986913f22de 2c7c9dbf4fe04b74846d60b159147059--8a9446da141943bea0008986913f22de 6f2fb6e9728b45deb8cd1cebc4a1949d 8a9446da141943bea0008986913f22de--6f2fb6e9728b45deb8cd1cebc4a1949d ce4ed97781e54192964f714e1f12ddf0 X 6f2fb6e9728b45deb8cd1cebc4a1949d--ce4ed97781e54192964f714e1f12ddf0 ce4ed97781e54192964f714e1f12ddf0--08938a54542545259a4f01ae05133726 807c2d99d37740b4820b2401382b408d RZ(1.0*g0) ce4ed97781e54192964f714e1f12ddf0--807c2d99d37740b4820b2401382b408d 40debc66455e43e3a8e7bce576c23e17 X 807c2d99d37740b4820b2401382b408d--40debc66455e43e3a8e7bce576c23e17 40debc66455e43e3a8e7bce576c23e17--d9b6803f4b6c4e30bd363c85ebe2e54c 592b33add1744213b87f742fab24ef69 40debc66455e43e3a8e7bce576c23e17--592b33add1744213b87f742fab24ef69 f7246c3fc98248c4b76d03e786d14730 592b33add1744213b87f742fab24ef69--f7246c3fc98248c4b76d03e786d14730 26dc9eda919b4d74a36aee21a76ea1ee f7246c3fc98248c4b76d03e786d14730--26dc9eda919b4d74a36aee21a76ea1ee 8b4ac60bc864458ab4e9f2555907b615 26dc9eda919b4d74a36aee21a76ea1ee--8b4ac60bc864458ab4e9f2555907b615 aa1bd1d09d2f495da5ced4dbe669c563 8b4ac60bc864458ab4e9f2555907b615--aa1bd1d09d2f495da5ced4dbe669c563 e210bc89f1864e2c89397c2ff8ed0279 aa1bd1d09d2f495da5ced4dbe669c563--e210bc89f1864e2c89397c2ff8ed0279 f0d63938ee2c439899083e626dd8a400 e210bc89f1864e2c89397c2ff8ed0279--f0d63938ee2c439899083e626dd8a400 b6ba022ffd2e4052b84ba980cb09219b f0d63938ee2c439899083e626dd8a400--b6ba022ffd2e4052b84ba980cb09219b 9fd45610a4e94450ab3cc743e8ac17c4 b6ba022ffd2e4052b84ba980cb09219b--9fd45610a4e94450ab3cc743e8ac17c4 e3fe3f2f5bf64653b09b211c0b6baa43 9fd45610a4e94450ab3cc743e8ac17c4--e3fe3f2f5bf64653b09b211c0b6baa43 c3a49c8eaa6e4fffa2f100e94b8caa8f e3fe3f2f5bf64653b09b211c0b6baa43--c3a49c8eaa6e4fffa2f100e94b8caa8f 98ea3deac32a4659b9ab69515276f071 c3a49c8eaa6e4fffa2f100e94b8caa8f--98ea3deac32a4659b9ab69515276f071 0c1e211f7315459898633a0b8dc34e03 98ea3deac32a4659b9ab69515276f071--0c1e211f7315459898633a0b8dc34e03 945839c3f4794721b505c2b2fad9ca65 0c1e211f7315459898633a0b8dc34e03--945839c3f4794721b505c2b2fad9ca65 29230c4c0ff9494f82e05d508961aaa5 945839c3f4794721b505c2b2fad9ca65--29230c4c0ff9494f82e05d508961aaa5 7be5bb188af649c3a884baa150979264 29230c4c0ff9494f82e05d508961aaa5--7be5bb188af649c3a884baa150979264 470556327a5c4bc9beda5981448cfc02 7be5bb188af649c3a884baa150979264--470556327a5c4bc9beda5981448cfc02 79f59f06944e41869b7d59ef4fd191c2 470556327a5c4bc9beda5981448cfc02--79f59f06944e41869b7d59ef4fd191c2 2426c509dec0413aa05b349dc2dea4d6 79f59f06944e41869b7d59ef4fd191c2--2426c509dec0413aa05b349dc2dea4d6 1abe240682234ad0aeb5b0eeabbf9ae5 2426c509dec0413aa05b349dc2dea4d6--1abe240682234ad0aeb5b0eeabbf9ae5 01a4010b3c594558b3bc70aa04fef0d3 1abe240682234ad0aeb5b0eeabbf9ae5--01a4010b3c594558b3bc70aa04fef0d3 5d512aebe15448a0b5b2f9e03299a421 01a4010b3c594558b3bc70aa04fef0d3--5d512aebe15448a0b5b2f9e03299a421 0ab23d6925224a3c8de27b13e2cb95c5 5d512aebe15448a0b5b2f9e03299a421--0ab23d6925224a3c8de27b13e2cb95c5 4d9d8c6b7b944002817f1251f8c5d5cf 0ab23d6925224a3c8de27b13e2cb95c5--4d9d8c6b7b944002817f1251f8c5d5cf 371bc7e98b7d43aa8a425ab1eb3aa4f9 4d9d8c6b7b944002817f1251f8c5d5cf--371bc7e98b7d43aa8a425ab1eb3aa4f9 dc77fc0138f6419fb8f3fa704c860ed4 371bc7e98b7d43aa8a425ab1eb3aa4f9--dc77fc0138f6419fb8f3fa704c860ed4 3c341eab4667414aa94177839374b953 dc77fc0138f6419fb8f3fa704c860ed4--3c341eab4667414aa94177839374b953 e043d956f53d40c5aa33593c24ed6486 3c341eab4667414aa94177839374b953--e043d956f53d40c5aa33593c24ed6486 6cb36fe9b5d141d5b3ea6673b10bd797 e043d956f53d40c5aa33593c24ed6486--6cb36fe9b5d141d5b3ea6673b10bd797 ec91e7a10b4a483f80c13c82028c3f67 6cb36fe9b5d141d5b3ea6673b10bd797--ec91e7a10b4a483f80c13c82028c3f67 ca52bc79f611415b95d7d0453805dd6e ec91e7a10b4a483f80c13c82028c3f67--ca52bc79f611415b95d7d0453805dd6e b034ec3f605447b79a831ccf11024a67 ca52bc79f611415b95d7d0453805dd6e--b034ec3f605447b79a831ccf11024a67 d04bfa9b8b7f46edba8bbbaffdbb0766 b034ec3f605447b79a831ccf11024a67--d04bfa9b8b7f46edba8bbbaffdbb0766 26d1851ed0e242a1a4a5a8e6fee55849 d04bfa9b8b7f46edba8bbbaffdbb0766--26d1851ed0e242a1a4a5a8e6fee55849 5ec229284da54062bc0b8c685efde28d 26d1851ed0e242a1a4a5a8e6fee55849--5ec229284da54062bc0b8c685efde28d 8d9e90992bc1413db360f738829f847c 5ec229284da54062bc0b8c685efde28d--8d9e90992bc1413db360f738829f847c 57836f8393d54952ad555f4dd598715a 8d9e90992bc1413db360f738829f847c--57836f8393d54952ad555f4dd598715a d44bf2aac1fe4fa086d1c3e290d96a08 57836f8393d54952ad555f4dd598715a--d44bf2aac1fe4fa086d1c3e290d96a08 c63373570b6c47f9b97d2816d9799fc0 d44bf2aac1fe4fa086d1c3e290d96a08--c63373570b6c47f9b97d2816d9799fc0 0583b5c44cae45c395e28b44abecd766 c63373570b6c47f9b97d2816d9799fc0--0583b5c44cae45c395e28b44abecd766 6d2aee6526014ea38ad0bcef80610569 0583b5c44cae45c395e28b44abecd766--6d2aee6526014ea38ad0bcef80610569 157dd05e72fb4c79b886fa9f48025954 6d2aee6526014ea38ad0bcef80610569--157dd05e72fb4c79b886fa9f48025954 b77bb301f5084aebbf351e77dcaf189e 157dd05e72fb4c79b886fa9f48025954--b77bb301f5084aebbf351e77dcaf189e 7eaa2dfdb11e4ec6b589febb039a6d76 b77bb301f5084aebbf351e77dcaf189e--7eaa2dfdb11e4ec6b589febb039a6d76 8c8766a8b646467f851c50e49353c7fe 7eaa2dfdb11e4ec6b589febb039a6d76--8c8766a8b646467f851c50e49353c7fe 08200ecfd1374e35aff4a97b60d42735 8c8766a8b646467f851c50e49353c7fe--08200ecfd1374e35aff4a97b60d42735 076b875078454e4a9c309245dfcb1f1d 08200ecfd1374e35aff4a97b60d42735--076b875078454e4a9c309245dfcb1f1d 5760997d844a40a39aa98f9b525aa4cb 076b875078454e4a9c309245dfcb1f1d--5760997d844a40a39aa98f9b525aa4cb 006a55743c404b988c5ed2450ebfa446 5760997d844a40a39aa98f9b525aa4cb--006a55743c404b988c5ed2450ebfa446 96c297a67db945de92c8e06b0c0d4681 006a55743c404b988c5ed2450ebfa446--96c297a67db945de92c8e06b0c0d4681 24ff8c951ac04096908d50bc5d901950 96c297a67db945de92c8e06b0c0d4681--24ff8c951ac04096908d50bc5d901950 91b9c2b70ca04e63916cbc2af87b430b 24ff8c951ac04096908d50bc5d901950--91b9c2b70ca04e63916cbc2af87b430b 9bee93c382dc473595a566903971de45 91b9c2b70ca04e63916cbc2af87b430b--9bee93c382dc473595a566903971de45 247eb521e22a422c9157faa9232e7ed9 9bee93c382dc473595a566903971de45--247eb521e22a422c9157faa9232e7ed9 d8bbe5527a6e40ff8242754646adcd68 247eb521e22a422c9157faa9232e7ed9--d8bbe5527a6e40ff8242754646adcd68 8c02df5923c640a8aed93e5ab4664f88 d8bbe5527a6e40ff8242754646adcd68--8c02df5923c640a8aed93e5ab4664f88 5f6afedccf5c4b5e93f4b5be79be332b 8c02df5923c640a8aed93e5ab4664f88--5f6afedccf5c4b5e93f4b5be79be332b baf82ca344d8473890f92112015477d8 5f6afedccf5c4b5e93f4b5be79be332b--baf82ca344d8473890f92112015477d8 a7bedadad4c24084af17bd831ffb89a7 baf82ca344d8473890f92112015477d8--a7bedadad4c24084af17bd831ffb89a7 da0dae379fed47ab9b784c1bd952f214 a7bedadad4c24084af17bd831ffb89a7--da0dae379fed47ab9b784c1bd952f214 fe9c33b0ae9f4bba84e5cde4a7a2d1e9 da0dae379fed47ab9b784c1bd952f214--fe9c33b0ae9f4bba84e5cde4a7a2d1e9 573af01c69aa40d98944e5beb8790791 fe9c33b0ae9f4bba84e5cde4a7a2d1e9--573af01c69aa40d98944e5beb8790791 08d51fc94be34346a7fd7484601c8ce5 573af01c69aa40d98944e5beb8790791--08d51fc94be34346a7fd7484601c8ce5 df0aa346a92841378a3cc5ce2f651ae0 08d51fc94be34346a7fd7484601c8ce5--df0aa346a92841378a3cc5ce2f651ae0 7f2581e1df88465798c5542d2ecaa67b df0aa346a92841378a3cc5ce2f651ae0--7f2581e1df88465798c5542d2ecaa67b bbb1e0a8f225464db7c42ff76c1b6f7c 7f2581e1df88465798c5542d2ecaa67b--bbb1e0a8f225464db7c42ff76c1b6f7c da1b2f83f75c4053af84e1597b4c07bf bbb1e0a8f225464db7c42ff76c1b6f7c--da1b2f83f75c4053af84e1597b4c07bf 214b05a8f4224162a8d34bab85af492e da1b2f83f75c4053af84e1597b4c07bf--214b05a8f4224162a8d34bab85af492e e196d4b868f347069888ad8638adb6da 214b05a8f4224162a8d34bab85af492e--e196d4b868f347069888ad8638adb6da 2b809ba72fa54380868192218b7c9b1e e196d4b868f347069888ad8638adb6da--2b809ba72fa54380868192218b7c9b1e d36b9a7a8eaa4f3684b3284b3d1fedc8 2b809ba72fa54380868192218b7c9b1e--d36b9a7a8eaa4f3684b3284b3d1fedc8 109ffc26317747e1b1b0822588c222c8 d36b9a7a8eaa4f3684b3284b3d1fedc8--109ffc26317747e1b1b0822588c222c8 8b8fc7b3ec314789a44e62e0ec681d2f 109ffc26317747e1b1b0822588c222c8--8b8fc7b3ec314789a44e62e0ec681d2f 2349ec8a3bce47c1b5e1bb0741acf4aa 8b8fc7b3ec314789a44e62e0ec681d2f--2349ec8a3bce47c1b5e1bb0741acf4aa 5778103e14c64f9388ae4123eef58404 2349ec8a3bce47c1b5e1bb0741acf4aa--5778103e14c64f9388ae4123eef58404 f005939b6e3348a69f6325a3ec052642 5778103e14c64f9388ae4123eef58404--f005939b6e3348a69f6325a3ec052642 34b37427071842d899a2054e1568be37 f005939b6e3348a69f6325a3ec052642--34b37427071842d899a2054e1568be37 35eba7efc6644a72b3549e6d58e873d1 34b37427071842d899a2054e1568be37--35eba7efc6644a72b3549e6d58e873d1 3cfd8bed443d4386bc7ef950e731993c 35eba7efc6644a72b3549e6d58e873d1--3cfd8bed443d4386bc7ef950e731993c b6983e24719b4d2ebc227e7a3afeac4b 3cfd8bed443d4386bc7ef950e731993c--b6983e24719b4d2ebc227e7a3afeac4b a51417b07b374917b7fba8b2eb978497 b6983e24719b4d2ebc227e7a3afeac4b--a51417b07b374917b7fba8b2eb978497 a6be96b7e5c442549b6d682b8678400e a51417b07b374917b7fba8b2eb978497--a6be96b7e5c442549b6d682b8678400e da7a5c1f801344a08e747e7db50151c1 a6be96b7e5c442549b6d682b8678400e--da7a5c1f801344a08e747e7db50151c1 44c96b78b3fc42ef8c5c9c29a74e5a48 da7a5c1f801344a08e747e7db50151c1--44c96b78b3fc42ef8c5c9c29a74e5a48 570211d2e6e848b1ae636f9a619cb98f 44c96b78b3fc42ef8c5c9c29a74e5a48--570211d2e6e848b1ae636f9a619cb98f 8119c001412b4bdf97dea53e2d46e447 570211d2e6e848b1ae636f9a619cb98f--8119c001412b4bdf97dea53e2d46e447 924e5cb46f00442e98730071604eef77 8119c001412b4bdf97dea53e2d46e447--924e5cb46f00442e98730071604eef77 7a5194d676e9482c8011a7bf0d2db2f2 924e5cb46f00442e98730071604eef77--7a5194d676e9482c8011a7bf0d2db2f2 ed9a893f3b4e4cacbddd55c9acdaa4ae 7a5194d676e9482c8011a7bf0d2db2f2--ed9a893f3b4e4cacbddd55c9acdaa4ae f27cfcbd4ec34ed786da5f074541f6ad X ed9a893f3b4e4cacbddd55c9acdaa4ae--f27cfcbd4ec34ed786da5f074541f6ad f27cfcbd4ec34ed786da5f074541f6ad--6093430d8a5042dfbeb2614cdcbb541b 08a2068013504cc982eb73dd8a9efdaa RZ(-1.0*g0) f27cfcbd4ec34ed786da5f074541f6ad--08a2068013504cc982eb73dd8a9efdaa da6e652a7ca44bc4b45a5dd7a9f0bcae X 08a2068013504cc982eb73dd8a9efdaa--da6e652a7ca44bc4b45a5dd7a9f0bcae da6e652a7ca44bc4b45a5dd7a9f0bcae--ef0ee6618f2d4df9929ee7ffcea733a9 2ebd2eaf104946f0ae0db51f4f4c6f27 da6e652a7ca44bc4b45a5dd7a9f0bcae--2ebd2eaf104946f0ae0db51f4f4c6f27 9e26f7f17a9e49be92367132a33e21a4 2ebd2eaf104946f0ae0db51f4f4c6f27--9e26f7f17a9e49be92367132a33e21a4 e2aa4edae1d04b749bab262db2d91c12 9e26f7f17a9e49be92367132a33e21a4--e2aa4edae1d04b749bab262db2d91c12 0518e99c9b2743abb771e07b8ab06e42 e2aa4edae1d04b749bab262db2d91c12--0518e99c9b2743abb771e07b8ab06e42 d71b49634bb64bacb6825cb02123cbbb 0518e99c9b2743abb771e07b8ab06e42--d71b49634bb64bacb6825cb02123cbbb 12c03d7b4ad340f58e4172318cc381ae RX(b07) d71b49634bb64bacb6825cb02123cbbb--12c03d7b4ad340f58e4172318cc381ae d62b6c0fe4fa4d268580befa09b4b7e3 12c03d7b4ad340f58e4172318cc381ae--d62b6c0fe4fa4d268580befa09b4b7e3 3836e186667b4d1b83c8e2e412bc632e d62b6c0fe4fa4d268580befa09b4b7e3--3836e186667b4d1b83c8e2e412bc632e ffa1245da3ed4582b706d089f7bdebc5 3836e186667b4d1b83c8e2e412bc632e--ffa1245da3ed4582b706d089f7bdebc5 ed25d4b3c9404f1f83865e994bd3a8b3 ffa1245da3ed4582b706d089f7bdebc5--ed25d4b3c9404f1f83865e994bd3a8b3 5c96826b488d45baaab25b08809a3434 ed25d4b3c9404f1f83865e994bd3a8b3--5c96826b488d45baaab25b08809a3434 64b68ce9fcf246f3a6134a700e62e54c 5c96826b488d45baaab25b08809a3434--64b68ce9fcf246f3a6134a700e62e54c ea826fb376574d8daa274d806d550475 X 64b68ce9fcf246f3a6134a700e62e54c--ea826fb376574d8daa274d806d550475 ea826fb376574d8daa274d806d550475--9d5f8f1cb5dc4b699b87ca5b36e84f87 7695110258014061ab8cbc297c279157 RZ(1.0*g1) ea826fb376574d8daa274d806d550475--7695110258014061ab8cbc297c279157 fa54d628beba45edac9f745e99cc931a X 7695110258014061ab8cbc297c279157--fa54d628beba45edac9f745e99cc931a fa54d628beba45edac9f745e99cc931a--fa333fd625f647bd881642c00bf46f55 004c408bf45849dd94ee0b7809392323 fa54d628beba45edac9f745e99cc931a--004c408bf45849dd94ee0b7809392323 ce8294feeaf5421ea664ffcfe3a84ee2 004c408bf45849dd94ee0b7809392323--ce8294feeaf5421ea664ffcfe3a84ee2 7044dfdf02e3458087286aa580e76e0c ce8294feeaf5421ea664ffcfe3a84ee2--7044dfdf02e3458087286aa580e76e0c 6e24fc01c2584f27809ce3f410555a66 7044dfdf02e3458087286aa580e76e0c--6e24fc01c2584f27809ce3f410555a66 0de99a5383bc4fb88f0b1c2640280e2b 6e24fc01c2584f27809ce3f410555a66--0de99a5383bc4fb88f0b1c2640280e2b e9607e1171544ab0ac4c974c06d2acf1 0de99a5383bc4fb88f0b1c2640280e2b--e9607e1171544ab0ac4c974c06d2acf1 f32a25698060413eb6fc400b843b6d36 e9607e1171544ab0ac4c974c06d2acf1--f32a25698060413eb6fc400b843b6d36 56a99da7a06e4968b0da9697fe011d58 f32a25698060413eb6fc400b843b6d36--56a99da7a06e4968b0da9697fe011d58 ce55644168ac4adf880fae11e54e8d9b 56a99da7a06e4968b0da9697fe011d58--ce55644168ac4adf880fae11e54e8d9b 116bc4d8911e41ecb45eb83e175e3038 ce55644168ac4adf880fae11e54e8d9b--116bc4d8911e41ecb45eb83e175e3038 f3ba7aea613447a09d388b3d40886cdb 116bc4d8911e41ecb45eb83e175e3038--f3ba7aea613447a09d388b3d40886cdb 75a90a717422421ea5d757060c38a48f f3ba7aea613447a09d388b3d40886cdb--75a90a717422421ea5d757060c38a48f 2419d3cfeb46498ba1b84e79c3027cd8 75a90a717422421ea5d757060c38a48f--2419d3cfeb46498ba1b84e79c3027cd8 5e1ce285e99940a79e9c9922fd1aceb9 2419d3cfeb46498ba1b84e79c3027cd8--5e1ce285e99940a79e9c9922fd1aceb9 c6b4198e0e774f8ca8dbe1f25c3198c7 5e1ce285e99940a79e9c9922fd1aceb9--c6b4198e0e774f8ca8dbe1f25c3198c7 94700dc6aea94809a213f42d3a1b7efe c6b4198e0e774f8ca8dbe1f25c3198c7--94700dc6aea94809a213f42d3a1b7efe c3fd45fb9fae4d9c95a5c022266bf7ea 94700dc6aea94809a213f42d3a1b7efe--c3fd45fb9fae4d9c95a5c022266bf7ea 40a80cd470ca48428b15ad34b431590b c3fd45fb9fae4d9c95a5c022266bf7ea--40a80cd470ca48428b15ad34b431590b 62dc4e8a33f14ab6b81448c1dbc1e612 40a80cd470ca48428b15ad34b431590b--62dc4e8a33f14ab6b81448c1dbc1e612 a26f89f077034566bf4fa48e700f9bfe 62dc4e8a33f14ab6b81448c1dbc1e612--a26f89f077034566bf4fa48e700f9bfe b2f46ee310474499b21b3d9fe472db2b a26f89f077034566bf4fa48e700f9bfe--b2f46ee310474499b21b3d9fe472db2b 5e6680d12a6745b3b89cdc9e2b2c7899 b2f46ee310474499b21b3d9fe472db2b--5e6680d12a6745b3b89cdc9e2b2c7899 8f0b4e7cbe3c41839bdc9a3d608d8215 5e6680d12a6745b3b89cdc9e2b2c7899--8f0b4e7cbe3c41839bdc9a3d608d8215 e19be870df1c48e8bc245e7468f0ab59 8f0b4e7cbe3c41839bdc9a3d608d8215--e19be870df1c48e8bc245e7468f0ab59 83f450aa4f16405ba623878a219eb090 e19be870df1c48e8bc245e7468f0ab59--83f450aa4f16405ba623878a219eb090 d8283f876f8f424283e6eedff5a2b1b1 83f450aa4f16405ba623878a219eb090--d8283f876f8f424283e6eedff5a2b1b1 94efb41f1e4044cd90c2acf0b20a2117 d8283f876f8f424283e6eedff5a2b1b1--94efb41f1e4044cd90c2acf0b20a2117 d206c41595684b15aa8553cf3924f942 94efb41f1e4044cd90c2acf0b20a2117--d206c41595684b15aa8553cf3924f942 b7d9cfee37364d80a9cd7c37e6350821 d206c41595684b15aa8553cf3924f942--b7d9cfee37364d80a9cd7c37e6350821 e046b3410632478e936758c63eef9e41 b7d9cfee37364d80a9cd7c37e6350821--e046b3410632478e936758c63eef9e41 c39c2c57378f4eacb0f0ad72cb9409ec e046b3410632478e936758c63eef9e41--c39c2c57378f4eacb0f0ad72cb9409ec 70beee27bf7a46e9b7994455a35e2540 c39c2c57378f4eacb0f0ad72cb9409ec--70beee27bf7a46e9b7994455a35e2540 c4fdf99bbbfa428aa8578efcc6e06833 70beee27bf7a46e9b7994455a35e2540--c4fdf99bbbfa428aa8578efcc6e06833 9f97cdfb369246b58a5fa097eaecd7bb c4fdf99bbbfa428aa8578efcc6e06833--9f97cdfb369246b58a5fa097eaecd7bb 4a6d2cd324044eb5b6e434d546a1113e 9f97cdfb369246b58a5fa097eaecd7bb--4a6d2cd324044eb5b6e434d546a1113e 9e2f88008ff040448e834c47e5ce0e52 4a6d2cd324044eb5b6e434d546a1113e--9e2f88008ff040448e834c47e5ce0e52 778bc3dc1da844ef8b83e56d94635f23 9e2f88008ff040448e834c47e5ce0e52--778bc3dc1da844ef8b83e56d94635f23 566c001e9c9c4a61bed22984907f7dd9 778bc3dc1da844ef8b83e56d94635f23--566c001e9c9c4a61bed22984907f7dd9 7b3607777b6448239235043e23952be8 566c001e9c9c4a61bed22984907f7dd9--7b3607777b6448239235043e23952be8 be9c3bd35b1a4ae0bc380d55bae8f1c5 7b3607777b6448239235043e23952be8--be9c3bd35b1a4ae0bc380d55bae8f1c5 b66a991651db429e9c782f4ef72c588a be9c3bd35b1a4ae0bc380d55bae8f1c5--b66a991651db429e9c782f4ef72c588a 6df02a97877544af98b3e5fa6dab5737 b66a991651db429e9c782f4ef72c588a--6df02a97877544af98b3e5fa6dab5737 ba925a8db1484e5bb39a3720c95fae8c 6df02a97877544af98b3e5fa6dab5737--ba925a8db1484e5bb39a3720c95fae8c 2936cd3f321b44ca8731cbbdff8f2762 ba925a8db1484e5bb39a3720c95fae8c--2936cd3f321b44ca8731cbbdff8f2762 6ccc5cc25617473da9682b78dca8111f 2936cd3f321b44ca8731cbbdff8f2762--6ccc5cc25617473da9682b78dca8111f 49ac744f26ce48f1ba70f94f26f33f43 6ccc5cc25617473da9682b78dca8111f--49ac744f26ce48f1ba70f94f26f33f43 be5a4ef46e574725870944fde1e2428d 49ac744f26ce48f1ba70f94f26f33f43--be5a4ef46e574725870944fde1e2428d 8ce05120e57144aa9928581bbc640b1b be5a4ef46e574725870944fde1e2428d--8ce05120e57144aa9928581bbc640b1b feca09b741ab4e8dbf2264c5f88cf7c8 8ce05120e57144aa9928581bbc640b1b--feca09b741ab4e8dbf2264c5f88cf7c8 bfdfc756f7e0424fa16c4d020bacef06 feca09b741ab4e8dbf2264c5f88cf7c8--bfdfc756f7e0424fa16c4d020bacef06 5942ee77025944d6a9ed6df49a7b30fd bfdfc756f7e0424fa16c4d020bacef06--5942ee77025944d6a9ed6df49a7b30fd 9b7e1a4ad9184ced96f5a3ff71d040d3 5942ee77025944d6a9ed6df49a7b30fd--9b7e1a4ad9184ced96f5a3ff71d040d3 eff9b91ceb7949ceb6f65d717f100975 9b7e1a4ad9184ced96f5a3ff71d040d3--eff9b91ceb7949ceb6f65d717f100975 ba5834e486cd4694bbf1fc35f7168059 eff9b91ceb7949ceb6f65d717f100975--ba5834e486cd4694bbf1fc35f7168059 2a7514363d1e4b25a1e3385c0870a7b2 ba5834e486cd4694bbf1fc35f7168059--2a7514363d1e4b25a1e3385c0870a7b2 aadfc3d34a0f445b96f480652d27a57b 2a7514363d1e4b25a1e3385c0870a7b2--aadfc3d34a0f445b96f480652d27a57b b23071ac31b24fac83ed5f47dcd10204 aadfc3d34a0f445b96f480652d27a57b--b23071ac31b24fac83ed5f47dcd10204 a6513fae6f74469ebcb74a5cf6364e5e b23071ac31b24fac83ed5f47dcd10204--a6513fae6f74469ebcb74a5cf6364e5e 53c033ae4b52430ca24ed12ab40eebc6 a6513fae6f74469ebcb74a5cf6364e5e--53c033ae4b52430ca24ed12ab40eebc6 59e9cbe0f6854315b086b4ae4b4430c5 53c033ae4b52430ca24ed12ab40eebc6--59e9cbe0f6854315b086b4ae4b4430c5 981975e64d5843afbba7c3f4621449d7 59e9cbe0f6854315b086b4ae4b4430c5--981975e64d5843afbba7c3f4621449d7 30d9dd1ab7854c38b78e506c5b0e540d 981975e64d5843afbba7c3f4621449d7--30d9dd1ab7854c38b78e506c5b0e540d 8aa89a3feb9b49078948f9229bd6a73e 30d9dd1ab7854c38b78e506c5b0e540d--8aa89a3feb9b49078948f9229bd6a73e 0f2ad9bf719d4878b77cfc7a654eadc5 8aa89a3feb9b49078948f9229bd6a73e--0f2ad9bf719d4878b77cfc7a654eadc5 5bd0e9d9f2dc48e2945284ab38f2fd22 0f2ad9bf719d4878b77cfc7a654eadc5--5bd0e9d9f2dc48e2945284ab38f2fd22 88a7e61ade9448419089c42ec5fcabe4 5bd0e9d9f2dc48e2945284ab38f2fd22--88a7e61ade9448419089c42ec5fcabe4 29f82cda8d7b499da55df6ba3d6f5a71 88a7e61ade9448419089c42ec5fcabe4--29f82cda8d7b499da55df6ba3d6f5a71 b25e8cde4c6d43bfb372331fc00b9f1f 29f82cda8d7b499da55df6ba3d6f5a71--b25e8cde4c6d43bfb372331fc00b9f1f 8d995e1c19c7483488bb747cadbe70dd b25e8cde4c6d43bfb372331fc00b9f1f--8d995e1c19c7483488bb747cadbe70dd e28e851a180e45149e6d59500ff88ee4 8d995e1c19c7483488bb747cadbe70dd--e28e851a180e45149e6d59500ff88ee4 d44c0983122144e1b55ca0d3ece7a6dd e28e851a180e45149e6d59500ff88ee4--d44c0983122144e1b55ca0d3ece7a6dd 2319155d462b4598b67827ab8c4a4dfc d44c0983122144e1b55ca0d3ece7a6dd--2319155d462b4598b67827ab8c4a4dfc d165a3851d244cfe9dddb478c4f8db4a 2319155d462b4598b67827ab8c4a4dfc--d165a3851d244cfe9dddb478c4f8db4a dcb6e112202b4dce8b35ec468be36391 d165a3851d244cfe9dddb478c4f8db4a--dcb6e112202b4dce8b35ec468be36391 4e22a4d2eabb41b5b039c0a6bc3e6322 dcb6e112202b4dce8b35ec468be36391--4e22a4d2eabb41b5b039c0a6bc3e6322 c1a60941363b405baed332bcf200bf3f 4e22a4d2eabb41b5b039c0a6bc3e6322--c1a60941363b405baed332bcf200bf3f 1d2864563cab456298ce39e83cb6b8f0 c1a60941363b405baed332bcf200bf3f--1d2864563cab456298ce39e83cb6b8f0 b5a41979450e4ddead7cb72b6a2cd3f3 1d2864563cab456298ce39e83cb6b8f0--b5a41979450e4ddead7cb72b6a2cd3f3 e815d9d65c5242d3b0b1c501d4639b3b b5a41979450e4ddead7cb72b6a2cd3f3--e815d9d65c5242d3b0b1c501d4639b3b 25499b7fcd68412a8240d9f67e031096 e815d9d65c5242d3b0b1c501d4639b3b--25499b7fcd68412a8240d9f67e031096 3dbbe2a18b3e45da84ccc5732c63cce7 25499b7fcd68412a8240d9f67e031096--3dbbe2a18b3e45da84ccc5732c63cce7 65a5560c4e9a47e484e548e6f4872785 3dbbe2a18b3e45da84ccc5732c63cce7--65a5560c4e9a47e484e548e6f4872785 7e4544991c8d47d2a88a9da38a7a14b6 65a5560c4e9a47e484e548e6f4872785--7e4544991c8d47d2a88a9da38a7a14b6 2f8ac304edb34a66ae62032c7e8d74a9 7e4544991c8d47d2a88a9da38a7a14b6--2f8ac304edb34a66ae62032c7e8d74a9 f1b0ddd15095444d995de412009dceb1 2f8ac304edb34a66ae62032c7e8d74a9--f1b0ddd15095444d995de412009dceb1 587412088e4546f5851833a43c496061 f1b0ddd15095444d995de412009dceb1--587412088e4546f5851833a43c496061 d050fcceb7cb4c8f93e408a93d61356e 587412088e4546f5851833a43c496061--d050fcceb7cb4c8f93e408a93d61356e b0c926e70c384998b59a2502c5871d26 d050fcceb7cb4c8f93e408a93d61356e--b0c926e70c384998b59a2502c5871d26 de0084f3aeac46378f2ac5503db0d20f b0c926e70c384998b59a2502c5871d26--de0084f3aeac46378f2ac5503db0d20f 7bc32fd8d8264f7b93a4119716dc2d03 X de0084f3aeac46378f2ac5503db0d20f--7bc32fd8d8264f7b93a4119716dc2d03 7bc32fd8d8264f7b93a4119716dc2d03--2fe0d31799224294ba21779fafe6649c fe8fc198eb1d4d5196e6fdb5fad23908 RZ(-1.0*g1) 7bc32fd8d8264f7b93a4119716dc2d03--fe8fc198eb1d4d5196e6fdb5fad23908 785ff3ec906844a1bd3f1423e4b19ac5 X fe8fc198eb1d4d5196e6fdb5fad23908--785ff3ec906844a1bd3f1423e4b19ac5 785ff3ec906844a1bd3f1423e4b19ac5--64210f20464f4ab3ad0955413acbeed6 5dfae436c6cb4f1eba788368538ee0f1 785ff3ec906844a1bd3f1423e4b19ac5--5dfae436c6cb4f1eba788368538ee0f1 4c1ab680ab5340768d2257b38f27a5ad 5dfae436c6cb4f1eba788368538ee0f1--4c1ab680ab5340768d2257b38f27a5ad 11696f3135b4468da8a11285682b7c4a 4c1ab680ab5340768d2257b38f27a5ad--11696f3135b4468da8a11285682b7c4a f5f6366f6e17435ea182bc5b4b5c5cd6 11696f3135b4468da8a11285682b7c4a--f5f6366f6e17435ea182bc5b4b5c5cd6 24b1ea3c5e43459db9ef582aeb8f9130 f5f6366f6e17435ea182bc5b4b5c5cd6--24b1ea3c5e43459db9ef582aeb8f9130 1b3a8fdc21fe4c8290623b7799fe7f02 RX(b17) 24b1ea3c5e43459db9ef582aeb8f9130--1b3a8fdc21fe4c8290623b7799fe7f02 1b3a8fdc21fe4c8290623b7799fe7f02--3987a32961f44d2f99a53bbddae6d21b"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -4.118147591321714\nMaxCut cost at iteration 10: 9.11095224601467\nMaxCut cost at iteration 20: 10.950688557985707\nMaxCut cost at iteration 30: 10.986355917678672\nMaxCut cost at iteration 40: 10.995102922107925\nMaxCut cost at iteration 50: 10.998182185432938\nMaxCut cost at iteration 60: 10.999781946474236\nMaxCut cost at iteration 70: 10.999977936015291\nMaxCut cost at iteration 80: 10.99999780652105\nMaxCut cost at iteration 90: 10.999999782317074\nMaxCut cost at iteration 100: 10.999999978400623\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 11000101  2024-02-01T16:33:41.440087 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2024-02-01T16:33:46.132912 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_70759a15f7b541ba968fa1a95ed346ad Constant Chebyshev FM cluster_ec37f93286f84165bc027f4a57ba2098 Constant Fourier FM df30d47eff0a450fa4bee27ded1fbd8c 0 ab5e1f6c5bd545c5a10586015b0253e7 RX(phi) df30d47eff0a450fa4bee27ded1fbd8c--ab5e1f6c5bd545c5a10586015b0253e7 cd131ce0bc3d4ca38ecff398996cd900 1 4ec415a9cee04d3b911221ece418644b RX(acos(phi)) ab5e1f6c5bd545c5a10586015b0253e7--4ec415a9cee04d3b911221ece418644b 19adeb508cdf413b9588791a7992d606 4ec415a9cee04d3b911221ece418644b--19adeb508cdf413b9588791a7992d606 4254c43c40b148cc8b4e92e7b1cdca5d 34a1dfd1f2444cbd97e9b3ad1da66698 RX(phi) cd131ce0bc3d4ca38ecff398996cd900--34a1dfd1f2444cbd97e9b3ad1da66698 646073a27788456eb5e40b03420217cf 2 d730d8de64f84dd4a5f8f75dd1110c02 RX(acos(phi)) 34a1dfd1f2444cbd97e9b3ad1da66698--d730d8de64f84dd4a5f8f75dd1110c02 d730d8de64f84dd4a5f8f75dd1110c02--4254c43c40b148cc8b4e92e7b1cdca5d 88b39a0d6f50444e823cd75f23a88afb 51659df67c314f1f8ea98007a7066b71 RX(phi) 646073a27788456eb5e40b03420217cf--51659df67c314f1f8ea98007a7066b71 8582959b143f4298a632532d5132ea84 RX(acos(phi)) 51659df67c314f1f8ea98007a7066b71--8582959b143f4298a632532d5132ea84 8582959b143f4298a632532d5132ea84--88b39a0d6f50444e823cd75f23a88afb <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom function\ndef custom_fn(x):\n    return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_fn)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_63f4f6e37dfb40f0a3984b3acaaea4c4 Constant &lt;function custom_fn at 0x7fa95bd1b9a0&gt; FM cluster_9fba9a5b07d940b181c74bc910e88516 Constant asin FM 95e82857bb6746068d424e4a9dc25c8e 0 23a5befc273a41ce88dda7c675158670 RX(asin(phi)) 95e82857bb6746068d424e4a9dc25c8e--23a5befc273a41ce88dda7c675158670 bdb629a1695440e7b82f6b39b96de200 1 cb222f9059154e02a0db7883ef432a0d RX(phi**2 + asin(phi)) 23a5befc273a41ce88dda7c675158670--cb222f9059154e02a0db7883ef432a0d ee80d0102752485c8d9cd4ba4d9b9aa6 cb222f9059154e02a0db7883ef432a0d--ee80d0102752485c8d9cd4ba4d9b9aa6 6d2999d8e65a431786c1b4c2c7cd6121 3f38214b6d0e493da58b1fc467824642 RX(asin(phi)) bdb629a1695440e7b82f6b39b96de200--3f38214b6d0e493da58b1fc467824642 a2732d4772544aef99376016c8907ab0 2 1ae98cf3e11a4974ab42b1e9335fe60d RX(phi**2 + asin(phi)) 3f38214b6d0e493da58b1fc467824642--1ae98cf3e11a4974ab42b1e9335fe60d 1ae98cf3e11a4974ab42b1e9335fe60d--6d2999d8e65a431786c1b4c2c7cd6121 46a5aa0a22cf476eae0bebd500abaec9 6c1f7ebc67d943088731a0b0eec9fa78 RX(asin(phi)) a2732d4772544aef99376016c8907ab0--6c1f7ebc67d943088731a0b0eec9fa78 99fe1e31cae1422fbec39e9f0061e250 RX(phi**2 + asin(phi)) 6c1f7ebc67d943088731a0b0eec9fa78--99fe1e31cae1422fbec39e9f0061e250 99fe1e31cae1422fbec39e9f0061e250--46a5aa0a22cf476eae0bebd500abaec9 <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_ac0ab80d2f02456dbc3746216d1a309d Exponential Fourier FM cluster_bf970cf827494d49b7b785c88941d5c9 Constant Fourier FM cluster_b22eed5cdbaf430a9a463f3f5fac7718 Tower Fourier FM 315f50fca82f4c57acf7dbea2192d4db 0 2ce1475ba4844e9380e89299d37a8e6d RX(phi) 315f50fca82f4c57acf7dbea2192d4db--2ce1475ba4844e9380e89299d37a8e6d 1bb4bc504ec0499496e2360a3aec60cf 1 cfa0bd5d7b794885998303c5d88d7554 RX(1.0*phi) 2ce1475ba4844e9380e89299d37a8e6d--cfa0bd5d7b794885998303c5d88d7554 f9ef39338ce44e07a4707cfa108975d0 RX(1.0*phi) cfa0bd5d7b794885998303c5d88d7554--f9ef39338ce44e07a4707cfa108975d0 98aee60b727f4b25bf449d460abba9bd f9ef39338ce44e07a4707cfa108975d0--98aee60b727f4b25bf449d460abba9bd e041cfb6e4054bf0b4a546109901de1d 75f6b3e87eee4cdc9661b96b5eecb7e6 RX(phi) 1bb4bc504ec0499496e2360a3aec60cf--75f6b3e87eee4cdc9661b96b5eecb7e6 e4ecd23a654044caa5e5e4ccff01a0f6 2 2727a0625a744f00b1290ccf0e4d5be3 RX(2.0*phi) 75f6b3e87eee4cdc9661b96b5eecb7e6--2727a0625a744f00b1290ccf0e4d5be3 0c3d32cd36674859a705fc37b25a10b4 RX(2.0*phi) 2727a0625a744f00b1290ccf0e4d5be3--0c3d32cd36674859a705fc37b25a10b4 0c3d32cd36674859a705fc37b25a10b4--e041cfb6e4054bf0b4a546109901de1d f9c530649a2144e58ace9036bdb7cb4e a355c46cc0154ba883d1fadd7596ae90 RX(phi) e4ecd23a654044caa5e5e4ccff01a0f6--a355c46cc0154ba883d1fadd7596ae90 0aeab37ae1054bc1a385c43e8fcfecb7 3 f0e21f33bb5f4e10b63dc69752c81130 RX(3.0*phi) a355c46cc0154ba883d1fadd7596ae90--f0e21f33bb5f4e10b63dc69752c81130 22e3252634bc4791907623c625d87c26 RX(4.0*phi) f0e21f33bb5f4e10b63dc69752c81130--22e3252634bc4791907623c625d87c26 22e3252634bc4791907623c625d87c26--f9c530649a2144e58ace9036bdb7cb4e bbd0658735d6452fb8a73c1cab4e9fea 45b51fced9854b5c8d174572b9697243 RX(phi) 0aeab37ae1054bc1a385c43e8fcfecb7--45b51fced9854b5c8d174572b9697243 af21e7a2301448688d5c2993937982d1 4 4a0436187c6e49a38493556c5fc15fcc RX(4.0*phi) 45b51fced9854b5c8d174572b9697243--4a0436187c6e49a38493556c5fc15fcc e49100b9c7c047c4ae9fd5aa72589983 RX(8.0*phi) 4a0436187c6e49a38493556c5fc15fcc--e49100b9c7c047c4ae9fd5aa72589983 e49100b9c7c047c4ae9fd5aa72589983--bbd0658735d6452fb8a73c1cab4e9fea f541f3cc8f3b46d5838fdb2226c03e05 eda9f2c74653431a9874eaaf14e319b3 RX(phi) af21e7a2301448688d5c2993937982d1--eda9f2c74653431a9874eaaf14e319b3 0abc12f8888a49f6bd1de345d0dec3fb RX(5.0*phi) eda9f2c74653431a9874eaaf14e319b3--0abc12f8888a49f6bd1de345d0dec3fb cb25a55f8f014fb0babac909cb97c7d5 RX(16.0*phi) 0abc12f8888a49f6bd1de345d0dec3fb--cb25a55f8f014fb0babac909cb97c7d5 cb25a55f8f014fb0babac909cb97c7d5--f541f3cc8f3b46d5838fdb2226c03e05 <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 86378aac4ea64af7a2d68e9ccc0c0335 0 67e602d0bc5740ac9a1bd7a6b47b10e4 RX(1.0*acos(phi)) 86378aac4ea64af7a2d68e9ccc0c0335--67e602d0bc5740ac9a1bd7a6b47b10e4 4c41db90d437428cbf5a98fdcf23a5b6 1 08540c2878fc48929b953365c82d7ffa 67e602d0bc5740ac9a1bd7a6b47b10e4--08540c2878fc48929b953365c82d7ffa 74a94c0700c142ffbbf67226ff59e5ee 5b0b92663d104b93beeeea87ebd7cbd6 RX(1.414*acos(phi)) 4c41db90d437428cbf5a98fdcf23a5b6--5b0b92663d104b93beeeea87ebd7cbd6 054551ae1c1d4e23b2fe33fdfdd44e67 2 5b0b92663d104b93beeeea87ebd7cbd6--74a94c0700c142ffbbf67226ff59e5ee 4cbc9e14a27c45de81199f4342ae9351 0a960d0674934982953585e94e18a0e9 RX(1.732*acos(phi)) 054551ae1c1d4e23b2fe33fdfdd44e67--0a960d0674934982953585e94e18a0e9 2721a8e528a54bc193eedcf7390152d1 3 0a960d0674934982953585e94e18a0e9--4cbc9e14a27c45de81199f4342ae9351 7ebc082ce39447dcb0ff6822b3c0cca7 b57043ad8c064fbf9f0bf299d334e33d RX(2.0*acos(phi)) 2721a8e528a54bc193eedcf7390152d1--b57043ad8c064fbf9f0bf299d334e33d 6abb19dc34964233a76c84da08a6b7f5 4 b57043ad8c064fbf9f0bf299d334e33d--7ebc082ce39447dcb0ff6822b3c0cca7 e9df0f452d4a4f32a516a649060c7247 80d9da3c45e942c1867f6c45d2855583 RX(2.236*acos(phi)) 6abb19dc34964233a76c84da08a6b7f5--80d9da3c45e942c1867f6c45d2855583 80d9da3c45e942c1867f6c45d2855583--e9df0f452d4a4f32a516a649060c7247 <p>To add a trainable parameter that multiplies the feature parameter inside the encoding function, simply pass a <code>param_prefix</code> string:</p> <pre><code>n_qubits = 5\n\nfm_trainable = feature_map(\n    n_qubits,\n    fm_type=BasisSet.FOURIER,\n    reupload_scaling=ReuploadScaling.EXP,\n    param_prefix = \"w\",\n)\n</code></pre> %3 24dcefa30e36428e85103bcb217eff7a 0 a3ca17fc3cd84f3e8316fff4772e9641 RX(1.0*phi*w\u2080) 24dcefa30e36428e85103bcb217eff7a--a3ca17fc3cd84f3e8316fff4772e9641 82091263097841e3935ca44bf296c323 1 9e814eadc40f4e13a9e3f327d83dc238 a3ca17fc3cd84f3e8316fff4772e9641--9e814eadc40f4e13a9e3f327d83dc238 9cb690ca654041579b0855f588f0165e 9951fbc7640048b68c1185b928cbd5e0 RX(2.0*phi*w\u2081) 82091263097841e3935ca44bf296c323--9951fbc7640048b68c1185b928cbd5e0 06b9791944634c6899b07d1e97747170 2 9951fbc7640048b68c1185b928cbd5e0--9cb690ca654041579b0855f588f0165e fb0b621a808c4c07b4b4e05d42d46de5 9eea5bd6614448b2956786c17a8ec50b RX(4.0*phi*w\u2082) 06b9791944634c6899b07d1e97747170--9eea5bd6614448b2956786c17a8ec50b 5cf6f4b8573c4ebd9c25326f792512e8 3 9eea5bd6614448b2956786c17a8ec50b--fb0b621a808c4c07b4b4e05d42d46de5 61a2c125b42f4bb8802390ab34549909 546249580d9b417081cd02f92bd03b42 RX(8.0*phi*w\u2083) 5cf6f4b8573c4ebd9c25326f792512e8--546249580d9b417081cd02f92bd03b42 14dff316e6bb44be9a65ccfa444654ec 4 546249580d9b417081cd02f92bd03b42--61a2c125b42f4bb8802390ab34549909 eb4b66cab3ab48a39799eec3c0b01f51 88d7aa01b01e40bbb59029a9412aa968 RX(16.0*phi*w\u2084) 14dff316e6bb44be9a65ccfa444654ec--88d7aa01b01e40bbb59029a9412aa968 88d7aa01b01e40bbb59029a9412aa968--eb4b66cab3ab48a39799eec3c0b01f51 <p>Note that for the Fourier feature map, the encoding function is simply \\(f(x)=x\\). For other cases, like the Chebyshev <code>acos()</code> encoding, the trainable parameter may cause the feature value to be outside the domain of the encoding function. This will eventually be fixed by adding range constraints to trainable parameters in Qadence.</p> <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0, # Extra multiplier, which can also be a Parameter\n    param_prefix = \"w\", # Add trainable parameters\n)\n</code></pre> %3 160c0cc08c0a4e5eb793765350ea360f 0 3799b1bc9151408a843b68b55f65c7cc RY(80.0*acos(w\u2084*(0.667*x + 1.667))) 160c0cc08c0a4e5eb793765350ea360f--3799b1bc9151408a843b68b55f65c7cc 76f3a1c92e634cd4ad1c8f1c6805aff9 1 e4f1b5e0dae34fed9b17a336052e88c3 3799b1bc9151408a843b68b55f65c7cc--e4f1b5e0dae34fed9b17a336052e88c3 92eb864e2ba545908e9b427de052d1b7 a3aa3621c03e4d1bab516b49cec1f241 RY(40.0*acos(w\u2083*(0.667*x + 1.667))) 76f3a1c92e634cd4ad1c8f1c6805aff9--a3aa3621c03e4d1bab516b49cec1f241 6129b6e10d6c4527afc93cb17c614150 2 a3aa3621c03e4d1bab516b49cec1f241--92eb864e2ba545908e9b427de052d1b7 4a315f6899a242cda7a2c6f5659b5d3a bd5b0fcbfb9f4bde9aead8e2143363b9 RY(20.0*acos(w\u2082*(0.667*x + 1.667))) 6129b6e10d6c4527afc93cb17c614150--bd5b0fcbfb9f4bde9aead8e2143363b9 077bc08c159e428fa7e5020770b68a09 3 bd5b0fcbfb9f4bde9aead8e2143363b9--4a315f6899a242cda7a2c6f5659b5d3a f30cf73713bf469f86fcdf285064e280 112e6aba33764a49adf18110d5c41116 RY(10.0*acos(w\u2081*(0.667*x + 1.667))) 077bc08c159e428fa7e5020770b68a09--112e6aba33764a49adf18110d5c41116 729db48b12274b5789866a74103c64c4 4 112e6aba33764a49adf18110d5c41116--f30cf73713bf469f86fcdf285064e280 595b4e645c8849ff9707438d9bba4368 393c2df2c9b54c9d8a34f81b9f2bbc2e RY(5.0*acos(w\u2080*(0.667*x + 1.667))) 729db48b12274b5789866a74103c64c4--393c2df2c9b54c9d8a34f81b9f2bbc2e 393c2df2c9b54c9d8a34f81b9f2bbc2e--595b4e645c8849ff9707438d9bba4368"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 87e26f1900ab4f91a741dd609e7afbe8 0 d45df327a2d24085b7781de05baed308 RX(theta\u2080) 87e26f1900ab4f91a741dd609e7afbe8--d45df327a2d24085b7781de05baed308 379f11f69f8d415eac1285e556d5db63 1 d5ec6d8f021c49fe8264d31facd6c602 RY(theta\u2083) d45df327a2d24085b7781de05baed308--d5ec6d8f021c49fe8264d31facd6c602 48d25e638fed4226a69c7c1452d49379 RX(theta\u2086) d5ec6d8f021c49fe8264d31facd6c602--48d25e638fed4226a69c7c1452d49379 8d0c51a300ae4635ac503019b47dcc41 48d25e638fed4226a69c7c1452d49379--8d0c51a300ae4635ac503019b47dcc41 573915ae04e441a185f3297def484c23 8d0c51a300ae4635ac503019b47dcc41--573915ae04e441a185f3297def484c23 517b93f674a247fda9297862505faebd RX(theta\u2089) 573915ae04e441a185f3297def484c23--517b93f674a247fda9297862505faebd 065c4acb7b13460e81c1a5c95c24b203 RY(theta\u2081\u2082) 517b93f674a247fda9297862505faebd--065c4acb7b13460e81c1a5c95c24b203 0ce545b1272347edbbcacf089be32bee RX(theta\u2081\u2085) 065c4acb7b13460e81c1a5c95c24b203--0ce545b1272347edbbcacf089be32bee 76fd639e367f49409b42bcdd53844d71 0ce545b1272347edbbcacf089be32bee--76fd639e367f49409b42bcdd53844d71 750306c08d1d477291571a65d0fe49fc 76fd639e367f49409b42bcdd53844d71--750306c08d1d477291571a65d0fe49fc c23aa6e8ca0d457487e5904b5d93b1a6 750306c08d1d477291571a65d0fe49fc--c23aa6e8ca0d457487e5904b5d93b1a6 50f2c8a10e7d48cd8a64c7628c920de9 6c36cfb3cb2b446c81f9ce9cd0cefe28 RX(theta\u2081) 379f11f69f8d415eac1285e556d5db63--6c36cfb3cb2b446c81f9ce9cd0cefe28 724a8e7e047047778a88e5ad4447cda3 2 7bf6d3d8044e4b2a8c25881af72cacff RY(theta\u2084) 6c36cfb3cb2b446c81f9ce9cd0cefe28--7bf6d3d8044e4b2a8c25881af72cacff 8831e90407e04f598992d7bbec903cde RX(theta\u2087) 7bf6d3d8044e4b2a8c25881af72cacff--8831e90407e04f598992d7bbec903cde 4a0aef29752f4f98b90218550a202281 X 8831e90407e04f598992d7bbec903cde--4a0aef29752f4f98b90218550a202281 4a0aef29752f4f98b90218550a202281--8d0c51a300ae4635ac503019b47dcc41 3078ef0293e548ccbde8396856c3a0ec 4a0aef29752f4f98b90218550a202281--3078ef0293e548ccbde8396856c3a0ec 2085445f8d0047c2871d9a8a42330b0a RX(theta\u2081\u2080) 3078ef0293e548ccbde8396856c3a0ec--2085445f8d0047c2871d9a8a42330b0a 950b5a65124d470f84a8a61b00fbc71d RY(theta\u2081\u2083) 2085445f8d0047c2871d9a8a42330b0a--950b5a65124d470f84a8a61b00fbc71d e30ab41e994e479cbac1dde9c06eeafc RX(theta\u2081\u2086) 950b5a65124d470f84a8a61b00fbc71d--e30ab41e994e479cbac1dde9c06eeafc 0a3fee6ccd214346a23ecae07ea45a0c X e30ab41e994e479cbac1dde9c06eeafc--0a3fee6ccd214346a23ecae07ea45a0c 0a3fee6ccd214346a23ecae07ea45a0c--76fd639e367f49409b42bcdd53844d71 f7a60b1f102647d8acc76f1a236989fe 0a3fee6ccd214346a23ecae07ea45a0c--f7a60b1f102647d8acc76f1a236989fe f7a60b1f102647d8acc76f1a236989fe--50f2c8a10e7d48cd8a64c7628c920de9 ab4c0a9e2edf45899b5ed600340ff5cb 0a19365e7ea14278afbd95987b317a85 RX(theta\u2082) 724a8e7e047047778a88e5ad4447cda3--0a19365e7ea14278afbd95987b317a85 5dd206cbe1004f929a707409785764a7 RY(theta\u2085) 0a19365e7ea14278afbd95987b317a85--5dd206cbe1004f929a707409785764a7 11868c2047434d2e838bb1550435e70e RX(theta\u2088) 5dd206cbe1004f929a707409785764a7--11868c2047434d2e838bb1550435e70e c86911634a2e4e68b2f95f22e9750971 11868c2047434d2e838bb1550435e70e--c86911634a2e4e68b2f95f22e9750971 67d4c1a0d4604643bb17b792ed0b2610 X c86911634a2e4e68b2f95f22e9750971--67d4c1a0d4604643bb17b792ed0b2610 67d4c1a0d4604643bb17b792ed0b2610--3078ef0293e548ccbde8396856c3a0ec 7965dd3bccaa4f9da2f808f64df0467f RX(theta\u2081\u2081) 67d4c1a0d4604643bb17b792ed0b2610--7965dd3bccaa4f9da2f808f64df0467f 8f4f8c28b1ec4e74acc0fa9d30f9322e RY(theta\u2081\u2084) 7965dd3bccaa4f9da2f808f64df0467f--8f4f8c28b1ec4e74acc0fa9d30f9322e 3431f80a34b043cc84e7880028c64cdb RX(theta\u2081\u2087) 8f4f8c28b1ec4e74acc0fa9d30f9322e--3431f80a34b043cc84e7880028c64cdb 09a90345b4b849eaba2245152ea60292 3431f80a34b043cc84e7880028c64cdb--09a90345b4b849eaba2245152ea60292 97bfac7b168640a299b4f520fea9d651 X 09a90345b4b849eaba2245152ea60292--97bfac7b168640a299b4f520fea9d651 97bfac7b168640a299b4f520fea9d651--f7a60b1f102647d8acc76f1a236989fe 97bfac7b168640a299b4f520fea9d651--ab4c0a9e2edf45899b5ed600340ff5cb <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 94ccc9dfcf3147a09b0b4739849a1c4f 0 a856c499bd09468092a53aac5c3accd6 RX(phi\u2080) 94ccc9dfcf3147a09b0b4739849a1c4f--a856c499bd09468092a53aac5c3accd6 473a1ec183ac4cb4a98fce8c824adc99 1 866dcac307df470582e51a52607c9006 RY(phi\u2083) a856c499bd09468092a53aac5c3accd6--866dcac307df470582e51a52607c9006 2bdb67bfc07445a7a84fb57a277206da RX(phi\u2086) 866dcac307df470582e51a52607c9006--2bdb67bfc07445a7a84fb57a277206da 4f8b206562994438a5501942f21758fb 2bdb67bfc07445a7a84fb57a277206da--4f8b206562994438a5501942f21758fb 6dfbeb30902d418e9e64229680fd5760 4f8b206562994438a5501942f21758fb--6dfbeb30902d418e9e64229680fd5760 2e4a46b04ef340b98841046f7498a644 RX(phi\u2089) 6dfbeb30902d418e9e64229680fd5760--2e4a46b04ef340b98841046f7498a644 4a6381343e614273b24c02a4cc923ed1 RY(phi\u2081\u2082) 2e4a46b04ef340b98841046f7498a644--4a6381343e614273b24c02a4cc923ed1 fb5705b3215946d4b30e81c7b553f41b RX(phi\u2081\u2085) 4a6381343e614273b24c02a4cc923ed1--fb5705b3215946d4b30e81c7b553f41b 8ad3248ed33e4933b0e9c1ecf6ac05c6 fb5705b3215946d4b30e81c7b553f41b--8ad3248ed33e4933b0e9c1ecf6ac05c6 efd053d8e09d43b1afd477ca26145a32 8ad3248ed33e4933b0e9c1ecf6ac05c6--efd053d8e09d43b1afd477ca26145a32 74466c98f16a4d56a9a67cceea07fb41 efd053d8e09d43b1afd477ca26145a32--74466c98f16a4d56a9a67cceea07fb41 cd1e0f93b2164a3682af330b070a13ed 1b8cc26353a940c3bfb50b2fb891db7a RX(phi\u2081) 473a1ec183ac4cb4a98fce8c824adc99--1b8cc26353a940c3bfb50b2fb891db7a 9404ca30cb624f8ea8a9cc031424ce09 2 fb6c4f0fc66443abbcbbd921a6ca1ebe RY(phi\u2084) 1b8cc26353a940c3bfb50b2fb891db7a--fb6c4f0fc66443abbcbbd921a6ca1ebe cc1cb6eff0ce4ceaad787a143a1b13b7 RX(phi\u2087) fb6c4f0fc66443abbcbbd921a6ca1ebe--cc1cb6eff0ce4ceaad787a143a1b13b7 d59af3602c954c2598518b82bac88220 PHASE(phi_ent\u2080) cc1cb6eff0ce4ceaad787a143a1b13b7--d59af3602c954c2598518b82bac88220 d59af3602c954c2598518b82bac88220--4f8b206562994438a5501942f21758fb 03660a1620fc492c8c9ce3e8be347318 d59af3602c954c2598518b82bac88220--03660a1620fc492c8c9ce3e8be347318 943321c73d194610bc6faa61ea95d73c RX(phi\u2081\u2080) 03660a1620fc492c8c9ce3e8be347318--943321c73d194610bc6faa61ea95d73c 468a4e96df9f43f3b93c3846abde1ecd RY(phi\u2081\u2083) 943321c73d194610bc6faa61ea95d73c--468a4e96df9f43f3b93c3846abde1ecd f366b184b16146d3ba08ede5bb4f3ea7 RX(phi\u2081\u2086) 468a4e96df9f43f3b93c3846abde1ecd--f366b184b16146d3ba08ede5bb4f3ea7 1497f353965046e09de7cda4e000e78a PHASE(phi_ent\u2082) f366b184b16146d3ba08ede5bb4f3ea7--1497f353965046e09de7cda4e000e78a 1497f353965046e09de7cda4e000e78a--8ad3248ed33e4933b0e9c1ecf6ac05c6 d39c10d176514174a1c3d9332c045db5 1497f353965046e09de7cda4e000e78a--d39c10d176514174a1c3d9332c045db5 d39c10d176514174a1c3d9332c045db5--cd1e0f93b2164a3682af330b070a13ed c053c23767f047af815e97f944bc4a8e 986505b1667b40029ca2b269863cd7e7 RX(phi\u2082) 9404ca30cb624f8ea8a9cc031424ce09--986505b1667b40029ca2b269863cd7e7 69c85ee4b26b436a868d0e7e8c13b4e2 RY(phi\u2085) 986505b1667b40029ca2b269863cd7e7--69c85ee4b26b436a868d0e7e8c13b4e2 4f02c5aae4474aa296318d07f167c227 RX(phi\u2088) 69c85ee4b26b436a868d0e7e8c13b4e2--4f02c5aae4474aa296318d07f167c227 847be7a087e54a07abf4c1d6d38a2629 4f02c5aae4474aa296318d07f167c227--847be7a087e54a07abf4c1d6d38a2629 e57bdb294f814420b2b42d003248838e PHASE(phi_ent\u2081) 847be7a087e54a07abf4c1d6d38a2629--e57bdb294f814420b2b42d003248838e e57bdb294f814420b2b42d003248838e--03660a1620fc492c8c9ce3e8be347318 4e97e953a8b5407db7fa4623c4fcdf9c RX(phi\u2081\u2081) e57bdb294f814420b2b42d003248838e--4e97e953a8b5407db7fa4623c4fcdf9c 5fb1d65413614479897f416290970202 RY(phi\u2081\u2084) 4e97e953a8b5407db7fa4623c4fcdf9c--5fb1d65413614479897f416290970202 1f8aa3129ec84c1f953c216c730206a3 RX(phi\u2081\u2087) 5fb1d65413614479897f416290970202--1f8aa3129ec84c1f953c216c730206a3 2ede78234a7e4584be51126b17474439 1f8aa3129ec84c1f953c216c730206a3--2ede78234a7e4584be51126b17474439 e0955b1e3a21404b91d12787b0ef3c45 PHASE(phi_ent\u2083) 2ede78234a7e4584be51126b17474439--e0955b1e3a21404b91d12787b0ef3c45 e0955b1e3a21404b91d12787b0ef3c45--d39c10d176514174a1c3d9332c045db5 e0955b1e3a21404b91d12787b0ef3c45--c053c23767f047af815e97f944bc4a8e <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_90bbb123a8c84f66a6af9dd5dd938b55 cluster_e001db1282a44d68b593a822b806c777 80d06fb77d76484ebc3eab6863f1e560 0 954d0ce676df45499d6daa1f6c8c6d90 RX(theta\u2080) 80d06fb77d76484ebc3eab6863f1e560--954d0ce676df45499d6daa1f6c8c6d90 b0777dd35e2348b4847300bdc9426ab1 1 50ed206a705a422fadcae1e1d5d86650 RY(theta\u2083) 954d0ce676df45499d6daa1f6c8c6d90--50ed206a705a422fadcae1e1d5d86650 8c32b021909e4bb189619add27198923 RX(theta\u2086) 50ed206a705a422fadcae1e1d5d86650--8c32b021909e4bb189619add27198923 f0e171ac89ce402595933de51c1d1cc3 HamEvo 8c32b021909e4bb189619add27198923--f0e171ac89ce402595933de51c1d1cc3 e05eec5a9320419d98d478a0e6eb1247 RX(theta\u2089) f0e171ac89ce402595933de51c1d1cc3--e05eec5a9320419d98d478a0e6eb1247 af7074b2cac74c0f8260e29f603dfc52 RY(theta\u2081\u2082) e05eec5a9320419d98d478a0e6eb1247--af7074b2cac74c0f8260e29f603dfc52 4494612d7fa943e6b28ce6d959397bd4 RX(theta\u2081\u2085) af7074b2cac74c0f8260e29f603dfc52--4494612d7fa943e6b28ce6d959397bd4 22da7b7b32a84afeb4d56bc424e0fd3f HamEvo 4494612d7fa943e6b28ce6d959397bd4--22da7b7b32a84afeb4d56bc424e0fd3f 3ea1cdbcc3a54ceb984844639eb4b856 22da7b7b32a84afeb4d56bc424e0fd3f--3ea1cdbcc3a54ceb984844639eb4b856 392952b41b394f80a228e75d5346d26d 7cae968acf4c4b2d917416d0183f3467 RX(theta\u2081) b0777dd35e2348b4847300bdc9426ab1--7cae968acf4c4b2d917416d0183f3467 2f2a2a1cf9b94f36ba862a06382cae1c 2 118a36650524496f8fd490e55419ee0e RY(theta\u2084) 7cae968acf4c4b2d917416d0183f3467--118a36650524496f8fd490e55419ee0e 44eef4b9476f4f03ac91016d93b21684 RX(theta\u2087) 118a36650524496f8fd490e55419ee0e--44eef4b9476f4f03ac91016d93b21684 e22ab3e0a14b400e853bdbf3dcb476dd t = theta_t\u2080 44eef4b9476f4f03ac91016d93b21684--e22ab3e0a14b400e853bdbf3dcb476dd 96bf7fd5f51b4b7e856ed4a218bbb47f RX(theta\u2081\u2080) e22ab3e0a14b400e853bdbf3dcb476dd--96bf7fd5f51b4b7e856ed4a218bbb47f 39a95292a4bb4da589cb58af6e005a32 RY(theta\u2081\u2083) 96bf7fd5f51b4b7e856ed4a218bbb47f--39a95292a4bb4da589cb58af6e005a32 ac4bac55c5534ceea735dc6bb1657a9d RX(theta\u2081\u2086) 39a95292a4bb4da589cb58af6e005a32--ac4bac55c5534ceea735dc6bb1657a9d c7bdcfd2d0414215b272a0c4d81a13dd t = theta_t\u2081 ac4bac55c5534ceea735dc6bb1657a9d--c7bdcfd2d0414215b272a0c4d81a13dd c7bdcfd2d0414215b272a0c4d81a13dd--392952b41b394f80a228e75d5346d26d 0d805eeae53540e090665b5daa44a202 8518b27cea66445ba0bb2026b0c49aa2 RX(theta\u2082) 2f2a2a1cf9b94f36ba862a06382cae1c--8518b27cea66445ba0bb2026b0c49aa2 fa7991544f184d95b85ff2b5a80356cd RY(theta\u2085) 8518b27cea66445ba0bb2026b0c49aa2--fa7991544f184d95b85ff2b5a80356cd c48abfc99a10426593b4d096ce402bca RX(theta\u2088) fa7991544f184d95b85ff2b5a80356cd--c48abfc99a10426593b4d096ce402bca e6cf595a681e492d9ad9e9fa5fca3476 c48abfc99a10426593b4d096ce402bca--e6cf595a681e492d9ad9e9fa5fca3476 8ae205c78b634af1ba5e8809b7dd450b RX(theta\u2081\u2081) e6cf595a681e492d9ad9e9fa5fca3476--8ae205c78b634af1ba5e8809b7dd450b 05964090798247af95c6904b9cb9ddf1 RY(theta\u2081\u2084) 8ae205c78b634af1ba5e8809b7dd450b--05964090798247af95c6904b9cb9ddf1 863093ff24ea401b91720c7a528377c1 RX(theta\u2081\u2087) 05964090798247af95c6904b9cb9ddf1--863093ff24ea401b91720c7a528377c1 e9859f0fec6c4f3fb8ef04abd70a4362 863093ff24ea401b91720c7a528377c1--e9859f0fec6c4f3fb8ef04abd70a4362 e9859f0fec6c4f3fb8ef04abd70a4362--0d805eeae53540e090665b5daa44a202 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_9ab2d68ff1554978898fcba4200f988f cluster_a7f62477e669425b97ea7be359b6fb49 b42e17e3643d4c29a2a80954acdd9512 0 41a9543075d046e7921215fec4e1b267 RX(theta\u2080) b42e17e3643d4c29a2a80954acdd9512--41a9543075d046e7921215fec4e1b267 f2bc9c0bfc6f4880b8a984d55594259e 1 1d80a32470e34dff89b4a236d581a433 RY(theta\u2086) 41a9543075d046e7921215fec4e1b267--1d80a32470e34dff89b4a236d581a433 f0d0d050029a40c5b1199d95f2da1e6e RX(theta\u2081\u2082) 1d80a32470e34dff89b4a236d581a433--f0d0d050029a40c5b1199d95f2da1e6e ad4e4cddd8924ecc83f671b4e3c34f21 f0d0d050029a40c5b1199d95f2da1e6e--ad4e4cddd8924ecc83f671b4e3c34f21 104fb609b34a4d7b91be6cf77e186e58 RX(theta\u2081\u2088) ad4e4cddd8924ecc83f671b4e3c34f21--104fb609b34a4d7b91be6cf77e186e58 f4e5fbda81324d16a6f392382ac1aacd RY(theta\u2082\u2084) 104fb609b34a4d7b91be6cf77e186e58--f4e5fbda81324d16a6f392382ac1aacd d1084d89d4c342fabbfaf74aded9b807 RX(theta\u2083\u2080) f4e5fbda81324d16a6f392382ac1aacd--d1084d89d4c342fabbfaf74aded9b807 256c13334b2a49cb8968bb635acc644b d1084d89d4c342fabbfaf74aded9b807--256c13334b2a49cb8968bb635acc644b f078c4257975480cb73c1f41f95f9aa2 256c13334b2a49cb8968bb635acc644b--f078c4257975480cb73c1f41f95f9aa2 bfe2e0fee8b24881a9f97c81eea3ec2b 68966f600ecb48e09836ed4988b19cc6 RX(theta\u2081) f2bc9c0bfc6f4880b8a984d55594259e--68966f600ecb48e09836ed4988b19cc6 dcb356cabedf424e861d99d4cfc5edec 2 f014d938d73b44f897b7a07274a6d336 RY(theta\u2087) 68966f600ecb48e09836ed4988b19cc6--f014d938d73b44f897b7a07274a6d336 4fa658deb0d14a89b8643a05b8cbc625 RX(theta\u2081\u2083) f014d938d73b44f897b7a07274a6d336--4fa658deb0d14a89b8643a05b8cbc625 afc4aa63cb614a399532da46fdd7ec44 4fa658deb0d14a89b8643a05b8cbc625--afc4aa63cb614a399532da46fdd7ec44 b3e40a97181744ca8f8d3c8f6ca21624 RX(theta\u2081\u2089) afc4aa63cb614a399532da46fdd7ec44--b3e40a97181744ca8f8d3c8f6ca21624 c75e1da9e7c140b8bcfe23b948c6b0d5 RY(theta\u2082\u2085) b3e40a97181744ca8f8d3c8f6ca21624--c75e1da9e7c140b8bcfe23b948c6b0d5 2e12b6d51e5e4efeac7e61a6e5a504df RX(theta\u2083\u2081) c75e1da9e7c140b8bcfe23b948c6b0d5--2e12b6d51e5e4efeac7e61a6e5a504df 51aa61f7f40f4f1ca62a397a2533b91d 2e12b6d51e5e4efeac7e61a6e5a504df--51aa61f7f40f4f1ca62a397a2533b91d 51aa61f7f40f4f1ca62a397a2533b91d--bfe2e0fee8b24881a9f97c81eea3ec2b a2d2944c18e24e8bb8dbac6e7ee3df0d 608ff2cd5a104d5aa6f1878871cdd2fe RX(theta\u2082) dcb356cabedf424e861d99d4cfc5edec--608ff2cd5a104d5aa6f1878871cdd2fe 0a2b17f2a574479691babc27a498a7da 3 1a089ba9d3024ff88cfbb0f4c49b1e0d RY(theta\u2088) 608ff2cd5a104d5aa6f1878871cdd2fe--1a089ba9d3024ff88cfbb0f4c49b1e0d b7d36a99f4194750876d45904e2e81d8 RX(theta\u2081\u2084) 1a089ba9d3024ff88cfbb0f4c49b1e0d--b7d36a99f4194750876d45904e2e81d8 b91afc66cf7b45a892192c2b366421b6 HamEvo b7d36a99f4194750876d45904e2e81d8--b91afc66cf7b45a892192c2b366421b6 1d3ca6e9a48945a99952813ec8ff40e4 RX(theta\u2082\u2080) b91afc66cf7b45a892192c2b366421b6--1d3ca6e9a48945a99952813ec8ff40e4 a42fd600d1fa44ffbe98946dfd0d9135 RY(theta\u2082\u2086) 1d3ca6e9a48945a99952813ec8ff40e4--a42fd600d1fa44ffbe98946dfd0d9135 b3a2990c4f7f46caa4cf56218486a3b4 RX(theta\u2083\u2082) a42fd600d1fa44ffbe98946dfd0d9135--b3a2990c4f7f46caa4cf56218486a3b4 80f7d4eacd5b4a9097cae54513205ba0 HamEvo b3a2990c4f7f46caa4cf56218486a3b4--80f7d4eacd5b4a9097cae54513205ba0 80f7d4eacd5b4a9097cae54513205ba0--a2d2944c18e24e8bb8dbac6e7ee3df0d 04d532c38595473283e8dd455bc1c083 0453759e2c16484e93edeae04db54612 RX(theta\u2083) 0a2b17f2a574479691babc27a498a7da--0453759e2c16484e93edeae04db54612 a698d37eb71246fb96a17968c198d7b3 4 301edb7612b44dbc893b4a40485fb31b RY(theta\u2089) 0453759e2c16484e93edeae04db54612--301edb7612b44dbc893b4a40485fb31b 3a4239d8069d4023b24e948b0ab3e432 RX(theta\u2081\u2085) 301edb7612b44dbc893b4a40485fb31b--3a4239d8069d4023b24e948b0ab3e432 da580f001e2a4e5a8907ef92551f3651 t = theta_t\u2080 3a4239d8069d4023b24e948b0ab3e432--da580f001e2a4e5a8907ef92551f3651 77764db506794532bdaaf1a326f2b05e RX(theta\u2082\u2081) da580f001e2a4e5a8907ef92551f3651--77764db506794532bdaaf1a326f2b05e dedf9a142eaf401cac756b47b5bb8759 RY(theta\u2082\u2087) 77764db506794532bdaaf1a326f2b05e--dedf9a142eaf401cac756b47b5bb8759 041f96a46ddf45a1839abb3f989f2444 RX(theta\u2083\u2083) dedf9a142eaf401cac756b47b5bb8759--041f96a46ddf45a1839abb3f989f2444 c8052936438d484d9b414f50703e1ec4 t = theta_t\u2081 041f96a46ddf45a1839abb3f989f2444--c8052936438d484d9b414f50703e1ec4 c8052936438d484d9b414f50703e1ec4--04d532c38595473283e8dd455bc1c083 0f77c02bebdd44368ddb576a5e47cfbd 6694b53b1cdd4caea6420a03a66f6624 RX(theta\u2084) a698d37eb71246fb96a17968c198d7b3--6694b53b1cdd4caea6420a03a66f6624 7128345a02e84703a0b3e924f564bffb 5 20f14693a3a8466d81f47dcccfb20b05 RY(theta\u2081\u2080) 6694b53b1cdd4caea6420a03a66f6624--20f14693a3a8466d81f47dcccfb20b05 e14e62cd31f44e3bbd5dbced2f370cb3 RX(theta\u2081\u2086) 20f14693a3a8466d81f47dcccfb20b05--e14e62cd31f44e3bbd5dbced2f370cb3 584b6c1ac7b14708bf9198fe2f87e4f5 e14e62cd31f44e3bbd5dbced2f370cb3--584b6c1ac7b14708bf9198fe2f87e4f5 ad925395e7c64620bc1ea63152609f55 RX(theta\u2082\u2082) 584b6c1ac7b14708bf9198fe2f87e4f5--ad925395e7c64620bc1ea63152609f55 50bb2e50fd8843ee9ed294f51e8758a4 RY(theta\u2082\u2088) ad925395e7c64620bc1ea63152609f55--50bb2e50fd8843ee9ed294f51e8758a4 28deea3563eb4480a2278f38bab4c863 RX(theta\u2083\u2084) 50bb2e50fd8843ee9ed294f51e8758a4--28deea3563eb4480a2278f38bab4c863 87942503d9554e468b1e49f4ccde885a 28deea3563eb4480a2278f38bab4c863--87942503d9554e468b1e49f4ccde885a 87942503d9554e468b1e49f4ccde885a--0f77c02bebdd44368ddb576a5e47cfbd 353fd256dcbc4db5bfc3afcb580eeea9 055e73f1278b4910b1096b28511f2bf1 RX(theta\u2085) 7128345a02e84703a0b3e924f564bffb--055e73f1278b4910b1096b28511f2bf1 d6b93285c6b543398f91b8b45844480c RY(theta\u2081\u2081) 055e73f1278b4910b1096b28511f2bf1--d6b93285c6b543398f91b8b45844480c fb62211b2599451392ec9dbd922c2d0b RX(theta\u2081\u2087) d6b93285c6b543398f91b8b45844480c--fb62211b2599451392ec9dbd922c2d0b cc40286a30574796b30015ab1945d1d5 fb62211b2599451392ec9dbd922c2d0b--cc40286a30574796b30015ab1945d1d5 523d519dc3e145d29e41a739000d9e10 RX(theta\u2082\u2083) cc40286a30574796b30015ab1945d1d5--523d519dc3e145d29e41a739000d9e10 a112fa8c5e2d4483b9cfbac4f721a51c RY(theta\u2082\u2089) 523d519dc3e145d29e41a739000d9e10--a112fa8c5e2d4483b9cfbac4f721a51c 1d794eb62c1f4661a687577f828b39be RX(theta\u2083\u2085) a112fa8c5e2d4483b9cfbac4f721a51c--1d794eb62c1f4661a687577f828b39be 71cde6d6c26345a0b9fcbc3f19409d51 1d794eb62c1f4661a687577f828b39be--71cde6d6c26345a0b9fcbc3f19409d51 71cde6d6c26345a0b9fcbc3f19409d51--353fd256dcbc4db5bfc3afcb580eeea9"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_00724589234d4c8d8cd6eb243ced8779 BPMA-1 cluster_5e0f4feb884f48e085247cf7ab1e3595 BPMA-0 02c80b238de8419abb6315d5d4741e2d 0 99ae27fb9f5f47dbbe4c297a52f83307 RX(iia_\u03b1\u2080\u2080) 02c80b238de8419abb6315d5d4741e2d--99ae27fb9f5f47dbbe4c297a52f83307 c19b15c0cae849199236ce0ca73dcec5 1 52da5d0321744d0abfe025eab94aa9f5 RY(iia_\u03b1\u2080\u2083) 99ae27fb9f5f47dbbe4c297a52f83307--52da5d0321744d0abfe025eab94aa9f5 e3d8f1a7a6294f58bbdcf996c3a18cc5 52da5d0321744d0abfe025eab94aa9f5--e3d8f1a7a6294f58bbdcf996c3a18cc5 d667b68dfe2f4964beda8610e01689d2 e3d8f1a7a6294f58bbdcf996c3a18cc5--d667b68dfe2f4964beda8610e01689d2 725c9a70b5e0425197a62fbd6d279d85 RX(iia_\u03b3\u2080\u2080) d667b68dfe2f4964beda8610e01689d2--725c9a70b5e0425197a62fbd6d279d85 e443c94be5ce4ceca18584ebaea088dd 725c9a70b5e0425197a62fbd6d279d85--e443c94be5ce4ceca18584ebaea088dd 0148269ff9ad464c9b947e74d37eecc2 e443c94be5ce4ceca18584ebaea088dd--0148269ff9ad464c9b947e74d37eecc2 f8f9c982ae1e49faa887c5c58205fd1f RY(iia_\u03b2\u2080\u2083) 0148269ff9ad464c9b947e74d37eecc2--f8f9c982ae1e49faa887c5c58205fd1f 6a6b4ff81b2c49829c5df0fb4bffc2fb RX(iia_\u03b2\u2080\u2080) f8f9c982ae1e49faa887c5c58205fd1f--6a6b4ff81b2c49829c5df0fb4bffc2fb 6c56abf0aab5496ba88f7b860d1497e9 RX(iia_\u03b1\u2081\u2080) 6a6b4ff81b2c49829c5df0fb4bffc2fb--6c56abf0aab5496ba88f7b860d1497e9 55f3e5978dc548ee8c0aa679ca47b8c0 RY(iia_\u03b1\u2081\u2083) 6c56abf0aab5496ba88f7b860d1497e9--55f3e5978dc548ee8c0aa679ca47b8c0 9960df0fad814a198219487f30264846 55f3e5978dc548ee8c0aa679ca47b8c0--9960df0fad814a198219487f30264846 750d1a7654624ebe96be4c6aea63fdd2 9960df0fad814a198219487f30264846--750d1a7654624ebe96be4c6aea63fdd2 681e77aab3df441287c81ca72ac0e82f RX(iia_\u03b3\u2081\u2080) 750d1a7654624ebe96be4c6aea63fdd2--681e77aab3df441287c81ca72ac0e82f 6c73b161f8f844f3a7c056958aa45908 681e77aab3df441287c81ca72ac0e82f--6c73b161f8f844f3a7c056958aa45908 21cc749ac90544e19ccb7ff8d86bef2d 6c73b161f8f844f3a7c056958aa45908--21cc749ac90544e19ccb7ff8d86bef2d b744b565daaa4ae2adabf3ee8e63781c RY(iia_\u03b2\u2081\u2083) 21cc749ac90544e19ccb7ff8d86bef2d--b744b565daaa4ae2adabf3ee8e63781c 0ddc6f4978fc49668d4e4f7489197490 RX(iia_\u03b2\u2081\u2080) b744b565daaa4ae2adabf3ee8e63781c--0ddc6f4978fc49668d4e4f7489197490 ee24ed97758e4f689965ad360567a047 0ddc6f4978fc49668d4e4f7489197490--ee24ed97758e4f689965ad360567a047 baad225ea75c4e7fb060de2b049ca784 c758f3c403444fe6b9f1585813fdb743 RX(iia_\u03b1\u2080\u2081) c19b15c0cae849199236ce0ca73dcec5--c758f3c403444fe6b9f1585813fdb743 8ee3a80f55e547659e612f92fb3f3b0f 2 0d2f9cabeb4f4165928e3ff3718ee2c2 RY(iia_\u03b1\u2080\u2084) c758f3c403444fe6b9f1585813fdb743--0d2f9cabeb4f4165928e3ff3718ee2c2 f8f32be696dc4ff6bd8f1c86264d4575 X 0d2f9cabeb4f4165928e3ff3718ee2c2--f8f32be696dc4ff6bd8f1c86264d4575 f8f32be696dc4ff6bd8f1c86264d4575--e3d8f1a7a6294f58bbdcf996c3a18cc5 8f1c0c2e764f4c0d9fb0c71555fefca1 f8f32be696dc4ff6bd8f1c86264d4575--8f1c0c2e764f4c0d9fb0c71555fefca1 6db41d90fa4b4725a32711a9282820c8 RX(iia_\u03b3\u2080\u2081) 8f1c0c2e764f4c0d9fb0c71555fefca1--6db41d90fa4b4725a32711a9282820c8 d8ba82f7fb2545a5878e8d669caf2e81 6db41d90fa4b4725a32711a9282820c8--d8ba82f7fb2545a5878e8d669caf2e81 8ee617b12b0d49b4ac96101b2bbb4f57 X d8ba82f7fb2545a5878e8d669caf2e81--8ee617b12b0d49b4ac96101b2bbb4f57 8ee617b12b0d49b4ac96101b2bbb4f57--0148269ff9ad464c9b947e74d37eecc2 fbb5cdcdaab542babb47a208cfdf2315 RY(iia_\u03b2\u2080\u2084) 8ee617b12b0d49b4ac96101b2bbb4f57--fbb5cdcdaab542babb47a208cfdf2315 133976236074470ab07f0c19d7918850 RX(iia_\u03b2\u2080\u2081) fbb5cdcdaab542babb47a208cfdf2315--133976236074470ab07f0c19d7918850 f4e98da62abb4714a10980a5761f271b RX(iia_\u03b1\u2081\u2081) 133976236074470ab07f0c19d7918850--f4e98da62abb4714a10980a5761f271b c829c885ab3c44f4aeb20ff8926c5be3 RY(iia_\u03b1\u2081\u2084) f4e98da62abb4714a10980a5761f271b--c829c885ab3c44f4aeb20ff8926c5be3 cbc20b3f5f954cf5a6e635f3db7c2c23 X c829c885ab3c44f4aeb20ff8926c5be3--cbc20b3f5f954cf5a6e635f3db7c2c23 cbc20b3f5f954cf5a6e635f3db7c2c23--9960df0fad814a198219487f30264846 ff90cf10bbc1471997da857eef99ce65 cbc20b3f5f954cf5a6e635f3db7c2c23--ff90cf10bbc1471997da857eef99ce65 bdcd0b9d6d454a43ae1c62b6a55be971 RX(iia_\u03b3\u2081\u2081) ff90cf10bbc1471997da857eef99ce65--bdcd0b9d6d454a43ae1c62b6a55be971 68231e96ad1042298307dbff6e583ff8 bdcd0b9d6d454a43ae1c62b6a55be971--68231e96ad1042298307dbff6e583ff8 ecf44e02240448da98213d7ff0c49f3f X 68231e96ad1042298307dbff6e583ff8--ecf44e02240448da98213d7ff0c49f3f ecf44e02240448da98213d7ff0c49f3f--21cc749ac90544e19ccb7ff8d86bef2d ca97aa36e08c4f46b85087060f4446cc RY(iia_\u03b2\u2081\u2084) ecf44e02240448da98213d7ff0c49f3f--ca97aa36e08c4f46b85087060f4446cc 66f625b30717417396bfb281295e1ae8 RX(iia_\u03b2\u2081\u2081) ca97aa36e08c4f46b85087060f4446cc--66f625b30717417396bfb281295e1ae8 66f625b30717417396bfb281295e1ae8--baad225ea75c4e7fb060de2b049ca784 0b68b9aec9d74c1dbee743ebc0e7f5c4 23d71885e98d49efb4216d04f33a9e34 RX(iia_\u03b1\u2080\u2082) 8ee3a80f55e547659e612f92fb3f3b0f--23d71885e98d49efb4216d04f33a9e34 944d39c1374443698ff79f4910968828 RY(iia_\u03b1\u2080\u2085) 23d71885e98d49efb4216d04f33a9e34--944d39c1374443698ff79f4910968828 d38e55d15fea432fa6377f18bb56c912 944d39c1374443698ff79f4910968828--d38e55d15fea432fa6377f18bb56c912 69cc59579c9a4b2593118214a18fa5a1 X d38e55d15fea432fa6377f18bb56c912--69cc59579c9a4b2593118214a18fa5a1 69cc59579c9a4b2593118214a18fa5a1--8f1c0c2e764f4c0d9fb0c71555fefca1 a33307c43251445a990d226a455f020b RX(iia_\u03b3\u2080\u2082) 69cc59579c9a4b2593118214a18fa5a1--a33307c43251445a990d226a455f020b b89fbf7c2cf14d079fbff2710614adc3 X a33307c43251445a990d226a455f020b--b89fbf7c2cf14d079fbff2710614adc3 b89fbf7c2cf14d079fbff2710614adc3--d8ba82f7fb2545a5878e8d669caf2e81 f963a1ae9cf940cab28e2d7fb0e5b733 b89fbf7c2cf14d079fbff2710614adc3--f963a1ae9cf940cab28e2d7fb0e5b733 f9989d2b034c4e02a762b29e0cc0ca77 RY(iia_\u03b2\u2080\u2085) f963a1ae9cf940cab28e2d7fb0e5b733--f9989d2b034c4e02a762b29e0cc0ca77 bc3b2bdbd11640e4826df14ba780ae27 RX(iia_\u03b2\u2080\u2082) f9989d2b034c4e02a762b29e0cc0ca77--bc3b2bdbd11640e4826df14ba780ae27 03c38e789ff44000a9513fc07c220ba7 RX(iia_\u03b1\u2081\u2082) bc3b2bdbd11640e4826df14ba780ae27--03c38e789ff44000a9513fc07c220ba7 7ebef395dbcb483ebf43d6131d62fa7f RY(iia_\u03b1\u2081\u2085) 03c38e789ff44000a9513fc07c220ba7--7ebef395dbcb483ebf43d6131d62fa7f 1ac0ee22ed9d401587e07130982df4fe 7ebef395dbcb483ebf43d6131d62fa7f--1ac0ee22ed9d401587e07130982df4fe d090ff3d20d84092bbccd1a02a8c2bcf X 1ac0ee22ed9d401587e07130982df4fe--d090ff3d20d84092bbccd1a02a8c2bcf d090ff3d20d84092bbccd1a02a8c2bcf--ff90cf10bbc1471997da857eef99ce65 1087433a22974aa1b9deddfc84a23bf9 RX(iia_\u03b3\u2081\u2082) d090ff3d20d84092bbccd1a02a8c2bcf--1087433a22974aa1b9deddfc84a23bf9 f50eea4c76cf49bc866c1190e2313b08 X 1087433a22974aa1b9deddfc84a23bf9--f50eea4c76cf49bc866c1190e2313b08 f50eea4c76cf49bc866c1190e2313b08--68231e96ad1042298307dbff6e583ff8 1460c19fb8554aab8f07fb192b43ee5e f50eea4c76cf49bc866c1190e2313b08--1460c19fb8554aab8f07fb192b43ee5e 60d872d53f24474088c56a1e2577fbff RY(iia_\u03b2\u2081\u2085) 1460c19fb8554aab8f07fb192b43ee5e--60d872d53f24474088c56a1e2577fbff 4cc90e19e824473ebe5c9c5367b9104d RX(iia_\u03b2\u2081\u2082) 60d872d53f24474088c56a1e2577fbff--4cc90e19e824473ebe5c9c5367b9104d 4cc90e19e824473ebe5c9c5367b9104d--0b68b9aec9d74c1dbee743ebc0e7f5c4"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>Sample-based measurement protocols are fundamental tools for the prediction and estimation of a quantum state as the result of NISQ programs executions. Their resource efficient implementation is a current and active research field. Qadence offers two main measurement protocols: quantum state tomography and classical shadows.</p>"},{"location":"realistic_sims/measurements/#quantum-state-tomography","title":"Quantum state tomography","text":"<p>The fundamental task of quantum state tomography is to learn an approximate classical description of an output quantum state described by a density matrix \\(\\rho\\), from repeated measurements of copies on a chosen basis. To do so, \\(\\rho\\) is expanded in a basis of observables (the tomography step) and for a given observable \\(\\hat{\\mathcal{O}}\\), the expectation value is calculated with \\(\\langle \\hat{\\mathcal{O}} \\rangle=\\textrm{Tr}(\\hat{\\mathcal{O}}\\rho)\\). A number of measurement repetitions in a suitable basis is then required to estimate \\(\\langle \\hat{\\mathcal{O}} \\rangle\\).</p> <p>The main drawback is the scaling in measurements for the retrieval of the classical expression for a \\(n\\)-qubit quantum state as \\(2^n \\times 2^n\\), together with a large amount of classical post-processing.</p> <p>For an observable expressed as a Pauli string \\(\\hat{\\mathcal{P}}\\), the expectation value for a state \\(|\\psi \\rangle\\) can be derived as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\langle \\psi | \\hat{\\mathcal{P}} |\\psi \\rangle=\\langle \\psi | \\hat{\\mathcal{R}}^\\dagger \\hat{\\mathcal{D}} \\hat{\\mathcal{R}} |\\psi \\rangle \\] <p>The operator \\(\\hat{\\mathcal{R}}\\) diagonalizes \\(\\hat{\\mathcal{P}}\\) and rotates the state into an eigenstate in the computational basis. Therefore, \\(\\hat{\\mathcal{R}}|\\psi \\rangle=\\sum\\limits_{z}a_z|z\\rangle\\) and the expectation value can finally be expressed as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\sum_{z,z'}\\langle z |\\bar{a}_z\\hat{\\mathcal{D}}a_{z'}|z'\\rangle = \\sum_{z}|a_z|^2(-1)^{\\phi_z(\\hat{\\mathcal{P}})} \\] <p>In Qadence, running a tomographical experiment is made simple by defining a <code>Measurements</code> object that captures all options for execution:</p> <pre><code>from torch import tensor\nfrom qadence import hamiltonian_factory, BackendName, DiffMode\nfrom qadence import Parameter, chain, kron, RX, RY, Z, QuantumCircuit, QuantumModel\nfrom qadence.measurements import Measurements\n\n# Define parameters for a circuit.\ntheta1 = Parameter(\"theta1\", trainable=False)\ntheta2 = Parameter(\"theta2\", trainable=False)\ntheta3 = Parameter(\"theta3\", trainable=False)\ntheta4 = Parameter(\"theta4\", trainable=False)\n\nblocks = chain(\n    kron(RX(0, theta1), RY(1, theta2)),\n    kron(RX(0, theta3), RY(1, theta4)),\n)\n\nvalues = {\n    \"theta1\": tensor([0.5]),\n    \"theta2\": tensor([1.5]),\n    \"theta3\": tensor([2.0]),\n    \"theta4\": tensor([2.5]),\n}\n\n# Create a circuit and an observable.\ncircuit = QuantumCircuit(2, blocks)\nobservable = hamiltonian_factory(2, detuning=Z)\n\n# Create a model.\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n)\n\n# Define a measurement protocol by passing the shot budget as an option.\ntomo_options = {\"n_shots\": 100000}\ntomo_measurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=tomo_options)\n\n# Get the exact expectation value.\nexact_values = model.expectation(\n    values=values,\n)\n\n# Run the tomography experiment.\nestimated_values_tomo = model.expectation(\n    values=values,\n    measurement=tomo_measurement,\n)\n</code></pre> <pre><code>Exact expectation value = tensor([[-1.4548]])\nEstimated expectation value tomo = tensor([[-1.4503]])\n</code></pre>"},{"location":"realistic_sims/measurements/#classical-shadows","title":"Classical shadows","text":"<p>Recently, a much less resource demanding protocol based on classical shadows has been proposed<sup>1</sup>. It combines ideas from shadow tomography<sup>2</sup> and randomized measurement protocols capable of learning a classical shadow of an unknown quantum state \\(\\rho\\). It relies on deliberately discarding the full classical characterization of the quantum state, and instead focuses on accurately predicting a restricted set of properties that provide efficient protocols for the study of the system.</p> <p>A random measurement consists of applying random unitary rotations before a fixed measurement on each copy of a state. Appropriately averaging over these measurements produces an efficient estimator for the expectation value of an observable. This protocol therefore creates a robust classical representation of the quantum state or classical shadow. The captured measurement information is then reuseable for multiple purposes, i.e. any observable expected value and available for noise mitigation postprocessing.</p> <p>A classical shadow is therefore an unbiased estimator of a quantum state \\(\\rho\\). Such an estimator is obtained with the following procedure<sup>1</sup>: first, apply a random unitary gate \\(U\\) to rotate the state: \\(\\rho \\rightarrow U \\rho U^\\dagger\\) and then perform a basis measurement to obtain a \\(n\\)-bit measurement \\(|\\hat{b}\\rangle \\in \\{0, 1\\}^n\\). Both unitary gates \\(U\\) and the measurement outcomes \\(|\\hat{b}\\rangle\\) are stored on a classical computer for postprocessing v \\(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U\\), a classical snapshot of the state \\(\\rho\\). The whole procedure can be seen as a quantum channel \\(\\mathcal{M}\\) that maps the initial unknown quantum state \\(\\rho\\) to the average result of the measurement protocol:</p> \\[ \\mathbb{E}[U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U] = \\mathcal{M}(\\rho) \\Rightarrow \\rho = \\mathbb{E}[\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)] \\] <p>It is worth noting that the single classical snapshot \\(\\hat{\\rho}=\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)\\) equals \\(\\rho\\) in expectation: \\(\\mathbb{E}[\\hat{\\rho}]=\\rho\\) despite \\(\\mathcal{M}^{-1}\\) not being a completely positive map. Repeating this procedure \\(N\\) times results in an array of \\(N\\) independent, classical snapshots of \\(\\rho\\) called the classical shadow:</p> \\[ S(\\rho, N) = \\{ \\hat{\\rho}_1=\\mathcal{M}^{-1}(U_1^\\dagger |\\hat{b}_1\\rangle\\langle \\hat{b}_1|U_1),\\cdots,\\hat{\\rho}_N=\\mathcal{M}^{-1}(U_N^\\dagger |\\hat{b}_N\\rangle\\langle \\hat{b}_N|U_N)\\} \\] <p>Along the same lines as the example before, estimating the expectation value using classical shadows in Qadence only requires to pass the right set of parameters to the <code>Measurements</code> object:</p> <pre><code># Classical shadows are defined up to some accuracy and confidence.\nshadow_options = {\"accuracy\": 0.1, \"confidence\": 0.1}  # Shadow size N=54400.\nshadow_measurement = Measurements(protocol=Measurements.SHADOW, options=shadow_options)\n\n# Run the experiment with classical shadows.\nestimated_values_shadow = model.expectation(\n    values=values,\n    measurement=shadow_measurement,\n)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-1.5018]])\n</code></pre>"},{"location":"realistic_sims/measurements/#references","title":"References","text":"<ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9\u21a9</p> </li> <li> <p>S. Aaronson. Shadow tomography of quantum states. In Proceedings of the 50th Annual A ACM SIGACT Symposium on Theory of Computing, STOC 2018, pages 325\u2013338, New York, NY, USA, 2018. ACM\u00a0\u21a9</p> </li> </ol>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>Beyond running noisy simulations, Qadence offers a number of noise mitigation techniques to achieve better accuracy of simulation outputs. Currently, mitigation addresses readout errors and depolarizing and dephasing noise for analog blocks.</p>"},{"location":"realistic_sims/mitigation/#readout-error-mitigation","title":"Readout error mitigation","text":"<p>The complete implementation of the mitigation technique is to measure \\(T\\) and classically apply \\(T^{\u22121}\\) to measured probability distributions. However there are several limitations of this approach:</p> <ul> <li>The complete implementation requires \\(2^n\\) characterization experiments (probability measurements), which is not scalable. The classical processing of the calibration data is also inefficient.</li> <li>The matrix \\(T\\) may become singular for large \\(n\\), preventing direct inversion.</li> <li>The inverse \\(T^{\u22121}\\) might not be a stochastic matrix, meaning that it can produce negative corrected probabilities.</li> <li>The correction is not rigorously justified, so we cannot be sure that we are only removing SPAM errors and not otherwise corrupting an estimated probability distribution.</li> </ul> <p>Qadence relies on the assumption of uncorrelated readout errors:</p> \\[ T=T_1\\otimes T_2\\otimes \\dots \\otimes T_n \\] <p>for which the inversion is straightforward:</p> \\[ T^{-1}=T_1^{-1}\\otimes T_2^{-1}\\otimes \\dots \\otimes T_n^{-1} \\] <p>However, even for a reduced \\(n\\) the third limitation holds. This can be avoided by reformulating into a minimization problem<sup>1</sup>:</p> \\[ \\lVert Tp_{\\textrm{corr}}-p_{\\textrm{raw}}\\rVert_{2}^{2} \\] <p>subjected to physicality constraints \\(0 \\leq p_{corr}(x) \\leq 1\\) and \\(\\lVert p_{corr} \\rVert = 1\\). At this point, two methods are implemented to solve this problem. The first one relies on solving using standard optimization tools, the second on Maximum-Likelihood Estimation<sup>2</sup>. In Qadence, this can be user defined using the mitigation protocol:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\nfrom qadence.mitigations import Mitigations\nfrom qadence.types import ReadOutOptimization\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use:\nnoise = Noise(protocol=Noise.READOUT)\n# Define the mitigation method solving the minimization problem:\noptions={\"optimization_type\": ReadOutOptimization.CONSTRAINED}  # ReadOutOptimization.MLE for the alternative method.\nmitigation = Mitigations(protocol=Mitigations.READOUT, options=options)\n\n# Run noiseless, noisy and mitigated simulations.\nn_shots = 100\nnoiseless_samples = model.sample(n_shots=n_shots)\nnoisy_samples = model.sample(noise=noise, n_shots=n_shots)\nmitigated_samples = model.sample(\n    noise=noise, mitigation=mitigation, n_shots=n_shots\n)\n\nprint(f\"noiseless {noiseless_samples}\")\nprint(f\"noisy {noisy_samples}\")\nprint(f\"mitigated {mitigated_samples}\")\n</code></pre> <pre><code>noiseless [Counter({'10': 54, '00': 46})]\nnoisy [Counter({'10': 52, '00': 39, '01': 6, '11': 3})]\nmitigated [Counter({'10': 44, '00': 43, '11': 7, '01': 6})]\n</code></pre>"},{"location":"realistic_sims/mitigation/#wip-zero-noise-extrapolation-for-analog-blocks","title":"[WIP] Zero-noise extrapolation for analog blocks","text":"<p>Zero-noise extrapolation (ZNE) is an error mitigation technique in which an expectation value is computed at different noise levels and, as a second step, the ideal expectation value is inferred by extrapolating the measured results to the zero-noise limit. In digital computing, this is typically implemented by \"folding\" the circuit and its dagger to artificially increase the noise through sequences of identities<sup>3</sup>. In the analog ZNE variation, analog blocks are time stretched to again artificially increase noise<sup>3</sup>.</p>"},{"location":"realistic_sims/mitigation/#references","title":"References","text":"<ol> <li> <p>Michael R. Geller and Mingyu Sun, Efficient correction of multiqubit measurement errors, (2020) \u21a9</p> </li> <li> <p>Smolin et al., Maximum Likelihood, Minimum Effort, (2011) \u21a9</p> </li> <li> <p>Mitiq: What's the theory behind ZNE? \u21a9\u21a9</p> </li> </ol>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. They are typically described using confusion matrices of the form:</p> \\[ T(x|x')=\\delta_{xx'} \\] <p>Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'10': 55, '00': 45})]\nnoisy = [Counter({'00': 49, '10': 46, '11': 4, '01': 1})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[1.0126]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9760]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': f661f594-d246-4ba3-a816-96cf047a05a0, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 2ba27c3a-a581-4156-8dc3-0e08ece6a8da, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': b2b9678a-90b0-4d04-845d-46aad14537b0, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 4a80c31e-ac6e-49af-b62d-33a2f3cc8c41, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': baef56fe-9af6-496f-a625-21fe6776e85f, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 24418da8-0670-4889-a3d0-b44899d518a1, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 9b164845-ecdb-4fac-81a6-394a445ad14a, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 4a5cf522-ae47-4156-849a-0da420b16cb4, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 3cc627c5-a934-4cb6-9879-e7909fde75bc, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 65846e1c-1cb1-4d0a-b715-def72e54fb19, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 050627d9-7738-40d0-a0db-3e127010cdb4, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_2: tensor([0.0286], requires_grad=True)\n  theta_1: tensor([0.0567], requires_grad=True)\n  theta_5: tensor([0.1901], requires_grad=True)\n  theta_8: tensor([0.4730], requires_grad=True)\n  theta_4: tensor([0.4681], requires_grad=True)\n  theta_0: tensor([0.2443], requires_grad=True)\n  theta_3: tensor([0.9100], requires_grad=True)\n  theta_7: tensor([0.5714], requires_grad=True)\n  theta_6: tensor([0.3384], requires_grad=True)\n}\nembedded = {\n  f661f594-d246-4ba3-a816-96cf047a05a0: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  2ba27c3a-a581-4156-8dc3-0e08ece6a8da: tensor([2., 2.])\n  b2b9678a-90b0-4d04-845d-46aad14537b0: tensor([0.2443], grad_fn=&lt;ViewBackward0&gt;)\n  4a80c31e-ac6e-49af-b62d-33a2f3cc8c41: tensor([0.0567], grad_fn=&lt;ViewBackward0&gt;)\n  baef56fe-9af6-496f-a625-21fe6776e85f: tensor([0.0286], grad_fn=&lt;ViewBackward0&gt;)\n  24418da8-0670-4889-a3d0-b44899d518a1: tensor([0.9100], grad_fn=&lt;ViewBackward0&gt;)\n  9b164845-ecdb-4fac-81a6-394a445ad14a: tensor([0.4681], grad_fn=&lt;ViewBackward0&gt;)\n  4a5cf522-ae47-4156-849a-0da420b16cb4: tensor([0.1901], grad_fn=&lt;ViewBackward0&gt;)\n  3cc627c5-a934-4cb6-9879-e7909fde75bc: tensor([0.3384], grad_fn=&lt;ViewBackward0&gt;)\n  65846e1c-1cb1-4d0a-b715-def72e54fb19: tensor([0.5714], grad_fn=&lt;ViewBackward0&gt;)\n  050627d9-7738-40d0-a0db-3e127010cdb4: tensor([0.4730], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  theta_2: tensor([0.0286], grad_fn=&lt;ViewBackward0&gt;)\n  theta_1: tensor([0.0567], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.1901], grad_fn=&lt;ViewBackward0&gt;)\n  theta_8: tensor([0.4730], grad_fn=&lt;ViewBackward0&gt;)\n  theta_4: tensor([0.4681], grad_fn=&lt;ViewBackward0&gt;)\n  theta_0: tensor([0.2443], grad_fn=&lt;ViewBackward0&gt;)\n  theta_3: tensor([0.9100], grad_fn=&lt;ViewBackward0&gt;)\n  theta_7: tensor([0.5714], grad_fn=&lt;ViewBackward0&gt;)\n  y: tensor([2., 2.])\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  theta_6: tensor([0.3384], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.1024-0.2150j, -0.0442-0.0478j,  0.1181-0.0056j,  0.1793+0.3932j,\n         -0.6275-0.4645j, -0.1817+0.1123j,  0.0725+0.0232j,  0.0196+0.2776j],\n        [ 0.1024-0.2150j, -0.0442-0.0478j,  0.1181-0.0056j,  0.1793+0.3932j,\n         -0.6275-0.4645j, -0.1817+0.1123j,  0.0725+0.0232j,  0.0196+0.2776j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 250, '100': 190, '011': 145, '111': 140, '001': 88, '110': 67, '101': 62, '010': 58})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(f661f594-d246-4ba3-a816-96cf047a05a0)-C----------------------------------------Rx(b2b9678a-90b0-4d04-845d-46aad14537b0)-Ry(24418da8-0670-4889-a3d0-b44899d518a1)-Rx(3cc627c5-a934-4cb6-9879-e7909fde75bc)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(2ba27c3a-a581-4156-8dc3-0e08ece6a8da)-X----------------------------------------Rx(4a80c31e-ac6e-49af-b62d-33a2f3cc8c41)-Ry(9b164845-ecdb-4fac-81a6-394a445ad14a)-Rx(65846e1c-1cb1-4d0a-b715-def72e54fb19)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(baef56fe-9af6-496f-a625-21fe6776e85f)-Ry(4a5cf522-ae47-4156-849a-0da420b16cb4)-Rx(050627d9-7738-40d0-a0db-3e127010cdb4)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [050627d9-7738-40d0-a0db-3e127010cdb4, 24418da8-0670-4889-a3d0-b44899d518a1, 2ba27c3a-a581-4156-8dc3-0e08ece6a8da, 3cc627c5-a934-4cb6-9879-e7909fde75bc, 4a5cf522-ae47-4156-849a-0da420b16cb4, 4a80c31e-ac6e-49af-b62d-33a2f3cc8c41, 65846e1c-1cb1-4d0a-b715-def72e54fb19, 9b164845-ecdb-4fac-81a6-394a445ad14a, b2b9678a-90b0-4d04-845d-46aad14537b0, baef56fe-9af6-496f-a625-21fe6776e85f, f661f594-d246-4ba3-a816-96cf047a05a0].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(1.23)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.24)-DEPO(0.1)-Ry(0.91)-DEPO(0.1)-Rx(0.34)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.83)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.06)-DEPO(0.1)-Ry(0.47)-DEPO(0.1)-Rx(0.57)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.03)-DEPO(0.1)-Ry(0.19)-DEPO(0.1)-Rx(0.47)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 e6ddae30bbf3417e8534b7b4da3ff0c8 0 d95aeb2a31f24edd9ec9920b22932dc5 X e6ddae30bbf3417e8534b7b4da3ff0c8--d95aeb2a31f24edd9ec9920b22932dc5 aea3a476549a471482d97c6bcaa2259c 1 e97fff15999345e3852d318d2fafdacb d95aeb2a31f24edd9ec9920b22932dc5--e97fff15999345e3852d318d2fafdacb 319a40c828a4467f8eec7f426c1265fe 0a8e12d4d69f4696b6b5c229207ad2e1 Y aea3a476549a471482d97c6bcaa2259c--0a8e12d4d69f4696b6b5c229207ad2e1 0a8e12d4d69f4696b6b5c229207ad2e1--319a40c828a4467f8eec7f426c1265fe </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 18e6ad7a8e3b42b8ad437357e0632d71 0 b8a7988be527471db9919040edbb7127 RX(0.5) 18e6ad7a8e3b42b8ad437357e0632d71--b8a7988be527471db9919040edbb7127 f571d2671d98452d8c4969b11ba19e1f b8a7988be527471db9919040edbb7127--f571d2671d98452d8c4969b11ba19e1f <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 035e41fe86e94690aac6e97f629dd23a 0 0af6930c897845c884a61ed7bb6011c1 035e41fe86e94690aac6e97f629dd23a--0af6930c897845c884a61ed7bb6011c1 a1be6c3a0b7149f7b8e5cb505d3b1c10 1 181325c25eb844cb8d6859ed0bfea4e6 0af6930c897845c884a61ed7bb6011c1--181325c25eb844cb8d6859ed0bfea4e6 9c2c6d0f352645b08ce357d87c85d82a fc5e5442d1024e06a434af5d434bd3f0 X a1be6c3a0b7149f7b8e5cb505d3b1c10--fc5e5442d1024e06a434af5d434bd3f0 fc5e5442d1024e06a434af5d434bd3f0--0af6930c897845c884a61ed7bb6011c1 fc5e5442d1024e06a434af5d434bd3f0--9c2c6d0f352645b08ce357d87c85d82a <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 994885b3920d44dca92667d215950631 0 4b5cc474a6bb4df9aa4525eca798a363 X 994885b3920d44dca92667d215950631--4b5cc474a6bb4df9aa4525eca798a363 3cf1d3ca9889416dbba48a484fced502 X 4b5cc474a6bb4df9aa4525eca798a363--3cf1d3ca9889416dbba48a484fced502 6cc9aa0d4d744e808c92bceb442d08e5 3cf1d3ca9889416dbba48a484fced502--6cc9aa0d4d744e808c92bceb442d08e5 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 8be62adc4a224a92809a3c44e47e8136 0 ffa726eb460c4f4da9be465fc1b12ea2 X 8be62adc4a224a92809a3c44e47e8136--ffa726eb460c4f4da9be465fc1b12ea2 45cda5aa62da4d63a6246d912161e65a 1 a77cf0ffa88c41798e686dac524c77c5 ffa726eb460c4f4da9be465fc1b12ea2--a77cf0ffa88c41798e686dac524c77c5 9c662be1b7f24c06aeff5622accdbf57 a77cf0ffa88c41798e686dac524c77c5--9c662be1b7f24c06aeff5622accdbf57 1be8c353ca4045d8a3f681963e3303e8 d982eed8c7aa4f399e3821a9ba29d0f9 45cda5aa62da4d63a6246d912161e65a--d982eed8c7aa4f399e3821a9ba29d0f9 f257679c9e38499f96dd7a3751172097 X d982eed8c7aa4f399e3821a9ba29d0f9--f257679c9e38499f96dd7a3751172097 f257679c9e38499f96dd7a3751172097--1be8c353ca4045d8a3f681963e3303e8 </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 754909d9ca0a4ef88620264ceeddb0e7 0 6e78fc9e19164d6ea63263697cc32492 X 754909d9ca0a4ef88620264ceeddb0e7--6e78fc9e19164d6ea63263697cc32492 c222196cf28b48a79f117ccae94a55ef 1 8d68845f93424e088359df0980a4c20a 6e78fc9e19164d6ea63263697cc32492--8d68845f93424e088359df0980a4c20a 5bcbe96571e64cbd9af942affc25dbb2 620a7f30e5884c6c970d5d469e756dc0 X c222196cf28b48a79f117ccae94a55ef--620a7f30e5884c6c970d5d469e756dc0 620a7f30e5884c6c970d5d469e756dc0--5bcbe96571e64cbd9af942affc25dbb2 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_d1b9fcec1b534c95a4579cef44b2cb08 subblock cluster_2c7d5247679d408bbf79c22570a6ccfa subblock ca8e1fe35e964a33a4849a494ba4cfbd 0 46f4f4a787314101a3e06627f0090341 X ca8e1fe35e964a33a4849a494ba4cfbd--46f4f4a787314101a3e06627f0090341 72a84628f7f8419dade743c9f3c49923 1 07385f2024e249e5baa96842534b76ea X 46f4f4a787314101a3e06627f0090341--07385f2024e249e5baa96842534b76ea a5389aba5d7b41ab9a8842e55822fceb 07385f2024e249e5baa96842534b76ea--a5389aba5d7b41ab9a8842e55822fceb b47bdd1920be4cdfb235ec8adedbcd75 6e1796fc99c64acebcf1662685fdf7aa Y 72a84628f7f8419dade743c9f3c49923--6e1796fc99c64acebcf1662685fdf7aa f9c5a8472e4e40f2a636b8e64a20ffed 2 1360e205970841d8bd174b4ae6e9865a Y 6e1796fc99c64acebcf1662685fdf7aa--1360e205970841d8bd174b4ae6e9865a 1360e205970841d8bd174b4ae6e9865a--b47bdd1920be4cdfb235ec8adedbcd75 357344c5bc364915b6b5022294d2aa58 c2fbbe5baab045c8bb1460ef71de228c f9c5a8472e4e40f2a636b8e64a20ffed--c2fbbe5baab045c8bb1460ef71de228c 19b4b50aab264412a9c9a365fff0602d 3 dde429a1a7814c799474e1445a48f827 c2fbbe5baab045c8bb1460ef71de228c--dde429a1a7814c799474e1445a48f827 dde429a1a7814c799474e1445a48f827--357344c5bc364915b6b5022294d2aa58 be8650714a6348dba24282f3007b348c 5aa7f05b87694783856be6ffa8989ecc 19b4b50aab264412a9c9a365fff0602d--5aa7f05b87694783856be6ffa8989ecc 29b418ba89e446929cd96f80cc1a8ab4 4 6fc525c59e14483396aefaa7177deaf8 5aa7f05b87694783856be6ffa8989ecc--6fc525c59e14483396aefaa7177deaf8 6fc525c59e14483396aefaa7177deaf8--be8650714a6348dba24282f3007b348c 7dec0f92e98c4330bec73ff5563a9bc4 8efc31e98a794184bda3cc8e08b08c19 X 29b418ba89e446929cd96f80cc1a8ab4--8efc31e98a794184bda3cc8e08b08c19 8efc31e98a794184bda3cc8e08b08c19--5aa7f05b87694783856be6ffa8989ecc 2c3c7143cb2b4c41ada4d030c2bee427 X 8efc31e98a794184bda3cc8e08b08c19--2c3c7143cb2b4c41ada4d030c2bee427 2c3c7143cb2b4c41ada4d030c2bee427--6fc525c59e14483396aefaa7177deaf8 2c3c7143cb2b4c41ada4d030c2bee427--7dec0f92e98c4330bec73ff5563a9bc4"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'11': 262, '00': 249, '10': 248, '01': 241})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'100': 30, '010': 27, '000': 24, '110': 19})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Alternatively, a custom interaction function can also be defined. The input should be two integer indices \\(i\\) and \\(j\\) and it should return a composition of pauli terms representing the interaction between qubits \\(i\\) and \\(j\\):</p> <pre><code>def custom_int(i: int, j: int):\n    return X(i) @ X(j) + Y(i) @ Y(j)\n\nn_qubits = 2\n\nhamilt = hamiltonian_factory(n_qubits, interaction=custom_int)\n</code></pre> <pre><code>AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 AddBlock(0,1)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u251c\u2500\u2500 X(0)\n        \u2502   \u2514\u2500\u2500 X(1)\n        \u2514\u2500\u2500 KronBlock(0,1)\n            \u251c\u2500\u2500 Y(0)\n            \u2514\u2500\u2500 Y(1)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(1)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import numpy as np\nfrom torch import tensor\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea, PI\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": tensor([PI / 2, PI])}\nvalues_ket = {\"psi\": tensor([PI / 2, PI])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[0.2568, 0.0030],\n        [0.0140, 0.0074]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from qadence import RX, run, PI\n\n# Let's use a torch type.\nblock = RX(0, PI)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9048+0.0000j, 0.0000-0.4258j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.9633+0.0000j, 0.0000-0.2685j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.8746+0.0000j, 0.3181+0.0000j, 0.0000-0.3439j, 0.0000-0.1251j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_46f3795f5751467ebb4ba1eb505922c6 [* 2] cluster_ba3ab2e1c9104792b5dce9d4a11defb9 Rotations 630ebed8da7c4958822607ecfbf405bb 0 538d9192b9144c5d8dd86302575d5a74 RX(phi/theta) 630ebed8da7c4958822607ecfbf405bb--538d9192b9144c5d8dd86302575d5a74 f69865c057e049f88d15baa8ef2b7b00 1 97f4f0f3b3c146a095bbf552a954428c RX(phi) 538d9192b9144c5d8dd86302575d5a74--97f4f0f3b3c146a095bbf552a954428c 930a8c49c85d4272a7e08090cd811a14 RX(phi) 97f4f0f3b3c146a095bbf552a954428c--930a8c49c85d4272a7e08090cd811a14 fece82fe719e4876a82b87f46d92b55b RX(phi + theta) 930a8c49c85d4272a7e08090cd811a14--fece82fe719e4876a82b87f46d92b55b c40f134d7c894ccdb6b2974952a9905d fece82fe719e4876a82b87f46d92b55b--c40f134d7c894ccdb6b2974952a9905d b7b43e0bd4144e778c9d9f936c86982e c40f134d7c894ccdb6b2974952a9905d--b7b43e0bd4144e778c9d9f936c86982e 3f9f218dfae6486199dfcb0c5eebce56 Z b7b43e0bd4144e778c9d9f936c86982e--3f9f218dfae6486199dfcb0c5eebce56 a2fe4ba8b3654c2990df4a0d436f72fa 3f9f218dfae6486199dfcb0c5eebce56--a2fe4ba8b3654c2990df4a0d436f72fa 5b5c263673394c3d8f3ef8928a090c6e bfca42085d2142ed9b35217aeaa4583d RY(2*theta) f69865c057e049f88d15baa8ef2b7b00--bfca42085d2142ed9b35217aeaa4583d 4799373416d54166a451a026a0205c41 2 6a485b3e1b294cc78d72b4fa9058b3cf RY(theta) bfca42085d2142ed9b35217aeaa4583d--6a485b3e1b294cc78d72b4fa9058b3cf bfe57cd5fc5f43f882a9b70b6b7df0f2 RY(theta) 6a485b3e1b294cc78d72b4fa9058b3cf--bfe57cd5fc5f43f882a9b70b6b7df0f2 aee23cbb6b8d42a3aef1a0ab5e7def8c RY(theta**2) bfe57cd5fc5f43f882a9b70b6b7df0f2--aee23cbb6b8d42a3aef1a0ab5e7def8c b88e61e5c35a47b784cf57add92d4604 X aee23cbb6b8d42a3aef1a0ab5e7def8c--b88e61e5c35a47b784cf57add92d4604 b88e61e5c35a47b784cf57add92d4604--c40f134d7c894ccdb6b2974952a9905d dd173beaeb42409fab3a921c7c4a2c30 b88e61e5c35a47b784cf57add92d4604--dd173beaeb42409fab3a921c7c4a2c30 e1ce0af121704be181008b4a94a579a2 Z dd173beaeb42409fab3a921c7c4a2c30--e1ce0af121704be181008b4a94a579a2 e1ce0af121704be181008b4a94a579a2--5b5c263673394c3d8f3ef8928a090c6e 10156a06641f47c593336c4f688d89f4 3c61eb6cd67f4b54aec4127769c1bbd4 RZ(cos(phi)) 4799373416d54166a451a026a0205c41--3c61eb6cd67f4b54aec4127769c1bbd4 6a678f83a6d349429fb93588d128f511 RZ(phi) 3c61eb6cd67f4b54aec4127769c1bbd4--6a678f83a6d349429fb93588d128f511 a5f4c1ecabea47be903ab674e7778581 RZ(phi) 6a678f83a6d349429fb93588d128f511--a5f4c1ecabea47be903ab674e7778581 e22b6290437d4928b4441bd4312fdd00 RZ(cos(phi)) a5f4c1ecabea47be903ab674e7778581--e22b6290437d4928b4441bd4312fdd00 783096f549704bf7b70b07751c546380 e22b6290437d4928b4441bd4312fdd00--783096f549704bf7b70b07751c546380 9782518acbfb4bf6916339b497c55ceb X 783096f549704bf7b70b07751c546380--9782518acbfb4bf6916339b497c55ceb 9782518acbfb4bf6916339b497c55ceb--dd173beaeb42409fab3a921c7c4a2c30 9f2eb47b63a64ee39084639cc61db172 Z 9782518acbfb4bf6916339b497c55ceb--9f2eb47b63a64ee39084639cc61db172 9f2eb47b63a64ee39084639cc61db172--10156a06641f47c593336c4f688d89f4 <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.6122]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.8583+0.0000j, 0.3487+0.0000j, 0.0000-0.3487j, 0.0000-0.1417j],\n        [0.9034+0.0000j, 0.2954+0.0000j, 0.0000-0.2954j, 0.0000-0.0966j],\n        [0.6968+0.0000j, 0.4597+0.0000j, 0.0000-0.4597j, 0.0000-0.3032j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 6bd5cdb6358b4b328ac3079b3ca5aa2d 0 d2dee1d3e6644a4ca048a6ba10835972 RX(theta\u2080) 6bd5cdb6358b4b328ac3079b3ca5aa2d--d2dee1d3e6644a4ca048a6ba10835972 1988908b29ca487e92b05a8b37c61f7b 1 392c46d049554d0d856364bbc124d3ff RY(theta\u2084) d2dee1d3e6644a4ca048a6ba10835972--392c46d049554d0d856364bbc124d3ff 145549be7b7d4092b8b5641c6e7a381f RX(theta\u2088) 392c46d049554d0d856364bbc124d3ff--145549be7b7d4092b8b5641c6e7a381f 3e47908682d6408c9a4978be48f5bef3 145549be7b7d4092b8b5641c6e7a381f--3e47908682d6408c9a4978be48f5bef3 6a65e310ee8f4816b38c8111c264de85 3e47908682d6408c9a4978be48f5bef3--6a65e310ee8f4816b38c8111c264de85 0c84ca025db340cb86ae99dc10ba35e4 RX(theta\u2081\u2082) 6a65e310ee8f4816b38c8111c264de85--0c84ca025db340cb86ae99dc10ba35e4 ce0a889114d34c38a8acc0ca6105d93f RY(theta\u2081\u2086) 0c84ca025db340cb86ae99dc10ba35e4--ce0a889114d34c38a8acc0ca6105d93f 0b448633e5054a7db6baaff03aa5341b RX(theta\u2082\u2080) ce0a889114d34c38a8acc0ca6105d93f--0b448633e5054a7db6baaff03aa5341b c625fcd3d3514ae1be385c500bbae196 0b448633e5054a7db6baaff03aa5341b--c625fcd3d3514ae1be385c500bbae196 4a2631ce204a4c6c8e5db8b250c52348 c625fcd3d3514ae1be385c500bbae196--4a2631ce204a4c6c8e5db8b250c52348 f2e27204ec56452398f6341f25feb374 4a2631ce204a4c6c8e5db8b250c52348--f2e27204ec56452398f6341f25feb374 381c32e2e02847a0b2f4472bf33f2f47 12cc33bac82744f0910228364349d826 RX(theta\u2081) 1988908b29ca487e92b05a8b37c61f7b--12cc33bac82744f0910228364349d826 1caf20dcd8054c1488b091076b1b7243 2 341769c994c94ebba43bbc551089c1ba RY(theta\u2085) 12cc33bac82744f0910228364349d826--341769c994c94ebba43bbc551089c1ba 3311c23d73cc4dfd90f0205d2f1915b8 RX(theta\u2089) 341769c994c94ebba43bbc551089c1ba--3311c23d73cc4dfd90f0205d2f1915b8 f48998460a5e42eb9ac056c273193d1e X 3311c23d73cc4dfd90f0205d2f1915b8--f48998460a5e42eb9ac056c273193d1e f48998460a5e42eb9ac056c273193d1e--3e47908682d6408c9a4978be48f5bef3 e6581d3ea7ac4acd910ff73afaac8c10 f48998460a5e42eb9ac056c273193d1e--e6581d3ea7ac4acd910ff73afaac8c10 230df82bf6724136a53bf025acb99e0f RX(theta\u2081\u2083) e6581d3ea7ac4acd910ff73afaac8c10--230df82bf6724136a53bf025acb99e0f 28f8546650674450a9def031fa710d8d RY(theta\u2081\u2087) 230df82bf6724136a53bf025acb99e0f--28f8546650674450a9def031fa710d8d 3ff33bb374684a49b291d069d65db1e5 RX(theta\u2082\u2081) 28f8546650674450a9def031fa710d8d--3ff33bb374684a49b291d069d65db1e5 e38cec285fcc460f976e727d63c35661 X 3ff33bb374684a49b291d069d65db1e5--e38cec285fcc460f976e727d63c35661 e38cec285fcc460f976e727d63c35661--c625fcd3d3514ae1be385c500bbae196 a8e24dfe215d413caca9b627c93e6e1f e38cec285fcc460f976e727d63c35661--a8e24dfe215d413caca9b627c93e6e1f a8e24dfe215d413caca9b627c93e6e1f--381c32e2e02847a0b2f4472bf33f2f47 1ec078f98dee458186d659760611a0bb bcac28bb28fe46c591880056cf714f84 RX(theta\u2082) 1caf20dcd8054c1488b091076b1b7243--bcac28bb28fe46c591880056cf714f84 3a87c063551d4670929937493d5b124c 3 3927f336293f4c4186931b9c3b25a83f RY(theta\u2086) bcac28bb28fe46c591880056cf714f84--3927f336293f4c4186931b9c3b25a83f 2a76641a13b34a6382a31575b2b8ce57 RX(theta\u2081\u2080) 3927f336293f4c4186931b9c3b25a83f--2a76641a13b34a6382a31575b2b8ce57 90c708c353fd40c685411ac23668b1ae 2a76641a13b34a6382a31575b2b8ce57--90c708c353fd40c685411ac23668b1ae f6ace178c03d47458bf59c9b0f59d916 X 90c708c353fd40c685411ac23668b1ae--f6ace178c03d47458bf59c9b0f59d916 f6ace178c03d47458bf59c9b0f59d916--e6581d3ea7ac4acd910ff73afaac8c10 126aadad56e341c6abf5113f4aa5dfab RX(theta\u2081\u2084) f6ace178c03d47458bf59c9b0f59d916--126aadad56e341c6abf5113f4aa5dfab 6d723611c6d44675a9da8e46b6ed0072 RY(theta\u2081\u2088) 126aadad56e341c6abf5113f4aa5dfab--6d723611c6d44675a9da8e46b6ed0072 9236f513bb4d486e9d399fe9559de556 RX(theta\u2082\u2082) 6d723611c6d44675a9da8e46b6ed0072--9236f513bb4d486e9d399fe9559de556 1e87e4fb9ca645c8a0f6c6e2ef7da4a7 9236f513bb4d486e9d399fe9559de556--1e87e4fb9ca645c8a0f6c6e2ef7da4a7 3a106d13962a4de3b82afb5411ef08e4 X 1e87e4fb9ca645c8a0f6c6e2ef7da4a7--3a106d13962a4de3b82afb5411ef08e4 3a106d13962a4de3b82afb5411ef08e4--a8e24dfe215d413caca9b627c93e6e1f 3a106d13962a4de3b82afb5411ef08e4--1ec078f98dee458186d659760611a0bb 7950a6fa63e2495fa7a5b720ad345bdd e4e2597dbb4a48f9943367c6a8c84f39 RX(theta\u2083) 3a87c063551d4670929937493d5b124c--e4e2597dbb4a48f9943367c6a8c84f39 d478113e7656407086c6343214a602e2 RY(theta\u2087) e4e2597dbb4a48f9943367c6a8c84f39--d478113e7656407086c6343214a602e2 73198e77837841f89238882996450e0c RX(theta\u2081\u2081) d478113e7656407086c6343214a602e2--73198e77837841f89238882996450e0c cdcf55c46d9e43689ab1322789a1a060 X 73198e77837841f89238882996450e0c--cdcf55c46d9e43689ab1322789a1a060 cdcf55c46d9e43689ab1322789a1a060--90c708c353fd40c685411ac23668b1ae 3d93ce81ec1f46febea257fc8d8d9f22 cdcf55c46d9e43689ab1322789a1a060--3d93ce81ec1f46febea257fc8d8d9f22 c39ea74f93344bba9a6896e697d7ec08 RX(theta\u2081\u2085) 3d93ce81ec1f46febea257fc8d8d9f22--c39ea74f93344bba9a6896e697d7ec08 c3b668aba8fb4c3799bb4d770e8b9ce6 RY(theta\u2081\u2089) c39ea74f93344bba9a6896e697d7ec08--c3b668aba8fb4c3799bb4d770e8b9ce6 503a50ca45334f4ab507ec86760fcb8a RX(theta\u2082\u2083) c3b668aba8fb4c3799bb4d770e8b9ce6--503a50ca45334f4ab507ec86760fcb8a 90fcd504509b4c7f9ef14d5db6ec6660 X 503a50ca45334f4ab507ec86760fcb8a--90fcd504509b4c7f9ef14d5db6ec6660 90fcd504509b4c7f9ef14d5db6ec6660--1e87e4fb9ca645c8a0f6c6e2ef7da4a7 e6b14fbffb30491b801068a89028f0aa 90fcd504509b4c7f9ef14d5db6ec6660--e6b14fbffb30491b801068a89028f0aa e6b14fbffb30491b801068a89028f0aa--7950a6fa63e2495fa7a5b720ad345bdd </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_149432d5882346e785bfd08eef146d40 HEA cluster_db3122fc6c57414bbcab01e05d1781ba HEA 497ea0a02b204dfc9a595dbc17bae46f 0 3f09f417bb7d4a469fa1412b4c3fcda5 RX(theta\u2080) 497ea0a02b204dfc9a595dbc17bae46f--3f09f417bb7d4a469fa1412b4c3fcda5 0b513dc612624ed1b10be0f4e1c63a90 1 0465dc60990e4c009ee7705c8ab2cb8c RY(theta\u2084) 3f09f417bb7d4a469fa1412b4c3fcda5--0465dc60990e4c009ee7705c8ab2cb8c 9028e154c63c4be98d3e5d7a80cc01e0 RX(theta\u2088) 0465dc60990e4c009ee7705c8ab2cb8c--9028e154c63c4be98d3e5d7a80cc01e0 4ac589cfac8e4689a9edd6390fb4f5c5 9028e154c63c4be98d3e5d7a80cc01e0--4ac589cfac8e4689a9edd6390fb4f5c5 d2ff282b465d4855b8ada43d52bcfcf1 4ac589cfac8e4689a9edd6390fb4f5c5--d2ff282b465d4855b8ada43d52bcfcf1 ede27b20e2c54a82b243970c0b5d3c53 RX(theta\u2081\u2082) d2ff282b465d4855b8ada43d52bcfcf1--ede27b20e2c54a82b243970c0b5d3c53 dd086b0ecf994c70a90e55d71ff7bd80 RY(theta\u2081\u2086) ede27b20e2c54a82b243970c0b5d3c53--dd086b0ecf994c70a90e55d71ff7bd80 8fddc2a690124d598a80e245b71130e4 RX(theta\u2082\u2080) dd086b0ecf994c70a90e55d71ff7bd80--8fddc2a690124d598a80e245b71130e4 fea773db6a814398902866579031a942 8fddc2a690124d598a80e245b71130e4--fea773db6a814398902866579031a942 b3a2bb4f1da744fcac759d751a337f68 fea773db6a814398902866579031a942--b3a2bb4f1da744fcac759d751a337f68 f5c557e2a3d445c6a6c88db0e76ce039 RX(theta\u2080) b3a2bb4f1da744fcac759d751a337f68--f5c557e2a3d445c6a6c88db0e76ce039 2990a2c7763e4797ab0cf858a55adac6 RY(theta\u2084) f5c557e2a3d445c6a6c88db0e76ce039--2990a2c7763e4797ab0cf858a55adac6 87c7eb629972491bb77e475cbe72174e RX(theta\u2088) 2990a2c7763e4797ab0cf858a55adac6--87c7eb629972491bb77e475cbe72174e c249e6e634794f37b579256c698f877c 87c7eb629972491bb77e475cbe72174e--c249e6e634794f37b579256c698f877c a603b68c42bb4d36a61c0ef42e047eff c249e6e634794f37b579256c698f877c--a603b68c42bb4d36a61c0ef42e047eff edd0fc7093be4ea0bdc486b0aefd9020 RX(theta\u2081\u2082) a603b68c42bb4d36a61c0ef42e047eff--edd0fc7093be4ea0bdc486b0aefd9020 2fcf82979bbd42f696104fa90e3ce389 RY(theta\u2081\u2086) edd0fc7093be4ea0bdc486b0aefd9020--2fcf82979bbd42f696104fa90e3ce389 e6234923698f4e3fa94e19fc0f189b72 RX(theta\u2082\u2080) 2fcf82979bbd42f696104fa90e3ce389--e6234923698f4e3fa94e19fc0f189b72 984a484633994e0297f17aef2241ac7c e6234923698f4e3fa94e19fc0f189b72--984a484633994e0297f17aef2241ac7c 3e50bd9d79c34139923715af36bbc4a1 984a484633994e0297f17aef2241ac7c--3e50bd9d79c34139923715af36bbc4a1 e6405aac5ce4421c862a824997a67de7 3e50bd9d79c34139923715af36bbc4a1--e6405aac5ce4421c862a824997a67de7 8ef1d9e287944f31be0118b4b09aabfb 72be641dfb014841925c83bb0346ecf8 RX(theta\u2081) 0b513dc612624ed1b10be0f4e1c63a90--72be641dfb014841925c83bb0346ecf8 6c6801d775cb417282548777182a1855 2 6372094460924095861f14e35b94c03c RY(theta\u2085) 72be641dfb014841925c83bb0346ecf8--6372094460924095861f14e35b94c03c 7eacf282cf184e29ada0e613b30ff197 RX(theta\u2089) 6372094460924095861f14e35b94c03c--7eacf282cf184e29ada0e613b30ff197 60204a79115b48819b89a1f7218e6337 X 7eacf282cf184e29ada0e613b30ff197--60204a79115b48819b89a1f7218e6337 60204a79115b48819b89a1f7218e6337--4ac589cfac8e4689a9edd6390fb4f5c5 88c05993ce0d46df90b75c2ca24f8d77 60204a79115b48819b89a1f7218e6337--88c05993ce0d46df90b75c2ca24f8d77 642cfc1333494af48c226c4e23e533b6 RX(theta\u2081\u2083) 88c05993ce0d46df90b75c2ca24f8d77--642cfc1333494af48c226c4e23e533b6 0251eec89fd947818256e8ea707dac12 RY(theta\u2081\u2087) 642cfc1333494af48c226c4e23e533b6--0251eec89fd947818256e8ea707dac12 7f564e8b279749358d4a21a1a66b5f52 RX(theta\u2082\u2081) 0251eec89fd947818256e8ea707dac12--7f564e8b279749358d4a21a1a66b5f52 adc0e8ef06d547d0bebf84d805a8ed2a X 7f564e8b279749358d4a21a1a66b5f52--adc0e8ef06d547d0bebf84d805a8ed2a adc0e8ef06d547d0bebf84d805a8ed2a--fea773db6a814398902866579031a942 8b6d9bca63e74abcadc28bc4d58e246d adc0e8ef06d547d0bebf84d805a8ed2a--8b6d9bca63e74abcadc28bc4d58e246d 39e126fb01244ec58e98fa4be4ff8e20 RX(theta\u2081) 8b6d9bca63e74abcadc28bc4d58e246d--39e126fb01244ec58e98fa4be4ff8e20 970f0315f44746ec9bd4af1f143b0206 RY(theta\u2085) 39e126fb01244ec58e98fa4be4ff8e20--970f0315f44746ec9bd4af1f143b0206 381c056ea4c048eda1482e932635f15f RX(theta\u2089) 970f0315f44746ec9bd4af1f143b0206--381c056ea4c048eda1482e932635f15f a50801ad841a4473a30a5bd55766a60c X 381c056ea4c048eda1482e932635f15f--a50801ad841a4473a30a5bd55766a60c a50801ad841a4473a30a5bd55766a60c--c249e6e634794f37b579256c698f877c 45ae63ba66604a9e81c5926336659847 a50801ad841a4473a30a5bd55766a60c--45ae63ba66604a9e81c5926336659847 793fa113391742a89617b8c23f823e10 RX(theta\u2081\u2083) 45ae63ba66604a9e81c5926336659847--793fa113391742a89617b8c23f823e10 3e796c0f5453408b9e39c1b3afdfb1c2 RY(theta\u2081\u2087) 793fa113391742a89617b8c23f823e10--3e796c0f5453408b9e39c1b3afdfb1c2 abcc6d90aa59474d961a515a57495a64 RX(theta\u2082\u2081) 3e796c0f5453408b9e39c1b3afdfb1c2--abcc6d90aa59474d961a515a57495a64 e8bede438132441487fb0616c9ba0778 X abcc6d90aa59474d961a515a57495a64--e8bede438132441487fb0616c9ba0778 e8bede438132441487fb0616c9ba0778--984a484633994e0297f17aef2241ac7c d24262097e964aafa8c174930d3bf596 e8bede438132441487fb0616c9ba0778--d24262097e964aafa8c174930d3bf596 d24262097e964aafa8c174930d3bf596--8ef1d9e287944f31be0118b4b09aabfb 73188c1aa0fd45789cf8386e8ccf3e63 bca20bf15d4d41ce9fde9c38b94b8dd3 RX(theta\u2082) 6c6801d775cb417282548777182a1855--bca20bf15d4d41ce9fde9c38b94b8dd3 df155672002e47cfb58b24a4d2f7f0d7 3 2a7ae6f8694d47b29a70f0fa1609a487 RY(theta\u2086) bca20bf15d4d41ce9fde9c38b94b8dd3--2a7ae6f8694d47b29a70f0fa1609a487 23176939b8a84635a284d412734b743d RX(theta\u2081\u2080) 2a7ae6f8694d47b29a70f0fa1609a487--23176939b8a84635a284d412734b743d cac37515453d4ff7963902ca7f6b2375 23176939b8a84635a284d412734b743d--cac37515453d4ff7963902ca7f6b2375 ba4f4a99062d4c8ca331374ea4854ba0 X cac37515453d4ff7963902ca7f6b2375--ba4f4a99062d4c8ca331374ea4854ba0 ba4f4a99062d4c8ca331374ea4854ba0--88c05993ce0d46df90b75c2ca24f8d77 d1ac69d31e9d474b9ecd4118d624adac RX(theta\u2081\u2084) ba4f4a99062d4c8ca331374ea4854ba0--d1ac69d31e9d474b9ecd4118d624adac fd8d1ce811db4422944f9125be46e928 RY(theta\u2081\u2088) d1ac69d31e9d474b9ecd4118d624adac--fd8d1ce811db4422944f9125be46e928 62c414eb007f4bc492ce70b1db5e91e1 RX(theta\u2082\u2082) fd8d1ce811db4422944f9125be46e928--62c414eb007f4bc492ce70b1db5e91e1 0863c0139da34f8fb9c999ed291fdbb8 62c414eb007f4bc492ce70b1db5e91e1--0863c0139da34f8fb9c999ed291fdbb8 c8f9e034b25f4f1093de99602a25bbbf X 0863c0139da34f8fb9c999ed291fdbb8--c8f9e034b25f4f1093de99602a25bbbf c8f9e034b25f4f1093de99602a25bbbf--8b6d9bca63e74abcadc28bc4d58e246d cf73f6214c5f4cada493c3e24c184d6f RX(theta\u2082) c8f9e034b25f4f1093de99602a25bbbf--cf73f6214c5f4cada493c3e24c184d6f ee7eb83a62d8494a878005dd014956e2 RY(theta\u2086) cf73f6214c5f4cada493c3e24c184d6f--ee7eb83a62d8494a878005dd014956e2 4b05d28709f04db0b0992a0aec147462 RX(theta\u2081\u2080) ee7eb83a62d8494a878005dd014956e2--4b05d28709f04db0b0992a0aec147462 8079978efdc24d76baf67127387014c6 4b05d28709f04db0b0992a0aec147462--8079978efdc24d76baf67127387014c6 24ac72b8cb864dbfa98dc7cf7503bcbb X 8079978efdc24d76baf67127387014c6--24ac72b8cb864dbfa98dc7cf7503bcbb 24ac72b8cb864dbfa98dc7cf7503bcbb--45ae63ba66604a9e81c5926336659847 1817f3f3ac64472c9a40c0cddc95ce22 RX(theta\u2081\u2084) 24ac72b8cb864dbfa98dc7cf7503bcbb--1817f3f3ac64472c9a40c0cddc95ce22 4d3a3925c44b400793f562debe0ff1ae RY(theta\u2081\u2088) 1817f3f3ac64472c9a40c0cddc95ce22--4d3a3925c44b400793f562debe0ff1ae 70edd4211b29403a9217f09daf6d416e RX(theta\u2082\u2082) 4d3a3925c44b400793f562debe0ff1ae--70edd4211b29403a9217f09daf6d416e 3a521043c4bc4aabbf360a4cb43181a3 70edd4211b29403a9217f09daf6d416e--3a521043c4bc4aabbf360a4cb43181a3 a5fced1a0df3445bbfec739ce7d5ee99 X 3a521043c4bc4aabbf360a4cb43181a3--a5fced1a0df3445bbfec739ce7d5ee99 a5fced1a0df3445bbfec739ce7d5ee99--d24262097e964aafa8c174930d3bf596 a5fced1a0df3445bbfec739ce7d5ee99--73188c1aa0fd45789cf8386e8ccf3e63 afba3f80b8074fac8b58600b253b2233 353360019fd84ff1a9f92682565a90d7 RX(theta\u2083) df155672002e47cfb58b24a4d2f7f0d7--353360019fd84ff1a9f92682565a90d7 36a230592c31437b83f29a305c74470e RY(theta\u2087) 353360019fd84ff1a9f92682565a90d7--36a230592c31437b83f29a305c74470e 429fbccd09e940e1b92c7828de5f96d4 RX(theta\u2081\u2081) 36a230592c31437b83f29a305c74470e--429fbccd09e940e1b92c7828de5f96d4 a46349d8e71242ee9a2d083bfa099469 X 429fbccd09e940e1b92c7828de5f96d4--a46349d8e71242ee9a2d083bfa099469 a46349d8e71242ee9a2d083bfa099469--cac37515453d4ff7963902ca7f6b2375 e4c12e2c3a2f4e89bc6b47812259f83d a46349d8e71242ee9a2d083bfa099469--e4c12e2c3a2f4e89bc6b47812259f83d 355d6c1d2ba2478faa831af63d2b4c01 RX(theta\u2081\u2085) e4c12e2c3a2f4e89bc6b47812259f83d--355d6c1d2ba2478faa831af63d2b4c01 c19fd89097db4d90927af0a14bb9bd8d RY(theta\u2081\u2089) 355d6c1d2ba2478faa831af63d2b4c01--c19fd89097db4d90927af0a14bb9bd8d 9ab3b82dffb042cd8e5825c6f26ff598 RX(theta\u2082\u2083) c19fd89097db4d90927af0a14bb9bd8d--9ab3b82dffb042cd8e5825c6f26ff598 7c56cb8393ae4b918a9cdaec47baaeb7 X 9ab3b82dffb042cd8e5825c6f26ff598--7c56cb8393ae4b918a9cdaec47baaeb7 7c56cb8393ae4b918a9cdaec47baaeb7--0863c0139da34f8fb9c999ed291fdbb8 d1fee822e5854b5fb2d36d8570d295f7 7c56cb8393ae4b918a9cdaec47baaeb7--d1fee822e5854b5fb2d36d8570d295f7 f697da6e5eeb4f55a480507997436ea9 RX(theta\u2083) d1fee822e5854b5fb2d36d8570d295f7--f697da6e5eeb4f55a480507997436ea9 42dd5036c00f4ba5b3a088198ecec085 RY(theta\u2087) f697da6e5eeb4f55a480507997436ea9--42dd5036c00f4ba5b3a088198ecec085 556d3135a7384729b29924680055be82 RX(theta\u2081\u2081) 42dd5036c00f4ba5b3a088198ecec085--556d3135a7384729b29924680055be82 4479312490ad4069a36fea978ab068ac X 556d3135a7384729b29924680055be82--4479312490ad4069a36fea978ab068ac 4479312490ad4069a36fea978ab068ac--8079978efdc24d76baf67127387014c6 e3bc3bb91bdf462489c9312ee081fd1b 4479312490ad4069a36fea978ab068ac--e3bc3bb91bdf462489c9312ee081fd1b e3964b9a20854ff8a017a4b944f317df RX(theta\u2081\u2085) e3bc3bb91bdf462489c9312ee081fd1b--e3964b9a20854ff8a017a4b944f317df 6a9c1b375101437da4c19b46e085f58b RY(theta\u2081\u2089) e3964b9a20854ff8a017a4b944f317df--6a9c1b375101437da4c19b46e085f58b 54c935a9734f44ce918fbffe3b291aa9 RX(theta\u2082\u2083) 6a9c1b375101437da4c19b46e085f58b--54c935a9734f44ce918fbffe3b291aa9 1341a0205fc248a493d07ac6db585f27 X 54c935a9734f44ce918fbffe3b291aa9--1341a0205fc248a493d07ac6db585f27 1341a0205fc248a493d07ac6db585f27--3a521043c4bc4aabbf360a4cb43181a3 9b8e32b3ab3e489e85b22a0ef32dd35d 1341a0205fc248a493d07ac6db585f27--9b8e32b3ab3e489e85b22a0ef32dd35d 9b8e32b3ab3e489e85b22a0ef32dd35d--afba3f80b8074fac8b58600b253b2233 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_ee8c72e36256443aa3b2a4f153479ae2 HEA cluster_f4980ef810374b989df794d71042b32f HEA 9ea55bd0809145029958e1fcdc02fa0c 0 38445ec06cc94ecaaee32910c21bc5b8 RX(p1\u2080) 9ea55bd0809145029958e1fcdc02fa0c--38445ec06cc94ecaaee32910c21bc5b8 1b30dfcaec7443fc9021cc184aa03046 1 1fd071ebcb0641078abb608b8e45348c RY(p1\u2084) 38445ec06cc94ecaaee32910c21bc5b8--1fd071ebcb0641078abb608b8e45348c a11b8d98a39b4fb28a3e77c0b068488c RX(p1\u2088) 1fd071ebcb0641078abb608b8e45348c--a11b8d98a39b4fb28a3e77c0b068488c 55045b4af95f481ba2beff9bfc7017bc a11b8d98a39b4fb28a3e77c0b068488c--55045b4af95f481ba2beff9bfc7017bc 8ec6f7c906824fb29c8b0858e325d73f 55045b4af95f481ba2beff9bfc7017bc--8ec6f7c906824fb29c8b0858e325d73f 38a31073a0b64f198be1f4ae9cca7fb1 RX(p1\u2081\u2082) 8ec6f7c906824fb29c8b0858e325d73f--38a31073a0b64f198be1f4ae9cca7fb1 749527e7bd0a4ccebba816661e3a47c9 RY(p1\u2081\u2086) 38a31073a0b64f198be1f4ae9cca7fb1--749527e7bd0a4ccebba816661e3a47c9 c8105172b6184add96a909c795c59db8 RX(p1\u2082\u2080) 749527e7bd0a4ccebba816661e3a47c9--c8105172b6184add96a909c795c59db8 4933ef2252c1442bb8d8655e05e36bee c8105172b6184add96a909c795c59db8--4933ef2252c1442bb8d8655e05e36bee ac8d45b2437243cf84ebaddc2f02e866 4933ef2252c1442bb8d8655e05e36bee--ac8d45b2437243cf84ebaddc2f02e866 b36803561f834f02a4b96dde7af785ab RX(p2\u2080) ac8d45b2437243cf84ebaddc2f02e866--b36803561f834f02a4b96dde7af785ab f986ae3403f646658ec3c21f356b6f66 RY(p2\u2084) b36803561f834f02a4b96dde7af785ab--f986ae3403f646658ec3c21f356b6f66 d5b07a6d84014099aa535f4d02efa143 RX(p2\u2088) f986ae3403f646658ec3c21f356b6f66--d5b07a6d84014099aa535f4d02efa143 c0595ff1eb9d4a2bb8a77f81b5eaee9e d5b07a6d84014099aa535f4d02efa143--c0595ff1eb9d4a2bb8a77f81b5eaee9e f2c4b716dffd4ac48f2759da2e06815f c0595ff1eb9d4a2bb8a77f81b5eaee9e--f2c4b716dffd4ac48f2759da2e06815f 9f21a2562ee8400ebfde043112dde3f2 RX(p2\u2081\u2082) f2c4b716dffd4ac48f2759da2e06815f--9f21a2562ee8400ebfde043112dde3f2 f64b5942309e49bcaa2ff6ac7017447a RY(p2\u2081\u2086) 9f21a2562ee8400ebfde043112dde3f2--f64b5942309e49bcaa2ff6ac7017447a 3f3872999b7347ba978d744b9a229231 RX(p2\u2082\u2080) f64b5942309e49bcaa2ff6ac7017447a--3f3872999b7347ba978d744b9a229231 180e82c6aa0d44b39b620bb868a10d53 3f3872999b7347ba978d744b9a229231--180e82c6aa0d44b39b620bb868a10d53 2181e0fd468b4e6385af795be62f797d 180e82c6aa0d44b39b620bb868a10d53--2181e0fd468b4e6385af795be62f797d 658b949787624ce7882e5bcc36964d52 2181e0fd468b4e6385af795be62f797d--658b949787624ce7882e5bcc36964d52 085935ac21b141bab2fc0558f77bcc0d 9fa1887548d64f62b396e725896ad192 RX(p1\u2081) 1b30dfcaec7443fc9021cc184aa03046--9fa1887548d64f62b396e725896ad192 00c5ca4c1f4d4d2c932f6bc898e5f7ec 2 d24d975821674580b777a4c4cbae7695 RY(p1\u2085) 9fa1887548d64f62b396e725896ad192--d24d975821674580b777a4c4cbae7695 b24936154a274162b06c278e362636b7 RX(p1\u2089) d24d975821674580b777a4c4cbae7695--b24936154a274162b06c278e362636b7 2ab76531c1f648e39d33423a5b141797 X b24936154a274162b06c278e362636b7--2ab76531c1f648e39d33423a5b141797 2ab76531c1f648e39d33423a5b141797--55045b4af95f481ba2beff9bfc7017bc be7204a7fc4c4e878bb8b5901b544140 2ab76531c1f648e39d33423a5b141797--be7204a7fc4c4e878bb8b5901b544140 669982128d8f47b083e35dd694adb309 RX(p1\u2081\u2083) be7204a7fc4c4e878bb8b5901b544140--669982128d8f47b083e35dd694adb309 948c2f9c81db485591fc10afd9586881 RY(p1\u2081\u2087) 669982128d8f47b083e35dd694adb309--948c2f9c81db485591fc10afd9586881 fa92966f0ad940159b221e201398cf70 RX(p1\u2082\u2081) 948c2f9c81db485591fc10afd9586881--fa92966f0ad940159b221e201398cf70 40d64999584847718464b640db265fac X fa92966f0ad940159b221e201398cf70--40d64999584847718464b640db265fac 40d64999584847718464b640db265fac--4933ef2252c1442bb8d8655e05e36bee 53024334cf8e479f93e22e0817fcf6a7 40d64999584847718464b640db265fac--53024334cf8e479f93e22e0817fcf6a7 f64ce852a4624aeda08769af7450f0b1 RX(p2\u2081) 53024334cf8e479f93e22e0817fcf6a7--f64ce852a4624aeda08769af7450f0b1 24e8d1a0610d4194adca7e1a4f5915a2 RY(p2\u2085) f64ce852a4624aeda08769af7450f0b1--24e8d1a0610d4194adca7e1a4f5915a2 f27f4b569c174b8b94b222452ee91ca8 RX(p2\u2089) 24e8d1a0610d4194adca7e1a4f5915a2--f27f4b569c174b8b94b222452ee91ca8 03f5b3b0c1494677945862efe28b65d4 X f27f4b569c174b8b94b222452ee91ca8--03f5b3b0c1494677945862efe28b65d4 03f5b3b0c1494677945862efe28b65d4--c0595ff1eb9d4a2bb8a77f81b5eaee9e d5f77ef75bdb4e2ea20b85fb6274b3f1 03f5b3b0c1494677945862efe28b65d4--d5f77ef75bdb4e2ea20b85fb6274b3f1 23b2dff52496451383c52f300cbff80b RX(p2\u2081\u2083) d5f77ef75bdb4e2ea20b85fb6274b3f1--23b2dff52496451383c52f300cbff80b 30e1655db8024c0a9ae7123d21bfc40d RY(p2\u2081\u2087) 23b2dff52496451383c52f300cbff80b--30e1655db8024c0a9ae7123d21bfc40d a7b39f4493094ec69875a557eeba4428 RX(p2\u2082\u2081) 30e1655db8024c0a9ae7123d21bfc40d--a7b39f4493094ec69875a557eeba4428 b1ee6937b0b944659410fd5d1376624b X a7b39f4493094ec69875a557eeba4428--b1ee6937b0b944659410fd5d1376624b b1ee6937b0b944659410fd5d1376624b--180e82c6aa0d44b39b620bb868a10d53 7ed321751fe243bc9873913af55ba467 b1ee6937b0b944659410fd5d1376624b--7ed321751fe243bc9873913af55ba467 7ed321751fe243bc9873913af55ba467--085935ac21b141bab2fc0558f77bcc0d 6fbc6a66f8a64a5ca467b30de6c99022 7cfb861872514c949286763e1db3e441 RX(p1\u2082) 00c5ca4c1f4d4d2c932f6bc898e5f7ec--7cfb861872514c949286763e1db3e441 9f82ae988f684a7498b1ae7687693f3e 3 3c2fc838ce784a018adc1b0f7ee8c8ac RY(p1\u2086) 7cfb861872514c949286763e1db3e441--3c2fc838ce784a018adc1b0f7ee8c8ac 1b2cfa9db2fa42aeb41959c8a6397dc7 RX(p1\u2081\u2080) 3c2fc838ce784a018adc1b0f7ee8c8ac--1b2cfa9db2fa42aeb41959c8a6397dc7 975b0cfe3cc94ae6985ba29a41e0d437 1b2cfa9db2fa42aeb41959c8a6397dc7--975b0cfe3cc94ae6985ba29a41e0d437 9594d24a5f41427f91f9c18bead90e07 X 975b0cfe3cc94ae6985ba29a41e0d437--9594d24a5f41427f91f9c18bead90e07 9594d24a5f41427f91f9c18bead90e07--be7204a7fc4c4e878bb8b5901b544140 a6383a7b14a0414fa0ef52ac8b98016e RX(p1\u2081\u2084) 9594d24a5f41427f91f9c18bead90e07--a6383a7b14a0414fa0ef52ac8b98016e af69b903de864643b14566e5c5fb4df0 RY(p1\u2081\u2088) a6383a7b14a0414fa0ef52ac8b98016e--af69b903de864643b14566e5c5fb4df0 9eb1fc0d697043c883543c368a752832 RX(p1\u2082\u2082) af69b903de864643b14566e5c5fb4df0--9eb1fc0d697043c883543c368a752832 f8364ca7c0654e27bc92e7a86cc99e34 9eb1fc0d697043c883543c368a752832--f8364ca7c0654e27bc92e7a86cc99e34 ed94dac42be34f08b5ba6dbfa68891c2 X f8364ca7c0654e27bc92e7a86cc99e34--ed94dac42be34f08b5ba6dbfa68891c2 ed94dac42be34f08b5ba6dbfa68891c2--53024334cf8e479f93e22e0817fcf6a7 3c1b84be373c4acfa1751284a09371f1 RX(p2\u2082) ed94dac42be34f08b5ba6dbfa68891c2--3c1b84be373c4acfa1751284a09371f1 daf19c98c5f04bb9a2ad59fa72fa4b92 RY(p2\u2086) 3c1b84be373c4acfa1751284a09371f1--daf19c98c5f04bb9a2ad59fa72fa4b92 1687ca9fe2c84c8d846ccd8288aad920 RX(p2\u2081\u2080) daf19c98c5f04bb9a2ad59fa72fa4b92--1687ca9fe2c84c8d846ccd8288aad920 177aa561624b406aa6f83095959e4eda 1687ca9fe2c84c8d846ccd8288aad920--177aa561624b406aa6f83095959e4eda 3bd5539f329449d09ec62cddbb0fcbf5 X 177aa561624b406aa6f83095959e4eda--3bd5539f329449d09ec62cddbb0fcbf5 3bd5539f329449d09ec62cddbb0fcbf5--d5f77ef75bdb4e2ea20b85fb6274b3f1 1fcb5579c10b4be2b0023915a7e472ec RX(p2\u2081\u2084) 3bd5539f329449d09ec62cddbb0fcbf5--1fcb5579c10b4be2b0023915a7e472ec e7bcaa66c3a34388a5b7d1a0a26efaf3 RY(p2\u2081\u2088) 1fcb5579c10b4be2b0023915a7e472ec--e7bcaa66c3a34388a5b7d1a0a26efaf3 8038de8f35c24eaeb6562e69efc3825b RX(p2\u2082\u2082) e7bcaa66c3a34388a5b7d1a0a26efaf3--8038de8f35c24eaeb6562e69efc3825b 953dd9b8e107492abb0655aaa03412ca 8038de8f35c24eaeb6562e69efc3825b--953dd9b8e107492abb0655aaa03412ca ac6dc2bc2f58412bbfc55663ffe674e1 X 953dd9b8e107492abb0655aaa03412ca--ac6dc2bc2f58412bbfc55663ffe674e1 ac6dc2bc2f58412bbfc55663ffe674e1--7ed321751fe243bc9873913af55ba467 ac6dc2bc2f58412bbfc55663ffe674e1--6fbc6a66f8a64a5ca467b30de6c99022 91d1a1e1e8804a70b54a4b45aa8eb67f e23860caa697405eaebd98ca5baaa10a RX(p1\u2083) 9f82ae988f684a7498b1ae7687693f3e--e23860caa697405eaebd98ca5baaa10a b666fb28037245efb04c8db92c65e516 RY(p1\u2087) e23860caa697405eaebd98ca5baaa10a--b666fb28037245efb04c8db92c65e516 29b75d92bafb423a880633ce46b088a5 RX(p1\u2081\u2081) b666fb28037245efb04c8db92c65e516--29b75d92bafb423a880633ce46b088a5 fe3c0f0cdf3f46e785c7b7bdf90db77e X 29b75d92bafb423a880633ce46b088a5--fe3c0f0cdf3f46e785c7b7bdf90db77e fe3c0f0cdf3f46e785c7b7bdf90db77e--975b0cfe3cc94ae6985ba29a41e0d437 bca1f3415ad64199a36cb265b6fde79d fe3c0f0cdf3f46e785c7b7bdf90db77e--bca1f3415ad64199a36cb265b6fde79d 8d99fd3d88bd44d5bc552979f19ffa30 RX(p1\u2081\u2085) bca1f3415ad64199a36cb265b6fde79d--8d99fd3d88bd44d5bc552979f19ffa30 5eef3c4f2370453b8d7415f21edf9397 RY(p1\u2081\u2089) 8d99fd3d88bd44d5bc552979f19ffa30--5eef3c4f2370453b8d7415f21edf9397 4cda0e9b0f704f0fa4de0fc3fd893c59 RX(p1\u2082\u2083) 5eef3c4f2370453b8d7415f21edf9397--4cda0e9b0f704f0fa4de0fc3fd893c59 091d306674f34e9fb6d12ba637647a64 X 4cda0e9b0f704f0fa4de0fc3fd893c59--091d306674f34e9fb6d12ba637647a64 091d306674f34e9fb6d12ba637647a64--f8364ca7c0654e27bc92e7a86cc99e34 13020328b28d412ca9e141c1e125150f 091d306674f34e9fb6d12ba637647a64--13020328b28d412ca9e141c1e125150f 66ac4d715b314f4abec5c7fbfa9d47b1 RX(p2\u2083) 13020328b28d412ca9e141c1e125150f--66ac4d715b314f4abec5c7fbfa9d47b1 1884396dce154f72a01deeb384139865 RY(p2\u2087) 66ac4d715b314f4abec5c7fbfa9d47b1--1884396dce154f72a01deeb384139865 b976bd81e7f04d0bb07826a025270603 RX(p2\u2081\u2081) 1884396dce154f72a01deeb384139865--b976bd81e7f04d0bb07826a025270603 a996145bbb574dfcbcb26d1bb153e16a X b976bd81e7f04d0bb07826a025270603--a996145bbb574dfcbcb26d1bb153e16a a996145bbb574dfcbcb26d1bb153e16a--177aa561624b406aa6f83095959e4eda 44af1a1750f1499abecc8e9b8fe22dc9 a996145bbb574dfcbcb26d1bb153e16a--44af1a1750f1499abecc8e9b8fe22dc9 ac7b6ab134d6433ba3ac18cf0d33a96b RX(p2\u2081\u2085) 44af1a1750f1499abecc8e9b8fe22dc9--ac7b6ab134d6433ba3ac18cf0d33a96b afa971ae376f428bb739ec38cd071eea RY(p2\u2081\u2089) ac7b6ab134d6433ba3ac18cf0d33a96b--afa971ae376f428bb739ec38cd071eea 120121ea9fda4cf8bf83ec7fc14adf58 RX(p2\u2082\u2083) afa971ae376f428bb739ec38cd071eea--120121ea9fda4cf8bf83ec7fc14adf58 64aa281139584fdda4705b13f3fb0842 X 120121ea9fda4cf8bf83ec7fc14adf58--64aa281139584fdda4705b13f3fb0842 64aa281139584fdda4705b13f3fb0842--953dd9b8e107492abb0655aaa03412ca c62d10a58f674cbab01d8b0b9a9f7291 64aa281139584fdda4705b13f3fb0842--c62d10a58f674cbab01d8b0b9a9f7291 c62d10a58f674cbab01d8b0b9a9f7291--91d1a1e1e8804a70b54a4b45aa8eb67f </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.0855])), ('theta_0', tensor([0.5155])), ('theta_1', tensor([0.9281])), ('theta_10', tensor([0.9866])), ('theta_11', tensor([0.2450])), ('theta_12', tensor([0.4834])), ('theta_13', tensor([0.1215])), ('theta_14', tensor([0.0793])), ('theta_15', tensor([0.7420])), ('theta_16', tensor([0.6813])), ('theta_17', tensor([0.5558])), ('theta_18', tensor([0.9943])), ('theta_19', tensor([0.4941])), ('theta_2', tensor([0.8950])), ('theta_20', tensor([0.5997])), ('theta_21', tensor([0.0895])), ('theta_22', tensor([0.9110])), ('theta_23', tensor([0.1405])), ('theta_3', tensor([0.2954])), ('theta_4', tensor([0.5823])), ('theta_5', tensor([0.5412])), ('theta_6', tensor([0.5837])), ('theta_7', tensor([0.3800])), ('theta_8', tensor([0.2195])), ('theta_9', tensor([0.9872]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.0845])), ('theta_0', tensor([0.5145])), ('theta_1', tensor([0.9291])), ('theta_10', tensor([0.9876])), ('theta_11', tensor([0.2440])), ('theta_12', tensor([0.4844])), ('theta_13', tensor([0.1225])), ('theta_14', tensor([0.0803])), ('theta_15', tensor([0.7410])), ('theta_16', tensor([0.6803])), ('theta_17', tensor([0.5568])), ('theta_18', tensor([0.9933])), ('theta_19', tensor([0.4951])), ('theta_2', tensor([0.8960])), ('theta_20', tensor([0.6007])), ('theta_21', tensor([0.0905])), ('theta_22', tensor([0.9120])), ('theta_23', tensor([0.1395])), ('theta_3', tensor([0.2944])), ('theta_4', tensor([0.5833])), ('theta_5', tensor([0.5422])), ('theta_6', tensor([0.5827])), ('theta_7', tensor([0.3790])), ('theta_8', tensor([0.2205])), ('theta_9', tensor([0.9882]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 9.9885e-01+0.0000j,  0.0000e+00-0.0338j,  0.0000e+00-0.0338j,\n         -1.1468e-03+0.0000j],\n        [ 9.9919e-01+0.0000j,  0.0000e+00-0.0284j,  0.0000e+00-0.0284j,\n         -8.0882e-04+0.0000j],\n        [ 9.8061e-01+0.0000j,  0.0000e+00-0.1379j,  0.0000e+00-0.1379j,\n         -1.9395e-02+0.0000j]])\nxs = [Counter({'00': 100}), Counter({'00': 100}), Counter({'00': 97, '01': 2, '10': 1})]\nex = tensor([[0.9977],\n        [0.9984],\n        [0.9612]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9977, 0.9977],\n        [0.9984, 0.9984],\n        [0.9612, 0.9612]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2024-02-01T16:34:24.275594 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register, PI\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*PI, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2024-02-01T16:34:24.615018 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'00': 55, '01': 45})]\nSample in little endian = [Counter({'00': 52, '10': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'00': 55, '10': 45})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample, PI\n\n# RX(PI/4) on qubit 1\nn_qubits = 2\nop = RX(1, PI/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 84, '01': 16})]\nOn Braket = [Counter({'00': 84, '01': 16})]\nOn Pulser = [Counter({'00': 82, '01': 18})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [0.83300843+0.55326029j 0.        +0.j         0.        +0.j\n 0.        +0.j        ]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_d31ab7486d7b441cb77e00a88521fd53 Circuit block cluster_01a6ecac350c4faf9346ebfd214221c8 Prep block 391c02ae9cd249b19ca5eeb158c5244c 0 e398909da8ef4c73834aac9686ba5c80 391c02ae9cd249b19ca5eeb158c5244c--e398909da8ef4c73834aac9686ba5c80 53496836ade943d4b9067363410fb8e3 1 1ef774169b714ab9bae09717c09d08e6 RX(theta\u2080) e398909da8ef4c73834aac9686ba5c80--1ef774169b714ab9bae09717c09d08e6 99b3b356733e46f4ad7e47a2aee562cd RY(theta\u2084) 1ef774169b714ab9bae09717c09d08e6--99b3b356733e46f4ad7e47a2aee562cd 4d85a87ce08c43c7bc85954adbc755e3 RX(theta\u2088) 99b3b356733e46f4ad7e47a2aee562cd--4d85a87ce08c43c7bc85954adbc755e3 5cb5b5050e224c1aa56650911ee172ee 4d85a87ce08c43c7bc85954adbc755e3--5cb5b5050e224c1aa56650911ee172ee 2d08747f234e45188e833ba6f1992490 5cb5b5050e224c1aa56650911ee172ee--2d08747f234e45188e833ba6f1992490 866d00ef365c46b197d4166f1b19fa7d RX(theta\u2081\u2082) 2d08747f234e45188e833ba6f1992490--866d00ef365c46b197d4166f1b19fa7d 5e820a5a27d645a2893a85440e5148ac RY(theta\u2081\u2086) 866d00ef365c46b197d4166f1b19fa7d--5e820a5a27d645a2893a85440e5148ac 28103abf492745aa82649c24fd34ae11 RX(theta\u2082\u2080) 5e820a5a27d645a2893a85440e5148ac--28103abf492745aa82649c24fd34ae11 f4e176f871b346fe8ba369408b6d0d47 28103abf492745aa82649c24fd34ae11--f4e176f871b346fe8ba369408b6d0d47 002021072c5a4cacbb57be78081f9b43 f4e176f871b346fe8ba369408b6d0d47--002021072c5a4cacbb57be78081f9b43 f047e4c9a7c24e63b582f14a27aba55b 002021072c5a4cacbb57be78081f9b43--f047e4c9a7c24e63b582f14a27aba55b 691521a825764976b6c3d6e241cef878 9a128514f6614107b8b0dd7ce43d9d86 53496836ade943d4b9067363410fb8e3--9a128514f6614107b8b0dd7ce43d9d86 3109adeace314fc4927b8211eaf7261f 2 1420710c7e2e419d9c2f820c52db7426 RX(theta\u2081) 9a128514f6614107b8b0dd7ce43d9d86--1420710c7e2e419d9c2f820c52db7426 a84c68d2df9e4a8ca60e58511059837f RY(theta\u2085) 1420710c7e2e419d9c2f820c52db7426--a84c68d2df9e4a8ca60e58511059837f 083c74d743bf49e393266df3e3873f65 RX(theta\u2089) a84c68d2df9e4a8ca60e58511059837f--083c74d743bf49e393266df3e3873f65 3efec2fc19f845028ee86fdb4fa5051b X 083c74d743bf49e393266df3e3873f65--3efec2fc19f845028ee86fdb4fa5051b 3efec2fc19f845028ee86fdb4fa5051b--5cb5b5050e224c1aa56650911ee172ee efc4a11ae0654b51a7d9e51017549433 3efec2fc19f845028ee86fdb4fa5051b--efc4a11ae0654b51a7d9e51017549433 182db63b2f404b8bb2b6cfe955748ab0 RX(theta\u2081\u2083) efc4a11ae0654b51a7d9e51017549433--182db63b2f404b8bb2b6cfe955748ab0 8d2e05a8db3b45e9a9c65a465a7949bb RY(theta\u2081\u2087) 182db63b2f404b8bb2b6cfe955748ab0--8d2e05a8db3b45e9a9c65a465a7949bb 82cf6e6e156248c69ff8579bc8c9ce9c RX(theta\u2082\u2081) 8d2e05a8db3b45e9a9c65a465a7949bb--82cf6e6e156248c69ff8579bc8c9ce9c 08ecbb2db27b43039756e26eaa259722 X 82cf6e6e156248c69ff8579bc8c9ce9c--08ecbb2db27b43039756e26eaa259722 08ecbb2db27b43039756e26eaa259722--f4e176f871b346fe8ba369408b6d0d47 68edca74172a4b36aa6e9bd15c90f9fd 08ecbb2db27b43039756e26eaa259722--68edca74172a4b36aa6e9bd15c90f9fd 68edca74172a4b36aa6e9bd15c90f9fd--691521a825764976b6c3d6e241cef878 19e964cfe6354f7d8559bbb8ca04e7f9 39521d370d044c999e47bce930f9df67 3109adeace314fc4927b8211eaf7261f--39521d370d044c999e47bce930f9df67 3b6f529525fd45a0b3187358319a4763 3 cf29b67a2e094ee49f1c43f3aa7d62e1 RX(theta\u2082) 39521d370d044c999e47bce930f9df67--cf29b67a2e094ee49f1c43f3aa7d62e1 428b060f62af40c2af25a5d8fa98bca9 RY(theta\u2086) cf29b67a2e094ee49f1c43f3aa7d62e1--428b060f62af40c2af25a5d8fa98bca9 fca06176b40244c08780a9adde5739c1 RX(theta\u2081\u2080) 428b060f62af40c2af25a5d8fa98bca9--fca06176b40244c08780a9adde5739c1 48f8a9f3b5af48a1be82925e2b157950 fca06176b40244c08780a9adde5739c1--48f8a9f3b5af48a1be82925e2b157950 ce7648c1dcc446b9ba89f148435e1cfb X 48f8a9f3b5af48a1be82925e2b157950--ce7648c1dcc446b9ba89f148435e1cfb ce7648c1dcc446b9ba89f148435e1cfb--efc4a11ae0654b51a7d9e51017549433 8c2400260e52444684bdd48f21f0c7cd RX(theta\u2081\u2084) ce7648c1dcc446b9ba89f148435e1cfb--8c2400260e52444684bdd48f21f0c7cd 716d566aa50d4fada9794bc062863dd3 RY(theta\u2081\u2088) 8c2400260e52444684bdd48f21f0c7cd--716d566aa50d4fada9794bc062863dd3 30488e25e2a14181a54f6b83d2fb9d2c RX(theta\u2082\u2082) 716d566aa50d4fada9794bc062863dd3--30488e25e2a14181a54f6b83d2fb9d2c a79f36beef3447faa98a85260012c8eb 30488e25e2a14181a54f6b83d2fb9d2c--a79f36beef3447faa98a85260012c8eb 6835c40f82ef4d5b86e5f23f1146bed8 X a79f36beef3447faa98a85260012c8eb--6835c40f82ef4d5b86e5f23f1146bed8 6835c40f82ef4d5b86e5f23f1146bed8--68edca74172a4b36aa6e9bd15c90f9fd 6835c40f82ef4d5b86e5f23f1146bed8--19e964cfe6354f7d8559bbb8ca04e7f9 fa3314338a0f44bea2c8019b1d713e54 1c4afdfbd2294818b4d42cce26e0635c X 3b6f529525fd45a0b3187358319a4763--1c4afdfbd2294818b4d42cce26e0635c 3af788b200e1460695e8dc38512cfe85 RX(theta\u2083) 1c4afdfbd2294818b4d42cce26e0635c--3af788b200e1460695e8dc38512cfe85 8356d2b57c79485795466718fdd8d0e3 RY(theta\u2087) 3af788b200e1460695e8dc38512cfe85--8356d2b57c79485795466718fdd8d0e3 566e4512d3a5498f8dd61c9f18f9a186 RX(theta\u2081\u2081) 8356d2b57c79485795466718fdd8d0e3--566e4512d3a5498f8dd61c9f18f9a186 265299cd986b476cb75d16f83776071c X 566e4512d3a5498f8dd61c9f18f9a186--265299cd986b476cb75d16f83776071c 265299cd986b476cb75d16f83776071c--48f8a9f3b5af48a1be82925e2b157950 604bc14d686c4bacb26c37a08655c4f0 265299cd986b476cb75d16f83776071c--604bc14d686c4bacb26c37a08655c4f0 451301126b3a48e5b304bb08cf23b349 RX(theta\u2081\u2085) 604bc14d686c4bacb26c37a08655c4f0--451301126b3a48e5b304bb08cf23b349 8649c3669d134a8984022a85596a4057 RY(theta\u2081\u2089) 451301126b3a48e5b304bb08cf23b349--8649c3669d134a8984022a85596a4057 c5f479ee4fe44bf8a3f512256ebadf2b RX(theta\u2082\u2083) 8649c3669d134a8984022a85596a4057--c5f479ee4fe44bf8a3f512256ebadf2b b9b0486ab589441ba85312a0f5a6ca68 X c5f479ee4fe44bf8a3f512256ebadf2b--b9b0486ab589441ba85312a0f5a6ca68 b9b0486ab589441ba85312a0f5a6ca68--a79f36beef3447faa98a85260012c8eb 3ee92655224e4619aa665c16980822cf b9b0486ab589441ba85312a0f5a6ca68--3ee92655224e4619aa665c16980822cf 3ee92655224e4619aa665c16980822cf--fa3314338a0f44bea2c8019b1d713e54  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[ 0.4778-0.3032j, -0.2188+0.0063j, -0.5854+0.1054j, -0.0209+0.1171j,\n         -0.1233+0.1146j,  0.2949-0.1529j,  0.2178+0.2514j,  0.0053+0.1206j],\n        [ 0.0060+0.1147j,  0.1033+0.1432j, -0.2309+0.3088j, -0.2681+0.2402j,\n         -0.2283-0.2065j, -0.4066+0.1532j, -0.5098-0.1379j,  0.2512-0.2275j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 I(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}