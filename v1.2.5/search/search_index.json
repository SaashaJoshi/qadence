{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>For a high-level overview of Qadence features, check out our white paper.</p> <p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from qadence import X, Y, HamEvo, Register, product_state, sample, add, PI\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = PI / (2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from qadence import Register, AnalogRX, sample, PI\n\n# Global analog RX block.\nblock = AnalogRX(PI)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(PI))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 37, '10': 34, '01': 29})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@article{qadence2024pasqal,\n  title = {Qadence: a differentiable interface for digital-analog programs.},\n  author={Dominik Seitz and Niklas Heim and Jo\u00e3o P. Moutinho and Roland Guichard and Vytautas Abramavicius and Aleksander Wennersteen and Gert-Jan Both and Anton Quelle and Caroline de Groot and Gergana V. Velikova and Vincent E. Elfving and Mario Dagrada},\n  journal={arXiv:2401.09915},\n  url = {https://github.com/pasqal-io/qadence},\n  year = {2024}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    def _is_feature_param(p: Parameter) -&gt; bool:\n        return not p.trainable and not p.is_number\n\n    if observable is None:\n        self.inputs = list(filter(_is_feature_param, circuit.unique_parameters))\n    else:\n        uparams = unique_parameters(chain(circuit.block, *observable))\n        self.inputs = list(filter(_is_feature_param, uparams))\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/","title":"Advanced Tutorials","text":"<p>In this section, advanced programming concepts and implementations in Qadence are examplified.</p>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available via the PyQTorch or Horqrux backends</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> or <code>horqrux</code> backends are selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#adjoint-differentiation","title":"Adjoint Differentiation","text":"<p>Qadence also offers a memory-efficient, non-device compatible alternative to automatic differentation, called 'Adjoint Differentiation' <sup>4</sup> and allows for precisely calculating the gradients of variational parameters in O(P) time and using O(1) state-vectors. Adjoint Differentation is currently only supported by the Torch Engine and allows for first-order derivatives only.</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the differentiation modes can be selected via the <code>diff_mode</code> argument of the QuantumModel class. It either accepts a <code>DiffMode</code>(<code>DiffMode.GSPR</code>, <code>DiffMode.AD</code> or <code>DiffMode.ADJOINT</code>) or a string (<code>\"gpsr\"\"</code>, <code>\"ad\"</code> or <code>\"adjoint\"</code>). The code in the box below shows how to create <code>QuantumModel</code> instances with all available differentiation modes.</p> <pre><code>from qadence import (FeatureParameter, RX, Z, hea, chain,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# Define a symbolic parameter to differentiate with respect to\nx = FeatureParameter(\"x\")\n\nblock = chain(hea(n_qubits, 1), RX(0, x))\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD, ADJOINT and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_adjoint = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.ADJOINT)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# Create concrete values for the parameter we want to differentiate with respect to\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_adjoint = model_adjoint.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_adjoint = torch.autograd.grad(\n    exp_val_adjoint, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD ,ADJOINT and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_adjoint.detach().numpy(),\n           label=\"df/dx ADJOINT\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2024-01-30T10:16:01.331564 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence.engines.torch import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#low-level-differentiation-of-qadence-circuits-using-jax","title":"Low-level differentiation of qadence circuits using JAX","text":"<p>For users interested in using the <code>JAX</code> engine instead, we show how to run and differentiate qadence programs using the <code>horqrux</code> backend under qadence examples.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> <li> <p>Tyson et al., Efficient calculation of gradients in classical simulations of variational quantum algorithms \u21a9</p> </li> </ol>"},{"location":"advanced_tutorials/projectors/","title":"Projector blocks","text":"<p>This section introduces the <code>ProjectorBlock</code> as an implementation for the quantum mechanical projection operation onto the subspace spanned by \\(|a\\rangle\\): \\(\\mathbb{\\hat{P}}=|a\\rangle \\langle a|\\). It evaluates the outer product for bras and kets expressed as bitstrings for a given qubit support. They have to possess matching lengths.</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence.operations import Projector  # Projector as an operation.\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# As any block, the matrix representation can be retrieved.\nprojector_matrix = block_to_tensor(projector_block)\n</code></pre> <pre><code>projector matrix = tensor([[[0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\n</code></pre> <p>Other standard operations are expressed as projectors in Qadence. For instance, the number operator is the projector onto the 1-subspace, \\(N=|1\\rangle\\langle 1|\\).</p> <p>In fact, projectors can be used to compose any arbitrary operator. For example, the <code>CNOT</code> can be defined as \\(\\textrm{CNOT}(i,j)=|0\\rangle\\langle 0|_i\\otimes \\mathbb{I}_j+|1\\rangle\\langle 1|_i\\otimes X_j\\) and we can compare its matrix representation with the native one in Qadence:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import kron, I, X, CNOT\n\n# Define a projector for |0&gt; onto the qubit labelled 0.\nprojector0 = Projector(ket=\"0\", bra=\"0\", qubit_support=0)\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector1 = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# Construct the projector controlled CNOT.\nprojector_cnot = kron(projector0, I(1)) + kron(projector1, X(1))\n\n# Get the underlying unitary.\nprojector_cnot_matrix = block_to_tensor(projector_cnot)\n\n# Qadence CNOT unitary.\nqadence_cnot_matrix = block_to_tensor(CNOT(0,1))\n</code></pre> <pre><code>projector cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nqadence cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> <p>Another example is the canonical SWAP unitary that can be defined as \\(SWAP=|00\\rangle\\langle 00|+|01\\rangle\\langle 10|+|10\\rangle\\langle 01|+|11\\rangle\\langle 11|\\). Indeed, it can be shown that their matricial representations are again identical:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import SWAP\n\n# Define all projectors.\nprojector00 = Projector(ket=\"00\", bra=\"00\", qubit_support=(0, 1))\nprojector01 = Projector(ket=\"01\", bra=\"10\", qubit_support=(0, 1))\nprojector10 = Projector(ket=\"10\", bra=\"01\", qubit_support=(0, 1))\nprojector11 = Projector(ket=\"11\", bra=\"11\", qubit_support=(0, 1))\n\n# Construct the SWAP gate.\nprojector_swap = projector00 + projector10 + projector01 + projector11\n\n# Get the underlying unitary.\nprojector_swap_matrix = block_to_tensor(projector_swap)\n\n# Qadence SWAP unitary.\nqadence_swap_matrix = block_to_tensor(SWAP(0,1))\n</code></pre> <pre><code>projector swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]])\nqadence swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]], grad_fn=&lt;UnsafeViewBackward0&gt;)\n</code></pre> <p>Warning</p> <p>Projectors are non-unitary operators, only supported by the PyQTorch backend.</p> <p>To examplify this point, let's run some non-unitary computation involving projectors.</p> <pre><code>from qadence import chain, run\nfrom qadence.operations import H, CNOT\n\n# Define a projector for |1&gt; onto the qubit labelled 1.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=1)\n\n# Some non-unitary computation.\nnon_unitary_block = chain(H(0), CNOT(0,1), projector_block)\n\n# Projected wavefunction becomes unnormalized\nprojected_wf = run(non_unitary_block)  # Run on PyQTorch.\n</code></pre> <pre><code>projected_wf = tensor([[0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>supports_adjoint</code> <p>Does the backend support native adjoint differentation.</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p> <code>native_endianness</code> <p>The native endianness of the backend</p> <p> TYPE: <code>Endianness</code> </p> <code>engine</code> <p>The underlying (native) automatic differentiation engine of the backend.</p> <p> TYPE: <code>Engine</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: ArrayLike | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, InteractionBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine TORCH.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.TORCH, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine JAX.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.JAX, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = self.backend.expectation(circuit, observable, param_values, state)\n    else:\n        expectation = DifferentiableExpectation(\n            backend=self.backend,\n            circuit=circuit,\n            observable=observable,\n            param_values=param_values,\n            state=state,\n            measurement=measurement,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        ).psr()\n    return expectation\n</code></pre>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Qadence offers both a PyTorch and Jax differentiation engine.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are applied by implementing a custom <code>torch.autograd.Function</code> class for PyTorch and the <code>custom_vjp</code> in the Jax Engine, respectively.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> under <code>qadence.engines.torch.differentiable_expectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 bdcd068a3e914050b0dd229106f804df 0 644869656fb6441d999a642291637480 X bdcd068a3e914050b0dd229106f804df--644869656fb6441d999a642291637480 1f16586584904ca3ad7c58c810b53c32 1 0e06f996c7bf42f097b6914be5ef570f 644869656fb6441d999a642291637480--0e06f996c7bf42f097b6914be5ef570f aec4a98ec2d8423d86a867c607772f76 e2b6235b0d484a5294e743d3df1df3ad Y 1f16586584904ca3ad7c58c810b53c32--e2b6235b0d484a5294e743d3df1df3ad e2b6235b0d484a5294e743d3df1df3ad--aec4a98ec2d8423d86a867c607772f76 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 b3a29dec871c425f88cd9161d2bfcbe3 0 dd4c3d30c05c46e2bfe991b51e01c86c X b3a29dec871c425f88cd9161d2bfcbe3--dd4c3d30c05c46e2bfe991b51e01c86c 5477f86c3e7b4c9a812fd7e42d43ba8b Y dd4c3d30c05c46e2bfe991b51e01c86c--5477f86c3e7b4c9a812fd7e42d43ba8b 9778af4174804dfab7ac83ef01c6ef41 5477f86c3e7b4c9a812fd7e42d43ba8b--9778af4174804dfab7ac83ef01c6ef41 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 c557a4d852b7421c99db78873f8534c2 0 68b1a37c1c7a472fb5a33db82dc21489 X c557a4d852b7421c99db78873f8534c2--68b1a37c1c7a472fb5a33db82dc21489 1fd769ef6b0740549a33a836400c8fdb 1 e933861c234945ecbd5fb0a63a45c27d 68b1a37c1c7a472fb5a33db82dc21489--e933861c234945ecbd5fb0a63a45c27d 6f90d3fac8dc45c5a37a1e8234c4cb30 e933861c234945ecbd5fb0a63a45c27d--6f90d3fac8dc45c5a37a1e8234c4cb30 74eb9864d5f84ad3899fea7266fb462e 8e84d0f7ac76467c8625e445a9270cb6 1fd769ef6b0740549a33a836400c8fdb--8e84d0f7ac76467c8625e445a9270cb6 69d6bf5cce164e4d80defc98ac2dec2d Y 8e84d0f7ac76467c8625e445a9270cb6--69d6bf5cce164e4d80defc98ac2dec2d 69d6bf5cce164e4d80defc98ac2dec2d--74eb9864d5f84ad3899fea7266fb462e <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_a3cef04727f544a0861a8e59e867010e f0092c79cf2641dc9f4cbd158554572a 0 8603ee73f21d418e88bd2154387f3122 f0092c79cf2641dc9f4cbd158554572a--8603ee73f21d418e88bd2154387f3122 1f65aeb78a1c4c8aa9c375cec63f7864 1 8ebb83ea9d3047f490578e9ede283430 8603ee73f21d418e88bd2154387f3122--8ebb83ea9d3047f490578e9ede283430 6c7d634e395d4435a41da8963b7d3c84 6191ac767f9a41bda8727d8429bef37c AddBlock 1f65aeb78a1c4c8aa9c375cec63f7864--6191ac767f9a41bda8727d8429bef37c 0faf3ea7a221482095147643969077be 2 6191ac767f9a41bda8727d8429bef37c--6c7d634e395d4435a41da8963b7d3c84 c3c3847d97e24abe96f4df42ced73e93 144d033c90f348e9bc9aa4dc5b203356 0faf3ea7a221482095147643969077be--144d033c90f348e9bc9aa4dc5b203356 144d033c90f348e9bc9aa4dc5b203356--c3c3847d97e24abe96f4df42ced73e93 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_ebe8ccb2abe64e728753f573a70b7f48 cluster_b398880ae8dc426ca56c6a9091231e21 rx a89d37f27fc440818230358216f1b96a 0 4d1e057d0231470fab5587ae6ff93dc2 X a89d37f27fc440818230358216f1b96a--4d1e057d0231470fab5587ae6ff93dc2 61870cafeadd43a3b7d1935f74d06d87 1 77f174984d5b43b5886c78ac4b8994f9 4d1e057d0231470fab5587ae6ff93dc2--77f174984d5b43b5886c78ac4b8994f9 86510a0c40544f96a882c9e35dccfddd 77f174984d5b43b5886c78ac4b8994f9--86510a0c40544f96a882c9e35dccfddd ebb7c142b86940cc814792a79d800a8b 86510a0c40544f96a882c9e35dccfddd--ebb7c142b86940cc814792a79d800a8b 5861d63daca4464c80929246d999125d 50262db9be574546b3af3b859efd70f8 Y 61870cafeadd43a3b7d1935f74d06d87--50262db9be574546b3af3b859efd70f8 7bd9efa6f37f4d39a8529ad432f6a1ff 2 49f5da9a80d14f3ebfc677ba10c0b177 50262db9be574546b3af3b859efd70f8--49f5da9a80d14f3ebfc677ba10c0b177 23f92188364e4183a2d49d490c87a676 HamEvo 49f5da9a80d14f3ebfc677ba10c0b177--23f92188364e4183a2d49d490c87a676 23f92188364e4183a2d49d490c87a676--5861d63daca4464c80929246d999125d 5f5e772cf00f482ab85b6ac553f53e76 0d11a53f6a9a46688add0ba51f698264 RX(x) 7bd9efa6f37f4d39a8529ad432f6a1ff--0d11a53f6a9a46688add0ba51f698264 d08bc18044b144b39d8d4618fab63764 3 6c8c7ae371fc496d83f8fc58bade5fe1 0d11a53f6a9a46688add0ba51f698264--6c8c7ae371fc496d83f8fc58bade5fe1 f6ee33ab85a5433cb22f08b4cfb9cd5b t = 10 6c8c7ae371fc496d83f8fc58bade5fe1--f6ee33ab85a5433cb22f08b4cfb9cd5b f6ee33ab85a5433cb22f08b4cfb9cd5b--5f5e772cf00f482ab85b6ac553f53e76 14ff7cc3e90a47b9a9726b4ce537b539 af1e537868fa4d8a873584ba99fc3aa0 RX(0.5) d08bc18044b144b39d8d4618fab63764--af1e537868fa4d8a873584ba99fc3aa0 00963a0a9f9741bc827e424021af1069 X af1e537868fa4d8a873584ba99fc3aa0--00963a0a9f9741bc827e424021af1069 00963a0a9f9741bc827e424021af1069--6c8c7ae371fc496d83f8fc58bade5fe1 19c1375fe2404cd28a8df8acd6441cc1 00963a0a9f9741bc827e424021af1069--19c1375fe2404cd28a8df8acd6441cc1 19c1375fe2404cd28a8df8acd6441cc1--14ff7cc3e90a47b9a9726b4ce537b539 <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_c74a579890234324aad83f6e42142fd4 HEA cluster_462f1f0a91c9474f8309835b282481f5 Tower Fourier FM 1a380e5ad1204ff9b7487b617f5f5a6b 0 4ba38a8610ba46c38718ca0e1605e8a0 RX(1.0*phi) 1a380e5ad1204ff9b7487b617f5f5a6b--4ba38a8610ba46c38718ca0e1605e8a0 5b5b90026c6a43cebeb0870c0139a170 1 0712681db2014394b9d4700c0819bf3b RX(theta\u2080) 4ba38a8610ba46c38718ca0e1605e8a0--0712681db2014394b9d4700c0819bf3b a41d9a683d0d47598057e3f895633bcb RY(theta\u2084) 0712681db2014394b9d4700c0819bf3b--a41d9a683d0d47598057e3f895633bcb 4bacbf5d200e48e4818091baf9000f94 RX(theta\u2088) a41d9a683d0d47598057e3f895633bcb--4bacbf5d200e48e4818091baf9000f94 c0e97fa0002d43b9be6567e32d66220f 4bacbf5d200e48e4818091baf9000f94--c0e97fa0002d43b9be6567e32d66220f e4c9504b211144f68fee63e9d41a6140 c0e97fa0002d43b9be6567e32d66220f--e4c9504b211144f68fee63e9d41a6140 bd12df91aa44413993a03fb7d729d097 RX(theta\u2081\u2082) e4c9504b211144f68fee63e9d41a6140--bd12df91aa44413993a03fb7d729d097 91d9704b7e8849e7b519231d527962ad RY(theta\u2081\u2086) bd12df91aa44413993a03fb7d729d097--91d9704b7e8849e7b519231d527962ad 9ea1d8eece0244c1836f95bf0099027a RX(theta\u2082\u2080) 91d9704b7e8849e7b519231d527962ad--9ea1d8eece0244c1836f95bf0099027a 36c6cf0b141a44b0babb35d66eb33dc8 9ea1d8eece0244c1836f95bf0099027a--36c6cf0b141a44b0babb35d66eb33dc8 0c3b5fd1e8334c7cae0cb489d86df686 36c6cf0b141a44b0babb35d66eb33dc8--0c3b5fd1e8334c7cae0cb489d86df686 6485994988d44b73a7daf9c565e087d4 0c3b5fd1e8334c7cae0cb489d86df686--6485994988d44b73a7daf9c565e087d4 0e2a97498a6a46d0b22544576bc2b02a 481d084331b64e1292083428d7f33293 RX(2.0*phi) 5b5b90026c6a43cebeb0870c0139a170--481d084331b64e1292083428d7f33293 e20929a95f7140409f7d125c3b8d8bed 2 5562ac8c88a74e1b8406f8bb7bc23ca2 RX(theta\u2081) 481d084331b64e1292083428d7f33293--5562ac8c88a74e1b8406f8bb7bc23ca2 05e247e89d9241b1909da0301a48be4a RY(theta\u2085) 5562ac8c88a74e1b8406f8bb7bc23ca2--05e247e89d9241b1909da0301a48be4a c30c0de896c3499a8728b328e83ee18c RX(theta\u2089) 05e247e89d9241b1909da0301a48be4a--c30c0de896c3499a8728b328e83ee18c 7f96e4998bdb40c79564380913f24604 X c30c0de896c3499a8728b328e83ee18c--7f96e4998bdb40c79564380913f24604 7f96e4998bdb40c79564380913f24604--c0e97fa0002d43b9be6567e32d66220f 6651836443bc4a779d01d685944048a1 7f96e4998bdb40c79564380913f24604--6651836443bc4a779d01d685944048a1 45dae3c929e54534bf56bec741777753 RX(theta\u2081\u2083) 6651836443bc4a779d01d685944048a1--45dae3c929e54534bf56bec741777753 f469ef11e9fc4aeba7ff8bc50fbf1a66 RY(theta\u2081\u2087) 45dae3c929e54534bf56bec741777753--f469ef11e9fc4aeba7ff8bc50fbf1a66 96ff4aaed49b47e4855ae0ab37ab53e3 RX(theta\u2082\u2081) f469ef11e9fc4aeba7ff8bc50fbf1a66--96ff4aaed49b47e4855ae0ab37ab53e3 89bcbd63c1e24c9ebeb72652cbd87fcc X 96ff4aaed49b47e4855ae0ab37ab53e3--89bcbd63c1e24c9ebeb72652cbd87fcc 89bcbd63c1e24c9ebeb72652cbd87fcc--36c6cf0b141a44b0babb35d66eb33dc8 fca3ff52ca894a30a0010a61204a2fc5 89bcbd63c1e24c9ebeb72652cbd87fcc--fca3ff52ca894a30a0010a61204a2fc5 fca3ff52ca894a30a0010a61204a2fc5--0e2a97498a6a46d0b22544576bc2b02a d563996141e642a1b09e9e4109d72a50 de12cdd6f9fb40cba250a7547d86a79f RX(3.0*phi) e20929a95f7140409f7d125c3b8d8bed--de12cdd6f9fb40cba250a7547d86a79f 6a8182e82b3245f3a92b4fe19d039772 3 2952dfa56ad744e69d0c128af2ede6d9 RX(theta\u2082) de12cdd6f9fb40cba250a7547d86a79f--2952dfa56ad744e69d0c128af2ede6d9 98c1c97caa434b25b729a5846dc98926 RY(theta\u2086) 2952dfa56ad744e69d0c128af2ede6d9--98c1c97caa434b25b729a5846dc98926 22df7ecf63aa45ce90df2437c0d4dd43 RX(theta\u2081\u2080) 98c1c97caa434b25b729a5846dc98926--22df7ecf63aa45ce90df2437c0d4dd43 cbea9cdfe5084aedb0700255bc911ddb 22df7ecf63aa45ce90df2437c0d4dd43--cbea9cdfe5084aedb0700255bc911ddb ed71ba453b3141e7a734adb6793766dc X cbea9cdfe5084aedb0700255bc911ddb--ed71ba453b3141e7a734adb6793766dc ed71ba453b3141e7a734adb6793766dc--6651836443bc4a779d01d685944048a1 4d12910d2c8447848d88df430d70a9aa RX(theta\u2081\u2084) ed71ba453b3141e7a734adb6793766dc--4d12910d2c8447848d88df430d70a9aa 9ead29859da243f38ed3fbcd21786eaf RY(theta\u2081\u2088) 4d12910d2c8447848d88df430d70a9aa--9ead29859da243f38ed3fbcd21786eaf 08ce18f1197447d7899b59a96161b8b8 RX(theta\u2082\u2082) 9ead29859da243f38ed3fbcd21786eaf--08ce18f1197447d7899b59a96161b8b8 394fec3b91ba4d98b771975510194a3d 08ce18f1197447d7899b59a96161b8b8--394fec3b91ba4d98b771975510194a3d 1fd6f2ef6e274f8496c6b64c1cda6ab1 X 394fec3b91ba4d98b771975510194a3d--1fd6f2ef6e274f8496c6b64c1cda6ab1 1fd6f2ef6e274f8496c6b64c1cda6ab1--fca3ff52ca894a30a0010a61204a2fc5 1fd6f2ef6e274f8496c6b64c1cda6ab1--d563996141e642a1b09e9e4109d72a50 f0fb2c0c47284d84aeba73f476669498 efef77ce64cc4304a8b58c7d932f666c RX(4.0*phi) 6a8182e82b3245f3a92b4fe19d039772--efef77ce64cc4304a8b58c7d932f666c 248cb01e84c5416f888a16d775c17a54 RX(theta\u2083) efef77ce64cc4304a8b58c7d932f666c--248cb01e84c5416f888a16d775c17a54 ff4f527068be4b4ba0cec259ab472ed6 RY(theta\u2087) 248cb01e84c5416f888a16d775c17a54--ff4f527068be4b4ba0cec259ab472ed6 f995f3d3352b4c27bff1b1858bb1319f RX(theta\u2081\u2081) ff4f527068be4b4ba0cec259ab472ed6--f995f3d3352b4c27bff1b1858bb1319f 6cf2c1a7f1f441b1aa34030e507240a8 X f995f3d3352b4c27bff1b1858bb1319f--6cf2c1a7f1f441b1aa34030e507240a8 6cf2c1a7f1f441b1aa34030e507240a8--cbea9cdfe5084aedb0700255bc911ddb ee2eefa66c2d489bac873e34b08b6260 6cf2c1a7f1f441b1aa34030e507240a8--ee2eefa66c2d489bac873e34b08b6260 5220a1dcdf0740048b7009d7bec909d2 RX(theta\u2081\u2085) ee2eefa66c2d489bac873e34b08b6260--5220a1dcdf0740048b7009d7bec909d2 ea88506e9a48416c90e016455cd5d019 RY(theta\u2081\u2089) 5220a1dcdf0740048b7009d7bec909d2--ea88506e9a48416c90e016455cd5d019 16967fac1ca2443a9c430fe4e3171100 RX(theta\u2082\u2083) ea88506e9a48416c90e016455cd5d019--16967fac1ca2443a9c430fe4e3171100 36c0465caf8b41b98daf9bbbaab4e835 X 16967fac1ca2443a9c430fe4e3171100--36c0465caf8b41b98daf9bbbaab4e835 36c0465caf8b41b98daf9bbbaab4e835--394fec3b91ba4d98b771975510194a3d 1bb0a5e83b50472abbe9406e6bb48097 36c0465caf8b41b98daf9bbbaab4e835--1bb0a5e83b50472abbe9406e6bb48097 1bb0a5e83b50472abbe9406e6bb48097--f0fb2c0c47284d84aeba73f476669498 <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_74a643efccc34f6b8cefec6fd21da602 Obs. cluster_6a8471cce10747e39b39671ee36263ad cluster_db95263ec2504c0192c8472091a29d0d HEA 50e664db560149bb95fb63c337b3751a 0 cd1a197506f64f698130242445158a92 RX(theta\u2080) 50e664db560149bb95fb63c337b3751a--cd1a197506f64f698130242445158a92 bdd997da32654d1e892d45ae40f1c662 1 d021e75675364fa0beb70c2a6bf1a9ad RY(theta\u2083) cd1a197506f64f698130242445158a92--d021e75675364fa0beb70c2a6bf1a9ad 961b78a0340b4a13ad6053d822bb23e7 RX(theta\u2086) d021e75675364fa0beb70c2a6bf1a9ad--961b78a0340b4a13ad6053d822bb23e7 dce747d290b34d8d83637ee0bf91a2e8 961b78a0340b4a13ad6053d822bb23e7--dce747d290b34d8d83637ee0bf91a2e8 428aa9be4708441db054843c3153e509 dce747d290b34d8d83637ee0bf91a2e8--428aa9be4708441db054843c3153e509 172fd885656c46ceb4c3d2b7d3c3293b RX(theta\u2089) 428aa9be4708441db054843c3153e509--172fd885656c46ceb4c3d2b7d3c3293b a70be6d809d34ebd9fa3efc510651a87 RY(theta\u2081\u2082) 172fd885656c46ceb4c3d2b7d3c3293b--a70be6d809d34ebd9fa3efc510651a87 0aaceda004f84e369e5175c81191530a RX(theta\u2081\u2085) a70be6d809d34ebd9fa3efc510651a87--0aaceda004f84e369e5175c81191530a 8b59344f30d1472da567aee769a86e69 0aaceda004f84e369e5175c81191530a--8b59344f30d1472da567aee769a86e69 f5c8108a0c934e0da97aaf23c8fabcb9 8b59344f30d1472da567aee769a86e69--f5c8108a0c934e0da97aaf23c8fabcb9 c927151f6c5342e8b0dcba74189bead2 f5c8108a0c934e0da97aaf23c8fabcb9--c927151f6c5342e8b0dcba74189bead2 feeb0c3770394e498f918dcf8b6c73a2 c927151f6c5342e8b0dcba74189bead2--feeb0c3770394e498f918dcf8b6c73a2 5998738fef06438fb8b64c27a4ccf66a 97e6bf210c834b3d96f9918b1d72610c RX(theta\u2081) bdd997da32654d1e892d45ae40f1c662--97e6bf210c834b3d96f9918b1d72610c 10aab8619514477eaa24108a8e633611 2 e33ac66310344ef49c4b69f7c49ef1c7 RY(theta\u2084) 97e6bf210c834b3d96f9918b1d72610c--e33ac66310344ef49c4b69f7c49ef1c7 b7b9401b351a41c0be98b7d36b0b3b81 RX(theta\u2087) e33ac66310344ef49c4b69f7c49ef1c7--b7b9401b351a41c0be98b7d36b0b3b81 15efdb497bfb43bb837c3713a3dac702 X b7b9401b351a41c0be98b7d36b0b3b81--15efdb497bfb43bb837c3713a3dac702 15efdb497bfb43bb837c3713a3dac702--dce747d290b34d8d83637ee0bf91a2e8 831a6d9de166424fadd381a0329d2d35 15efdb497bfb43bb837c3713a3dac702--831a6d9de166424fadd381a0329d2d35 1047be2bdf5c4111adb1c04d07376e64 RX(theta\u2081\u2080) 831a6d9de166424fadd381a0329d2d35--1047be2bdf5c4111adb1c04d07376e64 038c7c4c9e1742a9b16c9c298f6577bc RY(theta\u2081\u2083) 1047be2bdf5c4111adb1c04d07376e64--038c7c4c9e1742a9b16c9c298f6577bc 6f526d4c87c241ec90e78f5790fed3cb RX(theta\u2081\u2086) 038c7c4c9e1742a9b16c9c298f6577bc--6f526d4c87c241ec90e78f5790fed3cb 0694e3e7bb1d4104819ac7383bb18f5e X 6f526d4c87c241ec90e78f5790fed3cb--0694e3e7bb1d4104819ac7383bb18f5e 0694e3e7bb1d4104819ac7383bb18f5e--8b59344f30d1472da567aee769a86e69 c013b747960a4ffe87aeff7920c28789 0694e3e7bb1d4104819ac7383bb18f5e--c013b747960a4ffe87aeff7920c28789 624fa994cf54438f88ea1d84a23de4e4 AddBlock c013b747960a4ffe87aeff7920c28789--624fa994cf54438f88ea1d84a23de4e4 624fa994cf54438f88ea1d84a23de4e4--5998738fef06438fb8b64c27a4ccf66a c46e19d20fa04b4ca1de8452594cbf31 6401a946cf804a8c9a6b86789184f0df RX(theta\u2082) 10aab8619514477eaa24108a8e633611--6401a946cf804a8c9a6b86789184f0df 178b347b75cf4ca783dcc33cdc3ebc2a RY(theta\u2085) 6401a946cf804a8c9a6b86789184f0df--178b347b75cf4ca783dcc33cdc3ebc2a 054f642b5fe04dfe9e7e5fe999483e2a RX(theta\u2088) 178b347b75cf4ca783dcc33cdc3ebc2a--054f642b5fe04dfe9e7e5fe999483e2a eb33899daac5444f9887aec8518b9066 054f642b5fe04dfe9e7e5fe999483e2a--eb33899daac5444f9887aec8518b9066 f7ace9f2f1384ed3a3e35da10b0a8074 X eb33899daac5444f9887aec8518b9066--f7ace9f2f1384ed3a3e35da10b0a8074 f7ace9f2f1384ed3a3e35da10b0a8074--831a6d9de166424fadd381a0329d2d35 9ca0df96c9b64241b2865c1583d47699 RX(theta\u2081\u2081) f7ace9f2f1384ed3a3e35da10b0a8074--9ca0df96c9b64241b2865c1583d47699 a5cd5c6e0c0c46d4ab32c56d26c7c555 RY(theta\u2081\u2084) 9ca0df96c9b64241b2865c1583d47699--a5cd5c6e0c0c46d4ab32c56d26c7c555 fed78598fb574e239dd3b91867d6c028 RX(theta\u2081\u2087) a5cd5c6e0c0c46d4ab32c56d26c7c555--fed78598fb574e239dd3b91867d6c028 db03782722784a11b3edfd8406b0d057 fed78598fb574e239dd3b91867d6c028--db03782722784a11b3edfd8406b0d057 a6c65cb8d3ba4a66a5760dbb877bae3b X db03782722784a11b3edfd8406b0d057--a6c65cb8d3ba4a66a5760dbb877bae3b a6c65cb8d3ba4a66a5760dbb877bae3b--c013b747960a4ffe87aeff7920c28789 a3202b824452457fa8c8363bfddf3671 a6c65cb8d3ba4a66a5760dbb877bae3b--a3202b824452457fa8c8363bfddf3671 a3202b824452457fa8c8363bfddf3671--c46e19d20fa04b4ca1de8452594cbf31 <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 bb71df26050445639d1e8c1b2c8d8c99 0 dcbb6fb63e9c401fbbdb9f4f6506364e bb71df26050445639d1e8c1b2c8d8c99--dcbb6fb63e9c401fbbdb9f4f6506364e f6135cc68116445d9f2e13be883dd144 1 cc303c9b34c5498588347a32b4739d84 c391a23664f248159e6ca215e3776e11 dcbb6fb63e9c401fbbdb9f4f6506364e--c391a23664f248159e6ca215e3776e11 daec8e77ef7d456596a17d1776c6eba2 cc303c9b34c5498588347a32b4739d84--daec8e77ef7d456596a17d1776c6eba2 e79b70c4587f4593a22c69b94007df06 170c7486dfbc400b9416e7a7640dff8f daec8e77ef7d456596a17d1776c6eba2--170c7486dfbc400b9416e7a7640dff8f 4d84772562bc40b7a6257733b1b6a2c2 e79b70c4587f4593a22c69b94007df06--4d84772562bc40b7a6257733b1b6a2c2 4bf208a078e246d8946db49cc3e8fa39 ff62ee9f2335475bbdc290ad5575a323 f6135cc68116445d9f2e13be883dd144--ff62ee9f2335475bbdc290ad5575a323 74d29c7b16684f929d0e3cc5eedec94b 2 ff62ee9f2335475bbdc290ad5575a323--cc303c9b34c5498588347a32b4739d84 702edfc6c9aa4b8fa3bf5d2a57fb7f79 c391a23664f248159e6ca215e3776e11--702edfc6c9aa4b8fa3bf5d2a57fb7f79 e45b101277864ff497482a33ec4b3355 702edfc6c9aa4b8fa3bf5d2a57fb7f79--e45b101277864ff497482a33ec4b3355 e45b101277864ff497482a33ec4b3355--4bf208a078e246d8946db49cc3e8fa39 272af0b33c464d278561706179c3f98c a60ecbf29f2d478aa5ebf2977fd80f5f 74d29c7b16684f929d0e3cc5eedec94b--a60ecbf29f2d478aa5ebf2977fd80f5f fdd29404036145a9bded7a6c1fafedd2 3 968c93e675894094a46be2f7bce5787b a60ecbf29f2d478aa5ebf2977fd80f5f--968c93e675894094a46be2f7bce5787b 5f117a20753043998825335ffe0edec8 968c93e675894094a46be2f7bce5787b--5f117a20753043998825335ffe0edec8 3ae954e7803a4a6e82ca31c985eb27d6 5f117a20753043998825335ffe0edec8--3ae954e7803a4a6e82ca31c985eb27d6 3ae954e7803a4a6e82ca31c985eb27d6--272af0b33c464d278561706179c3f98c 128bb356e67040f6b380500b98d0bf2a fe050210119b49d4b8da31fd514985f0 fdd29404036145a9bded7a6c1fafedd2--fe050210119b49d4b8da31fd514985f0 ed0275c111df467f9f767118f61304a9 fe050210119b49d4b8da31fd514985f0--ed0275c111df467f9f767118f61304a9 e14eeca2b9ad45a88fb26693b503aad2 ed0275c111df467f9f767118f61304a9--e14eeca2b9ad45a88fb26693b503aad2 e14eeca2b9ad45a88fb26693b503aad2--e79b70c4587f4593a22c69b94007df06 170c7486dfbc400b9416e7a7640dff8f--128bb356e67040f6b380500b98d0bf2a <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 974f1d4cf46c43ca844c516494b8713d 0 07401233c0a14833ada32000fe5a992e 974f1d4cf46c43ca844c516494b8713d--07401233c0a14833ada32000fe5a992e 70348b1d255d4c44aa0b7b14751b62fa 1 681134cc213a4d5fb6dd858c84b0b448 07401233c0a14833ada32000fe5a992e--681134cc213a4d5fb6dd858c84b0b448 1805991430cd4cec835efa46d6d202f3 681134cc213a4d5fb6dd858c84b0b448--1805991430cd4cec835efa46d6d202f3 03f3c193134a4061afd324197817dbd3 1805991430cd4cec835efa46d6d202f3--03f3c193134a4061afd324197817dbd3 7359a66d73b14e209e383bb87804c289 3988302ea32a41bb92742e01748e1936 PHASE(0.5) 70348b1d255d4c44aa0b7b14751b62fa--3988302ea32a41bb92742e01748e1936 d28f13baf19b4590a2715099d1924a28 2 3988302ea32a41bb92742e01748e1936--07401233c0a14833ada32000fe5a992e 487fa124322144f0a9b5cad68a7627dd 3988302ea32a41bb92742e01748e1936--487fa124322144f0a9b5cad68a7627dd 98ba4713706546b8b7ec849cce0ceeeb 487fa124322144f0a9b5cad68a7627dd--98ba4713706546b8b7ec849cce0ceeeb 98ba4713706546b8b7ec849cce0ceeeb--7359a66d73b14e209e383bb87804c289 160a1ca9d8e1444aa2414d0a380e6f0e ccd9c3a98a1f4664bf291a895ae5be2f d28f13baf19b4590a2715099d1924a28--ccd9c3a98a1f4664bf291a895ae5be2f 59344050c3184d94853e75ed608463e5 3 f7739a3b4bbd423a97b508e53774a09e PHASE(0.5) ccd9c3a98a1f4664bf291a895ae5be2f--f7739a3b4bbd423a97b508e53774a09e f7739a3b4bbd423a97b508e53774a09e--681134cc213a4d5fb6dd858c84b0b448 adf881c9ebac4b57bd92a2a3ae4cd37f f7739a3b4bbd423a97b508e53774a09e--adf881c9ebac4b57bd92a2a3ae4cd37f adf881c9ebac4b57bd92a2a3ae4cd37f--160a1ca9d8e1444aa2414d0a380e6f0e d7b31298915245b0868196f2f5118cbb 42dd3e2489f74b3aa368830096257b74 59344050c3184d94853e75ed608463e5--42dd3e2489f74b3aa368830096257b74 4f12de3296684886b7526405d46943ef 42dd3e2489f74b3aa368830096257b74--4f12de3296684886b7526405d46943ef bf5d737cf9f941e48c4109794ef3407f PHASE(0.5) 4f12de3296684886b7526405d46943ef--bf5d737cf9f941e48c4109794ef3407f bf5d737cf9f941e48c4109794ef3407f--1805991430cd4cec835efa46d6d202f3 bf5d737cf9f941e48c4109794ef3407f--d7b31298915245b0868196f2f5118cbb"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from qadence import AnalogRot, PI\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = PI, # [rad/\u03bcs]\n    delta = PI, # [rad/\u03bcs]\n    phase = PI, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run, PI\nfrom qadence.analog.constants import C6_DICT\nfrom math import cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = PI\ndelta = PI\nphase = PI\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run, PI\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = PI\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>AnalogInteraction</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, AnalogInteraction, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = AnalogInteraction(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction, PI\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * PI * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * PI * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice, PI\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = PI)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>AnalogInteraction</code> operation initializes an <code>InteractionBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = QubitSupportType.GLOBAL</code>. However, composing blocks using <code>kron</code> with local qubit supports and different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, AnalogInteraction\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    AnalogInteraction(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    AnalogInteraction(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    AnalogInteraction(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2024-01-30T10:16:05.465141 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook, we solve a quadratic unconstrained binary optimization (QUBO) problem with Qadence. QUBOs are very popular combinatorial optimization problems with a wide range of applications. Here, we solve the problem using the QAOA <sup>1</sup> variational algorithm by embedding the QUBO problem weights onto a register as standard for neutral atom quantum devices.</p> <p>Additional background information on QUBOs can be found here, directly solved using the pulse-level interface Pulser.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: optimal register coordinates for embedding the QUBO problem <p>A basic ingredient for solving a QUBO problem with a neutral atom device is to embed the problem onto the atomic register. In short, embedding algorithms cast the problem onto a graph mapped onto the register by optimally finding atomic coordinates. A discussion on the embedding algorithms is beyond the scope of this tutorial and a simplified version taken from here is added below.</p> <p><pre><code>import numpy as np\nimport numpy.typing as npt\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom qadence import RydbergDevice\n\ndef qubo_register_coords(Q: np.ndarray, device: RydbergDevice) -&gt; list:\n    \"\"\"Compute coordinates for register.\"\"\"\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        interaction_coeff = device.rydberg_level\n        new_Q = squareform(interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <p>With the embedding routine under our belt, let's start by adding the required imports and ensure the reproducibility of this tutorial.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRX, AnalogRZ, chain\nfrom qadence.ml_tools import train_gradient_free, TrainConfig, num_parameters\nimport nevergrad as ng\nimport matplotlib.pyplot as plt\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted edges and a cost function to be optimized. The weighted edges are represented by a real-valued symmetric matrix <code>Q</code> which is used throughout the tutorial.</p> <pre><code># QUBO problem weights (real-value symmetric matrix)\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n\ndef loss(model: QuantumModel, *args) -&gt; tuple[float, dict]:\n    to_arr_fn = lambda bitstring: np.array(list(bitstring), dtype=int)\n    cost_fn = lambda arr: arr.T @ Q @ arr\n    samples = model.sample({}, n_shots=1000)[0]  # extract samples\n    cost_fn = sum(samples[key] * cost_fn(to_arr_fn(key)) for key in samples)\n    return cost_fn / sum(samples.values()), {}  # We return an optional metrics dict\n</code></pre> <p>The QAOA algorithm needs a variational quantum circuit with optimizable parameters. For that purpose, we use a fully analog circuit composed of two global rotations per layer on different axes of the Bloch sphere. The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian <sup>1</sup>. In this setting, the embedding is realized by the appropriate register coordinates and the resulting qubit interaction.</p> Rydberg level <p>The Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in the original tutorial, and set the device specifications with the updated Rydberg level.</p> <pre><code># Device specification and atomic register\ndevice = RydbergDevice(rydberg_level=70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q, device), device_specs=device\n)\n\n# Analog variational quantum circuit\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\ncircuit = QuantumCircuit(reg, block)\n</code></pre> <pre><code>\n</code></pre> <p>By feeding the circuit to a <code>QuantumModel</code> we can check the initial counts where no clear solution can be found:</p> <pre><code>model = QuantumModel(circuit)\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'01000': 197, '00001': 193, '00010': 189, '00100': 174, '10000': 169, '00000': 78})\n</code></pre> <p>Finally, we can proceed with the variational optimization. The cost function defined above is derived from bitstring computations and therefore non differentiable. We use Qadence ML facilities to run gradient-free optimizations using the <code>nevergrad</code> library.</p> <pre><code>config = TrainConfig(max_iter=100)\noptimizer = ng.optimizers.NGOpt(\n    budget=config.max_iter, parametrization=num_parameters(model)\n)\ntrain_gradient_free(model, None, optimizer, config, loss)\n\noptimal_counts = model.sample({}, n_shots=1000)[0]\n</code></pre>   optimal_count = Counter({'00100': 191, '10000': 190, '00001': 183, '01000': 181, '00010': 163, '00000': 92})    <p>Finally, let's plot the solution. The expected bitstrings are marked in red.</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings = [\"01011\", \"00111\"]\n\ndef plot_distribution(C, ax, title):\n    C = dict(sorted(C.items(), key=lambda item: item[1], reverse=True))\n    indexes = solution_bitstrings # QUBO solutions\n    color_dict = {key: \"r\" if key in indexes else \"g\" for key in C}\n    ax.set_xlabel(\"bitstrings\")\n    ax.set_ylabel(\"counts\")\n    ax.set_xticks([i for i in range(len(C.keys()))], C.keys(), rotation=90)\n    ax.bar(list(C.keys())[:20], list(C.values())[:20])\n    ax.set_title(title)\n\nfig, axs = plt.subplots(1, 2, figsize=(12, 4))\nplot_distribution(initial_counts, axs[0], \"Initial counts\")\nplot_distribution(optimal_counts, axs[1], \"Optimal counts\")\n</code></pre> 2024-01-30T10:16:07.050137 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/#references","title":"References","text":"<ol> <li> <p>Edward Farhi, Jeffrey Goldstone, Sam Gutmann, A Quantum Approximate Optimization Algorithm, arXiv:1411.4028 (2014) \u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo, PI\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = PI\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=PI,            # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_6839549c6f884777bae65227a7a636e0 cluster_db6baa9ff4164ca4baca37e6b4658a37 cluster_fc73cac0ca014f1d9a6aa091ea25eef8 cluster_2960c63efbdd4e73aec0cff230cecadb cluster_34154b0ac4c54b118afd722affdc548e cluster_c76f70f41b9d45be836318ae6c54f7e5 cluster_98483d1a40d24d6bb5f653bf7c906470 4f5572073d1941248b7adac4bb2d4073 0 517f455723fb473a8a1b618992b33fe0 HamEvo 4f5572073d1941248b7adac4bb2d4073--517f455723fb473a8a1b618992b33fe0 bc441ca822cf4c4590c40cfe5effdaf4 1 e43b6a4830c140ca8387ea45d4ccc094 HamEvo 517f455723fb473a8a1b618992b33fe0--e43b6a4830c140ca8387ea45d4ccc094 445c03d7f2624f72baa513592b108b73 HamEvo e43b6a4830c140ca8387ea45d4ccc094--445c03d7f2624f72baa513592b108b73 f6dedb824a7142c3a69737fac972a2f7 X 445c03d7f2624f72baa513592b108b73--f6dedb824a7142c3a69737fac972a2f7 56471f3376dd4a62bf632767ce2abd7c HamEvo f6dedb824a7142c3a69737fac972a2f7--56471f3376dd4a62bf632767ce2abd7c d9c2ca2556a946afb878b4e8423d0cc7 HamEvo 56471f3376dd4a62bf632767ce2abd7c--d9c2ca2556a946afb878b4e8423d0cc7 a9da39f982c7463c9f21c36a76175a3b X d9c2ca2556a946afb878b4e8423d0cc7--a9da39f982c7463c9f21c36a76175a3b dc82246c827744b0883e85a522885c61 a9da39f982c7463c9f21c36a76175a3b--dc82246c827744b0883e85a522885c61 1343a55f012947e98d0081e7baa602a8 HamEvo dc82246c827744b0883e85a522885c61--1343a55f012947e98d0081e7baa602a8 d11701280e1e413bba0f994dac3820ae HamEvo 1343a55f012947e98d0081e7baa602a8--d11701280e1e413bba0f994dac3820ae 65fd25500be8451087ce1c161b266d0b d11701280e1e413bba0f994dac3820ae--65fd25500be8451087ce1c161b266d0b 86b243f7ada843b6a1f9baf45841fcba 65fd25500be8451087ce1c161b266d0b--86b243f7ada843b6a1f9baf45841fcba b632350f138c4b3b91e956483e2c06c6 9e87847f51bd4e16b9a07ad2a060db9f t = -3.142 bc441ca822cf4c4590c40cfe5effdaf4--9e87847f51bd4e16b9a07ad2a060db9f e3ab1c3290f64464a6146d3cac8642c2 2 c4a5ef8a9fbc4ba1b3b9453d9dad7415 t = 3.142 9e87847f51bd4e16b9a07ad2a060db9f--c4a5ef8a9fbc4ba1b3b9453d9dad7415 d14188d1699c422dbb1ee39b9bd5d76e t = -3.142 c4a5ef8a9fbc4ba1b3b9453d9dad7415--d14188d1699c422dbb1ee39b9bd5d76e 46611899c46b488f9e355876cb99879f d14188d1699c422dbb1ee39b9bd5d76e--46611899c46b488f9e355876cb99879f c4ef0698f5c4474bafe50a0684e1183b t = 1.571 46611899c46b488f9e355876cb99879f--c4ef0698f5c4474bafe50a0684e1183b e2f4179e291a440bbc9931a827ea9245 t = 1.571 c4ef0698f5c4474bafe50a0684e1183b--e2f4179e291a440bbc9931a827ea9245 098cb710ec7d49f0892ffde867fbd84e e2f4179e291a440bbc9931a827ea9245--098cb710ec7d49f0892ffde867fbd84e 6ece77f493c749adbd1fff4c8eef4136 X 098cb710ec7d49f0892ffde867fbd84e--6ece77f493c749adbd1fff4c8eef4136 072c5443ff064a02928a129b45fb647e t = 1.571 6ece77f493c749adbd1fff4c8eef4136--072c5443ff064a02928a129b45fb647e c19e5bee9a904e1bb6bda946832b0b54 t = 1.571 072c5443ff064a02928a129b45fb647e--c19e5bee9a904e1bb6bda946832b0b54 6680fc566bcf4cdfac8a36e55ebd0c5d X c19e5bee9a904e1bb6bda946832b0b54--6680fc566bcf4cdfac8a36e55ebd0c5d 6680fc566bcf4cdfac8a36e55ebd0c5d--b632350f138c4b3b91e956483e2c06c6 0cd32ede015244348b6d390d0f17a93b 3fd2c45aa8b246619754f07d60946189 e3ab1c3290f64464a6146d3cac8642c2--3fd2c45aa8b246619754f07d60946189 81c60501580545a89f5100ef8f915d6b 3fd2c45aa8b246619754f07d60946189--81c60501580545a89f5100ef8f915d6b 8f2afdda03a64d46a4cf08fb6506d804 81c60501580545a89f5100ef8f915d6b--8f2afdda03a64d46a4cf08fb6506d804 ff1012a1b2e4477a96abea5a35d041aa X 8f2afdda03a64d46a4cf08fb6506d804--ff1012a1b2e4477a96abea5a35d041aa 074b2b76569b4e87b98d0d72c1c9610e ff1012a1b2e4477a96abea5a35d041aa--074b2b76569b4e87b98d0d72c1c9610e cc5abd97963b41fb8282eab0943e9cd8 074b2b76569b4e87b98d0d72c1c9610e--cc5abd97963b41fb8282eab0943e9cd8 5b01d7a33a2e4a9d8ef8081b29faab9f X cc5abd97963b41fb8282eab0943e9cd8--5b01d7a33a2e4a9d8ef8081b29faab9f 95049487eae24c96a1b4e18d48c90d23 X 5b01d7a33a2e4a9d8ef8081b29faab9f--95049487eae24c96a1b4e18d48c90d23 3c56a7fc293245a5adeecd31552ed455 95049487eae24c96a1b4e18d48c90d23--3c56a7fc293245a5adeecd31552ed455 dc7f76b3eec844e49211f1c01a176805 3c56a7fc293245a5adeecd31552ed455--dc7f76b3eec844e49211f1c01a176805 2e5de85f538d4a7cb0f6b536880d44f5 X dc7f76b3eec844e49211f1c01a176805--2e5de85f538d4a7cb0f6b536880d44f5 2e5de85f538d4a7cb0f6b536880d44f5--0cd32ede015244348b6d390d0f17a93b <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_5e592853a47545fbbe28df8b3613ffeb cluster_5531fe6882d8441fa5027c94dc91c3aa 0dd4ee3f49834ba8b73190bc7ce15842 0 466214fd0ce149bf8fe34f16fcc7f4b6 X 0dd4ee3f49834ba8b73190bc7ce15842--466214fd0ce149bf8fe34f16fcc7f4b6 60de69bf25f348d19f5ab8d5d00628db 1 cf70bd37393443998e1210e8df645e6c HamEvo 466214fd0ce149bf8fe34f16fcc7f4b6--cf70bd37393443998e1210e8df645e6c 4052147935c8452f9f68b950afb6e7c8 X cf70bd37393443998e1210e8df645e6c--4052147935c8452f9f68b950afb6e7c8 394f340a54354beab22d3f2678267896 4052147935c8452f9f68b950afb6e7c8--394f340a54354beab22d3f2678267896 1554561404a4477c8d11b64392259e33 HamEvo 394f340a54354beab22d3f2678267896--1554561404a4477c8d11b64392259e33 37b5f27d42264050b6b28fdf2ecf0c3a 1554561404a4477c8d11b64392259e33--37b5f27d42264050b6b28fdf2ecf0c3a 8f1f8d6f756a441ebda1e9ea25da2517 37b5f27d42264050b6b28fdf2ecf0c3a--8f1f8d6f756a441ebda1e9ea25da2517 cf65c36cc8c44878b76f716d73906c0b 816c7fa54d5248c3971efc1a30fd2abc 60de69bf25f348d19f5ab8d5d00628db--816c7fa54d5248c3971efc1a30fd2abc 128892d5118a4c5abfc5efcfa574e72e 2 902b13028d3e4465b2ce594d5aedd88c t = -0.500 816c7fa54d5248c3971efc1a30fd2abc--902b13028d3e4465b2ce594d5aedd88c fce0695904cb4c68b762b3e2b13fd834 902b13028d3e4465b2ce594d5aedd88c--fce0695904cb4c68b762b3e2b13fd834 856ba0ddccdd49e1b0506e4e548273bd X fce0695904cb4c68b762b3e2b13fd834--856ba0ddccdd49e1b0506e4e548273bd e1a2d77450ac4c2498f5d428b596d6e9 t = -0.500 856ba0ddccdd49e1b0506e4e548273bd--e1a2d77450ac4c2498f5d428b596d6e9 4f35ed084d0d46ca9086651a3463d33d X e1a2d77450ac4c2498f5d428b596d6e9--4f35ed084d0d46ca9086651a3463d33d 4f35ed084d0d46ca9086651a3463d33d--cf65c36cc8c44878b76f716d73906c0b 143704b3196e4dec8d149a6b52900958 b73f5aa1b01a4ea88ac7585c3999398c X 128892d5118a4c5abfc5efcfa574e72e--b73f5aa1b01a4ea88ac7585c3999398c 598e090b5aa541f782efa07582a5627d b73f5aa1b01a4ea88ac7585c3999398c--598e090b5aa541f782efa07582a5627d 2b820437972f4bd09bfb2e39eddcdcbb X 598e090b5aa541f782efa07582a5627d--2b820437972f4bd09bfb2e39eddcdcbb bacc31459a804196b581e85440b8fd8c X 2b820437972f4bd09bfb2e39eddcdcbb--bacc31459a804196b581e85440b8fd8c 16c40584c1844e1bbb10501b77a5806d bacc31459a804196b581e85440b8fd8c--16c40584c1844e1bbb10501b77a5806d 83b6a9af3922472089ab98f308ade8a5 X 16c40584c1844e1bbb10501b77a5806d--83b6a9af3922472089ab98f308ade8a5 83b6a9af3922472089ab98f308ade8a5--143704b3196e4dec8d149a6b52900958 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_fb7cea927eda4922bf12bffbd3d55c3b cluster_e6263a1f82ea4003aa65863369dd465d 657f4232206440deae4f328a3a07b11b 0 a49935977f6143c4802b0cf60f576bcd X 657f4232206440deae4f328a3a07b11b--a49935977f6143c4802b0cf60f576bcd 4576f1640deb4783a69c888ea0f5a661 1 166a4a8db08f4a0e8a9e4424731eb9d5 HamEvo a49935977f6143c4802b0cf60f576bcd--166a4a8db08f4a0e8a9e4424731eb9d5 32324d4d93be4cb49831cf529d91e40a X 166a4a8db08f4a0e8a9e4424731eb9d5--32324d4d93be4cb49831cf529d91e40a 7f8636eb777944529d90988f283b3b39 32324d4d93be4cb49831cf529d91e40a--7f8636eb777944529d90988f283b3b39 6e5280a6ce88436489dc10a3658a6f08 HamEvo 7f8636eb777944529d90988f283b3b39--6e5280a6ce88436489dc10a3658a6f08 0dccf9f86579430b878b7e316db9ec17 6e5280a6ce88436489dc10a3658a6f08--0dccf9f86579430b878b7e316db9ec17 c52015cc06364e3a8c560b9f67d33f77 0dccf9f86579430b878b7e316db9ec17--c52015cc06364e3a8c560b9f67d33f77 647c42e428344468bc2f3572b2a41110 469e5c7457854005b9010f6a7ea7fde5 4576f1640deb4783a69c888ea0f5a661--469e5c7457854005b9010f6a7ea7fde5 70af0a3449034436bbd210d865bd39d5 2 344c9c8d1ffc4db79a1d16699606cc8f t = -500.000000000000 469e5c7457854005b9010f6a7ea7fde5--344c9c8d1ffc4db79a1d16699606cc8f 1ed8ab9a2a8f4099833feeef8e732063 344c9c8d1ffc4db79a1d16699606cc8f--1ed8ab9a2a8f4099833feeef8e732063 be6dda365e5242d4a0ce0944b80e68a6 X 1ed8ab9a2a8f4099833feeef8e732063--be6dda365e5242d4a0ce0944b80e68a6 3aa4307853714c24827730fbc8d05814 t = -500.000000000000 be6dda365e5242d4a0ce0944b80e68a6--3aa4307853714c24827730fbc8d05814 17dfb88f9c5248a9b865da43503d934d X 3aa4307853714c24827730fbc8d05814--17dfb88f9c5248a9b865da43503d934d 17dfb88f9c5248a9b865da43503d934d--647c42e428344468bc2f3572b2a41110 4e407e21a33a4203ace644a53a471109 1ebf29e1601f455a9c7d338b1d22fb46 X 70af0a3449034436bbd210d865bd39d5--1ebf29e1601f455a9c7d338b1d22fb46 75f0f4b0d2f44ab79833e047fafd7232 1ebf29e1601f455a9c7d338b1d22fb46--75f0f4b0d2f44ab79833e047fafd7232 236bdf729433437fad2bf3dda1732bc3 X 75f0f4b0d2f44ab79833e047fafd7232--236bdf729433437fad2bf3dda1732bc3 1be76d2220bc49ed96081c18f4ba5738 X 236bdf729433437fad2bf3dda1732bc3--1be76d2220bc49ed96081c18f4ba5738 6f632bc2715b4fe5b5b33bedca4e554e 1be76d2220bc49ed96081c18f4ba5738--6f632bc2715b4fe5b5b33bedca4e554e 18c02b38748e40b093e6b1700a9e6668 X 6f632bc2715b4fe5b5b33bedca4e554e--18c02b38748e40b093e6b1700a9e6668 18c02b38748e40b093e6b1700a9e6668--4e407e21a33a4203ace644a53a471109 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>AnalogInteraction</code> An idle block to to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.19153186677421175, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel, PI\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 30, '11': 20})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2024-01-30T10:16:07.572455 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2024-01-30T10:16:07.936178 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 21, '10': 2})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>AnalogInteraction</code> and <code>AnalogRY</code> blocks together with appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, AnalogInteraction\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-PI / 2),\n        AnalogInteraction(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([PI / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2024-01-30T10:16:08.409840 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(PI/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2024-01-30T10:16:08.564040 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n    PI\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.0100])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.0106])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(PI)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.6974]) The trained function value:  tensor([[0.6974]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>InteractionBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, AnalogInteraction\n\nb = chain(AnalogInteraction(200), AnalogInteraction(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), AnalogInteraction(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `InteractionBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, AnalogInteraction\n\n    b = chain(AnalogInteraction(200), AnalogInteraction(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), AnalogInteraction(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.InteractionBlock","title":"<code>InteractionBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Free-evolution for the Hamiltonian interaction term of a register of qubits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct, use the <code>AnalogInteraction</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.1205+0.2779j, -0.4028-0.5196j, -0.6412+0.0323j, -0.2348-0.0933j],\n         [-0.1532-0.2579j,  0.3364+0.4789j, -0.6311-0.0889j, -0.3710+0.1539j],\n         [-0.2295-0.6436j, -0.0058-0.3170j,  0.1553+0.2692j, -0.3819-0.4360j],\n         [-0.0921-0.5856j, -0.2621-0.2365j, -0.1598-0.2440j,  0.4385+0.4966j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * PI),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None, param_prefix=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | Callable | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data provided comes from. Used to map input data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI). Used to map data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <code>param_prefix</code> <p>string prefix to create trainable parameters multiplying the feature parameter inside the feature-encoding function. Note that currently this does not take into account the domain of the feature-encoding function.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | Callable | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n    param_prefix: str | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data provided comes from. Used to map input data\n            to the correct domain of the feature-encoding function.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI).\n            Used to map data to the correct domain of the feature-encoding function.\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n        param_prefix: string prefix to create trainable parameters multiplying the feature parameter\n            inside the feature-encoding function. Note that currently this does not take into\n            account the domain of the feature-encoding function.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    # Backwards compatibility\n    fm_type, reupload_scaling = backwards_compatibility(fm_type, reupload_scaling)\n\n    scaled_fparam = fm_parameter_scaling(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    transform_func = fm_parameter_func(fm_type)\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    fparam = scaled_fparam\n    for i, qubit in enumerate(support):\n        if param_prefix is not None:\n            train_param = VariationalParameter(param_prefix + f\"_{i}\")\n            fparam = train_param * scaled_fparam\n        op_list.append(op(qubit, multiplier * rs_func(i) * transform_func(fparam)))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | Callable | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | Callable | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        if callable(interaction):\n            int_fn = interaction\n            try:\n                if not block_is_qubit_hamiltonian(interaction(0, 1)):\n                    raise ValueError(\"Custom interactions must be composed of Pauli operators.\")\n            except TypeError:\n                raise TypeError(\n                    \"Please use a custom interaction function signed with two integer parameters.\"\n                )\n        else:\n            int_fn = INTERACTION_DICT.get(interaction, None)  # type: ignore [arg-type]\n            if int_fn is None:\n                raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * PI / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7ff8e773ab00&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7ff8e773af80&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, None)\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    data = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.3026, 0.2765]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n[tensor([0.6595, 0.0538, 0.8660, 0.8650, 0.0394]), tensor([0.2900, 0.3294, 0.6735, 0.3359, 0.2816]), tensor([0.4227, 0.3033, 0.5571, 0.8693, 0.4491])]\n[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run, PI\nimport torch\nhevo = HamEvo(generator=RX(0, PI), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.1384-3.6270e-17j, -0.5441+1.7335e-17j],\n        [ 1.2545-5.3697e-17j, -0.7574+3.2421e-17j]])\ntensor([[1.5091-0.7780j, 0.5771-0.9542j],\n        [1.4106-0.5384j, 0.5040-0.6605j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * PI / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * PI / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-PI / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = PI\n    omega = 0\n    duration = alpha / delta * 1000\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=0.0, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n\n    if omega == 0 and delta == 0:\n        raise ValueError(\"Parameters omega and delta cannot both be 0.\")\n\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    alpha = duration * h_norm / 1000\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogInteraction","title":"<code>AnalogInteraction(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Evolution of the interaction term for a register of qubits.</p> <p>Constructs a <code>InteractionBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to evolve the interaction for in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>InteractionBlock</code> is applied to. Can be either <code>\"global\"</code> to evolve the interaction block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>InteractionBlock</code> <p>a <code>InteractionBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogInteraction(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; InteractionBlock:\n    \"\"\"Evolution of the interaction term for a register of qubits.\n\n    Constructs a [`InteractionBlock`][qadence.blocks.analog.InteractionBlock].\n\n    Arguments:\n        duration: Time to evolve the interaction for in nanoseconds.\n        qubit_support: Qubits the `InteractionBlock` is applied to. Can be either\n            `\"global\"` to evolve the interaction block to all qubits or a tuple of integers.\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        a `InteractionBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return InteractionBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['cd708a66-76e7-41af-80f7-dc8599a65f1d', '6d01a1f0-f87a-4eac-808b-fc50c62d9ccc'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.9859993654159114\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.6903893734503416\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = make_differentiable(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False, engine=Engine.TORCH)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level.</p> <p>parameters or gate-level parameters. The constructed embedding function has the signature:</p> <pre><code> embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False, engine: Engine = Engine.TORCH\n) -&gt; tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType],]:\n    \"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*.\n\n    parameters or *gate-level* parameters. The constructed embedding function has the signature:\n\n         embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n    concretize_parameter = _concretize_parameter(engine)\n    if engine == Engine.TORCH:\n        cast_dtype = tensor\n    else:\n        from jax.numpy import array\n\n        cast_dtype = array\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, DifferentiableExpression] = {\n        expr: make_differentiable(expr=expr, engine=engine)\n        for expr in unique_expressions\n        if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n        embedded_params: dict[sympy.Expr, ArrayLike] = {}\n        for expr, fn in embeddings.items():\n            angle: ArrayLike\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: ParamDictType = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: ParamDictType\n    params = {\n        p.name: concretize_parameter(value=p.value, trainable=True) for p in trainable_symbols\n    }\n    params.update(\n        {\n            stringify(expr): concretize_parameter(value=evaluate(expr), trainable=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): cast_dtype(nparray(expr.tolist(), dtype=npcdouble))\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('118d7f36-4d7a-438a-b4f4-b743e3b7e61d', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.6398639069137206'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('079c4aef-e43f-4c6e-83ef-dad46c404b77', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.4276945815961849'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('76703149-1d8a-40cb-a6d9-c1c36c33c9f2', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.8742892845567309'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a4f27634-76f3-4e11-9460-a0a1065fa9a3', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.41919975377010965'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('6d9112bd-8e25-42b8-9b48-380cc52aced5', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6109177287180888'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('9fc35a7c-a995-4f29-a211-f467f9ea7be5', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.37421788716051174'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('2e777a9c-b11e-464e-9987-aff18afb593c', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9806087614373826'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('65f3f0f6-6833-438c-98ca-d719449db462', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.1191298453974663'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('2992f064-faa3-4cfd-8b24-c0e7942a3e74', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.2908857259376022'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('f2d63158-d05b-492d-bee1-0ab6bbd7be94', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.43496561975352277'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('c7fdf0d4-b21e-4947-a59d-55f706d90f82', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.13952221070351867'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('f2acfc8b-396b-448c-867a-c4b66e993ca2', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.230873635340905'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>11010001\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.3881-0.1329j,  0.2745-0.3881j, -0.2080+0.2140j,  0.6633-0.2767j]])\ntensor([[0.8285-0.2437j, 0.1422+0.4837j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGINTERACTION","title":"<code>ANALOGINTERACTION = 'AnalogInteraction'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog interaction operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANGLE","title":"<code>ENTANGLE = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 78, '1000': 8, '0010': 5, '0100': 4, '0001': 1, '0101': 1, '1010': 1, '1101': 1, '1110': 1})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[-0.0018],\n        [-0.0004],\n        [ 0.0510],\n        [ 0.0049],\n        [ 0.0771],\n        [ 0.0133],\n        [-0.0328],\n        [-0.0192],\n        [ 0.0395],\n        [-0.0323]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4053],\n        [0.9018],\n        [0.9084],\n        [0.2606],\n        [0.9428]]), tensor([[0.3943],\n        [0.7844],\n        [0.7885],\n        [0.2577],\n        [0.8092]])], 'y2': [tensor([[0.4695],\n        [0.1881],\n        [0.6359],\n        [0.7454],\n        [0.2043]]), tensor([[0.4524],\n        [0.1870],\n        [0.5939],\n        [0.6783],\n        [0.2029]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2024-01-30T10:16:30.820004 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2024-01-30T10:16:31.387539 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_ad461d9c4eb44f4a94ff466216be50cb mixing cluster_840f379d00c14434a991b2dfff02b02a cost cluster_e98827aabd044631b561a137a84b82e3 mixing cluster_fa8e837732c64667a8396761a473b46c cost 8eb56de7c78e4a2c9f48d4a906b5ef9b 0 042afcdfc206404aa4fdb4fdf38895d7 8eb56de7c78e4a2c9f48d4a906b5ef9b--042afcdfc206404aa4fdb4fdf38895d7 0830aa978f594b1483e4534e14f08551 1 2c0cf3dc5af341288820be2bf844deeb 042afcdfc206404aa4fdb4fdf38895d7--2c0cf3dc5af341288820be2bf844deeb ef9e317c88db46b5a54cd8f2cb4f1756 2c0cf3dc5af341288820be2bf844deeb--ef9e317c88db46b5a54cd8f2cb4f1756 c0bf133e38864a49bd24e1e2fc24cee0 ef9e317c88db46b5a54cd8f2cb4f1756--c0bf133e38864a49bd24e1e2fc24cee0 f5ab28eb6ef74767973c4eedd60a7e3c c0bf133e38864a49bd24e1e2fc24cee0--f5ab28eb6ef74767973c4eedd60a7e3c 24fcd90c52b24d8da9fa79cccd25f600 f5ab28eb6ef74767973c4eedd60a7e3c--24fcd90c52b24d8da9fa79cccd25f600 e7091d6d747d45b9ac9bca588160e766 24fcd90c52b24d8da9fa79cccd25f600--e7091d6d747d45b9ac9bca588160e766 e4116a46d94647f2bc3050f439df265b e7091d6d747d45b9ac9bca588160e766--e4116a46d94647f2bc3050f439df265b 4a4366bf65794070b61fb354777c0976 e4116a46d94647f2bc3050f439df265b--4a4366bf65794070b61fb354777c0976 f5ff3949ddc140638ba9d93d368d3f6d 4a4366bf65794070b61fb354777c0976--f5ff3949ddc140638ba9d93d368d3f6d 0977c59e2bb84debaa7c57288c6ebd15 f5ff3949ddc140638ba9d93d368d3f6d--0977c59e2bb84debaa7c57288c6ebd15 00dda24e2d224a71b16aa631e76d0ccd 0977c59e2bb84debaa7c57288c6ebd15--00dda24e2d224a71b16aa631e76d0ccd b9f4c75b0f224c9a917374836a7d8172 00dda24e2d224a71b16aa631e76d0ccd--b9f4c75b0f224c9a917374836a7d8172 2254743ea35d479dbef79c15f0f3f143 b9f4c75b0f224c9a917374836a7d8172--2254743ea35d479dbef79c15f0f3f143 7470ac43b6e347f6919a73c206376553 2254743ea35d479dbef79c15f0f3f143--7470ac43b6e347f6919a73c206376553 7309760b3b8d45038350d29922d6d6a4 7470ac43b6e347f6919a73c206376553--7309760b3b8d45038350d29922d6d6a4 b5d23946750740538b907e8f19d6fa8f 7309760b3b8d45038350d29922d6d6a4--b5d23946750740538b907e8f19d6fa8f 844db3cff3a846e3aaacd9f0d79d9aae b5d23946750740538b907e8f19d6fa8f--844db3cff3a846e3aaacd9f0d79d9aae e7e1a2173c5848a2b36b94cd37f37f07 844db3cff3a846e3aaacd9f0d79d9aae--e7e1a2173c5848a2b36b94cd37f37f07 0b3e76a23df74992bb38087e00a17b7d e7e1a2173c5848a2b36b94cd37f37f07--0b3e76a23df74992bb38087e00a17b7d f61440db00024219a02129c8b70647c1 0b3e76a23df74992bb38087e00a17b7d--f61440db00024219a02129c8b70647c1 becfe7e9e05640348de01721fa48d2cb f61440db00024219a02129c8b70647c1--becfe7e9e05640348de01721fa48d2cb b7ec126e973d49498cbaf7edb681f679 becfe7e9e05640348de01721fa48d2cb--b7ec126e973d49498cbaf7edb681f679 8864c1fa6622471a8025ba331c19d693 b7ec126e973d49498cbaf7edb681f679--8864c1fa6622471a8025ba331c19d693 64df949451ee4ae89e4f6b8a5b569ca7 8864c1fa6622471a8025ba331c19d693--64df949451ee4ae89e4f6b8a5b569ca7 4ee4fda17e3f48ef8784b3205691bd67 64df949451ee4ae89e4f6b8a5b569ca7--4ee4fda17e3f48ef8784b3205691bd67 383d6dc0698f403987107b6179f299fd 4ee4fda17e3f48ef8784b3205691bd67--383d6dc0698f403987107b6179f299fd f75dc8d3925c426597439f6195de619f 383d6dc0698f403987107b6179f299fd--f75dc8d3925c426597439f6195de619f 49349aaa42bc4739ba1c8df419038746 f75dc8d3925c426597439f6195de619f--49349aaa42bc4739ba1c8df419038746 884d5018e6804074819bcf5feadc6962 49349aaa42bc4739ba1c8df419038746--884d5018e6804074819bcf5feadc6962 7c5e16bd95404baf9657516da6901ca0 884d5018e6804074819bcf5feadc6962--7c5e16bd95404baf9657516da6901ca0 3e02f40a7d834d899f52937e47a80a73 7c5e16bd95404baf9657516da6901ca0--3e02f40a7d834d899f52937e47a80a73 25e1b1c9ad5d46d199932fa8164726f2 3e02f40a7d834d899f52937e47a80a73--25e1b1c9ad5d46d199932fa8164726f2 83138d5d6973434c9f444c3962ad6948 25e1b1c9ad5d46d199932fa8164726f2--83138d5d6973434c9f444c3962ad6948 b8286a6d9e004e4c8f9b23f5ba86306a 83138d5d6973434c9f444c3962ad6948--b8286a6d9e004e4c8f9b23f5ba86306a 5374e557b86a4a26bb8141a0ee5906e7 b8286a6d9e004e4c8f9b23f5ba86306a--5374e557b86a4a26bb8141a0ee5906e7 3def1e1e92724f46a46033a4af477fbc 5374e557b86a4a26bb8141a0ee5906e7--3def1e1e92724f46a46033a4af477fbc 927462a3e7134d63a18f29b793320b39 3def1e1e92724f46a46033a4af477fbc--927462a3e7134d63a18f29b793320b39 1a37af87b021474babcf7cfcc236ab7d 927462a3e7134d63a18f29b793320b39--1a37af87b021474babcf7cfcc236ab7d 8a8e5c55eda54ae0980d79109424a16c 1a37af87b021474babcf7cfcc236ab7d--8a8e5c55eda54ae0980d79109424a16c c1653bb6583f42859b142bcebd9ffd2b 8a8e5c55eda54ae0980d79109424a16c--c1653bb6583f42859b142bcebd9ffd2b 66129e38634945de9d53742a9df6b026 c1653bb6583f42859b142bcebd9ffd2b--66129e38634945de9d53742a9df6b026 e25154b3805f406ab81faa0c1c5ce9b9 66129e38634945de9d53742a9df6b026--e25154b3805f406ab81faa0c1c5ce9b9 581ff1ebffe04364baac797eed409bec e25154b3805f406ab81faa0c1c5ce9b9--581ff1ebffe04364baac797eed409bec 2fe847e87a8d46ab947963b472f10cfe 581ff1ebffe04364baac797eed409bec--2fe847e87a8d46ab947963b472f10cfe 5fce90764bb040b0bddadfbf13e2fc19 2fe847e87a8d46ab947963b472f10cfe--5fce90764bb040b0bddadfbf13e2fc19 17267445c9fa4fe69fba6ae2cd7dbbba 5fce90764bb040b0bddadfbf13e2fc19--17267445c9fa4fe69fba6ae2cd7dbbba ee54bd7dc06a4037bebcc9d8a3a6a36a 17267445c9fa4fe69fba6ae2cd7dbbba--ee54bd7dc06a4037bebcc9d8a3a6a36a 8909e9eded4b44f495bef2040a931244 ee54bd7dc06a4037bebcc9d8a3a6a36a--8909e9eded4b44f495bef2040a931244 d7255090d6df417685dc1c25f802fbda 8909e9eded4b44f495bef2040a931244--d7255090d6df417685dc1c25f802fbda 3891edb6ecb049ce94d2c82cffe2902a d7255090d6df417685dc1c25f802fbda--3891edb6ecb049ce94d2c82cffe2902a c2b3bc1510084f5cab46d5c19354a9ca 3891edb6ecb049ce94d2c82cffe2902a--c2b3bc1510084f5cab46d5c19354a9ca 9e184398d964418b84d22d91e59fcdb6 c2b3bc1510084f5cab46d5c19354a9ca--9e184398d964418b84d22d91e59fcdb6 fa981b23265a4cb9b5d4c2949866f864 9e184398d964418b84d22d91e59fcdb6--fa981b23265a4cb9b5d4c2949866f864 4cb826d5cb144e29842ab15f88107aff fa981b23265a4cb9b5d4c2949866f864--4cb826d5cb144e29842ab15f88107aff b642182b1de644f9bb2fabecdfe933c2 4cb826d5cb144e29842ab15f88107aff--b642182b1de644f9bb2fabecdfe933c2 9a9b7847f4e940b49e53700fa4e8871f b642182b1de644f9bb2fabecdfe933c2--9a9b7847f4e940b49e53700fa4e8871f 3a565842753e4dec8ba019d9bc211084 9a9b7847f4e940b49e53700fa4e8871f--3a565842753e4dec8ba019d9bc211084 c85babc2ecb54ac09587f7fa05aa9e0e 3a565842753e4dec8ba019d9bc211084--c85babc2ecb54ac09587f7fa05aa9e0e be5aba85f15b4f8fa38434d5f6251166 c85babc2ecb54ac09587f7fa05aa9e0e--be5aba85f15b4f8fa38434d5f6251166 41cd862af58c42ae8b5469bd1ed0447c be5aba85f15b4f8fa38434d5f6251166--41cd862af58c42ae8b5469bd1ed0447c adf945eb20b64ab39e0aee01f3df3a6d 41cd862af58c42ae8b5469bd1ed0447c--adf945eb20b64ab39e0aee01f3df3a6d a4b3b1b4dbcd46459d1d967bf9f2aecd adf945eb20b64ab39e0aee01f3df3a6d--a4b3b1b4dbcd46459d1d967bf9f2aecd ac474c7cf2ca4502a3c1a777d42db90b a4b3b1b4dbcd46459d1d967bf9f2aecd--ac474c7cf2ca4502a3c1a777d42db90b 950f43b67f8f427b8ac0a7d70c088fdc ac474c7cf2ca4502a3c1a777d42db90b--950f43b67f8f427b8ac0a7d70c088fdc 9308ab5057ca4a748988e9816ba736b0 950f43b67f8f427b8ac0a7d70c088fdc--9308ab5057ca4a748988e9816ba736b0 c4dd1da8ed034e12b5362f0c9711b353 9308ab5057ca4a748988e9816ba736b0--c4dd1da8ed034e12b5362f0c9711b353 ff7ca388fda54ee6ac10a40974144f2c c4dd1da8ed034e12b5362f0c9711b353--ff7ca388fda54ee6ac10a40974144f2c f0f61451163749e4b2d90a306d713aa3 ff7ca388fda54ee6ac10a40974144f2c--f0f61451163749e4b2d90a306d713aa3 265b1e31034148dfa41eeb050f1449e3 f0f61451163749e4b2d90a306d713aa3--265b1e31034148dfa41eeb050f1449e3 41492696c3ed4bcc8256104b47fedcb8 265b1e31034148dfa41eeb050f1449e3--41492696c3ed4bcc8256104b47fedcb8 49a1200ff3024a749d1f240278f80b0f 41492696c3ed4bcc8256104b47fedcb8--49a1200ff3024a749d1f240278f80b0f fde06c3f18e44968bfe9e88c970ef967 49a1200ff3024a749d1f240278f80b0f--fde06c3f18e44968bfe9e88c970ef967 35f08c7915014ee2a5ce3b488d6eacb7 fde06c3f18e44968bfe9e88c970ef967--35f08c7915014ee2a5ce3b488d6eacb7 deb0054f55494068bd5a8526de3fa1d4 35f08c7915014ee2a5ce3b488d6eacb7--deb0054f55494068bd5a8526de3fa1d4 45fda2a3006d4b85861002e7f77328fb deb0054f55494068bd5a8526de3fa1d4--45fda2a3006d4b85861002e7f77328fb 6f5290155ec040feb26f4d53eae8e2a3 45fda2a3006d4b85861002e7f77328fb--6f5290155ec040feb26f4d53eae8e2a3 e9e219e8f49d49c2a983a73fd3dcaa06 6f5290155ec040feb26f4d53eae8e2a3--e9e219e8f49d49c2a983a73fd3dcaa06 337f6ba20d1e42acb10637cc7f793dbd e9e219e8f49d49c2a983a73fd3dcaa06--337f6ba20d1e42acb10637cc7f793dbd 983e24b4f0294d90a3186d85a2624a83 337f6ba20d1e42acb10637cc7f793dbd--983e24b4f0294d90a3186d85a2624a83 6e9a93a646c949568e4350268ececc27 983e24b4f0294d90a3186d85a2624a83--6e9a93a646c949568e4350268ececc27 212d56be71b448968685d74fe230b32b 6e9a93a646c949568e4350268ececc27--212d56be71b448968685d74fe230b32b 42c5e6c032fd4cd38262678890a6da39 212d56be71b448968685d74fe230b32b--42c5e6c032fd4cd38262678890a6da39 bb65612c4ae348f9a690bbacd430dca0 42c5e6c032fd4cd38262678890a6da39--bb65612c4ae348f9a690bbacd430dca0 f60bbccdd3e9497b8db7313b1a52ea32 bb65612c4ae348f9a690bbacd430dca0--f60bbccdd3e9497b8db7313b1a52ea32 17cd597ff3f34f6ebcb37062b397afdb f60bbccdd3e9497b8db7313b1a52ea32--17cd597ff3f34f6ebcb37062b397afdb f1111c3f07a14c3595bfbd6ae6c52521 17cd597ff3f34f6ebcb37062b397afdb--f1111c3f07a14c3595bfbd6ae6c52521 645d525a16bb4783adc8709fcc7cb183 f1111c3f07a14c3595bfbd6ae6c52521--645d525a16bb4783adc8709fcc7cb183 70042faabca545b7940622b6693d769b 645d525a16bb4783adc8709fcc7cb183--70042faabca545b7940622b6693d769b 3603925e790648fdab7f6afa948b26d2 70042faabca545b7940622b6693d769b--3603925e790648fdab7f6afa948b26d2 c2b4cfccbc03420ba0707989f638e6b0 3603925e790648fdab7f6afa948b26d2--c2b4cfccbc03420ba0707989f638e6b0 2fe0fbdd3d7d457587417044dad6f225 c2b4cfccbc03420ba0707989f638e6b0--2fe0fbdd3d7d457587417044dad6f225 97f0b2996eb14d5c9131e590e9658c86 2fe0fbdd3d7d457587417044dad6f225--97f0b2996eb14d5c9131e590e9658c86 9aee0c7c997d4ffd934c8380e58d35a3 RX(b00) 97f0b2996eb14d5c9131e590e9658c86--9aee0c7c997d4ffd934c8380e58d35a3 f528276ebe7a4ef7b4a1fced0749eac4 9aee0c7c997d4ffd934c8380e58d35a3--f528276ebe7a4ef7b4a1fced0749eac4 7bd9e0fbb1f34f45811221379ddfe865 f528276ebe7a4ef7b4a1fced0749eac4--7bd9e0fbb1f34f45811221379ddfe865 7c05aa4a17ef4bb6b3be058c258816ee 7bd9e0fbb1f34f45811221379ddfe865--7c05aa4a17ef4bb6b3be058c258816ee eaa25d05c22846749228eff9d765fdf1 7c05aa4a17ef4bb6b3be058c258816ee--eaa25d05c22846749228eff9d765fdf1 c415030e030a4e7f95e8e566ecd188be eaa25d05c22846749228eff9d765fdf1--c415030e030a4e7f95e8e566ecd188be dca51c75b5264a2c9baee06a4bde6305 c415030e030a4e7f95e8e566ecd188be--dca51c75b5264a2c9baee06a4bde6305 f54e15cf68ea42d48d7d4fbdc84844f7 dca51c75b5264a2c9baee06a4bde6305--f54e15cf68ea42d48d7d4fbdc84844f7 16c09315cdd544d09f56a19b164f623b f54e15cf68ea42d48d7d4fbdc84844f7--16c09315cdd544d09f56a19b164f623b e406f29b56b64e309b569c84629dd271 16c09315cdd544d09f56a19b164f623b--e406f29b56b64e309b569c84629dd271 c934fae551c1422abd3587734fc13a29 e406f29b56b64e309b569c84629dd271--c934fae551c1422abd3587734fc13a29 9851702bd147487db8c9789d66220812 c934fae551c1422abd3587734fc13a29--9851702bd147487db8c9789d66220812 91fff4bf04004856bb219ee72f5927b6 9851702bd147487db8c9789d66220812--91fff4bf04004856bb219ee72f5927b6 1d0f09f6b9c54c3f9bfa98a46dd86efe 91fff4bf04004856bb219ee72f5927b6--1d0f09f6b9c54c3f9bfa98a46dd86efe dc6be48ab175458aa470e3155974c394 1d0f09f6b9c54c3f9bfa98a46dd86efe--dc6be48ab175458aa470e3155974c394 7730da24f7a34295946a5a95fe80b5fc dc6be48ab175458aa470e3155974c394--7730da24f7a34295946a5a95fe80b5fc 0c920df8f8dd4a52b6537a88165a98de 7730da24f7a34295946a5a95fe80b5fc--0c920df8f8dd4a52b6537a88165a98de c952c2d4f08d4ad7843f12e6dc783975 0c920df8f8dd4a52b6537a88165a98de--c952c2d4f08d4ad7843f12e6dc783975 8e0fde3e35b2430fab1c740c8703db80 c952c2d4f08d4ad7843f12e6dc783975--8e0fde3e35b2430fab1c740c8703db80 fc76dea1534f4488bc1b9ca014568fad 8e0fde3e35b2430fab1c740c8703db80--fc76dea1534f4488bc1b9ca014568fad 852976490749453d8dacf07f8750ef2d fc76dea1534f4488bc1b9ca014568fad--852976490749453d8dacf07f8750ef2d 501a560c3a1e44eea514126c092efffd 852976490749453d8dacf07f8750ef2d--501a560c3a1e44eea514126c092efffd 6c282e6e7db64b68b8f536484bf6ef67 501a560c3a1e44eea514126c092efffd--6c282e6e7db64b68b8f536484bf6ef67 ec75b4b92b4948a5b35164369bfe10be 6c282e6e7db64b68b8f536484bf6ef67--ec75b4b92b4948a5b35164369bfe10be c44add67bd3e43a588810a56981be515 ec75b4b92b4948a5b35164369bfe10be--c44add67bd3e43a588810a56981be515 fd49488f8e734e578aa60d1e94673d2a c44add67bd3e43a588810a56981be515--fd49488f8e734e578aa60d1e94673d2a 2057478958be4f93b47f7a84e5a697f2 fd49488f8e734e578aa60d1e94673d2a--2057478958be4f93b47f7a84e5a697f2 f219070489c348ccac92ef2b4f1eab37 2057478958be4f93b47f7a84e5a697f2--f219070489c348ccac92ef2b4f1eab37 1e8584e5e6214e9096e8ae3b06e82967 f219070489c348ccac92ef2b4f1eab37--1e8584e5e6214e9096e8ae3b06e82967 f541be281dc9445fac9473f384420b96 1e8584e5e6214e9096e8ae3b06e82967--f541be281dc9445fac9473f384420b96 2bc03c96e1be46c2a298d8fea053c927 f541be281dc9445fac9473f384420b96--2bc03c96e1be46c2a298d8fea053c927 0ab2ae98416e4390b4b7d597069646e1 2bc03c96e1be46c2a298d8fea053c927--0ab2ae98416e4390b4b7d597069646e1 2ac0ff73d6dd41d4a4059375b9fc8f57 0ab2ae98416e4390b4b7d597069646e1--2ac0ff73d6dd41d4a4059375b9fc8f57 f5639e4dd48242b8807907c98d12014e 2ac0ff73d6dd41d4a4059375b9fc8f57--f5639e4dd48242b8807907c98d12014e e948807590e441f99482062f113d4bc5 f5639e4dd48242b8807907c98d12014e--e948807590e441f99482062f113d4bc5 d94c51ebc7154c04ae7127c0e8f07e7f e948807590e441f99482062f113d4bc5--d94c51ebc7154c04ae7127c0e8f07e7f 98daa226f557497d9b95648056da42b9 d94c51ebc7154c04ae7127c0e8f07e7f--98daa226f557497d9b95648056da42b9 b926277577cf4b14b861985ba847fa01 98daa226f557497d9b95648056da42b9--b926277577cf4b14b861985ba847fa01 80a2d37be857422498c2af6bedaf4c73 b926277577cf4b14b861985ba847fa01--80a2d37be857422498c2af6bedaf4c73 c6964609c57f4c57a1f8277e0f2038a3 80a2d37be857422498c2af6bedaf4c73--c6964609c57f4c57a1f8277e0f2038a3 56a6dbaedd3349deaca494b787b472b0 c6964609c57f4c57a1f8277e0f2038a3--56a6dbaedd3349deaca494b787b472b0 c07a1f242ac1454493dee6bcf244f289 56a6dbaedd3349deaca494b787b472b0--c07a1f242ac1454493dee6bcf244f289 95e7f78f0ab34687906df122dac21fa4 c07a1f242ac1454493dee6bcf244f289--95e7f78f0ab34687906df122dac21fa4 cae65c1a31ca48158e8ff412ac2aa09d 95e7f78f0ab34687906df122dac21fa4--cae65c1a31ca48158e8ff412ac2aa09d eb2b6dfbab92450da3f8e5b4822d2ac7 cae65c1a31ca48158e8ff412ac2aa09d--eb2b6dfbab92450da3f8e5b4822d2ac7 7b1b2d37cb6c479ba818b839f8b6e458 eb2b6dfbab92450da3f8e5b4822d2ac7--7b1b2d37cb6c479ba818b839f8b6e458 978b91fbffe74765bf677699ab038601 7b1b2d37cb6c479ba818b839f8b6e458--978b91fbffe74765bf677699ab038601 e72465fd4f6c4947a0d94a90451a7525 978b91fbffe74765bf677699ab038601--e72465fd4f6c4947a0d94a90451a7525 c113f73a320349dc947c5562eb0125e5 e72465fd4f6c4947a0d94a90451a7525--c113f73a320349dc947c5562eb0125e5 34e97f4407f343c5844696290b69f2a2 c113f73a320349dc947c5562eb0125e5--34e97f4407f343c5844696290b69f2a2 4372cbdc7d4b4350ab24a0c4e342935b 34e97f4407f343c5844696290b69f2a2--4372cbdc7d4b4350ab24a0c4e342935b 9a257a06fb5841b389fd500609bc4259 4372cbdc7d4b4350ab24a0c4e342935b--9a257a06fb5841b389fd500609bc4259 8a71c2ffbc4a411a9de74eed2fa0d881 9a257a06fb5841b389fd500609bc4259--8a71c2ffbc4a411a9de74eed2fa0d881 d8ab408841214367b3883bd3da352676 8a71c2ffbc4a411a9de74eed2fa0d881--d8ab408841214367b3883bd3da352676 28b0b985b8604cb983b5bdda0ae84e92 d8ab408841214367b3883bd3da352676--28b0b985b8604cb983b5bdda0ae84e92 c5ec5d94ddc44cfeaa67b691a2662841 28b0b985b8604cb983b5bdda0ae84e92--c5ec5d94ddc44cfeaa67b691a2662841 6ba3bd5d9d8b4d688154b1309bcce4d0 c5ec5d94ddc44cfeaa67b691a2662841--6ba3bd5d9d8b4d688154b1309bcce4d0 8ce7cec9eaa2428186b4d7920d7a66b0 6ba3bd5d9d8b4d688154b1309bcce4d0--8ce7cec9eaa2428186b4d7920d7a66b0 fdf7216f99d342eeb440df45aae20042 8ce7cec9eaa2428186b4d7920d7a66b0--fdf7216f99d342eeb440df45aae20042 f5dfc8d7b2d148258d4e9b2414db4a5c fdf7216f99d342eeb440df45aae20042--f5dfc8d7b2d148258d4e9b2414db4a5c 5a3904016c1b4cde9be5304954b0566a f5dfc8d7b2d148258d4e9b2414db4a5c--5a3904016c1b4cde9be5304954b0566a 81262b8830ca4d37ba963f9c5162ac62 5a3904016c1b4cde9be5304954b0566a--81262b8830ca4d37ba963f9c5162ac62 275c87a8328c44f39b0017dba5e93bf3 81262b8830ca4d37ba963f9c5162ac62--275c87a8328c44f39b0017dba5e93bf3 a448606ab2fe43a297014764966dd794 275c87a8328c44f39b0017dba5e93bf3--a448606ab2fe43a297014764966dd794 e7155163beca4d209cffa9b35eb8de32 a448606ab2fe43a297014764966dd794--e7155163beca4d209cffa9b35eb8de32 b0501532659f4ae7bc005743f642159a e7155163beca4d209cffa9b35eb8de32--b0501532659f4ae7bc005743f642159a 6337bf919adf464da0a0cd7a77f66e3d b0501532659f4ae7bc005743f642159a--6337bf919adf464da0a0cd7a77f66e3d d89a050cb77c492abdf00808b7041f8d 6337bf919adf464da0a0cd7a77f66e3d--d89a050cb77c492abdf00808b7041f8d 1de125993ba846c1830433d36e446711 d89a050cb77c492abdf00808b7041f8d--1de125993ba846c1830433d36e446711 8e3d6f425e144219ae1e6cf7e07f2da2 1de125993ba846c1830433d36e446711--8e3d6f425e144219ae1e6cf7e07f2da2 e71b90e68c6149ab9fb081b3466d8090 8e3d6f425e144219ae1e6cf7e07f2da2--e71b90e68c6149ab9fb081b3466d8090 48256050f83642ec9cc63431ea91047a e71b90e68c6149ab9fb081b3466d8090--48256050f83642ec9cc63431ea91047a a718f0d54fca4a99af958d7bd1ce6271 48256050f83642ec9cc63431ea91047a--a718f0d54fca4a99af958d7bd1ce6271 110b45855b674d879697c9983ea6cfcd a718f0d54fca4a99af958d7bd1ce6271--110b45855b674d879697c9983ea6cfcd 4b2c88c5523c4573a5ad35de82826ca7 110b45855b674d879697c9983ea6cfcd--4b2c88c5523c4573a5ad35de82826ca7 85885cf54b2142d6bad8698e1667e5aa 4b2c88c5523c4573a5ad35de82826ca7--85885cf54b2142d6bad8698e1667e5aa 548758e5d16a4a299b793e5924088e38 85885cf54b2142d6bad8698e1667e5aa--548758e5d16a4a299b793e5924088e38 fd31062539bb4f0783b42e836b16e0c5 548758e5d16a4a299b793e5924088e38--fd31062539bb4f0783b42e836b16e0c5 96fc23543b074959bda835ce7c461f31 fd31062539bb4f0783b42e836b16e0c5--96fc23543b074959bda835ce7c461f31 3f050e0ad3d94600b8cf0491ecf6aee8 96fc23543b074959bda835ce7c461f31--3f050e0ad3d94600b8cf0491ecf6aee8 fe37152e63774d7f91d4693f07951937 3f050e0ad3d94600b8cf0491ecf6aee8--fe37152e63774d7f91d4693f07951937 84a3e2251f9d496a8f6beee2d6de660e fe37152e63774d7f91d4693f07951937--84a3e2251f9d496a8f6beee2d6de660e 166660569b4644568b5a13ec223686e7 84a3e2251f9d496a8f6beee2d6de660e--166660569b4644568b5a13ec223686e7 46f9789d8344430b90da60d8fc26a3e2 166660569b4644568b5a13ec223686e7--46f9789d8344430b90da60d8fc26a3e2 23b1c708ce074793a1fab640edcebf6e 46f9789d8344430b90da60d8fc26a3e2--23b1c708ce074793a1fab640edcebf6e b5e81a44cad443eeb3dad68a568b49cd 23b1c708ce074793a1fab640edcebf6e--b5e81a44cad443eeb3dad68a568b49cd ec8333045367425ab3b46882d7262eb1 b5e81a44cad443eeb3dad68a568b49cd--ec8333045367425ab3b46882d7262eb1 b999fe6efdc74b00a0e95a12a583af1b ec8333045367425ab3b46882d7262eb1--b999fe6efdc74b00a0e95a12a583af1b aceeb49d07154b4b9dd2c23dcf736cef b999fe6efdc74b00a0e95a12a583af1b--aceeb49d07154b4b9dd2c23dcf736cef c7eb09ed200c4e329828fdf604c4a56b aceeb49d07154b4b9dd2c23dcf736cef--c7eb09ed200c4e329828fdf604c4a56b 52ca6c523875404089aa6c1e48a2c239 c7eb09ed200c4e329828fdf604c4a56b--52ca6c523875404089aa6c1e48a2c239 ff13fffd18394b819354cf926285d968 52ca6c523875404089aa6c1e48a2c239--ff13fffd18394b819354cf926285d968 d7c00931483449fbb44068c950fceb31 ff13fffd18394b819354cf926285d968--d7c00931483449fbb44068c950fceb31 12bde8279a1b4ec7822add1852a4ad6a d7c00931483449fbb44068c950fceb31--12bde8279a1b4ec7822add1852a4ad6a 26924d884fdc4dd088eebdf3f4da5cfb RX(b10) 12bde8279a1b4ec7822add1852a4ad6a--26924d884fdc4dd088eebdf3f4da5cfb e02f01236d0a416bb691741865ab9f52 26924d884fdc4dd088eebdf3f4da5cfb--e02f01236d0a416bb691741865ab9f52 6ec3c32b7f9448529d18dd725b661833 32a8f9fa9113433fbc1750a100331735 X 0830aa978f594b1483e4534e14f08551--32a8f9fa9113433fbc1750a100331735 bd17ca2a349e42ecb3ecc91e24ae25f0 2 32a8f9fa9113433fbc1750a100331735--042afcdfc206404aa4fdb4fdf38895d7 ec31e38ff1a14aa4809f2925c084242f 32a8f9fa9113433fbc1750a100331735--ec31e38ff1a14aa4809f2925c084242f f2f55ae403bf4331a8054bf480e71eb5 ec31e38ff1a14aa4809f2925c084242f--f2f55ae403bf4331a8054bf480e71eb5 9737d64c506b4642a3a6e6008b693d09 f2f55ae403bf4331a8054bf480e71eb5--9737d64c506b4642a3a6e6008b693d09 deda750bf3874296b075a1ffd742ff08 9737d64c506b4642a3a6e6008b693d09--deda750bf3874296b075a1ffd742ff08 be62026895fe4df6876f3e14f3fa6b64 deda750bf3874296b075a1ffd742ff08--be62026895fe4df6876f3e14f3fa6b64 b88e1b28f993408483e93467f0f9f648 be62026895fe4df6876f3e14f3fa6b64--b88e1b28f993408483e93467f0f9f648 cc9df09c75224d29869accb1c44d4900 b88e1b28f993408483e93467f0f9f648--cc9df09c75224d29869accb1c44d4900 3f651460f6ad4e568b2e887becaa753a cc9df09c75224d29869accb1c44d4900--3f651460f6ad4e568b2e887becaa753a c4d61496185b4e64a60f96c97c805a6b 3f651460f6ad4e568b2e887becaa753a--c4d61496185b4e64a60f96c97c805a6b 7a3ca4daed6748aba6235a661096f312 c4d61496185b4e64a60f96c97c805a6b--7a3ca4daed6748aba6235a661096f312 6b53a13b0b264724b21d0ad7c8981e66 7a3ca4daed6748aba6235a661096f312--6b53a13b0b264724b21d0ad7c8981e66 81957a0e307f4716a461e9e503cbd8f5 6b53a13b0b264724b21d0ad7c8981e66--81957a0e307f4716a461e9e503cbd8f5 7e9640626e764724b874fee7812c7db6 81957a0e307f4716a461e9e503cbd8f5--7e9640626e764724b874fee7812c7db6 45cb96a466fc41f197ab2c9224168a75 X 7e9640626e764724b874fee7812c7db6--45cb96a466fc41f197ab2c9224168a75 45cb96a466fc41f197ab2c9224168a75--7470ac43b6e347f6919a73c206376553 f8ffbdf42ac94309b22cdae26a9f24d3 X 45cb96a466fc41f197ab2c9224168a75--f8ffbdf42ac94309b22cdae26a9f24d3 f8ffbdf42ac94309b22cdae26a9f24d3--7309760b3b8d45038350d29922d6d6a4 c7bef544276344eeab2a8d157668291d f8ffbdf42ac94309b22cdae26a9f24d3--c7bef544276344eeab2a8d157668291d 65a95ea06589498fa290ed0eeb911807 c7bef544276344eeab2a8d157668291d--65a95ea06589498fa290ed0eeb911807 820fab7e44974aa5ae4bcc6ac213b004 65a95ea06589498fa290ed0eeb911807--820fab7e44974aa5ae4bcc6ac213b004 c23178027643414e88d39a94c2dba83a 820fab7e44974aa5ae4bcc6ac213b004--c23178027643414e88d39a94c2dba83a 07b2a02ae0874e118c43dca9bd09c676 c23178027643414e88d39a94c2dba83a--07b2a02ae0874e118c43dca9bd09c676 bdd952e0d1044d698ffda7ba5f3468e8 X 07b2a02ae0874e118c43dca9bd09c676--bdd952e0d1044d698ffda7ba5f3468e8 bdd952e0d1044d698ffda7ba5f3468e8--becfe7e9e05640348de01721fa48d2cb 82a85d1647b748f48af00ec5b51e45b0 X bdd952e0d1044d698ffda7ba5f3468e8--82a85d1647b748f48af00ec5b51e45b0 82a85d1647b748f48af00ec5b51e45b0--b7ec126e973d49498cbaf7edb681f679 fc7c5190face4b94b6345df3db9dde89 82a85d1647b748f48af00ec5b51e45b0--fc7c5190face4b94b6345df3db9dde89 0e0ed08249194e439f1b805195aca8a6 fc7c5190face4b94b6345df3db9dde89--0e0ed08249194e439f1b805195aca8a6 294a8d1189824cbe9e151fd152586ab8 0e0ed08249194e439f1b805195aca8a6--294a8d1189824cbe9e151fd152586ab8 0cff13d8206e490e8603b0b8c31db084 294a8d1189824cbe9e151fd152586ab8--0cff13d8206e490e8603b0b8c31db084 dfbba6d584ed4d58b94ed9052cc0d37c 0cff13d8206e490e8603b0b8c31db084--dfbba6d584ed4d58b94ed9052cc0d37c c7f69084763f48d3a3f94274fab77c8c dfbba6d584ed4d58b94ed9052cc0d37c--c7f69084763f48d3a3f94274fab77c8c a7a47c10566d4a3b8f2f69335b50d949 c7f69084763f48d3a3f94274fab77c8c--a7a47c10566d4a3b8f2f69335b50d949 9820be5128d34ad681659f471d267bca a7a47c10566d4a3b8f2f69335b50d949--9820be5128d34ad681659f471d267bca 25d349bda9c34ba58639a4aa9034f945 9820be5128d34ad681659f471d267bca--25d349bda9c34ba58639a4aa9034f945 7ec715307e2c43998fa62514d49d5fed X 25d349bda9c34ba58639a4aa9034f945--7ec715307e2c43998fa62514d49d5fed 7ec715307e2c43998fa62514d49d5fed--25e1b1c9ad5d46d199932fa8164726f2 188d1bf709bb441ca941efe004a28cf1 7ec715307e2c43998fa62514d49d5fed--188d1bf709bb441ca941efe004a28cf1 f3cc9b1bcded48c89866475ba11cefde 188d1bf709bb441ca941efe004a28cf1--f3cc9b1bcded48c89866475ba11cefde 9e2b8b296a2343e3a9136f5a27669bbc f3cc9b1bcded48c89866475ba11cefde--9e2b8b296a2343e3a9136f5a27669bbc 4899b401dbe24dcca80636a566ab7592 9e2b8b296a2343e3a9136f5a27669bbc--4899b401dbe24dcca80636a566ab7592 e7f03a77973041b58d6336b2698ec298 4899b401dbe24dcca80636a566ab7592--e7f03a77973041b58d6336b2698ec298 6f9bbdcffb584b2c87bee6bede8eb8d6 e7f03a77973041b58d6336b2698ec298--6f9bbdcffb584b2c87bee6bede8eb8d6 bfc897124b47410baae2e6bc03ecd147 6f9bbdcffb584b2c87bee6bede8eb8d6--bfc897124b47410baae2e6bc03ecd147 fa0d6f6f58644d45844a86e4de29c0de bfc897124b47410baae2e6bc03ecd147--fa0d6f6f58644d45844a86e4de29c0de eb1472a7307d4c0bb2f8ad6e8263498b fa0d6f6f58644d45844a86e4de29c0de--eb1472a7307d4c0bb2f8ad6e8263498b f69ffb28a00f4f28b4c119dc380347d6 eb1472a7307d4c0bb2f8ad6e8263498b--f69ffb28a00f4f28b4c119dc380347d6 9dae6d0d50374f2d9c9cd64b7329772c f69ffb28a00f4f28b4c119dc380347d6--9dae6d0d50374f2d9c9cd64b7329772c 875b63c7e7104372aec80bbd112be4fe 9dae6d0d50374f2d9c9cd64b7329772c--875b63c7e7104372aec80bbd112be4fe fea33e9d5e834734bd2da60589aaad43 875b63c7e7104372aec80bbd112be4fe--fea33e9d5e834734bd2da60589aaad43 24a49730165343d6a45dad8d20056f4a fea33e9d5e834734bd2da60589aaad43--24a49730165343d6a45dad8d20056f4a 002c736f17bb48108f283a0f844b6726 24a49730165343d6a45dad8d20056f4a--002c736f17bb48108f283a0f844b6726 3235706f9bb84c7392e266475e1fe14e 002c736f17bb48108f283a0f844b6726--3235706f9bb84c7392e266475e1fe14e 9c2acea8496f43bca048c652b1013063 3235706f9bb84c7392e266475e1fe14e--9c2acea8496f43bca048c652b1013063 3b2abe1a77104c1194c1aed7ad54b9f5 9c2acea8496f43bca048c652b1013063--3b2abe1a77104c1194c1aed7ad54b9f5 addca0e0b9654c27bd9fa4cf22826684 3b2abe1a77104c1194c1aed7ad54b9f5--addca0e0b9654c27bd9fa4cf22826684 2f1947b8cf5a4ff9a230706fb8be760f addca0e0b9654c27bd9fa4cf22826684--2f1947b8cf5a4ff9a230706fb8be760f de5504a7f1d54a74bf15350905bbe932 2f1947b8cf5a4ff9a230706fb8be760f--de5504a7f1d54a74bf15350905bbe932 46adfd89d8094ac98957850550a88216 de5504a7f1d54a74bf15350905bbe932--46adfd89d8094ac98957850550a88216 c214f0ec65304ee7b3605f5daf9b9cbf 46adfd89d8094ac98957850550a88216--c214f0ec65304ee7b3605f5daf9b9cbf f35be5ff4dcf4ef0a459ee44eefc2aa3 c214f0ec65304ee7b3605f5daf9b9cbf--f35be5ff4dcf4ef0a459ee44eefc2aa3 47d074c02f04415e91d9e4f18f1a7052 f35be5ff4dcf4ef0a459ee44eefc2aa3--47d074c02f04415e91d9e4f18f1a7052 4ab6f0cd97d5478dad9b21267a4a1f30 47d074c02f04415e91d9e4f18f1a7052--4ab6f0cd97d5478dad9b21267a4a1f30 35455061f7ee44108d4d0c243eeb8c7d 4ab6f0cd97d5478dad9b21267a4a1f30--35455061f7ee44108d4d0c243eeb8c7d 837724a3e6964e6f8296c01c97f44072 35455061f7ee44108d4d0c243eeb8c7d--837724a3e6964e6f8296c01c97f44072 52d40e85913b4485bbdd0c5bc2e0dc8f 837724a3e6964e6f8296c01c97f44072--52d40e85913b4485bbdd0c5bc2e0dc8f ccc9c911eeb948f093bcd0da81b67b24 52d40e85913b4485bbdd0c5bc2e0dc8f--ccc9c911eeb948f093bcd0da81b67b24 df120d8b471640ceaa109c9453775d3a ccc9c911eeb948f093bcd0da81b67b24--df120d8b471640ceaa109c9453775d3a 4511a89bcfcc4469bc9e4004dbdffd6d df120d8b471640ceaa109c9453775d3a--4511a89bcfcc4469bc9e4004dbdffd6d 95f595ae46434f4982f49a165f275631 4511a89bcfcc4469bc9e4004dbdffd6d--95f595ae46434f4982f49a165f275631 fe3acec8598e41ac873054d509f9c5f5 95f595ae46434f4982f49a165f275631--fe3acec8598e41ac873054d509f9c5f5 c8f8b2c5472541c0a0c2d64e68e6dc9c fe3acec8598e41ac873054d509f9c5f5--c8f8b2c5472541c0a0c2d64e68e6dc9c be04d4667c604bce8d9318734ce4d4d3 c8f8b2c5472541c0a0c2d64e68e6dc9c--be04d4667c604bce8d9318734ce4d4d3 fe79eb3875ee495caebd9accb71b1b3a be04d4667c604bce8d9318734ce4d4d3--fe79eb3875ee495caebd9accb71b1b3a 43d8bd51b0bb42acbcebcb8d489b271f fe79eb3875ee495caebd9accb71b1b3a--43d8bd51b0bb42acbcebcb8d489b271f 0306d879c09f406689581959b9f4c280 43d8bd51b0bb42acbcebcb8d489b271f--0306d879c09f406689581959b9f4c280 28428d8143184b99894504a22c3eda8a 0306d879c09f406689581959b9f4c280--28428d8143184b99894504a22c3eda8a c4c68ea6c49946199a494d79ef65007d 28428d8143184b99894504a22c3eda8a--c4c68ea6c49946199a494d79ef65007d d51beebfc1d546658291756eee4fbfcf c4c68ea6c49946199a494d79ef65007d--d51beebfc1d546658291756eee4fbfcf e974598857654a7091751d5d1efe143e d51beebfc1d546658291756eee4fbfcf--e974598857654a7091751d5d1efe143e 4c23987720984b218dfb2acc2f1ab652 e974598857654a7091751d5d1efe143e--4c23987720984b218dfb2acc2f1ab652 ffa91007ecc4474c9f011f1b4d907128 4c23987720984b218dfb2acc2f1ab652--ffa91007ecc4474c9f011f1b4d907128 8988e5af96f548188c9abf4e3b493fa3 ffa91007ecc4474c9f011f1b4d907128--8988e5af96f548188c9abf4e3b493fa3 b5b6847f6c204d82bad2647b70d42aef 8988e5af96f548188c9abf4e3b493fa3--b5b6847f6c204d82bad2647b70d42aef c8ed9d65093d4a73a5d16bd25fac2463 b5b6847f6c204d82bad2647b70d42aef--c8ed9d65093d4a73a5d16bd25fac2463 4f916c2456084f1f9f89d9e98780aeb6 c8ed9d65093d4a73a5d16bd25fac2463--4f916c2456084f1f9f89d9e98780aeb6 a20a6ddc829b4a7cac102380fd3135a6 4f916c2456084f1f9f89d9e98780aeb6--a20a6ddc829b4a7cac102380fd3135a6 b9e750b7b9084de984dbb4ff37798666 a20a6ddc829b4a7cac102380fd3135a6--b9e750b7b9084de984dbb4ff37798666 f29674c0eddc43708a7792d41c6f7af9 b9e750b7b9084de984dbb4ff37798666--f29674c0eddc43708a7792d41c6f7af9 36b3f74dcd09446d8089286ee453fb1f f29674c0eddc43708a7792d41c6f7af9--36b3f74dcd09446d8089286ee453fb1f c2e7a160d3894bbcb6aa8d6f690d38f6 36b3f74dcd09446d8089286ee453fb1f--c2e7a160d3894bbcb6aa8d6f690d38f6 da593bea6b7f4708b7747230d8ec1add c2e7a160d3894bbcb6aa8d6f690d38f6--da593bea6b7f4708b7747230d8ec1add 13f8c5a87fe5432b8c7eaa6454f7843b da593bea6b7f4708b7747230d8ec1add--13f8c5a87fe5432b8c7eaa6454f7843b d76e81068af640b48a62eab19089bd22 13f8c5a87fe5432b8c7eaa6454f7843b--d76e81068af640b48a62eab19089bd22 92b1c35fa9ab4748983c9e065e68116a d76e81068af640b48a62eab19089bd22--92b1c35fa9ab4748983c9e065e68116a 841eab5b28264b56a325dba9398784a4 92b1c35fa9ab4748983c9e065e68116a--841eab5b28264b56a325dba9398784a4 d7f3e8c7ca63405491c7df39a964b88c 841eab5b28264b56a325dba9398784a4--d7f3e8c7ca63405491c7df39a964b88c e11bd838158041c18af757ffffb0e371 RX(b01) d7f3e8c7ca63405491c7df39a964b88c--e11bd838158041c18af757ffffb0e371 d9f893cb67644b08b09a0715109ff85f X e11bd838158041c18af757ffffb0e371--d9f893cb67644b08b09a0715109ff85f d9f893cb67644b08b09a0715109ff85f--f528276ebe7a4ef7b4a1fced0749eac4 90ee99053a3c4357a5f427922fc66d48 d9f893cb67644b08b09a0715109ff85f--90ee99053a3c4357a5f427922fc66d48 e36b8966993046e88f4c826d45ca60a9 90ee99053a3c4357a5f427922fc66d48--e36b8966993046e88f4c826d45ca60a9 9b00ab9183b3417aaa2466a73a70102f e36b8966993046e88f4c826d45ca60a9--9b00ab9183b3417aaa2466a73a70102f b085d3ac5a654147ab06ed70378869da 9b00ab9183b3417aaa2466a73a70102f--b085d3ac5a654147ab06ed70378869da b8b809a82781424ea345f458bf9b5fd3 b085d3ac5a654147ab06ed70378869da--b8b809a82781424ea345f458bf9b5fd3 c4086d3055324549b7d44a01be6a10c3 b8b809a82781424ea345f458bf9b5fd3--c4086d3055324549b7d44a01be6a10c3 89951dc8df6c4f699d8dc02429542d57 c4086d3055324549b7d44a01be6a10c3--89951dc8df6c4f699d8dc02429542d57 df872a58c3a843c5ac9ac527db1d14cd 89951dc8df6c4f699d8dc02429542d57--df872a58c3a843c5ac9ac527db1d14cd 074a9f8de1144fb2893239f4a370211f df872a58c3a843c5ac9ac527db1d14cd--074a9f8de1144fb2893239f4a370211f 45b84d64958e4250a17aa962f336c2cf 074a9f8de1144fb2893239f4a370211f--45b84d64958e4250a17aa962f336c2cf 165a2a32ad244b3996ed30ff6e1583fb 45b84d64958e4250a17aa962f336c2cf--165a2a32ad244b3996ed30ff6e1583fb 6466e9a3b84e495dafe23a0c248a9ff9 165a2a32ad244b3996ed30ff6e1583fb--6466e9a3b84e495dafe23a0c248a9ff9 3b203c5e6f1644d28c63c9e4d23abf53 6466e9a3b84e495dafe23a0c248a9ff9--3b203c5e6f1644d28c63c9e4d23abf53 dbd39343ca094ebc8d447bbed766f6a7 X 3b203c5e6f1644d28c63c9e4d23abf53--dbd39343ca094ebc8d447bbed766f6a7 dbd39343ca094ebc8d447bbed766f6a7--7730da24f7a34295946a5a95fe80b5fc b0ce0fafb6b245568e4421a63fbf7490 X dbd39343ca094ebc8d447bbed766f6a7--b0ce0fafb6b245568e4421a63fbf7490 b0ce0fafb6b245568e4421a63fbf7490--0c920df8f8dd4a52b6537a88165a98de 23fa10f8a06743c4837abe64dd31d6f5 b0ce0fafb6b245568e4421a63fbf7490--23fa10f8a06743c4837abe64dd31d6f5 540c6a20e8714685b283f24df6c6e183 23fa10f8a06743c4837abe64dd31d6f5--540c6a20e8714685b283f24df6c6e183 f41ca83064e3425b900fffaf1434cf7f 540c6a20e8714685b283f24df6c6e183--f41ca83064e3425b900fffaf1434cf7f 3c400d9d01ee4f539294ee80273cced1 f41ca83064e3425b900fffaf1434cf7f--3c400d9d01ee4f539294ee80273cced1 918d6af551cb46dca8459b24df23ea41 3c400d9d01ee4f539294ee80273cced1--918d6af551cb46dca8459b24df23ea41 e760bdb2eaf84fd19f53af2f453f5790 X 918d6af551cb46dca8459b24df23ea41--e760bdb2eaf84fd19f53af2f453f5790 e760bdb2eaf84fd19f53af2f453f5790--6c282e6e7db64b68b8f536484bf6ef67 e67dba21f7d645a284e52af3c58d1eb5 X e760bdb2eaf84fd19f53af2f453f5790--e67dba21f7d645a284e52af3c58d1eb5 e67dba21f7d645a284e52af3c58d1eb5--ec75b4b92b4948a5b35164369bfe10be 768f74e4c8e3472cb881261b0070b643 e67dba21f7d645a284e52af3c58d1eb5--768f74e4c8e3472cb881261b0070b643 b48fde866e394222920f1a8b19894474 768f74e4c8e3472cb881261b0070b643--b48fde866e394222920f1a8b19894474 99263f63681f43668fb168bcce7541fd b48fde866e394222920f1a8b19894474--99263f63681f43668fb168bcce7541fd 39527c085d6446629dc0bd97e45b0e8f 99263f63681f43668fb168bcce7541fd--39527c085d6446629dc0bd97e45b0e8f f8aba623b4b349baa0dc59f4d3f9e05e 39527c085d6446629dc0bd97e45b0e8f--f8aba623b4b349baa0dc59f4d3f9e05e 183369f39369475eaa14c77b56d66209 f8aba623b4b349baa0dc59f4d3f9e05e--183369f39369475eaa14c77b56d66209 c5fa83b373f3402baf743b20a444eab8 183369f39369475eaa14c77b56d66209--c5fa83b373f3402baf743b20a444eab8 c1d98751cca14a73b38e756a459e7e11 c5fa83b373f3402baf743b20a444eab8--c1d98751cca14a73b38e756a459e7e11 a971543e218c4c8fa98ed86d0b6a2850 c1d98751cca14a73b38e756a459e7e11--a971543e218c4c8fa98ed86d0b6a2850 aa1ca318c8cc44919f74a991f19a424e X a971543e218c4c8fa98ed86d0b6a2850--aa1ca318c8cc44919f74a991f19a424e aa1ca318c8cc44919f74a991f19a424e--f5639e4dd48242b8807907c98d12014e 2e7b2902704c4947b567a809ca138368 aa1ca318c8cc44919f74a991f19a424e--2e7b2902704c4947b567a809ca138368 072af982b2fc463c847bf9eeca215e3b 2e7b2902704c4947b567a809ca138368--072af982b2fc463c847bf9eeca215e3b 0794e2b2a263449d8fd50145b3365e24 072af982b2fc463c847bf9eeca215e3b--0794e2b2a263449d8fd50145b3365e24 e4299997ed85469b8e51e0eb3a2ef03a 0794e2b2a263449d8fd50145b3365e24--e4299997ed85469b8e51e0eb3a2ef03a 7614febda67d4064a24d5e30d7162b88 e4299997ed85469b8e51e0eb3a2ef03a--7614febda67d4064a24d5e30d7162b88 649c4429b5ee4a70ab89759a5a34cf7c 7614febda67d4064a24d5e30d7162b88--649c4429b5ee4a70ab89759a5a34cf7c 388ac60191ee40349180f38d5d0cbb2e 649c4429b5ee4a70ab89759a5a34cf7c--388ac60191ee40349180f38d5d0cbb2e 4c2e2eddf07345a19d424ad42860e5b3 388ac60191ee40349180f38d5d0cbb2e--4c2e2eddf07345a19d424ad42860e5b3 06ebc7de1c9645e9977b94a8fc3db66a 4c2e2eddf07345a19d424ad42860e5b3--06ebc7de1c9645e9977b94a8fc3db66a ddc991bb4a47490794af17c0571ef601 06ebc7de1c9645e9977b94a8fc3db66a--ddc991bb4a47490794af17c0571ef601 8a400ecd2b124a0fb4cffdc4f538a989 ddc991bb4a47490794af17c0571ef601--8a400ecd2b124a0fb4cffdc4f538a989 5c91b04bca274a7991494a5a46a9c098 8a400ecd2b124a0fb4cffdc4f538a989--5c91b04bca274a7991494a5a46a9c098 2062e3d901684a48a6b0c760f9d91b4a 5c91b04bca274a7991494a5a46a9c098--2062e3d901684a48a6b0c760f9d91b4a af0346b07ada4c5e89c41ad1df9d3aad 2062e3d901684a48a6b0c760f9d91b4a--af0346b07ada4c5e89c41ad1df9d3aad 4c37c5ccd3964eda8aa7fd8de30a1890 af0346b07ada4c5e89c41ad1df9d3aad--4c37c5ccd3964eda8aa7fd8de30a1890 2b3d39aca0554b2c8c1be184debcfd73 4c37c5ccd3964eda8aa7fd8de30a1890--2b3d39aca0554b2c8c1be184debcfd73 35d73be5d95342fe8f91581fa3adda8c 2b3d39aca0554b2c8c1be184debcfd73--35d73be5d95342fe8f91581fa3adda8c 9afbc079264b4781af6185f5088cb717 35d73be5d95342fe8f91581fa3adda8c--9afbc079264b4781af6185f5088cb717 fd1eacccafd9469d9c4aa3b74d9b1b29 9afbc079264b4781af6185f5088cb717--fd1eacccafd9469d9c4aa3b74d9b1b29 305b75abba44495990bd14fd5fc4f47f fd1eacccafd9469d9c4aa3b74d9b1b29--305b75abba44495990bd14fd5fc4f47f 84a64f7d6e744f27acd596c6076ced4f 305b75abba44495990bd14fd5fc4f47f--84a64f7d6e744f27acd596c6076ced4f 8e42b96a8d4049589fc6a05f21b6eb34 84a64f7d6e744f27acd596c6076ced4f--8e42b96a8d4049589fc6a05f21b6eb34 1d54d8c61a444551a5f293e09478e27b 8e42b96a8d4049589fc6a05f21b6eb34--1d54d8c61a444551a5f293e09478e27b 6bc5f7f3fcec43ec8be41d261d5cddd2 1d54d8c61a444551a5f293e09478e27b--6bc5f7f3fcec43ec8be41d261d5cddd2 350e0c8033d547918f845e5160b779ac 6bc5f7f3fcec43ec8be41d261d5cddd2--350e0c8033d547918f845e5160b779ac 39df5e67eba44c84978e3e80d37dee3f 350e0c8033d547918f845e5160b779ac--39df5e67eba44c84978e3e80d37dee3f de862522b462463bae8730c63ca1a6a6 39df5e67eba44c84978e3e80d37dee3f--de862522b462463bae8730c63ca1a6a6 05a2ed4c9754409e96875ad8fdfd7669 de862522b462463bae8730c63ca1a6a6--05a2ed4c9754409e96875ad8fdfd7669 c769e179bc714aab83eeec487eb1212b 05a2ed4c9754409e96875ad8fdfd7669--c769e179bc714aab83eeec487eb1212b e5da9f85a816436a830ad47ee958deaf c769e179bc714aab83eeec487eb1212b--e5da9f85a816436a830ad47ee958deaf 51329c5001ab4151878a14d755a840a9 e5da9f85a816436a830ad47ee958deaf--51329c5001ab4151878a14d755a840a9 deb19dd6acea459ca48baffdb5535af2 51329c5001ab4151878a14d755a840a9--deb19dd6acea459ca48baffdb5535af2 24d91fad00a44619a7632154dc4cfdf1 deb19dd6acea459ca48baffdb5535af2--24d91fad00a44619a7632154dc4cfdf1 eaae2fdb2f924998b89450ded1926527 24d91fad00a44619a7632154dc4cfdf1--eaae2fdb2f924998b89450ded1926527 0506275b23da4306868000d88937fada eaae2fdb2f924998b89450ded1926527--0506275b23da4306868000d88937fada 7495494d6c8d45aca2d8b9851d788bad 0506275b23da4306868000d88937fada--7495494d6c8d45aca2d8b9851d788bad d2db9c1c615d48b4b50a6b981909d29c 7495494d6c8d45aca2d8b9851d788bad--d2db9c1c615d48b4b50a6b981909d29c 3cab16da801d4bd68766c81cc607f621 d2db9c1c615d48b4b50a6b981909d29c--3cab16da801d4bd68766c81cc607f621 2d11702ff6f044699eb47627ddf02747 3cab16da801d4bd68766c81cc607f621--2d11702ff6f044699eb47627ddf02747 40f9903da8424d7c99ed0c2c33807456 2d11702ff6f044699eb47627ddf02747--40f9903da8424d7c99ed0c2c33807456 ce1f432c6cdd46889c78c483492cdd19 40f9903da8424d7c99ed0c2c33807456--ce1f432c6cdd46889c78c483492cdd19 2bcbf6bf79664d71bf38ffd4651218e6 ce1f432c6cdd46889c78c483492cdd19--2bcbf6bf79664d71bf38ffd4651218e6 de3d1238ba8c4ab3bbd351d46b0b3c1c 2bcbf6bf79664d71bf38ffd4651218e6--de3d1238ba8c4ab3bbd351d46b0b3c1c 6375e33932a142079e6f2a8a77cd7c23 de3d1238ba8c4ab3bbd351d46b0b3c1c--6375e33932a142079e6f2a8a77cd7c23 53ab4e0190c540148155279f1e8501ca 6375e33932a142079e6f2a8a77cd7c23--53ab4e0190c540148155279f1e8501ca d427e69c30c545adb90715d8df83f5d4 53ab4e0190c540148155279f1e8501ca--d427e69c30c545adb90715d8df83f5d4 cab8ac07a648417bb572d41b31576cee d427e69c30c545adb90715d8df83f5d4--cab8ac07a648417bb572d41b31576cee 275c685dd88646bf99ee4ae98dd9fcf3 cab8ac07a648417bb572d41b31576cee--275c685dd88646bf99ee4ae98dd9fcf3 0b56ccd54fcd42e6b3331a1ae1614d88 275c685dd88646bf99ee4ae98dd9fcf3--0b56ccd54fcd42e6b3331a1ae1614d88 b10d739c6737438db09df74f2ec3468c 0b56ccd54fcd42e6b3331a1ae1614d88--b10d739c6737438db09df74f2ec3468c 57fcd3b6b9ae48e3a014cef6b891c087 b10d739c6737438db09df74f2ec3468c--57fcd3b6b9ae48e3a014cef6b891c087 736a4f3ed35f4f08ab7dfbc0bcb47158 57fcd3b6b9ae48e3a014cef6b891c087--736a4f3ed35f4f08ab7dfbc0bcb47158 e71be35449314497b08497ba3d9da237 736a4f3ed35f4f08ab7dfbc0bcb47158--e71be35449314497b08497ba3d9da237 c3639b8a1ed8423d908607917d9189e0 e71be35449314497b08497ba3d9da237--c3639b8a1ed8423d908607917d9189e0 71b9f02e219c4b4faf6d71856f5b5714 c3639b8a1ed8423d908607917d9189e0--71b9f02e219c4b4faf6d71856f5b5714 4887b55f8a0e48a8ade873ebdf108dc7 71b9f02e219c4b4faf6d71856f5b5714--4887b55f8a0e48a8ade873ebdf108dc7 0b7afffeb19c4628921192b3e4dd007c 4887b55f8a0e48a8ade873ebdf108dc7--0b7afffeb19c4628921192b3e4dd007c cbe308a354b14c089aa25c9e5aa97c0f 0b7afffeb19c4628921192b3e4dd007c--cbe308a354b14c089aa25c9e5aa97c0f c0ac4036c1df4ebe90096bb21b4c710e cbe308a354b14c089aa25c9e5aa97c0f--c0ac4036c1df4ebe90096bb21b4c710e f90924d25bc048bbbaf0496222d5b136 c0ac4036c1df4ebe90096bb21b4c710e--f90924d25bc048bbbaf0496222d5b136 f85b8439752445ef83b119a412b14b00 RX(b11) f90924d25bc048bbbaf0496222d5b136--f85b8439752445ef83b119a412b14b00 f85b8439752445ef83b119a412b14b00--6ec3c32b7f9448529d18dd725b661833 16dc5a07a3434a73bb49b41b66d66202 52956eeed9e54a8a9d2fc612ac199986 bd17ca2a349e42ecb3ecc91e24ae25f0--52956eeed9e54a8a9d2fc612ac199986 17535b41433442ac990bdfbaed76ac67 3 c842efc245704bcba2ca3ef9b8ea26f4 X 52956eeed9e54a8a9d2fc612ac199986--c842efc245704bcba2ca3ef9b8ea26f4 c842efc245704bcba2ca3ef9b8ea26f4--ec31e38ff1a14aa4809f2925c084242f 3a2fbfdd201240dd8a65ebc486ec335b c842efc245704bcba2ca3ef9b8ea26f4--3a2fbfdd201240dd8a65ebc486ec335b 50a1021f3fca4609853396caf35570bf 3a2fbfdd201240dd8a65ebc486ec335b--50a1021f3fca4609853396caf35570bf 73dd02f989e54b8499c6870e6231c51b 50a1021f3fca4609853396caf35570bf--73dd02f989e54b8499c6870e6231c51b 9cd50fb42bfe4c07af5786ad6e12dca5 73dd02f989e54b8499c6870e6231c51b--9cd50fb42bfe4c07af5786ad6e12dca5 5371a53460464d13b477379406d0167f 9cd50fb42bfe4c07af5786ad6e12dca5--5371a53460464d13b477379406d0167f efe2b73321424e838e8d69978cde51ef 5371a53460464d13b477379406d0167f--efe2b73321424e838e8d69978cde51ef 3aad3123ab884c5380472ecc0291dbac efe2b73321424e838e8d69978cde51ef--3aad3123ab884c5380472ecc0291dbac e73cfc59640a4b3eb286ae9be9e848d1 3aad3123ab884c5380472ecc0291dbac--e73cfc59640a4b3eb286ae9be9e848d1 af220adc0f754316a0bcad4f4163eacd e73cfc59640a4b3eb286ae9be9e848d1--af220adc0f754316a0bcad4f4163eacd 1e39e43715364bdda49c30d6f73646bd af220adc0f754316a0bcad4f4163eacd--1e39e43715364bdda49c30d6f73646bd 5cbe8920fc264010ad9c2c8f80e49c51 1e39e43715364bdda49c30d6f73646bd--5cbe8920fc264010ad9c2c8f80e49c51 abfa81ea3e5c43579429987e822a471a X 5cbe8920fc264010ad9c2c8f80e49c51--abfa81ea3e5c43579429987e822a471a abfa81ea3e5c43579429987e822a471a--7e9640626e764724b874fee7812c7db6 a6995ac51ffa4d8abd9b7824d0c0f5cf abfa81ea3e5c43579429987e822a471a--a6995ac51ffa4d8abd9b7824d0c0f5cf 7c0ca5db0b864820a57cf0f296e322d8 a6995ac51ffa4d8abd9b7824d0c0f5cf--7c0ca5db0b864820a57cf0f296e322d8 a1b82c8c7bd345e592ceb529ae653a6f X 7c0ca5db0b864820a57cf0f296e322d8--a1b82c8c7bd345e592ceb529ae653a6f a1b82c8c7bd345e592ceb529ae653a6f--c7bef544276344eeab2a8d157668291d 70a2149f874542c0affdeeecc012fc3f a1b82c8c7bd345e592ceb529ae653a6f--70a2149f874542c0affdeeecc012fc3f 0fadf44796744de9a38fbaf537ea84f1 70a2149f874542c0affdeeecc012fc3f--0fadf44796744de9a38fbaf537ea84f1 19d5458c889c4a1b9526a1cfcb46df1c 0fadf44796744de9a38fbaf537ea84f1--19d5458c889c4a1b9526a1cfcb46df1c c3cd0ab7985b46cb93d46952d15e1b23 X 19d5458c889c4a1b9526a1cfcb46df1c--c3cd0ab7985b46cb93d46952d15e1b23 c3cd0ab7985b46cb93d46952d15e1b23--07b2a02ae0874e118c43dca9bd09c676 4225566ffc564658a9ae6c05b71b8481 c3cd0ab7985b46cb93d46952d15e1b23--4225566ffc564658a9ae6c05b71b8481 b5bc9b0baef84605b343812b46a54641 4225566ffc564658a9ae6c05b71b8481--b5bc9b0baef84605b343812b46a54641 ee3f7cf85ea44b6a8d6ff2529ae56b3a X b5bc9b0baef84605b343812b46a54641--ee3f7cf85ea44b6a8d6ff2529ae56b3a ee3f7cf85ea44b6a8d6ff2529ae56b3a--fc7c5190face4b94b6345df3db9dde89 9f2dbed4ccaa4807b5e303bdec10bc96 ee3f7cf85ea44b6a8d6ff2529ae56b3a--9f2dbed4ccaa4807b5e303bdec10bc96 9677f28ba37e487bb9b9cea9ae0aeef2 9f2dbed4ccaa4807b5e303bdec10bc96--9677f28ba37e487bb9b9cea9ae0aeef2 373bd08cea5e4fb898d70842b35b3cde 9677f28ba37e487bb9b9cea9ae0aeef2--373bd08cea5e4fb898d70842b35b3cde 203059b53e28491588eb087881ba0430 373bd08cea5e4fb898d70842b35b3cde--203059b53e28491588eb087881ba0430 0b7e53a8442843888a1680566d344c58 203059b53e28491588eb087881ba0430--0b7e53a8442843888a1680566d344c58 7379069c52034e909aa36709514f0d21 0b7e53a8442843888a1680566d344c58--7379069c52034e909aa36709514f0d21 5cf8005dd6f745cba52cf9507de8b578 7379069c52034e909aa36709514f0d21--5cf8005dd6f745cba52cf9507de8b578 b7c3edea8714415b990ec03b838a3eca X 5cf8005dd6f745cba52cf9507de8b578--b7c3edea8714415b990ec03b838a3eca b7c3edea8714415b990ec03b838a3eca--25d349bda9c34ba58639a4aa9034f945 70083c8ed40c43c095d3a2c9bbfebaf7 b7c3edea8714415b990ec03b838a3eca--70083c8ed40c43c095d3a2c9bbfebaf7 da5f7f37a699463185f40963c97b048e X 70083c8ed40c43c095d3a2c9bbfebaf7--da5f7f37a699463185f40963c97b048e da5f7f37a699463185f40963c97b048e--188d1bf709bb441ca941efe004a28cf1 6df3a0989c6c4963896358e853ea0a0a da5f7f37a699463185f40963c97b048e--6df3a0989c6c4963896358e853ea0a0a c41f7872bfc047cdabf81d1b896d53a7 6df3a0989c6c4963896358e853ea0a0a--c41f7872bfc047cdabf81d1b896d53a7 f5f19648a4314c62bde33b27aa39a85c c41f7872bfc047cdabf81d1b896d53a7--f5f19648a4314c62bde33b27aa39a85c b45258cd215645928aeec5b7c387f8f0 X f5f19648a4314c62bde33b27aa39a85c--b45258cd215645928aeec5b7c387f8f0 b45258cd215645928aeec5b7c387f8f0--e7f03a77973041b58d6336b2698ec298 35e116b3698942f19dac60b6c8ab84fe X b45258cd215645928aeec5b7c387f8f0--35e116b3698942f19dac60b6c8ab84fe 35e116b3698942f19dac60b6c8ab84fe--6f9bbdcffb584b2c87bee6bede8eb8d6 7b284f6578db447fb8c1b337a3d042a9 35e116b3698942f19dac60b6c8ab84fe--7b284f6578db447fb8c1b337a3d042a9 9312363080e74701a517d4c3f3552331 7b284f6578db447fb8c1b337a3d042a9--9312363080e74701a517d4c3f3552331 0ceac17fa0d1410aa0a50783189bc4f6 9312363080e74701a517d4c3f3552331--0ceac17fa0d1410aa0a50783189bc4f6 6b813bb4abf94e8798664f0c4c4ccb0e 0ceac17fa0d1410aa0a50783189bc4f6--6b813bb4abf94e8798664f0c4c4ccb0e f3f9301703324e39a0d4e77de822f8c5 6b813bb4abf94e8798664f0c4c4ccb0e--f3f9301703324e39a0d4e77de822f8c5 fcea9b357acf4486b70e073f5b7e70bc f3f9301703324e39a0d4e77de822f8c5--fcea9b357acf4486b70e073f5b7e70bc 01035cacff1546e5a81fb82136f912d7 fcea9b357acf4486b70e073f5b7e70bc--01035cacff1546e5a81fb82136f912d7 b4b026366a1a4277828080971ef6dfc4 X 01035cacff1546e5a81fb82136f912d7--b4b026366a1a4277828080971ef6dfc4 b4b026366a1a4277828080971ef6dfc4--24a49730165343d6a45dad8d20056f4a abab8de8d52d4f17a4d16a62fc4da1f4 X b4b026366a1a4277828080971ef6dfc4--abab8de8d52d4f17a4d16a62fc4da1f4 abab8de8d52d4f17a4d16a62fc4da1f4--002c736f17bb48108f283a0f844b6726 1b6b6c93611e4313b22d705de30df518 abab8de8d52d4f17a4d16a62fc4da1f4--1b6b6c93611e4313b22d705de30df518 a63487a403654da5accae0474c416a6b 1b6b6c93611e4313b22d705de30df518--a63487a403654da5accae0474c416a6b d27b5c450bc04ced95a6eb9f198dc143 a63487a403654da5accae0474c416a6b--d27b5c450bc04ced95a6eb9f198dc143 daca47cd65f1498e84d0e008a9711162 d27b5c450bc04ced95a6eb9f198dc143--daca47cd65f1498e84d0e008a9711162 57599751817e4dc99e3840572d9a590b daca47cd65f1498e84d0e008a9711162--57599751817e4dc99e3840572d9a590b 7269ba9d84784432a5e7f4dce79e9e45 57599751817e4dc99e3840572d9a590b--7269ba9d84784432a5e7f4dce79e9e45 3e2edb423d8f4053942bf95b2d4eb4e0 7269ba9d84784432a5e7f4dce79e9e45--3e2edb423d8f4053942bf95b2d4eb4e0 9a1da87cf82a4e1587e9a5353b742d58 3e2edb423d8f4053942bf95b2d4eb4e0--9a1da87cf82a4e1587e9a5353b742d58 6a8c9c054f26426181ee83d17b2f008d 9a1da87cf82a4e1587e9a5353b742d58--6a8c9c054f26426181ee83d17b2f008d 7a58582f17a445b5bc1293cc35651e5f 6a8c9c054f26426181ee83d17b2f008d--7a58582f17a445b5bc1293cc35651e5f 97dc255757b447dea0ed75962c854cbf 7a58582f17a445b5bc1293cc35651e5f--97dc255757b447dea0ed75962c854cbf 95c51f932b9e4b7a8553c7470cb7b104 X 97dc255757b447dea0ed75962c854cbf--95c51f932b9e4b7a8553c7470cb7b104 95c51f932b9e4b7a8553c7470cb7b104--35455061f7ee44108d4d0c243eeb8c7d 9922663140db4dd49b65fb5b770ceaf0 95c51f932b9e4b7a8553c7470cb7b104--9922663140db4dd49b65fb5b770ceaf0 c20dfbf1cc714ac6a8ea89fc75ac1d51 9922663140db4dd49b65fb5b770ceaf0--c20dfbf1cc714ac6a8ea89fc75ac1d51 7e497cc0913147cd9f13d014799d329d c20dfbf1cc714ac6a8ea89fc75ac1d51--7e497cc0913147cd9f13d014799d329d fc782e91680a4a6c868424bfe7fca8b9 7e497cc0913147cd9f13d014799d329d--fc782e91680a4a6c868424bfe7fca8b9 86d097109f1a4a8cafe4b2e8f6aa8ed1 fc782e91680a4a6c868424bfe7fca8b9--86d097109f1a4a8cafe4b2e8f6aa8ed1 70c3b041ca0f4d44a3cdccae604c5b34 86d097109f1a4a8cafe4b2e8f6aa8ed1--70c3b041ca0f4d44a3cdccae604c5b34 8e15f9a1ac5548959f01eb91a43e6578 70c3b041ca0f4d44a3cdccae604c5b34--8e15f9a1ac5548959f01eb91a43e6578 577b8220b51a4ec0a1ea504bdb2aeef4 8e15f9a1ac5548959f01eb91a43e6578--577b8220b51a4ec0a1ea504bdb2aeef4 afb23d8118944193b8012f448e058ea4 577b8220b51a4ec0a1ea504bdb2aeef4--afb23d8118944193b8012f448e058ea4 f2c5cb30e3c14e44b3f56fdb95383d61 afb23d8118944193b8012f448e058ea4--f2c5cb30e3c14e44b3f56fdb95383d61 8ba3dfd5225d4c248544e05388d86742 f2c5cb30e3c14e44b3f56fdb95383d61--8ba3dfd5225d4c248544e05388d86742 3beaf0af856f4430887119f7e31d73db 8ba3dfd5225d4c248544e05388d86742--3beaf0af856f4430887119f7e31d73db 8e272fd9fd3f49ae9cb048ef4270a53e 3beaf0af856f4430887119f7e31d73db--8e272fd9fd3f49ae9cb048ef4270a53e 76022cdc66e24ef18bcc8563c5f1b254 8e272fd9fd3f49ae9cb048ef4270a53e--76022cdc66e24ef18bcc8563c5f1b254 a2c37ede639340a4ae6f5c3e8cf5f7c9 76022cdc66e24ef18bcc8563c5f1b254--a2c37ede639340a4ae6f5c3e8cf5f7c9 c9f37fb8571c488b84cf4adc7c2c0fa3 a2c37ede639340a4ae6f5c3e8cf5f7c9--c9f37fb8571c488b84cf4adc7c2c0fa3 24ae059a10a94fc388e4b6685df62b80 c9f37fb8571c488b84cf4adc7c2c0fa3--24ae059a10a94fc388e4b6685df62b80 b6435020b462492ab9153effb4e736a2 24ae059a10a94fc388e4b6685df62b80--b6435020b462492ab9153effb4e736a2 f232be33c4204f8cad78639342024dfd b6435020b462492ab9153effb4e736a2--f232be33c4204f8cad78639342024dfd d58d5ed54d1747acaea5f64063583435 f232be33c4204f8cad78639342024dfd--d58d5ed54d1747acaea5f64063583435 57755116288e47a8a4eae042be546842 d58d5ed54d1747acaea5f64063583435--57755116288e47a8a4eae042be546842 c3dc1c2a566a481bbcaf342a1d606fb3 57755116288e47a8a4eae042be546842--c3dc1c2a566a481bbcaf342a1d606fb3 401596e872fe46eea4218d9c6cc78ba5 c3dc1c2a566a481bbcaf342a1d606fb3--401596e872fe46eea4218d9c6cc78ba5 928e71ca40d24749bb6960c6507e7ff1 401596e872fe46eea4218d9c6cc78ba5--928e71ca40d24749bb6960c6507e7ff1 ce890eea4c0a4e2c8da1c7888baa4ea6 928e71ca40d24749bb6960c6507e7ff1--ce890eea4c0a4e2c8da1c7888baa4ea6 f37f995668bd410f8783b189694beebd ce890eea4c0a4e2c8da1c7888baa4ea6--f37f995668bd410f8783b189694beebd 2016a9dc39ca4b5d80a55d0b29559f43 f37f995668bd410f8783b189694beebd--2016a9dc39ca4b5d80a55d0b29559f43 964d2291509044b4bea217dd9c99f79c 2016a9dc39ca4b5d80a55d0b29559f43--964d2291509044b4bea217dd9c99f79c 258ba15a6fa143dcb3193ac98da4e1d3 964d2291509044b4bea217dd9c99f79c--258ba15a6fa143dcb3193ac98da4e1d3 8168afc5cd12431da9e574c1839bddcd 258ba15a6fa143dcb3193ac98da4e1d3--8168afc5cd12431da9e574c1839bddcd 68d621cf66434cc580640e40f3769804 8168afc5cd12431da9e574c1839bddcd--68d621cf66434cc580640e40f3769804 2a7c44c0c2154de9a54a2839e85fd246 68d621cf66434cc580640e40f3769804--2a7c44c0c2154de9a54a2839e85fd246 c4e94588c2ae4ee99593f7538ef4c503 2a7c44c0c2154de9a54a2839e85fd246--c4e94588c2ae4ee99593f7538ef4c503 321adfccf47044a1b59a8f16d6e92919 RX(b02) c4e94588c2ae4ee99593f7538ef4c503--321adfccf47044a1b59a8f16d6e92919 9995d3b5a8cb4655adebf3530f460930 321adfccf47044a1b59a8f16d6e92919--9995d3b5a8cb4655adebf3530f460930 dfafc343faef4f3292f688191bfb6b8c X 9995d3b5a8cb4655adebf3530f460930--dfafc343faef4f3292f688191bfb6b8c dfafc343faef4f3292f688191bfb6b8c--90ee99053a3c4357a5f427922fc66d48 37793a3de61c413f94a1d2629d681bd5 dfafc343faef4f3292f688191bfb6b8c--37793a3de61c413f94a1d2629d681bd5 8b2fa15c7fb24d93a8402a7d3526cf87 37793a3de61c413f94a1d2629d681bd5--8b2fa15c7fb24d93a8402a7d3526cf87 3a54c1b95b2b49b9b0df5c4a87a36967 8b2fa15c7fb24d93a8402a7d3526cf87--3a54c1b95b2b49b9b0df5c4a87a36967 1f1adaca0c5244a9a84d7e05929f0401 3a54c1b95b2b49b9b0df5c4a87a36967--1f1adaca0c5244a9a84d7e05929f0401 f2e9d40c1889427eb7ea03b3922f9126 1f1adaca0c5244a9a84d7e05929f0401--f2e9d40c1889427eb7ea03b3922f9126 0e19749c91614a439e00e430ab6e5b62 f2e9d40c1889427eb7ea03b3922f9126--0e19749c91614a439e00e430ab6e5b62 e229c6fcac6446a6a9340e9704985396 0e19749c91614a439e00e430ab6e5b62--e229c6fcac6446a6a9340e9704985396 ca8ddcd58a6045af9192f1f653869219 e229c6fcac6446a6a9340e9704985396--ca8ddcd58a6045af9192f1f653869219 47c18b82c168464cbb77fddd717a4191 ca8ddcd58a6045af9192f1f653869219--47c18b82c168464cbb77fddd717a4191 0159839e16c646958e171fba577a7bd3 47c18b82c168464cbb77fddd717a4191--0159839e16c646958e171fba577a7bd3 de00fd8db9394132bf1980d95a97eccc 0159839e16c646958e171fba577a7bd3--de00fd8db9394132bf1980d95a97eccc a8fe0b33341144599a36560c40c44e9f X de00fd8db9394132bf1980d95a97eccc--a8fe0b33341144599a36560c40c44e9f a8fe0b33341144599a36560c40c44e9f--3b203c5e6f1644d28c63c9e4d23abf53 74b95e088b7f4067b5be3bf62d320938 a8fe0b33341144599a36560c40c44e9f--74b95e088b7f4067b5be3bf62d320938 cfd726bc6b2643d88cff95ed8f0ef267 74b95e088b7f4067b5be3bf62d320938--cfd726bc6b2643d88cff95ed8f0ef267 b0a08822aeff414b90b57bb009826c24 X cfd726bc6b2643d88cff95ed8f0ef267--b0a08822aeff414b90b57bb009826c24 b0a08822aeff414b90b57bb009826c24--23fa10f8a06743c4837abe64dd31d6f5 82f1fac8e25244e5bf3aee273e31c459 b0a08822aeff414b90b57bb009826c24--82f1fac8e25244e5bf3aee273e31c459 61b57ee58a8f4797b52f3b5c82c7c55c 82f1fac8e25244e5bf3aee273e31c459--61b57ee58a8f4797b52f3b5c82c7c55c 7099a897a746408cb108d0e9451a8662 61b57ee58a8f4797b52f3b5c82c7c55c--7099a897a746408cb108d0e9451a8662 c813d5102d754ad69a96f88378e01f06 X 7099a897a746408cb108d0e9451a8662--c813d5102d754ad69a96f88378e01f06 c813d5102d754ad69a96f88378e01f06--918d6af551cb46dca8459b24df23ea41 e78d7243fc1c4e8eb488b67b7fd8439e c813d5102d754ad69a96f88378e01f06--e78d7243fc1c4e8eb488b67b7fd8439e 6c84b47572ed41c6844534cb152d3466 e78d7243fc1c4e8eb488b67b7fd8439e--6c84b47572ed41c6844534cb152d3466 937ba7fc470942b08c0ffa8691d5b45f X 6c84b47572ed41c6844534cb152d3466--937ba7fc470942b08c0ffa8691d5b45f 937ba7fc470942b08c0ffa8691d5b45f--768f74e4c8e3472cb881261b0070b643 c8551842a5f24722bc122e70fc1f8ace 937ba7fc470942b08c0ffa8691d5b45f--c8551842a5f24722bc122e70fc1f8ace b2310a0dfa0e48868778c43ff55751df c8551842a5f24722bc122e70fc1f8ace--b2310a0dfa0e48868778c43ff55751df 01331e0461c0461891ad44a5658a82d7 b2310a0dfa0e48868778c43ff55751df--01331e0461c0461891ad44a5658a82d7 3bca66e7ec6846e695fb75a2d73b4c0d 01331e0461c0461891ad44a5658a82d7--3bca66e7ec6846e695fb75a2d73b4c0d a69af24475dc405d81e4e4fd4a750698 3bca66e7ec6846e695fb75a2d73b4c0d--a69af24475dc405d81e4e4fd4a750698 edc1affe80ee4533a0c651993f136283 a69af24475dc405d81e4e4fd4a750698--edc1affe80ee4533a0c651993f136283 d6b35f31f6bc49cd9e7ce62ab52bb72b edc1affe80ee4533a0c651993f136283--d6b35f31f6bc49cd9e7ce62ab52bb72b db1d8f2850d143d183616e782a8ab887 X d6b35f31f6bc49cd9e7ce62ab52bb72b--db1d8f2850d143d183616e782a8ab887 db1d8f2850d143d183616e782a8ab887--a971543e218c4c8fa98ed86d0b6a2850 681d80df0e0e4546a4d14e5d4af582cc db1d8f2850d143d183616e782a8ab887--681d80df0e0e4546a4d14e5d4af582cc 4a7ce01a18a04daf903d971e1beaaa60 X 681d80df0e0e4546a4d14e5d4af582cc--4a7ce01a18a04daf903d971e1beaaa60 4a7ce01a18a04daf903d971e1beaaa60--2e7b2902704c4947b567a809ca138368 74b012f1eef54dd08f581aa4b251db7b 4a7ce01a18a04daf903d971e1beaaa60--74b012f1eef54dd08f581aa4b251db7b da9927ce99d4450785dacb2949ecea37 74b012f1eef54dd08f581aa4b251db7b--da9927ce99d4450785dacb2949ecea37 2ff443c952dd4348a4c36e10d0567f61 da9927ce99d4450785dacb2949ecea37--2ff443c952dd4348a4c36e10d0567f61 8824bf084f9b46509ed2a79dedc0f21c X 2ff443c952dd4348a4c36e10d0567f61--8824bf084f9b46509ed2a79dedc0f21c 8824bf084f9b46509ed2a79dedc0f21c--7614febda67d4064a24d5e30d7162b88 1d9f58c25bc941bf85fbef99695c2883 X 8824bf084f9b46509ed2a79dedc0f21c--1d9f58c25bc941bf85fbef99695c2883 1d9f58c25bc941bf85fbef99695c2883--649c4429b5ee4a70ab89759a5a34cf7c f46404e092e545379627672569aeeedb 1d9f58c25bc941bf85fbef99695c2883--f46404e092e545379627672569aeeedb ea3e7a25de114abcab09595afbac8af8 f46404e092e545379627672569aeeedb--ea3e7a25de114abcab09595afbac8af8 a8a9c43fa7c945eea4c5f719799c82cc ea3e7a25de114abcab09595afbac8af8--a8a9c43fa7c945eea4c5f719799c82cc bccb77b04be147b8863f3a230fa0f0f0 a8a9c43fa7c945eea4c5f719799c82cc--bccb77b04be147b8863f3a230fa0f0f0 8eb81b5c74234859b4d9876bf23cf8ab bccb77b04be147b8863f3a230fa0f0f0--8eb81b5c74234859b4d9876bf23cf8ab 7f8a63d20e084e288a3a2b772d4de68f 8eb81b5c74234859b4d9876bf23cf8ab--7f8a63d20e084e288a3a2b772d4de68f a53e821175b94b55b6cfc924f278ba54 7f8a63d20e084e288a3a2b772d4de68f--a53e821175b94b55b6cfc924f278ba54 7aea905551a64cc0a2ce6b999f44bc7f X a53e821175b94b55b6cfc924f278ba54--7aea905551a64cc0a2ce6b999f44bc7f 7aea905551a64cc0a2ce6b999f44bc7f--af0346b07ada4c5e89c41ad1df9d3aad c2001710c5054d2ca08c8c9acb0a5831 X 7aea905551a64cc0a2ce6b999f44bc7f--c2001710c5054d2ca08c8c9acb0a5831 c2001710c5054d2ca08c8c9acb0a5831--4c37c5ccd3964eda8aa7fd8de30a1890 1ee9d29f2f67413ab2ad2f23a0814799 c2001710c5054d2ca08c8c9acb0a5831--1ee9d29f2f67413ab2ad2f23a0814799 dacfb2e7133440bfaa4c23233b3d3555 1ee9d29f2f67413ab2ad2f23a0814799--dacfb2e7133440bfaa4c23233b3d3555 e337539c7e904dca89e0528cdccbe616 dacfb2e7133440bfaa4c23233b3d3555--e337539c7e904dca89e0528cdccbe616 15c44e560cb74aeea61cde8d14d80a85 e337539c7e904dca89e0528cdccbe616--15c44e560cb74aeea61cde8d14d80a85 e76d7953a43d4cde8547dac721536e34 15c44e560cb74aeea61cde8d14d80a85--e76d7953a43d4cde8547dac721536e34 c0024d31e928457189b63fbdf1ec64bb e76d7953a43d4cde8547dac721536e34--c0024d31e928457189b63fbdf1ec64bb 16a4f1e6e54140f8bd9ebc011bceb9e0 c0024d31e928457189b63fbdf1ec64bb--16a4f1e6e54140f8bd9ebc011bceb9e0 806f91f7f1c848108a10643cc83e105c 16a4f1e6e54140f8bd9ebc011bceb9e0--806f91f7f1c848108a10643cc83e105c c2c1b50a811e442395f607eb66868ab5 806f91f7f1c848108a10643cc83e105c--c2c1b50a811e442395f607eb66868ab5 2b8c9e6a602a4b988555264253ebb116 c2c1b50a811e442395f607eb66868ab5--2b8c9e6a602a4b988555264253ebb116 6de0f9eccee142ebb02808f06ef5dd40 2b8c9e6a602a4b988555264253ebb116--6de0f9eccee142ebb02808f06ef5dd40 8a36b7ec857f47289fc10c2894042d6c X 6de0f9eccee142ebb02808f06ef5dd40--8a36b7ec857f47289fc10c2894042d6c 8a36b7ec857f47289fc10c2894042d6c--de862522b462463bae8730c63ca1a6a6 006234680e444971bdae69dc34c21dc8 8a36b7ec857f47289fc10c2894042d6c--006234680e444971bdae69dc34c21dc8 e2ce67a099064c0797600b06e429ebda 006234680e444971bdae69dc34c21dc8--e2ce67a099064c0797600b06e429ebda 1a57f5a37ea745a7b4a40e3e91dc34a7 e2ce67a099064c0797600b06e429ebda--1a57f5a37ea745a7b4a40e3e91dc34a7 33b57f7b327b46128eec946cac36cd6e 1a57f5a37ea745a7b4a40e3e91dc34a7--33b57f7b327b46128eec946cac36cd6e b4cffa54fbdb4613953c9c3f52372d2c 33b57f7b327b46128eec946cac36cd6e--b4cffa54fbdb4613953c9c3f52372d2c 588f8c7f4cb74115939cbc84c9816ee2 b4cffa54fbdb4613953c9c3f52372d2c--588f8c7f4cb74115939cbc84c9816ee2 7f2d040712a64125b8aeb777673591f8 588f8c7f4cb74115939cbc84c9816ee2--7f2d040712a64125b8aeb777673591f8 e99e0f3a129e46bc987e355cbb7a3fef 7f2d040712a64125b8aeb777673591f8--e99e0f3a129e46bc987e355cbb7a3fef 302332df2876425bb55ea37d9321b365 e99e0f3a129e46bc987e355cbb7a3fef--302332df2876425bb55ea37d9321b365 ea937d1042d74d52aa8803fdb81f6700 302332df2876425bb55ea37d9321b365--ea937d1042d74d52aa8803fdb81f6700 c8c28c0a06fd403badce2edb4dc3b735 ea937d1042d74d52aa8803fdb81f6700--c8c28c0a06fd403badce2edb4dc3b735 c38ab22ac4834ba0a1adb01df3d172f4 c8c28c0a06fd403badce2edb4dc3b735--c38ab22ac4834ba0a1adb01df3d172f4 c1fac97659034e1085531413f9e0ae48 c38ab22ac4834ba0a1adb01df3d172f4--c1fac97659034e1085531413f9e0ae48 e9dc332cb6fc4854949f4037befd426e c1fac97659034e1085531413f9e0ae48--e9dc332cb6fc4854949f4037befd426e 8b72ad15f7d4417aa8eba61cd819c1f4 e9dc332cb6fc4854949f4037befd426e--8b72ad15f7d4417aa8eba61cd819c1f4 d625d91b1cae41bab053439061e1f314 8b72ad15f7d4417aa8eba61cd819c1f4--d625d91b1cae41bab053439061e1f314 c9c51fddcff744749bdca1dc93fdf410 d625d91b1cae41bab053439061e1f314--c9c51fddcff744749bdca1dc93fdf410 7cd4d412480747ecb61fc1258d4e02c8 c9c51fddcff744749bdca1dc93fdf410--7cd4d412480747ecb61fc1258d4e02c8 b6e31785479a4c5bbda6ba7baeed6144 7cd4d412480747ecb61fc1258d4e02c8--b6e31785479a4c5bbda6ba7baeed6144 9e5cf9538d404e1dabfb127738800520 b6e31785479a4c5bbda6ba7baeed6144--9e5cf9538d404e1dabfb127738800520 ee722528763e4ef2887d6df4d329b3d1 9e5cf9538d404e1dabfb127738800520--ee722528763e4ef2887d6df4d329b3d1 a91b7917d65845f085bce09d381deadf ee722528763e4ef2887d6df4d329b3d1--a91b7917d65845f085bce09d381deadf bc6efab34b6c44c1b50796346833f94c a91b7917d65845f085bce09d381deadf--bc6efab34b6c44c1b50796346833f94c 0e0d88da3c9740cabaaaa94a15acbcb2 bc6efab34b6c44c1b50796346833f94c--0e0d88da3c9740cabaaaa94a15acbcb2 16b4ae9241f74eea9d45e711190d9b9a 0e0d88da3c9740cabaaaa94a15acbcb2--16b4ae9241f74eea9d45e711190d9b9a ecc8d25df6bc43d38fd28bad7b1ac7d1 16b4ae9241f74eea9d45e711190d9b9a--ecc8d25df6bc43d38fd28bad7b1ac7d1 86146f638bf9465eb56ef314a75be96a ecc8d25df6bc43d38fd28bad7b1ac7d1--86146f638bf9465eb56ef314a75be96a 268140efd27143b49516ab53609478f9 86146f638bf9465eb56ef314a75be96a--268140efd27143b49516ab53609478f9 18112c01c1ee4f1cab33baf169b74407 268140efd27143b49516ab53609478f9--18112c01c1ee4f1cab33baf169b74407 a0f24bf19ff34e8da828e2744c568e9f 18112c01c1ee4f1cab33baf169b74407--a0f24bf19ff34e8da828e2744c568e9f 1557d9d84bba4900a02dc75ed6a6c251 a0f24bf19ff34e8da828e2744c568e9f--1557d9d84bba4900a02dc75ed6a6c251 7a3b8daa67ab499885542d590791655f 1557d9d84bba4900a02dc75ed6a6c251--7a3b8daa67ab499885542d590791655f 0c15ad0e93644a6d85ddbf852b59be06 7a3b8daa67ab499885542d590791655f--0c15ad0e93644a6d85ddbf852b59be06 8b6a5dc09ab34bf588237fb99a0ef4c4 RX(b12) 0c15ad0e93644a6d85ddbf852b59be06--8b6a5dc09ab34bf588237fb99a0ef4c4 8b6a5dc09ab34bf588237fb99a0ef4c4--16dc5a07a3434a73bb49b41b66d66202 63390212bb7c44fca55f70a553e0662c 6567db3b70a2459ba76bb81277688a8f 17535b41433442ac990bdfbaed76ac67--6567db3b70a2459ba76bb81277688a8f 6540661265974b56994bbf7c4bc55be2 4 edce688230fc4ac695beeea8fb2cd703 6567db3b70a2459ba76bb81277688a8f--edce688230fc4ac695beeea8fb2cd703 356dce00169c48638529b3807f3240c6 X edce688230fc4ac695beeea8fb2cd703--356dce00169c48638529b3807f3240c6 356dce00169c48638529b3807f3240c6--3a2fbfdd201240dd8a65ebc486ec335b 68df642107be48a09b426ef678c62891 356dce00169c48638529b3807f3240c6--68df642107be48a09b426ef678c62891 41c42a5cf12945d09671a0350eb2f8fd 68df642107be48a09b426ef678c62891--41c42a5cf12945d09671a0350eb2f8fd cb6923311fec4a6ba341ad97153be42d 41c42a5cf12945d09671a0350eb2f8fd--cb6923311fec4a6ba341ad97153be42d 82f374aeaaee4f289fe78862deb55434 cb6923311fec4a6ba341ad97153be42d--82f374aeaaee4f289fe78862deb55434 f1c2b64811f6409f89f732c268408140 82f374aeaaee4f289fe78862deb55434--f1c2b64811f6409f89f732c268408140 5f4f2f90d7da40b28db9c60be087bf79 f1c2b64811f6409f89f732c268408140--5f4f2f90d7da40b28db9c60be087bf79 135e2ce6d9ec47499cac135a039e0643 5f4f2f90d7da40b28db9c60be087bf79--135e2ce6d9ec47499cac135a039e0643 dfde4d8e31e94ba0b7686e15477130e5 135e2ce6d9ec47499cac135a039e0643--dfde4d8e31e94ba0b7686e15477130e5 a2e08aa57eff4cd1aaf1cd1485f141a5 dfde4d8e31e94ba0b7686e15477130e5--a2e08aa57eff4cd1aaf1cd1485f141a5 532a4f5f482e44afb9c458854164d728 X a2e08aa57eff4cd1aaf1cd1485f141a5--532a4f5f482e44afb9c458854164d728 532a4f5f482e44afb9c458854164d728--5cbe8920fc264010ad9c2c8f80e49c51 12a6c50446c943faabd4f1610b5e3597 532a4f5f482e44afb9c458854164d728--12a6c50446c943faabd4f1610b5e3597 64d8b408617543a388e5671c637fad24 12a6c50446c943faabd4f1610b5e3597--64d8b408617543a388e5671c637fad24 1fb36b2d9bb9451aa3f09619ba05b646 64d8b408617543a388e5671c637fad24--1fb36b2d9bb9451aa3f09619ba05b646 07ad74193a2e4b97bb2f84c316bd8709 1fb36b2d9bb9451aa3f09619ba05b646--07ad74193a2e4b97bb2f84c316bd8709 4678baeb4bf4452788802f71bc456fc6 X 07ad74193a2e4b97bb2f84c316bd8709--4678baeb4bf4452788802f71bc456fc6 4678baeb4bf4452788802f71bc456fc6--70a2149f874542c0affdeeecc012fc3f 78c38e7967404cb99aac89683023f88b RZ(-1.0*g0) 4678baeb4bf4452788802f71bc456fc6--78c38e7967404cb99aac89683023f88b 205706fe2076466c81849676808c2f93 X 78c38e7967404cb99aac89683023f88b--205706fe2076466c81849676808c2f93 205706fe2076466c81849676808c2f93--19d5458c889c4a1b9526a1cfcb46df1c 61d0c02104b5447a834f54d80cbdb4d8 205706fe2076466c81849676808c2f93--61d0c02104b5447a834f54d80cbdb4d8 11ad1b701e694213b79538ddc8bb7d4b 61d0c02104b5447a834f54d80cbdb4d8--11ad1b701e694213b79538ddc8bb7d4b 6bf97646a59a49a1893c305aab171713 11ad1b701e694213b79538ddc8bb7d4b--6bf97646a59a49a1893c305aab171713 41389ed18b55487b90d75b25af387048 6bf97646a59a49a1893c305aab171713--41389ed18b55487b90d75b25af387048 96405ba963364f05a71db9f1bc8b929e X 41389ed18b55487b90d75b25af387048--96405ba963364f05a71db9f1bc8b929e 96405ba963364f05a71db9f1bc8b929e--9f2dbed4ccaa4807b5e303bdec10bc96 9baad181f6594e30a1e6ac8ed9ca2143 96405ba963364f05a71db9f1bc8b929e--9baad181f6594e30a1e6ac8ed9ca2143 bab4694cde154f938c704f4f5a1a5e02 9baad181f6594e30a1e6ac8ed9ca2143--bab4694cde154f938c704f4f5a1a5e02 93b3620e0e5e41bbb2df1b794e509818 bab4694cde154f938c704f4f5a1a5e02--93b3620e0e5e41bbb2df1b794e509818 ef044ac6b0b54d7d9960c80594b3d2e3 93b3620e0e5e41bbb2df1b794e509818--ef044ac6b0b54d7d9960c80594b3d2e3 f82317b1f5904dc3853cbc5e159cb8a5 ef044ac6b0b54d7d9960c80594b3d2e3--f82317b1f5904dc3853cbc5e159cb8a5 feafd13738d04cc88eca3554c7a35e08 X f82317b1f5904dc3853cbc5e159cb8a5--feafd13738d04cc88eca3554c7a35e08 feafd13738d04cc88eca3554c7a35e08--5cf8005dd6f745cba52cf9507de8b578 ecbedf9ca00148939558c1288549e240 feafd13738d04cc88eca3554c7a35e08--ecbedf9ca00148939558c1288549e240 00fb2abf2ee1499390c527ba09ef9a7c ecbedf9ca00148939558c1288549e240--00fb2abf2ee1499390c527ba09ef9a7c fb7dae4a997c450d9355916c1250ce4d 00fb2abf2ee1499390c527ba09ef9a7c--fb7dae4a997c450d9355916c1250ce4d cc44f8ca7d304d099e234de3aca526c3 X fb7dae4a997c450d9355916c1250ce4d--cc44f8ca7d304d099e234de3aca526c3 cc44f8ca7d304d099e234de3aca526c3--6df3a0989c6c4963896358e853ea0a0a ab078dccaebc402e9390fb7f87377ea3 RZ(-1.0*g0) cc44f8ca7d304d099e234de3aca526c3--ab078dccaebc402e9390fb7f87377ea3 e255c0f2be154bdf91f689fe1850d9d6 X ab078dccaebc402e9390fb7f87377ea3--e255c0f2be154bdf91f689fe1850d9d6 e255c0f2be154bdf91f689fe1850d9d6--f5f19648a4314c62bde33b27aa39a85c d71cac17617f4ad2abe07b1da70fe5ed e255c0f2be154bdf91f689fe1850d9d6--d71cac17617f4ad2abe07b1da70fe5ed e961232427d1441ead79f34a974345d1 d71cac17617f4ad2abe07b1da70fe5ed--e961232427d1441ead79f34a974345d1 e780012270524da4804f34dbb5225b96 X e961232427d1441ead79f34a974345d1--e780012270524da4804f34dbb5225b96 e780012270524da4804f34dbb5225b96--7b284f6578db447fb8c1b337a3d042a9 5a48b90220324e22846d20a1ad4bf072 e780012270524da4804f34dbb5225b96--5a48b90220324e22846d20a1ad4bf072 bcf46347571a490691e129ebc2bf96b3 5a48b90220324e22846d20a1ad4bf072--bcf46347571a490691e129ebc2bf96b3 40f2cea81a8b4784ae64e7a2dd88fb84 bcf46347571a490691e129ebc2bf96b3--40f2cea81a8b4784ae64e7a2dd88fb84 a44db503b7254782b2cb1a3b091f4aec 40f2cea81a8b4784ae64e7a2dd88fb84--a44db503b7254782b2cb1a3b091f4aec ae4a10b78bbe4733bca70876c3e89e80 a44db503b7254782b2cb1a3b091f4aec--ae4a10b78bbe4733bca70876c3e89e80 13d875604dfb4387bf7b012ab24ee942 X ae4a10b78bbe4733bca70876c3e89e80--13d875604dfb4387bf7b012ab24ee942 13d875604dfb4387bf7b012ab24ee942--01035cacff1546e5a81fb82136f912d7 f1cfdc4e6eec47d9872cf85f0a052a19 13d875604dfb4387bf7b012ab24ee942--f1cfdc4e6eec47d9872cf85f0a052a19 57fb4696af1f41df9da21d02d67d52f4 f1cfdc4e6eec47d9872cf85f0a052a19--57fb4696af1f41df9da21d02d67d52f4 d6ceaf4c8ff04800a21ae4ac2dda999d X 57fb4696af1f41df9da21d02d67d52f4--d6ceaf4c8ff04800a21ae4ac2dda999d d6ceaf4c8ff04800a21ae4ac2dda999d--1b6b6c93611e4313b22d705de30df518 085713f3ebac47839e3d66ea6b782a7e d6ceaf4c8ff04800a21ae4ac2dda999d--085713f3ebac47839e3d66ea6b782a7e 76a24a41beb544b49cdea9ba2cbdf8f5 085713f3ebac47839e3d66ea6b782a7e--76a24a41beb544b49cdea9ba2cbdf8f5 7a1af03889c0430b9708ddea747462bb 76a24a41beb544b49cdea9ba2cbdf8f5--7a1af03889c0430b9708ddea747462bb b8b5f7203c864740818f00ba4da12cb0 7a1af03889c0430b9708ddea747462bb--b8b5f7203c864740818f00ba4da12cb0 af3073b6ec984246a0ffdc151f01093e b8b5f7203c864740818f00ba4da12cb0--af3073b6ec984246a0ffdc151f01093e eca238ecfff1463d8144c6f5a6f5b7e0 af3073b6ec984246a0ffdc151f01093e--eca238ecfff1463d8144c6f5a6f5b7e0 801c5532ab79487581dc645984fef50f eca238ecfff1463d8144c6f5a6f5b7e0--801c5532ab79487581dc645984fef50f 84a71621c81b48469def1a49ee244330 801c5532ab79487581dc645984fef50f--84a71621c81b48469def1a49ee244330 f0d3261323404a28b0d9058dfc86f542 84a71621c81b48469def1a49ee244330--f0d3261323404a28b0d9058dfc86f542 8e33bd2bf0fa4179acbf884acca000a5 X f0d3261323404a28b0d9058dfc86f542--8e33bd2bf0fa4179acbf884acca000a5 8e33bd2bf0fa4179acbf884acca000a5--97dc255757b447dea0ed75962c854cbf 45349674b8db4946912c71f736d4ee84 8e33bd2bf0fa4179acbf884acca000a5--45349674b8db4946912c71f736d4ee84 0af4c96578b04644bddc64c95a681337 X 45349674b8db4946912c71f736d4ee84--0af4c96578b04644bddc64c95a681337 0af4c96578b04644bddc64c95a681337--9922663140db4dd49b65fb5b770ceaf0 98acf31b9f82490db1049ad426758b6d RZ(-1.0*g0) 0af4c96578b04644bddc64c95a681337--98acf31b9f82490db1049ad426758b6d d3a2706c29ba4c2f9737bbdaf628ef89 X 98acf31b9f82490db1049ad426758b6d--d3a2706c29ba4c2f9737bbdaf628ef89 d3a2706c29ba4c2f9737bbdaf628ef89--7e497cc0913147cd9f13d014799d329d 3bd20e2bd4a941a19296a8406a966b85 X d3a2706c29ba4c2f9737bbdaf628ef89--3bd20e2bd4a941a19296a8406a966b85 3bd20e2bd4a941a19296a8406a966b85--fc782e91680a4a6c868424bfe7fca8b9 098ab10bc10b451f89b290c27774f153 3bd20e2bd4a941a19296a8406a966b85--098ab10bc10b451f89b290c27774f153 fd1b9d4cfe2a46ce87f58f34e6de1a89 098ab10bc10b451f89b290c27774f153--fd1b9d4cfe2a46ce87f58f34e6de1a89 72fef5c3040245c2bae3f7d762883cf4 fd1b9d4cfe2a46ce87f58f34e6de1a89--72fef5c3040245c2bae3f7d762883cf4 274c63be5b20439a967d1196c48924f7 72fef5c3040245c2bae3f7d762883cf4--274c63be5b20439a967d1196c48924f7 6efae544f857439b89cd36c0d68fa3c3 274c63be5b20439a967d1196c48924f7--6efae544f857439b89cd36c0d68fa3c3 43c6813511784d1487fe176b99748936 6efae544f857439b89cd36c0d68fa3c3--43c6813511784d1487fe176b99748936 aa83b63b5efc4e2281bccaee0901d4f1 43c6813511784d1487fe176b99748936--aa83b63b5efc4e2281bccaee0901d4f1 031c1349449b42d7923523a1fb5d69ce X aa83b63b5efc4e2281bccaee0901d4f1--031c1349449b42d7923523a1fb5d69ce 031c1349449b42d7923523a1fb5d69ce--3beaf0af856f4430887119f7e31d73db 7b34c358321f4a03884cb4ca05dd3938 031c1349449b42d7923523a1fb5d69ce--7b34c358321f4a03884cb4ca05dd3938 a6663ef483da40aeb8bdb6d4f9be7928 7b34c358321f4a03884cb4ca05dd3938--a6663ef483da40aeb8bdb6d4f9be7928 ccb2bc334dc64ea3bde55d7c6f2e47b9 a6663ef483da40aeb8bdb6d4f9be7928--ccb2bc334dc64ea3bde55d7c6f2e47b9 8d45e9f8ac1940a7b6fe687d74791d7e ccb2bc334dc64ea3bde55d7c6f2e47b9--8d45e9f8ac1940a7b6fe687d74791d7e a8e885c33d4c4eda90304ac462ea8556 8d45e9f8ac1940a7b6fe687d74791d7e--a8e885c33d4c4eda90304ac462ea8556 31cd7ecfd7864e98812c4f9ae82fea13 a8e885c33d4c4eda90304ac462ea8556--31cd7ecfd7864e98812c4f9ae82fea13 f38a1f8a74944964921d9f6b75c05d5f 31cd7ecfd7864e98812c4f9ae82fea13--f38a1f8a74944964921d9f6b75c05d5f 0eed59c0311a47cebce5c69fbeabb051 f38a1f8a74944964921d9f6b75c05d5f--0eed59c0311a47cebce5c69fbeabb051 674a96a0284d41c994cdfbe63ec2e3ca 0eed59c0311a47cebce5c69fbeabb051--674a96a0284d41c994cdfbe63ec2e3ca a0f852e13d664208b73b007dab25441c 674a96a0284d41c994cdfbe63ec2e3ca--a0f852e13d664208b73b007dab25441c 6a0d672066ea41e88a646be180e3a10a a0f852e13d664208b73b007dab25441c--6a0d672066ea41e88a646be180e3a10a 55386b6ef28645ffb9fd0384d614a2f1 6a0d672066ea41e88a646be180e3a10a--55386b6ef28645ffb9fd0384d614a2f1 fed44e8d656445f0a23329b26ce604ca 55386b6ef28645ffb9fd0384d614a2f1--fed44e8d656445f0a23329b26ce604ca db36a944b8bd49e1a4f7ff73e8ec8236 fed44e8d656445f0a23329b26ce604ca--db36a944b8bd49e1a4f7ff73e8ec8236 b3c8a7e46d074ee691d6444aa1a7ada2 db36a944b8bd49e1a4f7ff73e8ec8236--b3c8a7e46d074ee691d6444aa1a7ada2 86292a28e39a4f888b836f0f04970143 b3c8a7e46d074ee691d6444aa1a7ada2--86292a28e39a4f888b836f0f04970143 3125edd0eeaf414f84b31f8857ab6df4 86292a28e39a4f888b836f0f04970143--3125edd0eeaf414f84b31f8857ab6df4 167dc39ac92241c693f0bd2b71e0bd86 3125edd0eeaf414f84b31f8857ab6df4--167dc39ac92241c693f0bd2b71e0bd86 833f465842df46f093b1a74da701efa4 167dc39ac92241c693f0bd2b71e0bd86--833f465842df46f093b1a74da701efa4 916846c4107c4a4ea3ebf9f23dbc9c93 833f465842df46f093b1a74da701efa4--916846c4107c4a4ea3ebf9f23dbc9c93 11d2099e547c470cb6c1d5f9c7308d86 916846c4107c4a4ea3ebf9f23dbc9c93--11d2099e547c470cb6c1d5f9c7308d86 f001735e908446558e75d296faee0513 RX(b03) 11d2099e547c470cb6c1d5f9c7308d86--f001735e908446558e75d296faee0513 e2ed14bf517943a9b9031fda32c2aa7f f001735e908446558e75d296faee0513--e2ed14bf517943a9b9031fda32c2aa7f 4a1583afcb3042ed976f97ea26dc9b78 e2ed14bf517943a9b9031fda32c2aa7f--4a1583afcb3042ed976f97ea26dc9b78 8b0e10f7e37d4af7815fe3eccc7ba175 X 4a1583afcb3042ed976f97ea26dc9b78--8b0e10f7e37d4af7815fe3eccc7ba175 8b0e10f7e37d4af7815fe3eccc7ba175--37793a3de61c413f94a1d2629d681bd5 31df62d1a74a49bebbdc0e7feda14ec3 8b0e10f7e37d4af7815fe3eccc7ba175--31df62d1a74a49bebbdc0e7feda14ec3 af521a27e0ec4d8381a44bc6892bb061 31df62d1a74a49bebbdc0e7feda14ec3--af521a27e0ec4d8381a44bc6892bb061 cbc71821acc64caab72f0070aa2019d2 af521a27e0ec4d8381a44bc6892bb061--cbc71821acc64caab72f0070aa2019d2 9d44deee8d7246808023f5cb8c5ab6f3 cbc71821acc64caab72f0070aa2019d2--9d44deee8d7246808023f5cb8c5ab6f3 d6064a29782448e5b44bffb2963c0486 9d44deee8d7246808023f5cb8c5ab6f3--d6064a29782448e5b44bffb2963c0486 65a07cf3e17f42b0be6fc85bf57a77c9 d6064a29782448e5b44bffb2963c0486--65a07cf3e17f42b0be6fc85bf57a77c9 430365a23bd54e64a4b1f508d08acc15 65a07cf3e17f42b0be6fc85bf57a77c9--430365a23bd54e64a4b1f508d08acc15 9d11ed19dafe48daa554e292d54aa0ed 430365a23bd54e64a4b1f508d08acc15--9d11ed19dafe48daa554e292d54aa0ed 964ef3d306d14f1d80cf731e9d040ef9 9d11ed19dafe48daa554e292d54aa0ed--964ef3d306d14f1d80cf731e9d040ef9 a799850e1dde408caa57e96985a370ed X 964ef3d306d14f1d80cf731e9d040ef9--a799850e1dde408caa57e96985a370ed a799850e1dde408caa57e96985a370ed--de00fd8db9394132bf1980d95a97eccc 9f16d06c4bb449fabd9fe18d029282a0 a799850e1dde408caa57e96985a370ed--9f16d06c4bb449fabd9fe18d029282a0 83fff7b82fad426d9d7e92264a11c01a 9f16d06c4bb449fabd9fe18d029282a0--83fff7b82fad426d9d7e92264a11c01a e442566cb7314f31a302fc0dc6371116 83fff7b82fad426d9d7e92264a11c01a--e442566cb7314f31a302fc0dc6371116 a135fc88e6164013be0ce786d290f107 e442566cb7314f31a302fc0dc6371116--a135fc88e6164013be0ce786d290f107 032e422f17f8456dacc703fc725c7cd4 X a135fc88e6164013be0ce786d290f107--032e422f17f8456dacc703fc725c7cd4 032e422f17f8456dacc703fc725c7cd4--82f1fac8e25244e5bf3aee273e31c459 7dc1caf8039b426a82a2064b8f75e861 RZ(-1.0*g1) 032e422f17f8456dacc703fc725c7cd4--7dc1caf8039b426a82a2064b8f75e861 f886206869cc4e0ab8a78582b1e28e8b X 7dc1caf8039b426a82a2064b8f75e861--f886206869cc4e0ab8a78582b1e28e8b f886206869cc4e0ab8a78582b1e28e8b--7099a897a746408cb108d0e9451a8662 b3cb819622124ed1bb835b7bd11545e5 f886206869cc4e0ab8a78582b1e28e8b--b3cb819622124ed1bb835b7bd11545e5 c3728d8a6e094bd7b727bd1459c2921d b3cb819622124ed1bb835b7bd11545e5--c3728d8a6e094bd7b727bd1459c2921d e4dc256e1e02445d9653ac82d96f55c5 c3728d8a6e094bd7b727bd1459c2921d--e4dc256e1e02445d9653ac82d96f55c5 c02a977ffb4f48a5942caaaa35db14cb e4dc256e1e02445d9653ac82d96f55c5--c02a977ffb4f48a5942caaaa35db14cb d5845abccd304fe1a7316bcb2f2f2b01 X c02a977ffb4f48a5942caaaa35db14cb--d5845abccd304fe1a7316bcb2f2f2b01 d5845abccd304fe1a7316bcb2f2f2b01--c8551842a5f24722bc122e70fc1f8ace ee54a5dbb2cd4b499effaca73a0eaf5e d5845abccd304fe1a7316bcb2f2f2b01--ee54a5dbb2cd4b499effaca73a0eaf5e 027c72946bf444819236b15d3040ac33 ee54a5dbb2cd4b499effaca73a0eaf5e--027c72946bf444819236b15d3040ac33 7c8562c015ff40c085eb5df2a1d1f9a2 027c72946bf444819236b15d3040ac33--7c8562c015ff40c085eb5df2a1d1f9a2 8a79a469215a45e899e6f4f3e4fcfabd 7c8562c015ff40c085eb5df2a1d1f9a2--8a79a469215a45e899e6f4f3e4fcfabd 821c774c160e450caf131bb5db551a1b 8a79a469215a45e899e6f4f3e4fcfabd--821c774c160e450caf131bb5db551a1b be7fdd65069a41d9bab0bb1b7dc36e99 X 821c774c160e450caf131bb5db551a1b--be7fdd65069a41d9bab0bb1b7dc36e99 be7fdd65069a41d9bab0bb1b7dc36e99--d6b35f31f6bc49cd9e7ce62ab52bb72b 7973c5cc9e2240d8abd8fef497d9ca99 be7fdd65069a41d9bab0bb1b7dc36e99--7973c5cc9e2240d8abd8fef497d9ca99 6958453daef14bbb91cf07a7a3b209ee 7973c5cc9e2240d8abd8fef497d9ca99--6958453daef14bbb91cf07a7a3b209ee d4937ff4673d48e79d19eca096fd918a 6958453daef14bbb91cf07a7a3b209ee--d4937ff4673d48e79d19eca096fd918a e5363d600c2c456f8a84d741c85bf54a X d4937ff4673d48e79d19eca096fd918a--e5363d600c2c456f8a84d741c85bf54a e5363d600c2c456f8a84d741c85bf54a--74b012f1eef54dd08f581aa4b251db7b 047697b65da04ba2859e48a1d9686792 RZ(-1.0*g1) e5363d600c2c456f8a84d741c85bf54a--047697b65da04ba2859e48a1d9686792 9625545c6a854572b4cdc26b31ccabcb X 047697b65da04ba2859e48a1d9686792--9625545c6a854572b4cdc26b31ccabcb 9625545c6a854572b4cdc26b31ccabcb--2ff443c952dd4348a4c36e10d0567f61 93ad11e947814955b97aec15705d0d24 9625545c6a854572b4cdc26b31ccabcb--93ad11e947814955b97aec15705d0d24 4b8fd8db21ae47bb91e09f86a3745b3f 93ad11e947814955b97aec15705d0d24--4b8fd8db21ae47bb91e09f86a3745b3f ed9793b8640c4ec59fc6d6755616742e X 4b8fd8db21ae47bb91e09f86a3745b3f--ed9793b8640c4ec59fc6d6755616742e ed9793b8640c4ec59fc6d6755616742e--f46404e092e545379627672569aeeedb 6b6ad12eeb994791bd3465f02d662e23 ed9793b8640c4ec59fc6d6755616742e--6b6ad12eeb994791bd3465f02d662e23 be4ffa46cfbc4286addd959814c8abbb 6b6ad12eeb994791bd3465f02d662e23--be4ffa46cfbc4286addd959814c8abbb 4319534058b44cf188f5e600104d7058 be4ffa46cfbc4286addd959814c8abbb--4319534058b44cf188f5e600104d7058 6f0eff5b8ea24747bfa750140f0c477f 4319534058b44cf188f5e600104d7058--6f0eff5b8ea24747bfa750140f0c477f 98c06ef0fca64fcd9bd5f05d24d3a64b 6f0eff5b8ea24747bfa750140f0c477f--98c06ef0fca64fcd9bd5f05d24d3a64b 08c6e86afae84c229d310cf9e027fb46 X 98c06ef0fca64fcd9bd5f05d24d3a64b--08c6e86afae84c229d310cf9e027fb46 08c6e86afae84c229d310cf9e027fb46--a53e821175b94b55b6cfc924f278ba54 edb2a48ecaa7411a99ab361aacabf7bb 08c6e86afae84c229d310cf9e027fb46--edb2a48ecaa7411a99ab361aacabf7bb bb58781553fc4c40927470f1c67c534e edb2a48ecaa7411a99ab361aacabf7bb--bb58781553fc4c40927470f1c67c534e c08152f19e2d49ef811023e24b85d64f X bb58781553fc4c40927470f1c67c534e--c08152f19e2d49ef811023e24b85d64f c08152f19e2d49ef811023e24b85d64f--1ee9d29f2f67413ab2ad2f23a0814799 0ca9da77556f419aba96b58e1be5261c c08152f19e2d49ef811023e24b85d64f--0ca9da77556f419aba96b58e1be5261c 0a5005d299184aac86b9a49f08351727 0ca9da77556f419aba96b58e1be5261c--0a5005d299184aac86b9a49f08351727 5124903ec4d04d64a7db16d38e99be2d 0a5005d299184aac86b9a49f08351727--5124903ec4d04d64a7db16d38e99be2d a7d4b5cac1a34b91ae4febfd3a553989 5124903ec4d04d64a7db16d38e99be2d--a7d4b5cac1a34b91ae4febfd3a553989 fd79daf654874d2081f830848107041a a7d4b5cac1a34b91ae4febfd3a553989--fd79daf654874d2081f830848107041a 87746fff5e734db38cd900085f4a5b01 fd79daf654874d2081f830848107041a--87746fff5e734db38cd900085f4a5b01 cff9de9c34534c69adcdd15be3ffde9a 87746fff5e734db38cd900085f4a5b01--cff9de9c34534c69adcdd15be3ffde9a 1cb07602c0cf4fb1a0813bedeb0bd0e8 cff9de9c34534c69adcdd15be3ffde9a--1cb07602c0cf4fb1a0813bedeb0bd0e8 f7b1f064450f43bbb5c81506af847225 1cb07602c0cf4fb1a0813bedeb0bd0e8--f7b1f064450f43bbb5c81506af847225 fd1b9e20c46b4f939406b98f532d94dc X f7b1f064450f43bbb5c81506af847225--fd1b9e20c46b4f939406b98f532d94dc fd1b9e20c46b4f939406b98f532d94dc--6de0f9eccee142ebb02808f06ef5dd40 4157bbc66291423ca718a2594d1b53a9 fd1b9e20c46b4f939406b98f532d94dc--4157bbc66291423ca718a2594d1b53a9 3b148d365e894e03adb4173e113cd259 X 4157bbc66291423ca718a2594d1b53a9--3b148d365e894e03adb4173e113cd259 3b148d365e894e03adb4173e113cd259--006234680e444971bdae69dc34c21dc8 ec14189c4143491cb399c2263edb97a0 RZ(-1.0*g1) 3b148d365e894e03adb4173e113cd259--ec14189c4143491cb399c2263edb97a0 0927702cb631427297f6bacee0f1491f X ec14189c4143491cb399c2263edb97a0--0927702cb631427297f6bacee0f1491f 0927702cb631427297f6bacee0f1491f--1a57f5a37ea745a7b4a40e3e91dc34a7 55643484a72b45fdb5bf3e01f309406f X 0927702cb631427297f6bacee0f1491f--55643484a72b45fdb5bf3e01f309406f 55643484a72b45fdb5bf3e01f309406f--33b57f7b327b46128eec946cac36cd6e 3ed2eaa195804dbabeac885db780a47d 55643484a72b45fdb5bf3e01f309406f--3ed2eaa195804dbabeac885db780a47d c73ddf7bf54f4518bc4a3561a3333ff5 3ed2eaa195804dbabeac885db780a47d--c73ddf7bf54f4518bc4a3561a3333ff5 1eeeaca10a2e46dfb9836f3ce96a24bf c73ddf7bf54f4518bc4a3561a3333ff5--1eeeaca10a2e46dfb9836f3ce96a24bf d4fdd6b24b334f839fd145c1c5015a5c 1eeeaca10a2e46dfb9836f3ce96a24bf--d4fdd6b24b334f839fd145c1c5015a5c 999e00c0cedf493a8627d630a02e8133 d4fdd6b24b334f839fd145c1c5015a5c--999e00c0cedf493a8627d630a02e8133 8ae16b77988b4b34afd1161de285f6e7 999e00c0cedf493a8627d630a02e8133--8ae16b77988b4b34afd1161de285f6e7 b0b4c977593b46e99beecf1521cc3a85 8ae16b77988b4b34afd1161de285f6e7--b0b4c977593b46e99beecf1521cc3a85 0fe3095c98bc44da94c51dea4b5153cf X b0b4c977593b46e99beecf1521cc3a85--0fe3095c98bc44da94c51dea4b5153cf 0fe3095c98bc44da94c51dea4b5153cf--c38ab22ac4834ba0a1adb01df3d172f4 f21de0315b0a4165ae1925fd64569790 0fe3095c98bc44da94c51dea4b5153cf--f21de0315b0a4165ae1925fd64569790 9d897de664bb4af8958419b56a48d5e6 f21de0315b0a4165ae1925fd64569790--9d897de664bb4af8958419b56a48d5e6 a4acfbd5fc03475cb9eb056886fd471b 9d897de664bb4af8958419b56a48d5e6--a4acfbd5fc03475cb9eb056886fd471b 810529e5a9724be4a1a6585ad2260b49 a4acfbd5fc03475cb9eb056886fd471b--810529e5a9724be4a1a6585ad2260b49 c5cbf4bb002e4742bbeb29c7817d3c5b 810529e5a9724be4a1a6585ad2260b49--c5cbf4bb002e4742bbeb29c7817d3c5b 3fb24a7ccb2e48dabe3572e5fd3b5f6f c5cbf4bb002e4742bbeb29c7817d3c5b--3fb24a7ccb2e48dabe3572e5fd3b5f6f b4f2b8fdee4343979f37192728f5220a 3fb24a7ccb2e48dabe3572e5fd3b5f6f--b4f2b8fdee4343979f37192728f5220a 87259d1515104059a95a2c5b3d618d16 b4f2b8fdee4343979f37192728f5220a--87259d1515104059a95a2c5b3d618d16 645a220b334049e1a0f40ed99cf1a105 87259d1515104059a95a2c5b3d618d16--645a220b334049e1a0f40ed99cf1a105 f78bce6a1a0441d98a89da4852af2f6e 645a220b334049e1a0f40ed99cf1a105--f78bce6a1a0441d98a89da4852af2f6e 5b0446e4244142269ee72a402d58e33f f78bce6a1a0441d98a89da4852af2f6e--5b0446e4244142269ee72a402d58e33f 18fbd7a4370e446ab225a7d69177ff60 5b0446e4244142269ee72a402d58e33f--18fbd7a4370e446ab225a7d69177ff60 9852c444831f47ddb63b6544c5c540a1 18fbd7a4370e446ab225a7d69177ff60--9852c444831f47ddb63b6544c5c540a1 6fd9cfd3d55c4342a0437bbb1c75472e 9852c444831f47ddb63b6544c5c540a1--6fd9cfd3d55c4342a0437bbb1c75472e 5f1bb258aced4f6c99609d9125d0e06d 6fd9cfd3d55c4342a0437bbb1c75472e--5f1bb258aced4f6c99609d9125d0e06d 1ac9d46bfef64e60925c37444ee9596b 5f1bb258aced4f6c99609d9125d0e06d--1ac9d46bfef64e60925c37444ee9596b 2cb7616265734af1961cd2e03b152ff7 1ac9d46bfef64e60925c37444ee9596b--2cb7616265734af1961cd2e03b152ff7 71d7f85e5d7a40cab226865bff8275cf 2cb7616265734af1961cd2e03b152ff7--71d7f85e5d7a40cab226865bff8275cf 1451fa5893a3404bbd1312122c8c0cba 71d7f85e5d7a40cab226865bff8275cf--1451fa5893a3404bbd1312122c8c0cba 0a378530c1424f6ebb7cce9539ead778 1451fa5893a3404bbd1312122c8c0cba--0a378530c1424f6ebb7cce9539ead778 eda72265c7f54e66a60ecffdb0c5864d 0a378530c1424f6ebb7cce9539ead778--eda72265c7f54e66a60ecffdb0c5864d 6bc09213234a46d2aab0981db970a98f RX(b13) eda72265c7f54e66a60ecffdb0c5864d--6bc09213234a46d2aab0981db970a98f 6bc09213234a46d2aab0981db970a98f--63390212bb7c44fca55f70a553e0662c 1fabf75229384152914b4c7773f1f8e6 2a42d816582644c4be6d79754e03b8c4 6540661265974b56994bbf7c4bc55be2--2a42d816582644c4be6d79754e03b8c4 b96d82e12ead43cab285b2c2e8edcce2 5 e31b1632eb5549d6bd792053db7d10a8 2a42d816582644c4be6d79754e03b8c4--e31b1632eb5549d6bd792053db7d10a8 5b3d1bc36c8f480f938b6cc60bdef876 e31b1632eb5549d6bd792053db7d10a8--5b3d1bc36c8f480f938b6cc60bdef876 8cc6de7cfcca430b9c008b438e0935e4 X 5b3d1bc36c8f480f938b6cc60bdef876--8cc6de7cfcca430b9c008b438e0935e4 8cc6de7cfcca430b9c008b438e0935e4--68df642107be48a09b426ef678c62891 80e318fa6d2d4d4e942a0c23b181727d 8cc6de7cfcca430b9c008b438e0935e4--80e318fa6d2d4d4e942a0c23b181727d a48cd5a25cd145fb9dcf55ed9a5ace9f 80e318fa6d2d4d4e942a0c23b181727d--a48cd5a25cd145fb9dcf55ed9a5ace9f 7cc4f701dac54c4dae4202ec95e7bca8 a48cd5a25cd145fb9dcf55ed9a5ace9f--7cc4f701dac54c4dae4202ec95e7bca8 6aed0ab525fb40b8a41a69d91bfb3cc1 7cc4f701dac54c4dae4202ec95e7bca8--6aed0ab525fb40b8a41a69d91bfb3cc1 c7ebda803021410f83df1b49f349a6a3 6aed0ab525fb40b8a41a69d91bfb3cc1--c7ebda803021410f83df1b49f349a6a3 63ef4ca5985c4ee9b134ff8567d4514c c7ebda803021410f83df1b49f349a6a3--63ef4ca5985c4ee9b134ff8567d4514c be7630d987c2481686d5b2020360a3c1 63ef4ca5985c4ee9b134ff8567d4514c--be7630d987c2481686d5b2020360a3c1 788a09990d8749439e2a2380492340e1 X be7630d987c2481686d5b2020360a3c1--788a09990d8749439e2a2380492340e1 788a09990d8749439e2a2380492340e1--a2e08aa57eff4cd1aaf1cd1485f141a5 1bc0e66069ae4f26847caa3eb864839e 788a09990d8749439e2a2380492340e1--1bc0e66069ae4f26847caa3eb864839e 216ca44f40124349975a4ef10a9ba523 1bc0e66069ae4f26847caa3eb864839e--216ca44f40124349975a4ef10a9ba523 13f4f900661e466fbada45ae7731c3e9 216ca44f40124349975a4ef10a9ba523--13f4f900661e466fbada45ae7731c3e9 a098c20de19f4501b8465f0164cbf312 13f4f900661e466fbada45ae7731c3e9--a098c20de19f4501b8465f0164cbf312 fbc24db1dc044b23947d81d994fc547b a098c20de19f4501b8465f0164cbf312--fbc24db1dc044b23947d81d994fc547b fc22be8dc4e74d43af62985a53861fe2 fbc24db1dc044b23947d81d994fc547b--fc22be8dc4e74d43af62985a53861fe2 e0428b98c8ec4e00b965cf9eac59cff0 fc22be8dc4e74d43af62985a53861fe2--e0428b98c8ec4e00b965cf9eac59cff0 23aba4964e394fd4bc5293be1fb218de e0428b98c8ec4e00b965cf9eac59cff0--23aba4964e394fd4bc5293be1fb218de c860182b69ca497bacfa550e3bd5ecaf 23aba4964e394fd4bc5293be1fb218de--c860182b69ca497bacfa550e3bd5ecaf f0a836f49fe9489a85bd884e8b04cff4 c860182b69ca497bacfa550e3bd5ecaf--f0a836f49fe9489a85bd884e8b04cff4 82d9eb3474204587b2dc1e57fff47a55 f0a836f49fe9489a85bd884e8b04cff4--82d9eb3474204587b2dc1e57fff47a55 d6a7e8eff65a46be96407eae5268ed5a 82d9eb3474204587b2dc1e57fff47a55--d6a7e8eff65a46be96407eae5268ed5a 049edd855f4f49b89aafb969188def47 d6a7e8eff65a46be96407eae5268ed5a--049edd855f4f49b89aafb969188def47 c40a8930e76f4a7b8eab3dde33cf99ee X 049edd855f4f49b89aafb969188def47--c40a8930e76f4a7b8eab3dde33cf99ee c40a8930e76f4a7b8eab3dde33cf99ee--9baad181f6594e30a1e6ac8ed9ca2143 e8a6c56d0ae1455db1ea3aa0fa785ee8 c40a8930e76f4a7b8eab3dde33cf99ee--e8a6c56d0ae1455db1ea3aa0fa785ee8 d83bf1513ec74d84a69678093ca853da e8a6c56d0ae1455db1ea3aa0fa785ee8--d83bf1513ec74d84a69678093ca853da 713e314a111a485c97684cda7ad60b1a d83bf1513ec74d84a69678093ca853da--713e314a111a485c97684cda7ad60b1a dcde047683d74c378e0663b51e8cf782 X 713e314a111a485c97684cda7ad60b1a--dcde047683d74c378e0663b51e8cf782 dcde047683d74c378e0663b51e8cf782--f82317b1f5904dc3853cbc5e159cb8a5 96325375ace14d6fa6e78dd3ef75c3b4 dcde047683d74c378e0663b51e8cf782--96325375ace14d6fa6e78dd3ef75c3b4 0fbe96dd51f345d98bbfb7e4268e39c2 96325375ace14d6fa6e78dd3ef75c3b4--0fbe96dd51f345d98bbfb7e4268e39c2 650e3cb179f24b89a7a065d2f71c3f67 0fbe96dd51f345d98bbfb7e4268e39c2--650e3cb179f24b89a7a065d2f71c3f67 b59ce5d5be2b41f38ec6c0483346830b 650e3cb179f24b89a7a065d2f71c3f67--b59ce5d5be2b41f38ec6c0483346830b 935643f3aa9f400caa2a785f347b654f b59ce5d5be2b41f38ec6c0483346830b--935643f3aa9f400caa2a785f347b654f c64ceb9805aa453ab7a62e2c77254f8e 935643f3aa9f400caa2a785f347b654f--c64ceb9805aa453ab7a62e2c77254f8e 00cafb92740e4bb1b9731cc22aea14fd c64ceb9805aa453ab7a62e2c77254f8e--00cafb92740e4bb1b9731cc22aea14fd b2f652aae37e46269c167111a5787f53 00cafb92740e4bb1b9731cc22aea14fd--b2f652aae37e46269c167111a5787f53 034ade9c5f87491397af58ae38ed6416 b2f652aae37e46269c167111a5787f53--034ade9c5f87491397af58ae38ed6416 e1e23c9ee6b545e8af5dd421d6d6503a 034ade9c5f87491397af58ae38ed6416--e1e23c9ee6b545e8af5dd421d6d6503a ca80f4c5bf4c43b08c50c6dc24267175 X e1e23c9ee6b545e8af5dd421d6d6503a--ca80f4c5bf4c43b08c50c6dc24267175 ca80f4c5bf4c43b08c50c6dc24267175--5a48b90220324e22846d20a1ad4bf072 6992097def364d3bb0c7314f21193555 ca80f4c5bf4c43b08c50c6dc24267175--6992097def364d3bb0c7314f21193555 6f4fcbeb375e48868000485f643fb0cf 6992097def364d3bb0c7314f21193555--6f4fcbeb375e48868000485f643fb0cf b44ccf40b719459096adee992e4a5e4c 6f4fcbeb375e48868000485f643fb0cf--b44ccf40b719459096adee992e4a5e4c 44f629f5984c4aef886f21215d20b64a X b44ccf40b719459096adee992e4a5e4c--44f629f5984c4aef886f21215d20b64a 44f629f5984c4aef886f21215d20b64a--ae4a10b78bbe4733bca70876c3e89e80 acffa6df9e664aa3b5216c436088ce1d 44f629f5984c4aef886f21215d20b64a--acffa6df9e664aa3b5216c436088ce1d 6dddc82a983f496a9c23204902272fa3 acffa6df9e664aa3b5216c436088ce1d--6dddc82a983f496a9c23204902272fa3 ff925122cdda49988e4ba9fb33c52c08 6dddc82a983f496a9c23204902272fa3--ff925122cdda49988e4ba9fb33c52c08 63570fc1fbd24dba8610ee7dbb1511fc ff925122cdda49988e4ba9fb33c52c08--63570fc1fbd24dba8610ee7dbb1511fc c93a4637fe594c9ca4d262c42ce3edbf X 63570fc1fbd24dba8610ee7dbb1511fc--c93a4637fe594c9ca4d262c42ce3edbf c93a4637fe594c9ca4d262c42ce3edbf--085713f3ebac47839e3d66ea6b782a7e 9313464c8ed64c15a59d76dc1a8f5c14 c93a4637fe594c9ca4d262c42ce3edbf--9313464c8ed64c15a59d76dc1a8f5c14 2aae5cdd16d94770b4ac31ef56eddc48 9313464c8ed64c15a59d76dc1a8f5c14--2aae5cdd16d94770b4ac31ef56eddc48 5e1a052bafaf41a6a75860162ee3edab 2aae5cdd16d94770b4ac31ef56eddc48--5e1a052bafaf41a6a75860162ee3edab 8a27fd628f2c441eb3ee56796def7ac6 5e1a052bafaf41a6a75860162ee3edab--8a27fd628f2c441eb3ee56796def7ac6 3b8bea0873d443788ab9482b5c0344fa 8a27fd628f2c441eb3ee56796def7ac6--3b8bea0873d443788ab9482b5c0344fa 5d213a7592784cc4978d612ff5ba8842 3b8bea0873d443788ab9482b5c0344fa--5d213a7592784cc4978d612ff5ba8842 d011bbee0f9d43a68c3adc66cb5d7bd7 5d213a7592784cc4978d612ff5ba8842--d011bbee0f9d43a68c3adc66cb5d7bd7 2297701a346b4976bd9587588deae4c5 X d011bbee0f9d43a68c3adc66cb5d7bd7--2297701a346b4976bd9587588deae4c5 2297701a346b4976bd9587588deae4c5--f0d3261323404a28b0d9058dfc86f542 11b4be5edc1b4058816c0ce41ce3cd89 2297701a346b4976bd9587588deae4c5--11b4be5edc1b4058816c0ce41ce3cd89 e112e928628942d6a99227dbe0386339 11b4be5edc1b4058816c0ce41ce3cd89--e112e928628942d6a99227dbe0386339 975486a547f249538a06b52cf3375b32 e112e928628942d6a99227dbe0386339--975486a547f249538a06b52cf3375b32 5a69bc2534074a0991bc702d4c02f7c7 975486a547f249538a06b52cf3375b32--5a69bc2534074a0991bc702d4c02f7c7 fdd8791f8e484d63bc929d21a8dd5e85 5a69bc2534074a0991bc702d4c02f7c7--fdd8791f8e484d63bc929d21a8dd5e85 3c48c5615bb544e2a21161df22167b21 fdd8791f8e484d63bc929d21a8dd5e85--3c48c5615bb544e2a21161df22167b21 696f1618c12548048b4aafd05b85993e X 3c48c5615bb544e2a21161df22167b21--696f1618c12548048b4aafd05b85993e 696f1618c12548048b4aafd05b85993e--098ab10bc10b451f89b290c27774f153 728a96cfa2b84c5e86a111e98487f3ae 696f1618c12548048b4aafd05b85993e--728a96cfa2b84c5e86a111e98487f3ae 3f531c0c23514726b2b33008f8634dfc 728a96cfa2b84c5e86a111e98487f3ae--3f531c0c23514726b2b33008f8634dfc e5ae7121bb7c41c1b4e90c4f856fdbef 3f531c0c23514726b2b33008f8634dfc--e5ae7121bb7c41c1b4e90c4f856fdbef 4652d6867d0d45189259678d445d1456 e5ae7121bb7c41c1b4e90c4f856fdbef--4652d6867d0d45189259678d445d1456 03a28394fe2d4e6fb218f02443cd388d 4652d6867d0d45189259678d445d1456--03a28394fe2d4e6fb218f02443cd388d 6aa45ea2096647339d5e8c383b9a6bee X 03a28394fe2d4e6fb218f02443cd388d--6aa45ea2096647339d5e8c383b9a6bee 6aa45ea2096647339d5e8c383b9a6bee--aa83b63b5efc4e2281bccaee0901d4f1 1123fc18900f4034bbd1a15226460046 6aa45ea2096647339d5e8c383b9a6bee--1123fc18900f4034bbd1a15226460046 754408141bb7417d866a0a541f081cdb X 1123fc18900f4034bbd1a15226460046--754408141bb7417d866a0a541f081cdb 754408141bb7417d866a0a541f081cdb--7b34c358321f4a03884cb4ca05dd3938 e694638919ff4596813e12afd2c4c47f RZ(-1.0*g0) 754408141bb7417d866a0a541f081cdb--e694638919ff4596813e12afd2c4c47f bacd56ebd220487b8cae4d28508b33d2 X e694638919ff4596813e12afd2c4c47f--bacd56ebd220487b8cae4d28508b33d2 bacd56ebd220487b8cae4d28508b33d2--ccb2bc334dc64ea3bde55d7c6f2e47b9 2b2079828141443fa516ca48bd06dfbe X bacd56ebd220487b8cae4d28508b33d2--2b2079828141443fa516ca48bd06dfbe 2b2079828141443fa516ca48bd06dfbe--8d45e9f8ac1940a7b6fe687d74791d7e 153ded1cf86043949d106fa4e6d62ccb 2b2079828141443fa516ca48bd06dfbe--153ded1cf86043949d106fa4e6d62ccb b2cb6c3ac3204721b96e4b31e7ee199f 153ded1cf86043949d106fa4e6d62ccb--b2cb6c3ac3204721b96e4b31e7ee199f 0fa63c69baf74d619f27ddf20750dd47 b2cb6c3ac3204721b96e4b31e7ee199f--0fa63c69baf74d619f27ddf20750dd47 98573df9bbba42769d4b1ec03b34a0e9 X 0fa63c69baf74d619f27ddf20750dd47--98573df9bbba42769d4b1ec03b34a0e9 98573df9bbba42769d4b1ec03b34a0e9--0eed59c0311a47cebce5c69fbeabb051 a355694911dd43b8a2f92feb000beda3 X 98573df9bbba42769d4b1ec03b34a0e9--a355694911dd43b8a2f92feb000beda3 a355694911dd43b8a2f92feb000beda3--674a96a0284d41c994cdfbe63ec2e3ca 1281bdc8e87b4ecb91af6ea8b1a48b47 a355694911dd43b8a2f92feb000beda3--1281bdc8e87b4ecb91af6ea8b1a48b47 b7c790d5ba1f43c0888a363b91217f6b 1281bdc8e87b4ecb91af6ea8b1a48b47--b7c790d5ba1f43c0888a363b91217f6b 5030065a41d94e69b88f8c23ddf022ec b7c790d5ba1f43c0888a363b91217f6b--5030065a41d94e69b88f8c23ddf022ec 5e26fede0f674968bdde01ed989b88f9 5030065a41d94e69b88f8c23ddf022ec--5e26fede0f674968bdde01ed989b88f9 b7e90b13d646457a88289abf19036bf2 5e26fede0f674968bdde01ed989b88f9--b7e90b13d646457a88289abf19036bf2 8a57efe5ddaf4b6e85d76b50f299d350 X b7e90b13d646457a88289abf19036bf2--8a57efe5ddaf4b6e85d76b50f299d350 8a57efe5ddaf4b6e85d76b50f299d350--b3c8a7e46d074ee691d6444aa1a7ada2 19816200c80842fa947e0a996e196a5f 8a57efe5ddaf4b6e85d76b50f299d350--19816200c80842fa947e0a996e196a5f 33fcffb60e0a491f87f7f2094007b259 19816200c80842fa947e0a996e196a5f--33fcffb60e0a491f87f7f2094007b259 21648b1d71b34981bdde33357a7c349d 33fcffb60e0a491f87f7f2094007b259--21648b1d71b34981bdde33357a7c349d fb9d7a6000ef4276948f0ca7bc5c02d6 21648b1d71b34981bdde33357a7c349d--fb9d7a6000ef4276948f0ca7bc5c02d6 901707d0a0bc4fd0b383ac29b1747b64 fb9d7a6000ef4276948f0ca7bc5c02d6--901707d0a0bc4fd0b383ac29b1747b64 6db24c385dde4988b6614aedeafb804e 901707d0a0bc4fd0b383ac29b1747b64--6db24c385dde4988b6614aedeafb804e 42682b7d87b84fa0955287d76a1f024c RX(b04) 6db24c385dde4988b6614aedeafb804e--42682b7d87b84fa0955287d76a1f024c ee8b49e15cea47fe893af557b57eb6e0 42682b7d87b84fa0955287d76a1f024c--ee8b49e15cea47fe893af557b57eb6e0 6b0644b6e6e745a88528b4d7c8841d19 ee8b49e15cea47fe893af557b57eb6e0--6b0644b6e6e745a88528b4d7c8841d19 53958119d4d9405fad4497804957fe7a 6b0644b6e6e745a88528b4d7c8841d19--53958119d4d9405fad4497804957fe7a b2fc4a8edc494f1d94bff4ff47cbd079 X 53958119d4d9405fad4497804957fe7a--b2fc4a8edc494f1d94bff4ff47cbd079 b2fc4a8edc494f1d94bff4ff47cbd079--31df62d1a74a49bebbdc0e7feda14ec3 4127c91ab4324067b497a134633c42f0 b2fc4a8edc494f1d94bff4ff47cbd079--4127c91ab4324067b497a134633c42f0 31be150cdcbb4d2092915fea26d0543b 4127c91ab4324067b497a134633c42f0--31be150cdcbb4d2092915fea26d0543b b1db9fbbe86f4e9a924839e6eb9a6b91 31be150cdcbb4d2092915fea26d0543b--b1db9fbbe86f4e9a924839e6eb9a6b91 802a1cbeb3d54ab79c9e9ec8cbce403a b1db9fbbe86f4e9a924839e6eb9a6b91--802a1cbeb3d54ab79c9e9ec8cbce403a 5c42e18b94f8406e8e09377c216e80b8 802a1cbeb3d54ab79c9e9ec8cbce403a--5c42e18b94f8406e8e09377c216e80b8 01ae006a3c6f4113a2f350233524db20 5c42e18b94f8406e8e09377c216e80b8--01ae006a3c6f4113a2f350233524db20 9d46cd348fa14bc3bd1ce62860f42cef 01ae006a3c6f4113a2f350233524db20--9d46cd348fa14bc3bd1ce62860f42cef 671314bd3a094126ac568902c88d6ed0 X 9d46cd348fa14bc3bd1ce62860f42cef--671314bd3a094126ac568902c88d6ed0 671314bd3a094126ac568902c88d6ed0--964ef3d306d14f1d80cf731e9d040ef9 4b67b2f414414d98908152108252eb32 671314bd3a094126ac568902c88d6ed0--4b67b2f414414d98908152108252eb32 75c9767caddd467ca5a10a7d9f4334fd 4b67b2f414414d98908152108252eb32--75c9767caddd467ca5a10a7d9f4334fd f782cc34d56745d0958862901848bf58 75c9767caddd467ca5a10a7d9f4334fd--f782cc34d56745d0958862901848bf58 d46aec4ac3aa419988e8cb1a0a364f3a f782cc34d56745d0958862901848bf58--d46aec4ac3aa419988e8cb1a0a364f3a 84c2b412097149c5bd025d3300bb8460 d46aec4ac3aa419988e8cb1a0a364f3a--84c2b412097149c5bd025d3300bb8460 33bf133ea3f446fe8c6c7478d4f5b296 84c2b412097149c5bd025d3300bb8460--33bf133ea3f446fe8c6c7478d4f5b296 4531b846f2b845f68273eedeffae3327 33bf133ea3f446fe8c6c7478d4f5b296--4531b846f2b845f68273eedeffae3327 ef59f472312b4da8b5420a2e54e7519a 4531b846f2b845f68273eedeffae3327--ef59f472312b4da8b5420a2e54e7519a e2f686708cf74a4eb2d155c6d1b19e83 ef59f472312b4da8b5420a2e54e7519a--e2f686708cf74a4eb2d155c6d1b19e83 1d161d5a1253464298a2b85fb22f1f0d e2f686708cf74a4eb2d155c6d1b19e83--1d161d5a1253464298a2b85fb22f1f0d a1c0c834cd424a6aa7dd62f469aba5cc 1d161d5a1253464298a2b85fb22f1f0d--a1c0c834cd424a6aa7dd62f469aba5cc 0182553c106847f5bb5f13e4acce8697 a1c0c834cd424a6aa7dd62f469aba5cc--0182553c106847f5bb5f13e4acce8697 ea2f9a27bd164c7db81989d66a1f4997 0182553c106847f5bb5f13e4acce8697--ea2f9a27bd164c7db81989d66a1f4997 a10f49a5c6dd44c7bdd9795fb0a9cbe6 X ea2f9a27bd164c7db81989d66a1f4997--a10f49a5c6dd44c7bdd9795fb0a9cbe6 a10f49a5c6dd44c7bdd9795fb0a9cbe6--ee54a5dbb2cd4b499effaca73a0eaf5e 737f9673c0d442cfb1ec20596ec57f75 a10f49a5c6dd44c7bdd9795fb0a9cbe6--737f9673c0d442cfb1ec20596ec57f75 7b119bd2f69d4e65b3bd976813c1bb04 737f9673c0d442cfb1ec20596ec57f75--7b119bd2f69d4e65b3bd976813c1bb04 c4220a92e0684e65967c3b15f27b3262 7b119bd2f69d4e65b3bd976813c1bb04--c4220a92e0684e65967c3b15f27b3262 308815e799b744d49f351934ba4a1949 X c4220a92e0684e65967c3b15f27b3262--308815e799b744d49f351934ba4a1949 308815e799b744d49f351934ba4a1949--821c774c160e450caf131bb5db551a1b 3e593179f61f46de847a51f3e6a5a898 308815e799b744d49f351934ba4a1949--3e593179f61f46de847a51f3e6a5a898 c146a5cec5264660b1d07ece59b67240 3e593179f61f46de847a51f3e6a5a898--c146a5cec5264660b1d07ece59b67240 5711c94c860349ce94e4863c73476901 c146a5cec5264660b1d07ece59b67240--5711c94c860349ce94e4863c73476901 6e1b7b1169114b43ac6f95ab94b92c75 5711c94c860349ce94e4863c73476901--6e1b7b1169114b43ac6f95ab94b92c75 bf36da8f44f74965953a007f1acfff99 6e1b7b1169114b43ac6f95ab94b92c75--bf36da8f44f74965953a007f1acfff99 f4770a2182384c458ed3ded820f5e17b bf36da8f44f74965953a007f1acfff99--f4770a2182384c458ed3ded820f5e17b f0b05aedb9fc4aadb3908fb2a83a8c54 f4770a2182384c458ed3ded820f5e17b--f0b05aedb9fc4aadb3908fb2a83a8c54 bea2f67c807e4137bb8e707f3fb8a148 f0b05aedb9fc4aadb3908fb2a83a8c54--bea2f67c807e4137bb8e707f3fb8a148 84f0dbf5fd3b4264adb218ad51a56c7b bea2f67c807e4137bb8e707f3fb8a148--84f0dbf5fd3b4264adb218ad51a56c7b c27c752e6b544d1db14203a05c0a6840 84f0dbf5fd3b4264adb218ad51a56c7b--c27c752e6b544d1db14203a05c0a6840 4ffa9a56f9d74dd6bb590689c2f85989 X c27c752e6b544d1db14203a05c0a6840--4ffa9a56f9d74dd6bb590689c2f85989 4ffa9a56f9d74dd6bb590689c2f85989--6b6ad12eeb994791bd3465f02d662e23 97daf17cd16240d39d37a30e56da0bf0 4ffa9a56f9d74dd6bb590689c2f85989--97daf17cd16240d39d37a30e56da0bf0 914fd599f19e443c9e2b3489eca2fba6 97daf17cd16240d39d37a30e56da0bf0--914fd599f19e443c9e2b3489eca2fba6 95d136dd3e7546d8bc4ba835a052f4b1 914fd599f19e443c9e2b3489eca2fba6--95d136dd3e7546d8bc4ba835a052f4b1 2020a5498d41444195fb1c5f4b471406 X 95d136dd3e7546d8bc4ba835a052f4b1--2020a5498d41444195fb1c5f4b471406 2020a5498d41444195fb1c5f4b471406--98c06ef0fca64fcd9bd5f05d24d3a64b 0248beeffb194bd9ab09201581c10fd4 2020a5498d41444195fb1c5f4b471406--0248beeffb194bd9ab09201581c10fd4 6ac72eb23f9a4bfbbaeee69fcd323179 0248beeffb194bd9ab09201581c10fd4--6ac72eb23f9a4bfbbaeee69fcd323179 6cf3457a561040d99aee42bc818ed88d 6ac72eb23f9a4bfbbaeee69fcd323179--6cf3457a561040d99aee42bc818ed88d 1621e01c49914814b439bc6d6ff2bb2e 6cf3457a561040d99aee42bc818ed88d--1621e01c49914814b439bc6d6ff2bb2e 49f92f58fbf84914963177a5b91623a2 X 1621e01c49914814b439bc6d6ff2bb2e--49f92f58fbf84914963177a5b91623a2 49f92f58fbf84914963177a5b91623a2--0ca9da77556f419aba96b58e1be5261c 8df44e5a5d004adabb1493fc197a3e55 49f92f58fbf84914963177a5b91623a2--8df44e5a5d004adabb1493fc197a3e55 4ca4b8c4219d466ebd3a0e07852bc4ae 8df44e5a5d004adabb1493fc197a3e55--4ca4b8c4219d466ebd3a0e07852bc4ae 91af84ff3c37495e9dbea9ada12ef1fd 4ca4b8c4219d466ebd3a0e07852bc4ae--91af84ff3c37495e9dbea9ada12ef1fd f32e512652ba4dc3870580963ce21199 91af84ff3c37495e9dbea9ada12ef1fd--f32e512652ba4dc3870580963ce21199 8d50905ade6e4a0fa6fc306fdb3ff8a1 f32e512652ba4dc3870580963ce21199--8d50905ade6e4a0fa6fc306fdb3ff8a1 5322a26804144fe2a5cb933baf0f6418 8d50905ade6e4a0fa6fc306fdb3ff8a1--5322a26804144fe2a5cb933baf0f6418 c77c7ac512be4cd79c2694058bc1d4fc 5322a26804144fe2a5cb933baf0f6418--c77c7ac512be4cd79c2694058bc1d4fc 7321d7597591458595f10ed22ee7163a X c77c7ac512be4cd79c2694058bc1d4fc--7321d7597591458595f10ed22ee7163a 7321d7597591458595f10ed22ee7163a--f7b1f064450f43bbb5c81506af847225 b173b4764a4549199d3e445eae94274d 7321d7597591458595f10ed22ee7163a--b173b4764a4549199d3e445eae94274d 5c363ccc919d4b7c8daba2befed65c07 b173b4764a4549199d3e445eae94274d--5c363ccc919d4b7c8daba2befed65c07 fb22611a99da41bdb451ed3e89ce7fe9 5c363ccc919d4b7c8daba2befed65c07--fb22611a99da41bdb451ed3e89ce7fe9 ba55c577cf6b4b899aabb427d20aa36f fb22611a99da41bdb451ed3e89ce7fe9--ba55c577cf6b4b899aabb427d20aa36f c47b874f73f843b2b954a69ffe9c31b0 ba55c577cf6b4b899aabb427d20aa36f--c47b874f73f843b2b954a69ffe9c31b0 47a6f8401bdc4060b681189c566e63bd c47b874f73f843b2b954a69ffe9c31b0--47a6f8401bdc4060b681189c566e63bd 932f7462222c4ab5a1cce357e6d2e7b7 X 47a6f8401bdc4060b681189c566e63bd--932f7462222c4ab5a1cce357e6d2e7b7 932f7462222c4ab5a1cce357e6d2e7b7--3ed2eaa195804dbabeac885db780a47d d6afe04417eb47fea63e3358c6af47bf 932f7462222c4ab5a1cce357e6d2e7b7--d6afe04417eb47fea63e3358c6af47bf 0ec7a83f6f3f4c259bc2aa634741ab7a d6afe04417eb47fea63e3358c6af47bf--0ec7a83f6f3f4c259bc2aa634741ab7a b20c4ecd79f24017aadf1c1e6a469ef2 0ec7a83f6f3f4c259bc2aa634741ab7a--b20c4ecd79f24017aadf1c1e6a469ef2 7fcdf2547d684ceaba3579b0ad9a7539 b20c4ecd79f24017aadf1c1e6a469ef2--7fcdf2547d684ceaba3579b0ad9a7539 48e91317d1864d89b62d05f1f7549530 7fcdf2547d684ceaba3579b0ad9a7539--48e91317d1864d89b62d05f1f7549530 75e159ed33cc40d98a3625d82f4b58e2 X 48e91317d1864d89b62d05f1f7549530--75e159ed33cc40d98a3625d82f4b58e2 75e159ed33cc40d98a3625d82f4b58e2--b0b4c977593b46e99beecf1521cc3a85 3907922dfc304f3f9703ca1d14b6ce83 75e159ed33cc40d98a3625d82f4b58e2--3907922dfc304f3f9703ca1d14b6ce83 125013d2b0d747a0b50504f3d37a9a3c X 3907922dfc304f3f9703ca1d14b6ce83--125013d2b0d747a0b50504f3d37a9a3c 125013d2b0d747a0b50504f3d37a9a3c--f21de0315b0a4165ae1925fd64569790 49e8488339464f05989404e41349416c RZ(-1.0*g1) 125013d2b0d747a0b50504f3d37a9a3c--49e8488339464f05989404e41349416c c41070979dd54bae9780f99abde13b6d X 49e8488339464f05989404e41349416c--c41070979dd54bae9780f99abde13b6d c41070979dd54bae9780f99abde13b6d--a4acfbd5fc03475cb9eb056886fd471b 061993f2b0ee415095c300d133d3850c X c41070979dd54bae9780f99abde13b6d--061993f2b0ee415095c300d133d3850c 061993f2b0ee415095c300d133d3850c--810529e5a9724be4a1a6585ad2260b49 1a77cec3f22e45539555a791e20db4a6 061993f2b0ee415095c300d133d3850c--1a77cec3f22e45539555a791e20db4a6 10c73b318b844c5d9e9497f74fbdb003 1a77cec3f22e45539555a791e20db4a6--10c73b318b844c5d9e9497f74fbdb003 e5f6590b91df42ccae0fcf59002326f7 10c73b318b844c5d9e9497f74fbdb003--e5f6590b91df42ccae0fcf59002326f7 eb2a90107aee44f990c5d89aa92f49f4 X e5f6590b91df42ccae0fcf59002326f7--eb2a90107aee44f990c5d89aa92f49f4 eb2a90107aee44f990c5d89aa92f49f4--87259d1515104059a95a2c5b3d618d16 1475752a07ac40b3b5b5b2aa454bf55c X eb2a90107aee44f990c5d89aa92f49f4--1475752a07ac40b3b5b5b2aa454bf55c 1475752a07ac40b3b5b5b2aa454bf55c--645a220b334049e1a0f40ed99cf1a105 effdd02ef963403ab4c968a9d79fecb6 1475752a07ac40b3b5b5b2aa454bf55c--effdd02ef963403ab4c968a9d79fecb6 08793a8e727e4497805b190d965b0aa9 effdd02ef963403ab4c968a9d79fecb6--08793a8e727e4497805b190d965b0aa9 55e1924f75ea4df5b0438149598f8159 08793a8e727e4497805b190d965b0aa9--55e1924f75ea4df5b0438149598f8159 cafd42bee49745cfa10d9904361f4a57 55e1924f75ea4df5b0438149598f8159--cafd42bee49745cfa10d9904361f4a57 9d85ef300b6d4850a3c70899dac08315 cafd42bee49745cfa10d9904361f4a57--9d85ef300b6d4850a3c70899dac08315 be0bcb488d284c5aa3b9a0881f6d2bcb X 9d85ef300b6d4850a3c70899dac08315--be0bcb488d284c5aa3b9a0881f6d2bcb be0bcb488d284c5aa3b9a0881f6d2bcb--5f1bb258aced4f6c99609d9125d0e06d 60f643a731cd461ba170df7ed881a227 be0bcb488d284c5aa3b9a0881f6d2bcb--60f643a731cd461ba170df7ed881a227 0b47e08a3e7c46698dbc16b84d675f1b 60f643a731cd461ba170df7ed881a227--0b47e08a3e7c46698dbc16b84d675f1b ec56d3e840e8474bae1606e09336cbed 0b47e08a3e7c46698dbc16b84d675f1b--ec56d3e840e8474bae1606e09336cbed 672eeb5153894d2b936f761249a8d211 ec56d3e840e8474bae1606e09336cbed--672eeb5153894d2b936f761249a8d211 b58524b49b1b4a3ab51f1a7ef0a566e6 672eeb5153894d2b936f761249a8d211--b58524b49b1b4a3ab51f1a7ef0a566e6 e1de4ecfdceb459882c591c06c00e587 b58524b49b1b4a3ab51f1a7ef0a566e6--e1de4ecfdceb459882c591c06c00e587 8dede82c5d3847f4a3b07c05f8fbec82 RX(b14) e1de4ecfdceb459882c591c06c00e587--8dede82c5d3847f4a3b07c05f8fbec82 8dede82c5d3847f4a3b07c05f8fbec82--1fabf75229384152914b4c7773f1f8e6 5d2d9f7bf8364399a2cc6ee0c389bbd4 3fa830a87a3e4dbca7d4ba7157599d5a b96d82e12ead43cab285b2c2e8edcce2--3fa830a87a3e4dbca7d4ba7157599d5a c5c089cc522441eabf8f98794f3b66bd 6 8008267f49e14a908ef7d97f04b01a64 3fa830a87a3e4dbca7d4ba7157599d5a--8008267f49e14a908ef7d97f04b01a64 29dc8968eb124ee9bb676098121d67b3 8008267f49e14a908ef7d97f04b01a64--29dc8968eb124ee9bb676098121d67b3 bf2ad7df3fbd4480bec23b4b3829dd6a 29dc8968eb124ee9bb676098121d67b3--bf2ad7df3fbd4480bec23b4b3829dd6a 3fcc6520ed354f11a34d87dd1a5930a1 X bf2ad7df3fbd4480bec23b4b3829dd6a--3fcc6520ed354f11a34d87dd1a5930a1 3fcc6520ed354f11a34d87dd1a5930a1--80e318fa6d2d4d4e942a0c23b181727d 9a079844e4fd42da871f3cbd07159685 3fcc6520ed354f11a34d87dd1a5930a1--9a079844e4fd42da871f3cbd07159685 8aed1d6c26404ccead98f3e5f31f2044 9a079844e4fd42da871f3cbd07159685--8aed1d6c26404ccead98f3e5f31f2044 2d7c1a5c409249e8a45e228f383dc58b 8aed1d6c26404ccead98f3e5f31f2044--2d7c1a5c409249e8a45e228f383dc58b 84682d4a070345ceac86f16a40e8baa3 2d7c1a5c409249e8a45e228f383dc58b--84682d4a070345ceac86f16a40e8baa3 0b8ea63eb778464db4018e1e9aa689f3 84682d4a070345ceac86f16a40e8baa3--0b8ea63eb778464db4018e1e9aa689f3 0dec939f2a6041b4abd54700f4f90460 X 0b8ea63eb778464db4018e1e9aa689f3--0dec939f2a6041b4abd54700f4f90460 0dec939f2a6041b4abd54700f4f90460--be7630d987c2481686d5b2020360a3c1 c6380e65ef654925bb7927bbc62ef5c6 0dec939f2a6041b4abd54700f4f90460--c6380e65ef654925bb7927bbc62ef5c6 3daadd88c998482a9a40792b4396a2e0 c6380e65ef654925bb7927bbc62ef5c6--3daadd88c998482a9a40792b4396a2e0 ec5f9c6340ec414290008c6d11cfa156 3daadd88c998482a9a40792b4396a2e0--ec5f9c6340ec414290008c6d11cfa156 c7af37950fe64aebbb624a87f56cf031 ec5f9c6340ec414290008c6d11cfa156--c7af37950fe64aebbb624a87f56cf031 8b8015404aa64e2f8d1ce39b87e36a0c c7af37950fe64aebbb624a87f56cf031--8b8015404aa64e2f8d1ce39b87e36a0c f21df9636a354d4eab68cbc7715616ce 8b8015404aa64e2f8d1ce39b87e36a0c--f21df9636a354d4eab68cbc7715616ce 90e179ba50fe4e2ab86537f19328fea3 f21df9636a354d4eab68cbc7715616ce--90e179ba50fe4e2ab86537f19328fea3 3ceb135c2ff54639bdc238c36d960378 90e179ba50fe4e2ab86537f19328fea3--3ceb135c2ff54639bdc238c36d960378 3c738512b0124828b7e5bf4e753d69b5 3ceb135c2ff54639bdc238c36d960378--3c738512b0124828b7e5bf4e753d69b5 fd186781a9884bce999d673ee58b2dd8 3c738512b0124828b7e5bf4e753d69b5--fd186781a9884bce999d673ee58b2dd8 4c51d09e652c448db27c04973340e686 fd186781a9884bce999d673ee58b2dd8--4c51d09e652c448db27c04973340e686 d3b679ed59e64ab3b669ee8a167cdc5c 4c51d09e652c448db27c04973340e686--d3b679ed59e64ab3b669ee8a167cdc5c 0f45b8fe974947ffa1fca28be147660d d3b679ed59e64ab3b669ee8a167cdc5c--0f45b8fe974947ffa1fca28be147660d 5013054739ba4eeeb11c5ab29be444d5 0f45b8fe974947ffa1fca28be147660d--5013054739ba4eeeb11c5ab29be444d5 b1c2353426cb40a3b030d96356388282 5013054739ba4eeeb11c5ab29be444d5--b1c2353426cb40a3b030d96356388282 52dbffd5e4664756877d76c05cdc43e7 X b1c2353426cb40a3b030d96356388282--52dbffd5e4664756877d76c05cdc43e7 52dbffd5e4664756877d76c05cdc43e7--e8a6c56d0ae1455db1ea3aa0fa785ee8 71e43430567a4bb3be6e826d58f68acb RZ(-1.0*g0) 52dbffd5e4664756877d76c05cdc43e7--71e43430567a4bb3be6e826d58f68acb 7af265fe3a324bb8bf94e68b90c7e77f X 71e43430567a4bb3be6e826d58f68acb--7af265fe3a324bb8bf94e68b90c7e77f 7af265fe3a324bb8bf94e68b90c7e77f--713e314a111a485c97684cda7ad60b1a b92280ca4b684719be6300b7dfa21513 7af265fe3a324bb8bf94e68b90c7e77f--b92280ca4b684719be6300b7dfa21513 5771c67ae49547bfae0e13c9375869bb b92280ca4b684719be6300b7dfa21513--5771c67ae49547bfae0e13c9375869bb 4bca770a29864046b644f8e392942746 5771c67ae49547bfae0e13c9375869bb--4bca770a29864046b644f8e392942746 e8a97cd8e91b438b9fe4053ee365d9dc 4bca770a29864046b644f8e392942746--e8a97cd8e91b438b9fe4053ee365d9dc b96cfa1d332340aba76e8e2dcf5586d3 e8a97cd8e91b438b9fe4053ee365d9dc--b96cfa1d332340aba76e8e2dcf5586d3 5be0e8c471d740f189961d70e8188f73 b96cfa1d332340aba76e8e2dcf5586d3--5be0e8c471d740f189961d70e8188f73 b97f1af9880b47dfad8cc5a9e852e040 5be0e8c471d740f189961d70e8188f73--b97f1af9880b47dfad8cc5a9e852e040 39f884e0a11e4ab0ad888f555a479c68 b97f1af9880b47dfad8cc5a9e852e040--39f884e0a11e4ab0ad888f555a479c68 67093398f0494b298692fc2dec0783d3 39f884e0a11e4ab0ad888f555a479c68--67093398f0494b298692fc2dec0783d3 ec90ec470e804e6d969c266942769f6b 67093398f0494b298692fc2dec0783d3--ec90ec470e804e6d969c266942769f6b 866b2b6e93d04ea0ba1053c720680459 ec90ec470e804e6d969c266942769f6b--866b2b6e93d04ea0ba1053c720680459 c6fb56cf526842cf876038feae8c904b 866b2b6e93d04ea0ba1053c720680459--c6fb56cf526842cf876038feae8c904b 67a77e542f364b09babf53cac4b9cb73 X c6fb56cf526842cf876038feae8c904b--67a77e542f364b09babf53cac4b9cb73 67a77e542f364b09babf53cac4b9cb73--6992097def364d3bb0c7314f21193555 04e1ef1e55f14709a928c5767c9aac5d RZ(-1.0*g0) 67a77e542f364b09babf53cac4b9cb73--04e1ef1e55f14709a928c5767c9aac5d 5ae8189522d140b58f3657e380ac74e1 X 04e1ef1e55f14709a928c5767c9aac5d--5ae8189522d140b58f3657e380ac74e1 5ae8189522d140b58f3657e380ac74e1--b44ccf40b719459096adee992e4a5e4c 0e179d188f6145e48da00759b81d70a1 5ae8189522d140b58f3657e380ac74e1--0e179d188f6145e48da00759b81d70a1 867cbc89a5da4f308e8a2310f2288bce 0e179d188f6145e48da00759b81d70a1--867cbc89a5da4f308e8a2310f2288bce aaf1e049673e4b7483e52bf620af6909 867cbc89a5da4f308e8a2310f2288bce--aaf1e049673e4b7483e52bf620af6909 0845b91c29cf4258ab2c198baf93f6ec aaf1e049673e4b7483e52bf620af6909--0845b91c29cf4258ab2c198baf93f6ec 4906b39e1d5a4361bc4828f8be3abfd0 0845b91c29cf4258ab2c198baf93f6ec--4906b39e1d5a4361bc4828f8be3abfd0 505aeb2c69c145b9b9d85e9812fc4a65 4906b39e1d5a4361bc4828f8be3abfd0--505aeb2c69c145b9b9d85e9812fc4a65 f9c57d7f9314458b993dc02986297cfe X 505aeb2c69c145b9b9d85e9812fc4a65--f9c57d7f9314458b993dc02986297cfe f9c57d7f9314458b993dc02986297cfe--9313464c8ed64c15a59d76dc1a8f5c14 e8ffb272d562489eb11ca6c2749dfe9c f9c57d7f9314458b993dc02986297cfe--e8ffb272d562489eb11ca6c2749dfe9c e4345afe518e4de483e44cbe9ac0c27d e8ffb272d562489eb11ca6c2749dfe9c--e4345afe518e4de483e44cbe9ac0c27d 1f5e9ba5028c43019e64c87450b3cb7d e4345afe518e4de483e44cbe9ac0c27d--1f5e9ba5028c43019e64c87450b3cb7d 2c763bc3f98c478095d5b3e260ba011d 1f5e9ba5028c43019e64c87450b3cb7d--2c763bc3f98c478095d5b3e260ba011d b1641d1caf2c49c39a42ede98cea6135 2c763bc3f98c478095d5b3e260ba011d--b1641d1caf2c49c39a42ede98cea6135 2fdbe1de9f304da3913b74d59e264fe0 X b1641d1caf2c49c39a42ede98cea6135--2fdbe1de9f304da3913b74d59e264fe0 2fdbe1de9f304da3913b74d59e264fe0--d011bbee0f9d43a68c3adc66cb5d7bd7 6956741d3f9a4de8a5d11217d9c021ae 2fdbe1de9f304da3913b74d59e264fe0--6956741d3f9a4de8a5d11217d9c021ae ababc604a87a4f8ca70fef33ff6d74cf 6956741d3f9a4de8a5d11217d9c021ae--ababc604a87a4f8ca70fef33ff6d74cf e4271657af0f4b9bba9be7436edd7b5c ababc604a87a4f8ca70fef33ff6d74cf--e4271657af0f4b9bba9be7436edd7b5c b8033e36536c43dc99c09a54480df8a9 e4271657af0f4b9bba9be7436edd7b5c--b8033e36536c43dc99c09a54480df8a9 1a11d83b8b024073bf2d78090acb8e3a b8033e36536c43dc99c09a54480df8a9--1a11d83b8b024073bf2d78090acb8e3a 35e6390e86ec417f9d33282df2641691 1a11d83b8b024073bf2d78090acb8e3a--35e6390e86ec417f9d33282df2641691 2efaf945d5e741e18ef237d083a735e9 35e6390e86ec417f9d33282df2641691--2efaf945d5e741e18ef237d083a735e9 05f70fa04e394c769b42fc8f149c9d12 2efaf945d5e741e18ef237d083a735e9--05f70fa04e394c769b42fc8f149c9d12 e031ccec7eb34999934e461004034175 X 05f70fa04e394c769b42fc8f149c9d12--e031ccec7eb34999934e461004034175 e031ccec7eb34999934e461004034175--728a96cfa2b84c5e86a111e98487f3ae 12b9e3604e264a59a63eb975fe6b3ded e031ccec7eb34999934e461004034175--12b9e3604e264a59a63eb975fe6b3ded e341bf3157e548ecb6d17ab95f55d210 12b9e3604e264a59a63eb975fe6b3ded--e341bf3157e548ecb6d17ab95f55d210 039266cc1a794be2913ee2ca86a95711 e341bf3157e548ecb6d17ab95f55d210--039266cc1a794be2913ee2ca86a95711 d396decb34cf413bbb47884d49605e11 X 039266cc1a794be2913ee2ca86a95711--d396decb34cf413bbb47884d49605e11 d396decb34cf413bbb47884d49605e11--03a28394fe2d4e6fb218f02443cd388d c042bff6dc3e46499114f398e26d8645 d396decb34cf413bbb47884d49605e11--c042bff6dc3e46499114f398e26d8645 992f174fccdf4c9994a13cb61549a88a c042bff6dc3e46499114f398e26d8645--992f174fccdf4c9994a13cb61549a88a 8100f6c2fc1348d8bd04ce376fd0e669 992f174fccdf4c9994a13cb61549a88a--8100f6c2fc1348d8bd04ce376fd0e669 568ac5b6044e49fa884db1c68f01b732 8100f6c2fc1348d8bd04ce376fd0e669--568ac5b6044e49fa884db1c68f01b732 06f41448180e400b90c7470a9755b97f 568ac5b6044e49fa884db1c68f01b732--06f41448180e400b90c7470a9755b97f fc347baf3fe145738798dd2d9ce41a09 06f41448180e400b90c7470a9755b97f--fc347baf3fe145738798dd2d9ce41a09 e5ed86a078a241bba7fc56a37e489986 X fc347baf3fe145738798dd2d9ce41a09--e5ed86a078a241bba7fc56a37e489986 e5ed86a078a241bba7fc56a37e489986--153ded1cf86043949d106fa4e6d62ccb 1dd199f89c914ee8a5b81a109d5f18df RZ(-1.0*g0) e5ed86a078a241bba7fc56a37e489986--1dd199f89c914ee8a5b81a109d5f18df 36841b6a0d8a4b028e447b32e70a0b38 X 1dd199f89c914ee8a5b81a109d5f18df--36841b6a0d8a4b028e447b32e70a0b38 36841b6a0d8a4b028e447b32e70a0b38--0fa63c69baf74d619f27ddf20750dd47 ccb44f9ebb6a4d62beaa85016fa0a35c 36841b6a0d8a4b028e447b32e70a0b38--ccb44f9ebb6a4d62beaa85016fa0a35c a44fdad6600740ff82757236471bd164 ccb44f9ebb6a4d62beaa85016fa0a35c--a44fdad6600740ff82757236471bd164 70cac9098e2e417e878fc5764bbe22eb X a44fdad6600740ff82757236471bd164--70cac9098e2e417e878fc5764bbe22eb 70cac9098e2e417e878fc5764bbe22eb--1281bdc8e87b4ecb91af6ea8b1a48b47 7f63659f766e4b268bb44765c77c1211 70cac9098e2e417e878fc5764bbe22eb--7f63659f766e4b268bb44765c77c1211 6eedebd35e8546ed92bf766ed34c39d3 7f63659f766e4b268bb44765c77c1211--6eedebd35e8546ed92bf766ed34c39d3 303cd1bdcd7a49b0ac38df4a35527f1e 6eedebd35e8546ed92bf766ed34c39d3--303cd1bdcd7a49b0ac38df4a35527f1e a5c0e9e04b39437fa488e3c629efb66b X 303cd1bdcd7a49b0ac38df4a35527f1e--a5c0e9e04b39437fa488e3c629efb66b a5c0e9e04b39437fa488e3c629efb66b--b7e90b13d646457a88289abf19036bf2 17136d5261864cab9ab810f791e3c2f2 a5c0e9e04b39437fa488e3c629efb66b--17136d5261864cab9ab810f791e3c2f2 71d0c7d0cf614cbfbea0f3b33993b733 X 17136d5261864cab9ab810f791e3c2f2--71d0c7d0cf614cbfbea0f3b33993b733 71d0c7d0cf614cbfbea0f3b33993b733--19816200c80842fa947e0a996e196a5f 4482a64e9ee84afbbd3bad476f2b1126 RZ(-1.0*g0) 71d0c7d0cf614cbfbea0f3b33993b733--4482a64e9ee84afbbd3bad476f2b1126 2c90fd71227444f38cee12a196ba5163 X 4482a64e9ee84afbbd3bad476f2b1126--2c90fd71227444f38cee12a196ba5163 2c90fd71227444f38cee12a196ba5163--21648b1d71b34981bdde33357a7c349d 895a2461283e4452a85f3e5ae6b36819 2c90fd71227444f38cee12a196ba5163--895a2461283e4452a85f3e5ae6b36819 881713e806c14ccf8174d7011140e0cf 895a2461283e4452a85f3e5ae6b36819--881713e806c14ccf8174d7011140e0cf 9dad4ddef436406aae34be2681527f19 881713e806c14ccf8174d7011140e0cf--9dad4ddef436406aae34be2681527f19 1febb0b0cb88443ebd74d5a9568e8bc5 RX(b05) 9dad4ddef436406aae34be2681527f19--1febb0b0cb88443ebd74d5a9568e8bc5 b040a933db6e4e72bef0f8474cd2ed32 1febb0b0cb88443ebd74d5a9568e8bc5--b040a933db6e4e72bef0f8474cd2ed32 8890869e96994a5e9f4aaa7415d9945e b040a933db6e4e72bef0f8474cd2ed32--8890869e96994a5e9f4aaa7415d9945e e98d1fb10e464824afe55eee9c0e45d9 8890869e96994a5e9f4aaa7415d9945e--e98d1fb10e464824afe55eee9c0e45d9 0ce67a49198047c089cd5068e5d035f5 e98d1fb10e464824afe55eee9c0e45d9--0ce67a49198047c089cd5068e5d035f5 f6ecef31c21a4ebb8e1e03d7544b1d2f X 0ce67a49198047c089cd5068e5d035f5--f6ecef31c21a4ebb8e1e03d7544b1d2f f6ecef31c21a4ebb8e1e03d7544b1d2f--4127c91ab4324067b497a134633c42f0 ccc1f4d3cda146be87a197f13b276216 f6ecef31c21a4ebb8e1e03d7544b1d2f--ccc1f4d3cda146be87a197f13b276216 3116eec36f9249da98a4548c94307081 ccc1f4d3cda146be87a197f13b276216--3116eec36f9249da98a4548c94307081 970c61d8271542339587524a5db69810 3116eec36f9249da98a4548c94307081--970c61d8271542339587524a5db69810 a7f3776b2348412cb6e328ed07ea2049 970c61d8271542339587524a5db69810--a7f3776b2348412cb6e328ed07ea2049 ad1cf3f9ef5e4852b9d07f811ed09b88 a7f3776b2348412cb6e328ed07ea2049--ad1cf3f9ef5e4852b9d07f811ed09b88 0ea6c2222e604db1ab8de7fecec773e0 X ad1cf3f9ef5e4852b9d07f811ed09b88--0ea6c2222e604db1ab8de7fecec773e0 0ea6c2222e604db1ab8de7fecec773e0--9d46cd348fa14bc3bd1ce62860f42cef a6b5f40dab5e4b8ab8090e6a627c492b 0ea6c2222e604db1ab8de7fecec773e0--a6b5f40dab5e4b8ab8090e6a627c492b 092b163337e248178a8b1dc339ca7440 a6b5f40dab5e4b8ab8090e6a627c492b--092b163337e248178a8b1dc339ca7440 d8a77aa51c9f4e5da3d54012f22ff514 092b163337e248178a8b1dc339ca7440--d8a77aa51c9f4e5da3d54012f22ff514 59934b9f2fea4ae58ff0b29b2263f186 d8a77aa51c9f4e5da3d54012f22ff514--59934b9f2fea4ae58ff0b29b2263f186 89e562ab34454444b5dccfac31c58cb7 59934b9f2fea4ae58ff0b29b2263f186--89e562ab34454444b5dccfac31c58cb7 2d0ef89bc9c24ce7b43f357a8c482b18 89e562ab34454444b5dccfac31c58cb7--2d0ef89bc9c24ce7b43f357a8c482b18 cf9a65fecce9493e842be77ebb2bb8a6 2d0ef89bc9c24ce7b43f357a8c482b18--cf9a65fecce9493e842be77ebb2bb8a6 bacacf667e81479f807b9d761298bd74 cf9a65fecce9493e842be77ebb2bb8a6--bacacf667e81479f807b9d761298bd74 98d39308dd0240b1a4439f0fac8ecad0 bacacf667e81479f807b9d761298bd74--98d39308dd0240b1a4439f0fac8ecad0 aed3616821fd418888062d247018a1a1 98d39308dd0240b1a4439f0fac8ecad0--aed3616821fd418888062d247018a1a1 2b394539f5f04013835c8b4e2ffaaacf aed3616821fd418888062d247018a1a1--2b394539f5f04013835c8b4e2ffaaacf aa7d2f311eeb4619b1cd02e68072953c 2b394539f5f04013835c8b4e2ffaaacf--aa7d2f311eeb4619b1cd02e68072953c 62d96495a4964dd599e73c759942233b aa7d2f311eeb4619b1cd02e68072953c--62d96495a4964dd599e73c759942233b e5071af9b8264c69ac8da19ceefeb74b 62d96495a4964dd599e73c759942233b--e5071af9b8264c69ac8da19ceefeb74b 237bdbe2508848aaaf8a4f0904f0875e e5071af9b8264c69ac8da19ceefeb74b--237bdbe2508848aaaf8a4f0904f0875e 034d84c865e64aa1960a7583180fa77d X 237bdbe2508848aaaf8a4f0904f0875e--034d84c865e64aa1960a7583180fa77d 034d84c865e64aa1960a7583180fa77d--737f9673c0d442cfb1ec20596ec57f75 932a6a6cec8c4d0bb1dda908c77fb836 RZ(-1.0*g1) 034d84c865e64aa1960a7583180fa77d--932a6a6cec8c4d0bb1dda908c77fb836 2f3eb03092b34a0dbe08f399aa5e29d7 X 932a6a6cec8c4d0bb1dda908c77fb836--2f3eb03092b34a0dbe08f399aa5e29d7 2f3eb03092b34a0dbe08f399aa5e29d7--c4220a92e0684e65967c3b15f27b3262 ee37f48b011a42cd8831f8bb62f43dd6 2f3eb03092b34a0dbe08f399aa5e29d7--ee37f48b011a42cd8831f8bb62f43dd6 b53c265a2ee2457cabc1f07af5c50e73 ee37f48b011a42cd8831f8bb62f43dd6--b53c265a2ee2457cabc1f07af5c50e73 54c6a0b945234f2a9feafc28908655a5 b53c265a2ee2457cabc1f07af5c50e73--54c6a0b945234f2a9feafc28908655a5 42e9f03ab1e441a696756f99c5294076 54c6a0b945234f2a9feafc28908655a5--42e9f03ab1e441a696756f99c5294076 2c54dbffdfca4b899510a55c3350047d 42e9f03ab1e441a696756f99c5294076--2c54dbffdfca4b899510a55c3350047d 708526eaa41341299a9a2e48fedb8b14 2c54dbffdfca4b899510a55c3350047d--708526eaa41341299a9a2e48fedb8b14 e19e9d3b844c4c9d8b12d1a8d52fd6a6 708526eaa41341299a9a2e48fedb8b14--e19e9d3b844c4c9d8b12d1a8d52fd6a6 0e226f79d8634c87ad8278176f53a0b6 e19e9d3b844c4c9d8b12d1a8d52fd6a6--0e226f79d8634c87ad8278176f53a0b6 5984434e47a04314892bfcf27ebae687 0e226f79d8634c87ad8278176f53a0b6--5984434e47a04314892bfcf27ebae687 55dd8947ac42495bb4d05d1640bfeb26 5984434e47a04314892bfcf27ebae687--55dd8947ac42495bb4d05d1640bfeb26 4958b70f60894eeb8dbee268ec6ac0ba 55dd8947ac42495bb4d05d1640bfeb26--4958b70f60894eeb8dbee268ec6ac0ba a4466e68aae14c64b397586d024c0ade 4958b70f60894eeb8dbee268ec6ac0ba--a4466e68aae14c64b397586d024c0ade 2a4fae13cbd94382a22f881fda5cea7c X a4466e68aae14c64b397586d024c0ade--2a4fae13cbd94382a22f881fda5cea7c 2a4fae13cbd94382a22f881fda5cea7c--97daf17cd16240d39d37a30e56da0bf0 d6d6f8f8e9fc4d7691ac58842182713b RZ(-1.0*g1) 2a4fae13cbd94382a22f881fda5cea7c--d6d6f8f8e9fc4d7691ac58842182713b e9a986908d5c41bda7aa407d71565b76 X d6d6f8f8e9fc4d7691ac58842182713b--e9a986908d5c41bda7aa407d71565b76 e9a986908d5c41bda7aa407d71565b76--95d136dd3e7546d8bc4ba835a052f4b1 315b71fed5de424fbb65b0a76c834cab e9a986908d5c41bda7aa407d71565b76--315b71fed5de424fbb65b0a76c834cab 8f768e664274403b8ae49d8db90bbb2c 315b71fed5de424fbb65b0a76c834cab--8f768e664274403b8ae49d8db90bbb2c 6ec52a40eb0541459ad4666c1bb131bc 8f768e664274403b8ae49d8db90bbb2c--6ec52a40eb0541459ad4666c1bb131bc d8efbaf144bb47069d86ec22997a813d 6ec52a40eb0541459ad4666c1bb131bc--d8efbaf144bb47069d86ec22997a813d b1a8b74a3d0041d4b6deafd25b017027 d8efbaf144bb47069d86ec22997a813d--b1a8b74a3d0041d4b6deafd25b017027 fe59f8f3bff841269ed71e9d157f1ec6 b1a8b74a3d0041d4b6deafd25b017027--fe59f8f3bff841269ed71e9d157f1ec6 03bb3d145d8347e6b0f209bc1cca8a72 X fe59f8f3bff841269ed71e9d157f1ec6--03bb3d145d8347e6b0f209bc1cca8a72 03bb3d145d8347e6b0f209bc1cca8a72--8df44e5a5d004adabb1493fc197a3e55 424923504ed24c2b8e591bfc12cea2e7 03bb3d145d8347e6b0f209bc1cca8a72--424923504ed24c2b8e591bfc12cea2e7 93fdf01f16334107be54b49854aa7dc2 424923504ed24c2b8e591bfc12cea2e7--93fdf01f16334107be54b49854aa7dc2 d01dac6d84bd4e96816415b1b0f4a1ce 93fdf01f16334107be54b49854aa7dc2--d01dac6d84bd4e96816415b1b0f4a1ce c1272ca8e8be4966852e51127ef9ae39 d01dac6d84bd4e96816415b1b0f4a1ce--c1272ca8e8be4966852e51127ef9ae39 a4194016ef1b497c9ce681153c0ec31b c1272ca8e8be4966852e51127ef9ae39--a4194016ef1b497c9ce681153c0ec31b d679f2cb03f34b429ec8dbf0f267f181 X a4194016ef1b497c9ce681153c0ec31b--d679f2cb03f34b429ec8dbf0f267f181 d679f2cb03f34b429ec8dbf0f267f181--c77c7ac512be4cd79c2694058bc1d4fc d14a593b04d54ec9827b3630a20eb5da d679f2cb03f34b429ec8dbf0f267f181--d14a593b04d54ec9827b3630a20eb5da dda1a6dc03cc4033852b7b451437ec7d d14a593b04d54ec9827b3630a20eb5da--dda1a6dc03cc4033852b7b451437ec7d 1379310e37524c638c3c1c60cb338b5a dda1a6dc03cc4033852b7b451437ec7d--1379310e37524c638c3c1c60cb338b5a 12989727dc954123808a9e2913e8c44f 1379310e37524c638c3c1c60cb338b5a--12989727dc954123808a9e2913e8c44f f22f27ddd4974b55bcf18befeba14ba1 12989727dc954123808a9e2913e8c44f--f22f27ddd4974b55bcf18befeba14ba1 647b0eaaa71c4fe0b090cbe43afe3aeb f22f27ddd4974b55bcf18befeba14ba1--647b0eaaa71c4fe0b090cbe43afe3aeb ac253635d2994be0aaa7d7b720d4724b 647b0eaaa71c4fe0b090cbe43afe3aeb--ac253635d2994be0aaa7d7b720d4724b 45aa1e2bdb774f97869a19a3b8c9a68d ac253635d2994be0aaa7d7b720d4724b--45aa1e2bdb774f97869a19a3b8c9a68d 6a44b5b4d87146d9bc5f6d963adc698c X 45aa1e2bdb774f97869a19a3b8c9a68d--6a44b5b4d87146d9bc5f6d963adc698c 6a44b5b4d87146d9bc5f6d963adc698c--d6afe04417eb47fea63e3358c6af47bf f2b39e53ebd94c338c612985f7504e25 6a44b5b4d87146d9bc5f6d963adc698c--f2b39e53ebd94c338c612985f7504e25 cba42f5357264c1da78b7bfb2e881499 f2b39e53ebd94c338c612985f7504e25--cba42f5357264c1da78b7bfb2e881499 7ef55ef453e84618819381997599e041 cba42f5357264c1da78b7bfb2e881499--7ef55ef453e84618819381997599e041 63ae9b6dee3e4933b5cd66ad6e51c5f7 X 7ef55ef453e84618819381997599e041--63ae9b6dee3e4933b5cd66ad6e51c5f7 63ae9b6dee3e4933b5cd66ad6e51c5f7--48e91317d1864d89b62d05f1f7549530 db3e0c192fb14f1b943d0031c52bfa0a 63ae9b6dee3e4933b5cd66ad6e51c5f7--db3e0c192fb14f1b943d0031c52bfa0a 37021f02b3084ed5a8e0981631ef25cc db3e0c192fb14f1b943d0031c52bfa0a--37021f02b3084ed5a8e0981631ef25cc 730be77a2a4e4a5aadab6a9410121b5d 37021f02b3084ed5a8e0981631ef25cc--730be77a2a4e4a5aadab6a9410121b5d 9045f72bb3fc4d7e9f82791df6ee351b 730be77a2a4e4a5aadab6a9410121b5d--9045f72bb3fc4d7e9f82791df6ee351b ac5c849429ed4ea8b5ba7920a79cce73 9045f72bb3fc4d7e9f82791df6ee351b--ac5c849429ed4ea8b5ba7920a79cce73 80292113f5ce482c9a918729e36a398d ac5c849429ed4ea8b5ba7920a79cce73--80292113f5ce482c9a918729e36a398d ef8fda5e35644743b9100e8d682d2a20 X 80292113f5ce482c9a918729e36a398d--ef8fda5e35644743b9100e8d682d2a20 ef8fda5e35644743b9100e8d682d2a20--1a77cec3f22e45539555a791e20db4a6 8530864e08924aa2b51bc219cc54db4b RZ(-1.0*g1) ef8fda5e35644743b9100e8d682d2a20--8530864e08924aa2b51bc219cc54db4b e643fabd932c47d8ab7dcd2202ac55af X 8530864e08924aa2b51bc219cc54db4b--e643fabd932c47d8ab7dcd2202ac55af e643fabd932c47d8ab7dcd2202ac55af--e5f6590b91df42ccae0fcf59002326f7 d11c5cd59d024f2fbaba0f2a33328083 e643fabd932c47d8ab7dcd2202ac55af--d11c5cd59d024f2fbaba0f2a33328083 20a7580427ef40dc94e717f9ddfb69ec d11c5cd59d024f2fbaba0f2a33328083--20a7580427ef40dc94e717f9ddfb69ec 3e20bd5d3d2049ce8c750e2626166e81 X 20a7580427ef40dc94e717f9ddfb69ec--3e20bd5d3d2049ce8c750e2626166e81 3e20bd5d3d2049ce8c750e2626166e81--effdd02ef963403ab4c968a9d79fecb6 ba0cf92d408b4aed871537663a687b5f 3e20bd5d3d2049ce8c750e2626166e81--ba0cf92d408b4aed871537663a687b5f f92a1af500fe40c781578214acd15ef1 ba0cf92d408b4aed871537663a687b5f--f92a1af500fe40c781578214acd15ef1 9c40d9c8448b46eb961d56b3ce635c7a f92a1af500fe40c781578214acd15ef1--9c40d9c8448b46eb961d56b3ce635c7a b3e8f2cc90a14c3fa0b3380869964cb1 X 9c40d9c8448b46eb961d56b3ce635c7a--b3e8f2cc90a14c3fa0b3380869964cb1 b3e8f2cc90a14c3fa0b3380869964cb1--9d85ef300b6d4850a3c70899dac08315 4077ac62720a4823897dcfe2c4bcb767 b3e8f2cc90a14c3fa0b3380869964cb1--4077ac62720a4823897dcfe2c4bcb767 52eb4cbdee2b468195bfd29b9e65b479 X 4077ac62720a4823897dcfe2c4bcb767--52eb4cbdee2b468195bfd29b9e65b479 52eb4cbdee2b468195bfd29b9e65b479--60f643a731cd461ba170df7ed881a227 37f9ef4f4412448d9e846b651df5a54c RZ(-1.0*g1) 52eb4cbdee2b468195bfd29b9e65b479--37f9ef4f4412448d9e846b651df5a54c be54a7f3eb8f422f98669e700bd1f4cf X 37f9ef4f4412448d9e846b651df5a54c--be54a7f3eb8f422f98669e700bd1f4cf be54a7f3eb8f422f98669e700bd1f4cf--ec56d3e840e8474bae1606e09336cbed 992e69cbc96c4a8592ddff015de51981 be54a7f3eb8f422f98669e700bd1f4cf--992e69cbc96c4a8592ddff015de51981 9a97cdb7800e423b93d4fb966f47b33f 992e69cbc96c4a8592ddff015de51981--9a97cdb7800e423b93d4fb966f47b33f 84d3de86199243589d4f26c7f8845cf9 9a97cdb7800e423b93d4fb966f47b33f--84d3de86199243589d4f26c7f8845cf9 dad4be6a407a472aaaa7f05ebb4088b3 RX(b15) 84d3de86199243589d4f26c7f8845cf9--dad4be6a407a472aaaa7f05ebb4088b3 dad4be6a407a472aaaa7f05ebb4088b3--5d2d9f7bf8364399a2cc6ee0c389bbd4 5f631e168f3e4150a1b14f382679ec94 dedbf71e1f024782b635549446f0b351 c5c089cc522441eabf8f98794f3b66bd--dedbf71e1f024782b635549446f0b351 2027dfd39b5f4cbf9946a6d166287ae3 7 2731f64b93f04c37a927ce659294b374 dedbf71e1f024782b635549446f0b351--2731f64b93f04c37a927ce659294b374 764ee010a4a04f968dfb6925c806c056 2731f64b93f04c37a927ce659294b374--764ee010a4a04f968dfb6925c806c056 cc31b0817ca34c1db6e6c32b4c5e0dd6 764ee010a4a04f968dfb6925c806c056--cc31b0817ca34c1db6e6c32b4c5e0dd6 fe81d8919f1a480785f5fc08dee050e4 cc31b0817ca34c1db6e6c32b4c5e0dd6--fe81d8919f1a480785f5fc08dee050e4 c67f6da33ae142ab8f427fd331efaef3 X fe81d8919f1a480785f5fc08dee050e4--c67f6da33ae142ab8f427fd331efaef3 c67f6da33ae142ab8f427fd331efaef3--9a079844e4fd42da871f3cbd07159685 dccd83cff041400085ecf526e408f2d7 c67f6da33ae142ab8f427fd331efaef3--dccd83cff041400085ecf526e408f2d7 1e56917378d847379ec109b9005d9f57 dccd83cff041400085ecf526e408f2d7--1e56917378d847379ec109b9005d9f57 a8fdf6eafce941daae66504fae3ed16d 1e56917378d847379ec109b9005d9f57--a8fdf6eafce941daae66504fae3ed16d c8f65b68dec044fd89d510f682732aec X a8fdf6eafce941daae66504fae3ed16d--c8f65b68dec044fd89d510f682732aec c8f65b68dec044fd89d510f682732aec--0b8ea63eb778464db4018e1e9aa689f3 9f6dcd34c3ef4e729a5fef403f54e0f5 c8f65b68dec044fd89d510f682732aec--9f6dcd34c3ef4e729a5fef403f54e0f5 2260f4f505ec4064b437cca03d844d60 9f6dcd34c3ef4e729a5fef403f54e0f5--2260f4f505ec4064b437cca03d844d60 a18dac523ad74dd38845f2e04ac43829 2260f4f505ec4064b437cca03d844d60--a18dac523ad74dd38845f2e04ac43829 aec830b40efc44fba71e53dfc7d1a959 a18dac523ad74dd38845f2e04ac43829--aec830b40efc44fba71e53dfc7d1a959 f5466e8c797244eb9194d62f763361cb aec830b40efc44fba71e53dfc7d1a959--f5466e8c797244eb9194d62f763361cb 5d7a35ddcbef4aa1bf0b7a62d9b2287a f5466e8c797244eb9194d62f763361cb--5d7a35ddcbef4aa1bf0b7a62d9b2287a 46993c0d2d4e4b7d9c2b9c1c22d0be9f 5d7a35ddcbef4aa1bf0b7a62d9b2287a--46993c0d2d4e4b7d9c2b9c1c22d0be9f 0a691e19eb964ac8b336fbe945010404 46993c0d2d4e4b7d9c2b9c1c22d0be9f--0a691e19eb964ac8b336fbe945010404 bec4ae66a7364f44862b374372b2aa57 0a691e19eb964ac8b336fbe945010404--bec4ae66a7364f44862b374372b2aa57 d001a63b651c4bc1b8bb62420225ff4e bec4ae66a7364f44862b374372b2aa57--d001a63b651c4bc1b8bb62420225ff4e 0a9ecb8c8a57447c88e4e704a22eaae8 d001a63b651c4bc1b8bb62420225ff4e--0a9ecb8c8a57447c88e4e704a22eaae8 6b5bc4f7089a4d8b9f23d48a0edd208b 0a9ecb8c8a57447c88e4e704a22eaae8--6b5bc4f7089a4d8b9f23d48a0edd208b 9f0175c5f4c14114b8725411565363be 6b5bc4f7089a4d8b9f23d48a0edd208b--9f0175c5f4c14114b8725411565363be e4c7f233de7c47a49932eaeac348871b 9f0175c5f4c14114b8725411565363be--e4c7f233de7c47a49932eaeac348871b 35a4d0019e99488287c259689f21b507 e4c7f233de7c47a49932eaeac348871b--35a4d0019e99488287c259689f21b507 273e79b1c13d4a8ea45854950749d86d 35a4d0019e99488287c259689f21b507--273e79b1c13d4a8ea45854950749d86d 9b30d5a8615a4ef3baf8033ef6ec6c46 273e79b1c13d4a8ea45854950749d86d--9b30d5a8615a4ef3baf8033ef6ec6c46 07dc5dc537604349a77f6edd01ecaf45 9b30d5a8615a4ef3baf8033ef6ec6c46--07dc5dc537604349a77f6edd01ecaf45 95d56dec50424cca971ec918de80050e 07dc5dc537604349a77f6edd01ecaf45--95d56dec50424cca971ec918de80050e 04dc0465bd5747329fcdfa29521dc434 95d56dec50424cca971ec918de80050e--04dc0465bd5747329fcdfa29521dc434 dcb92014476a4c0fae45f4621d3aceaf 04dc0465bd5747329fcdfa29521dc434--dcb92014476a4c0fae45f4621d3aceaf 6885d3030aa04a05ab62e2701f53f73b dcb92014476a4c0fae45f4621d3aceaf--6885d3030aa04a05ab62e2701f53f73b 02b54dfb4dbe46eda315c938bbee1486 6885d3030aa04a05ab62e2701f53f73b--02b54dfb4dbe46eda315c938bbee1486 1a807c62d3764262bdd28ac83d734d58 02b54dfb4dbe46eda315c938bbee1486--1a807c62d3764262bdd28ac83d734d58 c6a464a1b94b46c5ab85b08a2757a0c3 1a807c62d3764262bdd28ac83d734d58--c6a464a1b94b46c5ab85b08a2757a0c3 9004c057a98e438d85803bfad3bd9576 c6a464a1b94b46c5ab85b08a2757a0c3--9004c057a98e438d85803bfad3bd9576 cd8fbad7501d4b759d50a05a5895eabc 9004c057a98e438d85803bfad3bd9576--cd8fbad7501d4b759d50a05a5895eabc cf63597be50a4cffaf48220930259ccc cd8fbad7501d4b759d50a05a5895eabc--cf63597be50a4cffaf48220930259ccc 014a855ade5047929e70498184e1cde9 cf63597be50a4cffaf48220930259ccc--014a855ade5047929e70498184e1cde9 066e406ab9ef4a34a8d0fe40806d456e 014a855ade5047929e70498184e1cde9--066e406ab9ef4a34a8d0fe40806d456e 1a9c7ad4eb044646924e86059d6a672b 066e406ab9ef4a34a8d0fe40806d456e--1a9c7ad4eb044646924e86059d6a672b aff34656bc83460da96a30ead5f3f2b7 1a9c7ad4eb044646924e86059d6a672b--aff34656bc83460da96a30ead5f3f2b7 2e6c527e5c4b4dc8b1f7d9e148d6a2d9 aff34656bc83460da96a30ead5f3f2b7--2e6c527e5c4b4dc8b1f7d9e148d6a2d9 05710b8b835b4a9d9695dae91610c532 2e6c527e5c4b4dc8b1f7d9e148d6a2d9--05710b8b835b4a9d9695dae91610c532 b232db395d084f34ab565b3bcc52d089 05710b8b835b4a9d9695dae91610c532--b232db395d084f34ab565b3bcc52d089 17025ae5d0be4fadb5f6a2d64355bacf b232db395d084f34ab565b3bcc52d089--17025ae5d0be4fadb5f6a2d64355bacf 5e2bfec5e8674fd5bcc3c79a20e03b43 17025ae5d0be4fadb5f6a2d64355bacf--5e2bfec5e8674fd5bcc3c79a20e03b43 f9a5f78e206f41af81c53708cc18a096 5e2bfec5e8674fd5bcc3c79a20e03b43--f9a5f78e206f41af81c53708cc18a096 a2ac9a5976e5484ebd4e18c4d3e76b75 f9a5f78e206f41af81c53708cc18a096--a2ac9a5976e5484ebd4e18c4d3e76b75 5f6e2936e65f4f57a800f1e1c42a21cc a2ac9a5976e5484ebd4e18c4d3e76b75--5f6e2936e65f4f57a800f1e1c42a21cc e6d04ff7f4cf496d8b94699798a358e2 5f6e2936e65f4f57a800f1e1c42a21cc--e6d04ff7f4cf496d8b94699798a358e2 a6823a71224a4000b68ab86de495fedf X e6d04ff7f4cf496d8b94699798a358e2--a6823a71224a4000b68ab86de495fedf a6823a71224a4000b68ab86de495fedf--e8ffb272d562489eb11ca6c2749dfe9c a00e3784cc5245fb817209028d04518d a6823a71224a4000b68ab86de495fedf--a00e3784cc5245fb817209028d04518d 050f479d162d4c6cb170583f368ae119 a00e3784cc5245fb817209028d04518d--050f479d162d4c6cb170583f368ae119 52ca0fc02f7143f48a48fd8ebe74a649 050f479d162d4c6cb170583f368ae119--52ca0fc02f7143f48a48fd8ebe74a649 e897de659a64448ba058954782e6bece X 52ca0fc02f7143f48a48fd8ebe74a649--e897de659a64448ba058954782e6bece e897de659a64448ba058954782e6bece--b1641d1caf2c49c39a42ede98cea6135 c5c2d04dde754c6b9a727ea4183ae1b3 e897de659a64448ba058954782e6bece--c5c2d04dde754c6b9a727ea4183ae1b3 cb472e7e3a8142eda637bd3e8140f54b c5c2d04dde754c6b9a727ea4183ae1b3--cb472e7e3a8142eda637bd3e8140f54b 2d1c4954bf3d413c909a9bd1fcfbb456 cb472e7e3a8142eda637bd3e8140f54b--2d1c4954bf3d413c909a9bd1fcfbb456 cbf63af2fa3d4ac096627515f92fc78f 2d1c4954bf3d413c909a9bd1fcfbb456--cbf63af2fa3d4ac096627515f92fc78f 7a23f9d0706b4ef794df90dc793d8978 cbf63af2fa3d4ac096627515f92fc78f--7a23f9d0706b4ef794df90dc793d8978 fe3218a842e24ac49f110e6228f9b24e 7a23f9d0706b4ef794df90dc793d8978--fe3218a842e24ac49f110e6228f9b24e f7eb579a26b14f519c0d0be082faad55 fe3218a842e24ac49f110e6228f9b24e--f7eb579a26b14f519c0d0be082faad55 b51343a3b1664fdfb15bdc1b4f2a1d3b f7eb579a26b14f519c0d0be082faad55--b51343a3b1664fdfb15bdc1b4f2a1d3b 1c9747d952ca439c92b485650f2a1061 b51343a3b1664fdfb15bdc1b4f2a1d3b--1c9747d952ca439c92b485650f2a1061 ec75ee57b2274824860c423decad50b9 1c9747d952ca439c92b485650f2a1061--ec75ee57b2274824860c423decad50b9 12f74704c367466da2b57e041c4b79a5 X ec75ee57b2274824860c423decad50b9--12f74704c367466da2b57e041c4b79a5 12f74704c367466da2b57e041c4b79a5--12b9e3604e264a59a63eb975fe6b3ded c460deab4d5e42b7b945dcfe5a2e2821 RZ(-1.0*g0) 12f74704c367466da2b57e041c4b79a5--c460deab4d5e42b7b945dcfe5a2e2821 9fda073b043443b7994792d590eae9a0 X c460deab4d5e42b7b945dcfe5a2e2821--9fda073b043443b7994792d590eae9a0 9fda073b043443b7994792d590eae9a0--039266cc1a794be2913ee2ca86a95711 6aaf5f3b62e64c76a35a7fa9a0e33be6 9fda073b043443b7994792d590eae9a0--6aaf5f3b62e64c76a35a7fa9a0e33be6 f7232c98ab2f461e9ecda0f2fc49d3a3 6aaf5f3b62e64c76a35a7fa9a0e33be6--f7232c98ab2f461e9ecda0f2fc49d3a3 af223784dfe34e4b9e68ee9522ac3f60 f7232c98ab2f461e9ecda0f2fc49d3a3--af223784dfe34e4b9e68ee9522ac3f60 cbbbcf89e5ad4959a42140807df7421e af223784dfe34e4b9e68ee9522ac3f60--cbbbcf89e5ad4959a42140807df7421e 2b8612a97d7143f280d06a167ed711c8 cbbbcf89e5ad4959a42140807df7421e--2b8612a97d7143f280d06a167ed711c8 6ed39f8af20e4f9a86c01a2e09ca9a8d 2b8612a97d7143f280d06a167ed711c8--6ed39f8af20e4f9a86c01a2e09ca9a8d 040e78a736b34729859d6c34d43b2983 6ed39f8af20e4f9a86c01a2e09ca9a8d--040e78a736b34729859d6c34d43b2983 432878c6136b456db92f25109a1c1cbd 040e78a736b34729859d6c34d43b2983--432878c6136b456db92f25109a1c1cbd 1c11867c4bae401cbd9b20b127e685e8 432878c6136b456db92f25109a1c1cbd--1c11867c4bae401cbd9b20b127e685e8 dd22651fb4a74171b39694b2225c04e9 1c11867c4bae401cbd9b20b127e685e8--dd22651fb4a74171b39694b2225c04e9 11794b7d7cdc45f19f7e850491d53a12 dd22651fb4a74171b39694b2225c04e9--11794b7d7cdc45f19f7e850491d53a12 12e6860581244e8496ba0f085310ca56 11794b7d7cdc45f19f7e850491d53a12--12e6860581244e8496ba0f085310ca56 e4777a58fbc94ad9a4fca8fbd2b6cc12 12e6860581244e8496ba0f085310ca56--e4777a58fbc94ad9a4fca8fbd2b6cc12 53864519203045e5861d415e9dbff323 X e4777a58fbc94ad9a4fca8fbd2b6cc12--53864519203045e5861d415e9dbff323 53864519203045e5861d415e9dbff323--7f63659f766e4b268bb44765c77c1211 4ccd811f406b48f89b5b33711077f3b8 RZ(-1.0*g0) 53864519203045e5861d415e9dbff323--4ccd811f406b48f89b5b33711077f3b8 3518fe12b9034a53b91a251e57f313db X 4ccd811f406b48f89b5b33711077f3b8--3518fe12b9034a53b91a251e57f313db 3518fe12b9034a53b91a251e57f313db--303cd1bdcd7a49b0ac38df4a35527f1e 1f01480d913141749466e6218eda1380 3518fe12b9034a53b91a251e57f313db--1f01480d913141749466e6218eda1380 45313bd5c0c24435b04f69975188e764 1f01480d913141749466e6218eda1380--45313bd5c0c24435b04f69975188e764 1fe37f03196f4306a1593f5faa1c16ab 45313bd5c0c24435b04f69975188e764--1fe37f03196f4306a1593f5faa1c16ab ea10e8333fe44470883d070e40b1a7cd 1fe37f03196f4306a1593f5faa1c16ab--ea10e8333fe44470883d070e40b1a7cd 94203093ab56419085d3706487adfef5 ea10e8333fe44470883d070e40b1a7cd--94203093ab56419085d3706487adfef5 eaa61d7a781740ba84496a53ceca32cb 94203093ab56419085d3706487adfef5--eaa61d7a781740ba84496a53ceca32cb 61bddbeccae943c18b21b7493b82e0a1 eaa61d7a781740ba84496a53ceca32cb--61bddbeccae943c18b21b7493b82e0a1 0e184e6accce4fc3845c40531e4f68c1 61bddbeccae943c18b21b7493b82e0a1--0e184e6accce4fc3845c40531e4f68c1 f16afe138aec48108f306d4adfcbcf1f RX(b06) 0e184e6accce4fc3845c40531e4f68c1--f16afe138aec48108f306d4adfcbcf1f 7785c6ee749947e2b0338823526fa0bf f16afe138aec48108f306d4adfcbcf1f--7785c6ee749947e2b0338823526fa0bf 71b4fd138b1445b29ded03ad2600b50a 7785c6ee749947e2b0338823526fa0bf--71b4fd138b1445b29ded03ad2600b50a 7f9c072e2ab54bc29d6db76e72459aa8 71b4fd138b1445b29ded03ad2600b50a--7f9c072e2ab54bc29d6db76e72459aa8 4bd225e1ae62417bb677df603771c064 7f9c072e2ab54bc29d6db76e72459aa8--4bd225e1ae62417bb677df603771c064 60b19f44df2d4e8f8253da45c589783f 4bd225e1ae62417bb677df603771c064--60b19f44df2d4e8f8253da45c589783f 4f14e08580474909af88398d046e7721 X 60b19f44df2d4e8f8253da45c589783f--4f14e08580474909af88398d046e7721 4f14e08580474909af88398d046e7721--ccc1f4d3cda146be87a197f13b276216 88458c75d8ba4ed880cb8311ec69c008 4f14e08580474909af88398d046e7721--88458c75d8ba4ed880cb8311ec69c008 1e1b0f661d9a4f2cb3dc5bed2fa560df 88458c75d8ba4ed880cb8311ec69c008--1e1b0f661d9a4f2cb3dc5bed2fa560df bf905dcedf624e71b3a9449f3ed83ff8 1e1b0f661d9a4f2cb3dc5bed2fa560df--bf905dcedf624e71b3a9449f3ed83ff8 bf546b2040d84dbe957a0484fa817100 X bf905dcedf624e71b3a9449f3ed83ff8--bf546b2040d84dbe957a0484fa817100 bf546b2040d84dbe957a0484fa817100--ad1cf3f9ef5e4852b9d07f811ed09b88 438b7af7519a473bb75ac7d7d91c948e bf546b2040d84dbe957a0484fa817100--438b7af7519a473bb75ac7d7d91c948e 462d3cda92cb405a8e3632c9c9fe7ecd 438b7af7519a473bb75ac7d7d91c948e--462d3cda92cb405a8e3632c9c9fe7ecd 3097f29201eb48d6a4a60afdea3c8303 462d3cda92cb405a8e3632c9c9fe7ecd--3097f29201eb48d6a4a60afdea3c8303 7b9bdf3b1ae847a49d58853496927b3d 3097f29201eb48d6a4a60afdea3c8303--7b9bdf3b1ae847a49d58853496927b3d 17e6cd51033c43fc9ac307a4654dd6ef 7b9bdf3b1ae847a49d58853496927b3d--17e6cd51033c43fc9ac307a4654dd6ef 066aa4cdfd1c4d1c925715b05fa15ab0 17e6cd51033c43fc9ac307a4654dd6ef--066aa4cdfd1c4d1c925715b05fa15ab0 d0d359d47e904103897b00fb142be8c8 066aa4cdfd1c4d1c925715b05fa15ab0--d0d359d47e904103897b00fb142be8c8 9a51bc3566d44d5dbcb7251434082085 d0d359d47e904103897b00fb142be8c8--9a51bc3566d44d5dbcb7251434082085 fea1ce7db91e466d804a487a0c4e8421 9a51bc3566d44d5dbcb7251434082085--fea1ce7db91e466d804a487a0c4e8421 cc69b65681bb4e8485162b62960c749d fea1ce7db91e466d804a487a0c4e8421--cc69b65681bb4e8485162b62960c749d bc1aac54320a46729dbef3e17cdd0603 cc69b65681bb4e8485162b62960c749d--bc1aac54320a46729dbef3e17cdd0603 8fd45815946e40a096c223ccf3e7871d bc1aac54320a46729dbef3e17cdd0603--8fd45815946e40a096c223ccf3e7871d c4dc65c4854b4d75b0b92cb30561e729 8fd45815946e40a096c223ccf3e7871d--c4dc65c4854b4d75b0b92cb30561e729 e893c6df9f6a4a018213b6bcac28c91e c4dc65c4854b4d75b0b92cb30561e729--e893c6df9f6a4a018213b6bcac28c91e 875569d0baed49159d6649cfa0216ca3 e893c6df9f6a4a018213b6bcac28c91e--875569d0baed49159d6649cfa0216ca3 a267018f409249fe9bb6da507970a873 875569d0baed49159d6649cfa0216ca3--a267018f409249fe9bb6da507970a873 851430632af249849d9748f591dca3cf a267018f409249fe9bb6da507970a873--851430632af249849d9748f591dca3cf f4d335c018b54b71b33b38c191ee33e3 851430632af249849d9748f591dca3cf--f4d335c018b54b71b33b38c191ee33e3 56c6a32f4cb245539420a34f17691811 f4d335c018b54b71b33b38c191ee33e3--56c6a32f4cb245539420a34f17691811 3338ee3751444d67b3638250bc8b5106 56c6a32f4cb245539420a34f17691811--3338ee3751444d67b3638250bc8b5106 5bd0c74f1b8c4010bc4f430ba631edaa 3338ee3751444d67b3638250bc8b5106--5bd0c74f1b8c4010bc4f430ba631edaa b9d0c6ccc6614fb1bc664ddcdcddd659 5bd0c74f1b8c4010bc4f430ba631edaa--b9d0c6ccc6614fb1bc664ddcdcddd659 e78d5d5e43ce4a8987f69b3d4699f08e b9d0c6ccc6614fb1bc664ddcdcddd659--e78d5d5e43ce4a8987f69b3d4699f08e 074fef9062e24623a491cfe359e4ce53 e78d5d5e43ce4a8987f69b3d4699f08e--074fef9062e24623a491cfe359e4ce53 f7ad2428f59a4e8a935999b8edc7b736 074fef9062e24623a491cfe359e4ce53--f7ad2428f59a4e8a935999b8edc7b736 231056505e124cb8842521b95443d30c f7ad2428f59a4e8a935999b8edc7b736--231056505e124cb8842521b95443d30c 962653fba8fe4af6966cd685caa36aff 231056505e124cb8842521b95443d30c--962653fba8fe4af6966cd685caa36aff 84f9c74fe15748d6aa69b530719eb9f3 962653fba8fe4af6966cd685caa36aff--84f9c74fe15748d6aa69b530719eb9f3 9a3cd792f8c2490682ca571637fab58a 84f9c74fe15748d6aa69b530719eb9f3--9a3cd792f8c2490682ca571637fab58a 84b22dff470e4e4d9050a51ac89b82c9 9a3cd792f8c2490682ca571637fab58a--84b22dff470e4e4d9050a51ac89b82c9 a5c73b6ba0f844bb8258e9249de0733f 84b22dff470e4e4d9050a51ac89b82c9--a5c73b6ba0f844bb8258e9249de0733f 43ef27c89d084e43891876efcdc4d564 a5c73b6ba0f844bb8258e9249de0733f--43ef27c89d084e43891876efcdc4d564 a409421a6636469bab2ae71254b0e60b 43ef27c89d084e43891876efcdc4d564--a409421a6636469bab2ae71254b0e60b 833af871b5af4a7f9febdc0c39e8b8c0 a409421a6636469bab2ae71254b0e60b--833af871b5af4a7f9febdc0c39e8b8c0 acbf7d8c525648aa9bbc74d99a12d429 833af871b5af4a7f9febdc0c39e8b8c0--acbf7d8c525648aa9bbc74d99a12d429 52be100ed3c549b58ae666e218b81fc2 acbf7d8c525648aa9bbc74d99a12d429--52be100ed3c549b58ae666e218b81fc2 2061a2ec30fe4531ad5217e7e9f8a545 52be100ed3c549b58ae666e218b81fc2--2061a2ec30fe4531ad5217e7e9f8a545 a8328844fedd4aae89e87d6abe7705bf 2061a2ec30fe4531ad5217e7e9f8a545--a8328844fedd4aae89e87d6abe7705bf 140f9cd5955f424dbf924745b677d04a a8328844fedd4aae89e87d6abe7705bf--140f9cd5955f424dbf924745b677d04a 370c89981cd94b85a171565ea83094e1 140f9cd5955f424dbf924745b677d04a--370c89981cd94b85a171565ea83094e1 9c199cfa1df2433890cb12726d74a9da 370c89981cd94b85a171565ea83094e1--9c199cfa1df2433890cb12726d74a9da 4fdfb478f2354c09b9556648dcd356e0 X 9c199cfa1df2433890cb12726d74a9da--4fdfb478f2354c09b9556648dcd356e0 4fdfb478f2354c09b9556648dcd356e0--424923504ed24c2b8e591bfc12cea2e7 eb471f9da90440cfb83e78195b1a2f28 4fdfb478f2354c09b9556648dcd356e0--eb471f9da90440cfb83e78195b1a2f28 c711ed428e6c4960a39af53a0f5d9bd5 eb471f9da90440cfb83e78195b1a2f28--c711ed428e6c4960a39af53a0f5d9bd5 c9d750d7acd7430ea0121c784f188cc0 c711ed428e6c4960a39af53a0f5d9bd5--c9d750d7acd7430ea0121c784f188cc0 86e95573820a4b9a8c81c437a95f3fa5 X c9d750d7acd7430ea0121c784f188cc0--86e95573820a4b9a8c81c437a95f3fa5 86e95573820a4b9a8c81c437a95f3fa5--a4194016ef1b497c9ce681153c0ec31b 8c11826c9b664c80aef15754b2145650 86e95573820a4b9a8c81c437a95f3fa5--8c11826c9b664c80aef15754b2145650 589920c56caa41a3b80e08968564f921 8c11826c9b664c80aef15754b2145650--589920c56caa41a3b80e08968564f921 02533e3efdb44ec481a87ac0e7308666 589920c56caa41a3b80e08968564f921--02533e3efdb44ec481a87ac0e7308666 4e9af77fc50d4ac09f53db1d90e73238 02533e3efdb44ec481a87ac0e7308666--4e9af77fc50d4ac09f53db1d90e73238 aa88d3da2eeb45d0aa8e8211681bdcf3 4e9af77fc50d4ac09f53db1d90e73238--aa88d3da2eeb45d0aa8e8211681bdcf3 8a4428f3a98340bb917af9c79b74306b aa88d3da2eeb45d0aa8e8211681bdcf3--8a4428f3a98340bb917af9c79b74306b abd3acda6cc74b30af7484e67f971dab 8a4428f3a98340bb917af9c79b74306b--abd3acda6cc74b30af7484e67f971dab 1b567d5fc0ca46709fe1b81ca4d26a78 abd3acda6cc74b30af7484e67f971dab--1b567d5fc0ca46709fe1b81ca4d26a78 2fb6f89d5b454b42b9ee70b57e4aeeaa 1b567d5fc0ca46709fe1b81ca4d26a78--2fb6f89d5b454b42b9ee70b57e4aeeaa 76b5d8812f4c4b3c95009d099a80b188 2fb6f89d5b454b42b9ee70b57e4aeeaa--76b5d8812f4c4b3c95009d099a80b188 f88b1740fa2043889accee0f5f6ecb93 X 76b5d8812f4c4b3c95009d099a80b188--f88b1740fa2043889accee0f5f6ecb93 f88b1740fa2043889accee0f5f6ecb93--f2b39e53ebd94c338c612985f7504e25 6c130ff769194a339eaa7a88a5ece470 RZ(-1.0*g1) f88b1740fa2043889accee0f5f6ecb93--6c130ff769194a339eaa7a88a5ece470 26f0febeb34c4c6a877ffa4d1db6ce2a X 6c130ff769194a339eaa7a88a5ece470--26f0febeb34c4c6a877ffa4d1db6ce2a 26f0febeb34c4c6a877ffa4d1db6ce2a--7ef55ef453e84618819381997599e041 10047039f16643a6abf7c6d87a50cd12 26f0febeb34c4c6a877ffa4d1db6ce2a--10047039f16643a6abf7c6d87a50cd12 a6df4d9d33ae46e4ad284f882883a130 10047039f16643a6abf7c6d87a50cd12--a6df4d9d33ae46e4ad284f882883a130 12a97ee10eaf4a068edfb77d7f229d86 a6df4d9d33ae46e4ad284f882883a130--12a97ee10eaf4a068edfb77d7f229d86 ad94f2ac8de3451bb13f6e6869404c05 12a97ee10eaf4a068edfb77d7f229d86--ad94f2ac8de3451bb13f6e6869404c05 252f56d15e6f4bfd9db15defc9d9e78f ad94f2ac8de3451bb13f6e6869404c05--252f56d15e6f4bfd9db15defc9d9e78f 27ff03f34b154b1aa0d2e03ff23ce398 252f56d15e6f4bfd9db15defc9d9e78f--27ff03f34b154b1aa0d2e03ff23ce398 b87fbc241bf243a5bc98602395395f06 27ff03f34b154b1aa0d2e03ff23ce398--b87fbc241bf243a5bc98602395395f06 8d99233165a64ec0b515cbf1915123d9 b87fbc241bf243a5bc98602395395f06--8d99233165a64ec0b515cbf1915123d9 b5c348f4abbc42fbb28e0c01b2561d95 8d99233165a64ec0b515cbf1915123d9--b5c348f4abbc42fbb28e0c01b2561d95 c4e3cf4ff2a546d5bf8195e7644aaf5c b5c348f4abbc42fbb28e0c01b2561d95--c4e3cf4ff2a546d5bf8195e7644aaf5c 9825faa0615f40f2a28f2991dfbe6c90 c4e3cf4ff2a546d5bf8195e7644aaf5c--9825faa0615f40f2a28f2991dfbe6c90 bd1504d6a12b4ffc89dd7d661eb59179 9825faa0615f40f2a28f2991dfbe6c90--bd1504d6a12b4ffc89dd7d661eb59179 49c7372ee3ff426e84b5722c1eab3179 bd1504d6a12b4ffc89dd7d661eb59179--49c7372ee3ff426e84b5722c1eab3179 e65661717fb74070ac3f2ee1494652dd X 49c7372ee3ff426e84b5722c1eab3179--e65661717fb74070ac3f2ee1494652dd e65661717fb74070ac3f2ee1494652dd--ba0cf92d408b4aed871537663a687b5f 3b5026f622724f41ba7430fc77c516fd RZ(-1.0*g1) e65661717fb74070ac3f2ee1494652dd--3b5026f622724f41ba7430fc77c516fd 5c73aa79a2914418bbd17d1f32fd972b X 3b5026f622724f41ba7430fc77c516fd--5c73aa79a2914418bbd17d1f32fd972b 5c73aa79a2914418bbd17d1f32fd972b--9c40d9c8448b46eb961d56b3ce635c7a 8cde8b1a0b014e3da313703fdf72b59a 5c73aa79a2914418bbd17d1f32fd972b--8cde8b1a0b014e3da313703fdf72b59a 3c61b0701edd4fe0a7eae67af366be4a 8cde8b1a0b014e3da313703fdf72b59a--3c61b0701edd4fe0a7eae67af366be4a 7def864103d54b4c8a9afade755aa1a4 3c61b0701edd4fe0a7eae67af366be4a--7def864103d54b4c8a9afade755aa1a4 7ee14912d08942789327f0e764386467 7def864103d54b4c8a9afade755aa1a4--7ee14912d08942789327f0e764386467 c73793c152a84fc2adcd2db344a7cec7 7ee14912d08942789327f0e764386467--c73793c152a84fc2adcd2db344a7cec7 662c85fbe18c47ce963aa30b2f09dc45 c73793c152a84fc2adcd2db344a7cec7--662c85fbe18c47ce963aa30b2f09dc45 ca989d5de47943488b138ecf2540f456 662c85fbe18c47ce963aa30b2f09dc45--ca989d5de47943488b138ecf2540f456 5968ea2148b144ababb376ce7bc0127a ca989d5de47943488b138ecf2540f456--5968ea2148b144ababb376ce7bc0127a 20ee34d9ab274ad0b618541ba75a072c RX(b16) 5968ea2148b144ababb376ce7bc0127a--20ee34d9ab274ad0b618541ba75a072c 20ee34d9ab274ad0b618541ba75a072c--5f631e168f3e4150a1b14f382679ec94 080aa0114186400cb6fcb2323ec4905c ce66b24fb71a4248a1beb9bf094f8de1 2027dfd39b5f4cbf9946a6d166287ae3--ce66b24fb71a4248a1beb9bf094f8de1 30d941227b2c46458d403765bc1a36f3 ce66b24fb71a4248a1beb9bf094f8de1--30d941227b2c46458d403765bc1a36f3 74fa8176d4cf4222a4de6b5d2dbb762d 30d941227b2c46458d403765bc1a36f3--74fa8176d4cf4222a4de6b5d2dbb762d 183989918cd8434eb6aa3fc1d2b8351f 74fa8176d4cf4222a4de6b5d2dbb762d--183989918cd8434eb6aa3fc1d2b8351f d63bcdfc4f874d98a9f2a6de812db787 183989918cd8434eb6aa3fc1d2b8351f--d63bcdfc4f874d98a9f2a6de812db787 2dff94bc6a594d598f3d7ca3875058fd d63bcdfc4f874d98a9f2a6de812db787--2dff94bc6a594d598f3d7ca3875058fd cb4f4d9c83924e92b3b1984c0e4c8ed9 X 2dff94bc6a594d598f3d7ca3875058fd--cb4f4d9c83924e92b3b1984c0e4c8ed9 cb4f4d9c83924e92b3b1984c0e4c8ed9--dccd83cff041400085ecf526e408f2d7 19d7b3e63107435d8d9e4e25ba01ed4a RZ(1.0*g0) cb4f4d9c83924e92b3b1984c0e4c8ed9--19d7b3e63107435d8d9e4e25ba01ed4a f969dbe581044bfca15cbf212cfcc372 X 19d7b3e63107435d8d9e4e25ba01ed4a--f969dbe581044bfca15cbf212cfcc372 f969dbe581044bfca15cbf212cfcc372--a8fdf6eafce941daae66504fae3ed16d cb61925edc9a466887eedaa9a237e36c f969dbe581044bfca15cbf212cfcc372--cb61925edc9a466887eedaa9a237e36c e3b52aeefbcc49f5affc26730611723e cb61925edc9a466887eedaa9a237e36c--e3b52aeefbcc49f5affc26730611723e 96edb8ed642b44a08dab42e8c2b39ca9 e3b52aeefbcc49f5affc26730611723e--96edb8ed642b44a08dab42e8c2b39ca9 ab32ca0fcec64dae867e246cc573421a 96edb8ed642b44a08dab42e8c2b39ca9--ab32ca0fcec64dae867e246cc573421a 7f660d389733488f8818f2b46fe88908 ab32ca0fcec64dae867e246cc573421a--7f660d389733488f8818f2b46fe88908 214630eba20c441ca0d0b78fe076313c 7f660d389733488f8818f2b46fe88908--214630eba20c441ca0d0b78fe076313c 4b58e4b6d91e4ac99861764992c50af1 214630eba20c441ca0d0b78fe076313c--4b58e4b6d91e4ac99861764992c50af1 1ad207f359e34aafb7e38e1d69cf8aad 4b58e4b6d91e4ac99861764992c50af1--1ad207f359e34aafb7e38e1d69cf8aad 22ba903229be42e789091d39d32e587f 1ad207f359e34aafb7e38e1d69cf8aad--22ba903229be42e789091d39d32e587f f8e7295e9092434c9b7a79aaef8112ba 22ba903229be42e789091d39d32e587f--f8e7295e9092434c9b7a79aaef8112ba ce2bc5aecd374ab098d3bea2ba67092a f8e7295e9092434c9b7a79aaef8112ba--ce2bc5aecd374ab098d3bea2ba67092a 7ecd5b001a9a4cfd81216ceaa5d006f3 ce2bc5aecd374ab098d3bea2ba67092a--7ecd5b001a9a4cfd81216ceaa5d006f3 779f2ce312cc481188e49f80f04f9efe 7ecd5b001a9a4cfd81216ceaa5d006f3--779f2ce312cc481188e49f80f04f9efe 6a931ab36b3f414bad758e2bfab3838b 779f2ce312cc481188e49f80f04f9efe--6a931ab36b3f414bad758e2bfab3838b 6a785e5047b246f0a57bf093e635050b 6a931ab36b3f414bad758e2bfab3838b--6a785e5047b246f0a57bf093e635050b 50e46a7c907b4cf48a97a8b3a8a38e0d 6a785e5047b246f0a57bf093e635050b--50e46a7c907b4cf48a97a8b3a8a38e0d 2972558253f0456f99467ab4117ab230 50e46a7c907b4cf48a97a8b3a8a38e0d--2972558253f0456f99467ab4117ab230 216b49f729d541ec9eb7166c16c99ad4 2972558253f0456f99467ab4117ab230--216b49f729d541ec9eb7166c16c99ad4 c5b8d84988ff4143bc5cf05758f724bc 216b49f729d541ec9eb7166c16c99ad4--c5b8d84988ff4143bc5cf05758f724bc b692c3086a014aba9667ad287fa08e1c c5b8d84988ff4143bc5cf05758f724bc--b692c3086a014aba9667ad287fa08e1c 0be062501df74612934c9d0d5f802907 b692c3086a014aba9667ad287fa08e1c--0be062501df74612934c9d0d5f802907 8a1a0acdf85d41b9862c38bf88b46941 0be062501df74612934c9d0d5f802907--8a1a0acdf85d41b9862c38bf88b46941 3beb6637614c44f3a21a2f3279da2aac 8a1a0acdf85d41b9862c38bf88b46941--3beb6637614c44f3a21a2f3279da2aac 65b07e85d9bf49848b90c11aabb31435 3beb6637614c44f3a21a2f3279da2aac--65b07e85d9bf49848b90c11aabb31435 eb539486b8344d07a0e191ab335af832 65b07e85d9bf49848b90c11aabb31435--eb539486b8344d07a0e191ab335af832 352315af4a704c85886acd7024bca872 eb539486b8344d07a0e191ab335af832--352315af4a704c85886acd7024bca872 58d25c66045e4aa68390fddf8e313dab 352315af4a704c85886acd7024bca872--58d25c66045e4aa68390fddf8e313dab 17e321dd040f456198cac6fb460264f2 58d25c66045e4aa68390fddf8e313dab--17e321dd040f456198cac6fb460264f2 450be13b665a46d09d10b3fa850edd33 17e321dd040f456198cac6fb460264f2--450be13b665a46d09d10b3fa850edd33 2911897e7e584373becc4251fd36ce84 450be13b665a46d09d10b3fa850edd33--2911897e7e584373becc4251fd36ce84 39b8ab8e67f8424a8e2b70c2f8cb9df4 2911897e7e584373becc4251fd36ce84--39b8ab8e67f8424a8e2b70c2f8cb9df4 739a217efc2544989bd7650bba107736 39b8ab8e67f8424a8e2b70c2f8cb9df4--739a217efc2544989bd7650bba107736 593c98f449bd498da38a45a506bbbfaf 739a217efc2544989bd7650bba107736--593c98f449bd498da38a45a506bbbfaf 9803be07eff4477bb1aaccbb4ffd5f69 593c98f449bd498da38a45a506bbbfaf--9803be07eff4477bb1aaccbb4ffd5f69 ef95a7b1d90f4d4c9958c3b476106d45 9803be07eff4477bb1aaccbb4ffd5f69--ef95a7b1d90f4d4c9958c3b476106d45 ce80efa8f593403fb33a6d424d361d10 ef95a7b1d90f4d4c9958c3b476106d45--ce80efa8f593403fb33a6d424d361d10 049d3653150c4e78a1ba8d593f36e8ba ce80efa8f593403fb33a6d424d361d10--049d3653150c4e78a1ba8d593f36e8ba abb5d3977a304d62b9231d7e62a9df42 049d3653150c4e78a1ba8d593f36e8ba--abb5d3977a304d62b9231d7e62a9df42 954d804ba49549b79c34290581f4a6b9 abb5d3977a304d62b9231d7e62a9df42--954d804ba49549b79c34290581f4a6b9 e12a8b9370bb4326a065ecd2b118e22b 954d804ba49549b79c34290581f4a6b9--e12a8b9370bb4326a065ecd2b118e22b 891a2c8bd60242a1b5cd314be9a4ba96 e12a8b9370bb4326a065ecd2b118e22b--891a2c8bd60242a1b5cd314be9a4ba96 16c7d4e469304986aefc1a3a8c1d63fd 891a2c8bd60242a1b5cd314be9a4ba96--16c7d4e469304986aefc1a3a8c1d63fd 87309a1dc2c941ee941ec93f350b9616 16c7d4e469304986aefc1a3a8c1d63fd--87309a1dc2c941ee941ec93f350b9616 295138a9abda4cb784ba1e11320c3dd1 X 87309a1dc2c941ee941ec93f350b9616--295138a9abda4cb784ba1e11320c3dd1 295138a9abda4cb784ba1e11320c3dd1--a00e3784cc5245fb817209028d04518d 43f0a1c711a04adda198bcc96efb9b72 RZ(-1.0*g0) 295138a9abda4cb784ba1e11320c3dd1--43f0a1c711a04adda198bcc96efb9b72 0c969fd236c8474ea31e3154f3d4c2f3 X 43f0a1c711a04adda198bcc96efb9b72--0c969fd236c8474ea31e3154f3d4c2f3 0c969fd236c8474ea31e3154f3d4c2f3--52ca0fc02f7143f48a48fd8ebe74a649 08e81910b5214c64ac6924601729a998 0c969fd236c8474ea31e3154f3d4c2f3--08e81910b5214c64ac6924601729a998 02a386b37a2743c48107accadcb429e1 08e81910b5214c64ac6924601729a998--02a386b37a2743c48107accadcb429e1 ce241083b01e4487a89f78709df85c27 02a386b37a2743c48107accadcb429e1--ce241083b01e4487a89f78709df85c27 e903e11e650248c4a8cc99d5916a4a55 ce241083b01e4487a89f78709df85c27--e903e11e650248c4a8cc99d5916a4a55 f6e888d2da1b4b2c8588c3227d654906 e903e11e650248c4a8cc99d5916a4a55--f6e888d2da1b4b2c8588c3227d654906 39e551b672eb4416b26afa891e340590 f6e888d2da1b4b2c8588c3227d654906--39e551b672eb4416b26afa891e340590 bac5d2ad4a9542b2b87390464d4efdc9 39e551b672eb4416b26afa891e340590--bac5d2ad4a9542b2b87390464d4efdc9 0fcbf7055f2c4b85bbb4ac19ad4a6ab4 bac5d2ad4a9542b2b87390464d4efdc9--0fcbf7055f2c4b85bbb4ac19ad4a6ab4 517c39db2c4b4e7f8eb200f29bd36c1a 0fcbf7055f2c4b85bbb4ac19ad4a6ab4--517c39db2c4b4e7f8eb200f29bd36c1a 43da7ed536b245a19ccac2b92f5b2767 517c39db2c4b4e7f8eb200f29bd36c1a--43da7ed536b245a19ccac2b92f5b2767 6dabc164c1814ad1b93fa3c25c67e80d 43da7ed536b245a19ccac2b92f5b2767--6dabc164c1814ad1b93fa3c25c67e80d 3be2ca60cdd847bf8cd2e896220e3c4d 6dabc164c1814ad1b93fa3c25c67e80d--3be2ca60cdd847bf8cd2e896220e3c4d 408d18666e8148fd9705d976ebfb8f2f 3be2ca60cdd847bf8cd2e896220e3c4d--408d18666e8148fd9705d976ebfb8f2f 4fc1a8f98b5941e8ac59ef99c3263b87 408d18666e8148fd9705d976ebfb8f2f--4fc1a8f98b5941e8ac59ef99c3263b87 cda3c6a760cb477d883f48a3fc04ab4b 4fc1a8f98b5941e8ac59ef99c3263b87--cda3c6a760cb477d883f48a3fc04ab4b 84e65e996c7b4e99869531bf2ecf7e2b cda3c6a760cb477d883f48a3fc04ab4b--84e65e996c7b4e99869531bf2ecf7e2b ded159fae0d6457e95cb27475f3ff4de 84e65e996c7b4e99869531bf2ecf7e2b--ded159fae0d6457e95cb27475f3ff4de 6a9f8ba7cb7f4140bbbc77303707ea94 ded159fae0d6457e95cb27475f3ff4de--6a9f8ba7cb7f4140bbbc77303707ea94 e2b8f8b8c7274d7ca0e3252050784648 6a9f8ba7cb7f4140bbbc77303707ea94--e2b8f8b8c7274d7ca0e3252050784648 a7eb01aab9624417b8698a31f5303f9d e2b8f8b8c7274d7ca0e3252050784648--a7eb01aab9624417b8698a31f5303f9d 75157584e98445eab662b090d3589795 a7eb01aab9624417b8698a31f5303f9d--75157584e98445eab662b090d3589795 c77342cc500e4f3bab70406785b4bffc 75157584e98445eab662b090d3589795--c77342cc500e4f3bab70406785b4bffc 4cec255b7c02439c93db5c80e0adb82f c77342cc500e4f3bab70406785b4bffc--4cec255b7c02439c93db5c80e0adb82f 9847202902a8405495e81cbbcb306d87 4cec255b7c02439c93db5c80e0adb82f--9847202902a8405495e81cbbcb306d87 c04e93adb803428f8e1ea6689db95819 9847202902a8405495e81cbbcb306d87--c04e93adb803428f8e1ea6689db95819 41433d0e2d6b4ec2841597eb298a93dd c04e93adb803428f8e1ea6689db95819--41433d0e2d6b4ec2841597eb298a93dd 60040af67aaa457ab23abb852f214858 41433d0e2d6b4ec2841597eb298a93dd--60040af67aaa457ab23abb852f214858 168eb6877efc43018bdedc5dd0e7b2c5 60040af67aaa457ab23abb852f214858--168eb6877efc43018bdedc5dd0e7b2c5 021f552fc75842a2ad9d2f55609f33fd 168eb6877efc43018bdedc5dd0e7b2c5--021f552fc75842a2ad9d2f55609f33fd 293b33677a654c8b9e091fecff331480 021f552fc75842a2ad9d2f55609f33fd--293b33677a654c8b9e091fecff331480 153d49561b594102a6bcb1a26fa8acc1 293b33677a654c8b9e091fecff331480--153d49561b594102a6bcb1a26fa8acc1 a59cf8e60b854045b5c6a32203249ebc 153d49561b594102a6bcb1a26fa8acc1--a59cf8e60b854045b5c6a32203249ebc 24af456b789e4e72aa3d7e3d194c0b16 a59cf8e60b854045b5c6a32203249ebc--24af456b789e4e72aa3d7e3d194c0b16 8b8a8f00add54aa3ab1c4423f80b36e5 24af456b789e4e72aa3d7e3d194c0b16--8b8a8f00add54aa3ab1c4423f80b36e5 b4b69f3ab27a41b9bdb954317b97666b 8b8a8f00add54aa3ab1c4423f80b36e5--b4b69f3ab27a41b9bdb954317b97666b 45776a0cf9f249c0a99e401925e0ef40 X b4b69f3ab27a41b9bdb954317b97666b--45776a0cf9f249c0a99e401925e0ef40 45776a0cf9f249c0a99e401925e0ef40--eaa61d7a781740ba84496a53ceca32cb 7bff1234fc3642168c4021b3c3c9d6a2 RZ(-1.0*g0) 45776a0cf9f249c0a99e401925e0ef40--7bff1234fc3642168c4021b3c3c9d6a2 7a9211686dcc4a49b9bc644199485418 X 7bff1234fc3642168c4021b3c3c9d6a2--7a9211686dcc4a49b9bc644199485418 7a9211686dcc4a49b9bc644199485418--0e184e6accce4fc3845c40531e4f68c1 0fbc263be52b4953a3438d0cab409efe RX(b07) 7a9211686dcc4a49b9bc644199485418--0fbc263be52b4953a3438d0cab409efe 83c815c5ba0140d495a0d28a6a4214ed 0fbc263be52b4953a3438d0cab409efe--83c815c5ba0140d495a0d28a6a4214ed db881eb7cfaa4f0f91335c9cb4f15c0e 83c815c5ba0140d495a0d28a6a4214ed--db881eb7cfaa4f0f91335c9cb4f15c0e b0389fdd62f8488799df4b75948facc7 db881eb7cfaa4f0f91335c9cb4f15c0e--b0389fdd62f8488799df4b75948facc7 4d561e240e2c41ae9b5893491579021b b0389fdd62f8488799df4b75948facc7--4d561e240e2c41ae9b5893491579021b cc48ab6490be49c6a3ad6c855a672848 4d561e240e2c41ae9b5893491579021b--cc48ab6490be49c6a3ad6c855a672848 7fbbbb16eb1244b69fa22268cae45d69 cc48ab6490be49c6a3ad6c855a672848--7fbbbb16eb1244b69fa22268cae45d69 b1fcf3a87b0c4a019d85c2b915f24cfb X 7fbbbb16eb1244b69fa22268cae45d69--b1fcf3a87b0c4a019d85c2b915f24cfb b1fcf3a87b0c4a019d85c2b915f24cfb--88458c75d8ba4ed880cb8311ec69c008 60d754dd6efb416892924e1ffe318987 RZ(1.0*g1) b1fcf3a87b0c4a019d85c2b915f24cfb--60d754dd6efb416892924e1ffe318987 b910be594d1e4a4aa2fface896f756e0 X 60d754dd6efb416892924e1ffe318987--b910be594d1e4a4aa2fface896f756e0 b910be594d1e4a4aa2fface896f756e0--bf905dcedf624e71b3a9449f3ed83ff8 8c724917fb994b97ada98d3d3b5b4c2d b910be594d1e4a4aa2fface896f756e0--8c724917fb994b97ada98d3d3b5b4c2d 52b59242cd5942439f7ca3c730d1f4ad 8c724917fb994b97ada98d3d3b5b4c2d--52b59242cd5942439f7ca3c730d1f4ad 564d334ef514421e9a37fc468e2b811f 52b59242cd5942439f7ca3c730d1f4ad--564d334ef514421e9a37fc468e2b811f 32e849fdad524605bbd3024df79be42e 564d334ef514421e9a37fc468e2b811f--32e849fdad524605bbd3024df79be42e 0c5db9fa879e46b8bb36416dce7ce001 32e849fdad524605bbd3024df79be42e--0c5db9fa879e46b8bb36416dce7ce001 718b91d136734cfa97f2341ab8f5157c 0c5db9fa879e46b8bb36416dce7ce001--718b91d136734cfa97f2341ab8f5157c 0f99d0bb792c41e19c028f70f1927a45 718b91d136734cfa97f2341ab8f5157c--0f99d0bb792c41e19c028f70f1927a45 1bc0772fe0424ca5a799920b681fa5e0 0f99d0bb792c41e19c028f70f1927a45--1bc0772fe0424ca5a799920b681fa5e0 0125ada54aab44c5b5fd3c73cae17468 1bc0772fe0424ca5a799920b681fa5e0--0125ada54aab44c5b5fd3c73cae17468 2ed717ff1d9e40d394c5d0f02cc403af 0125ada54aab44c5b5fd3c73cae17468--2ed717ff1d9e40d394c5d0f02cc403af 22b761e8b3684bc9b371b701a3949222 2ed717ff1d9e40d394c5d0f02cc403af--22b761e8b3684bc9b371b701a3949222 721db5e7c31e4df68cd6746e705589df 22b761e8b3684bc9b371b701a3949222--721db5e7c31e4df68cd6746e705589df 0466cda6a27a4e278524665ef34c1b77 721db5e7c31e4df68cd6746e705589df--0466cda6a27a4e278524665ef34c1b77 b41bff4cc6724b39ac64acd02dc908ce 0466cda6a27a4e278524665ef34c1b77--b41bff4cc6724b39ac64acd02dc908ce 7bbbce9e444a49ceb9d009a87f2c32e1 b41bff4cc6724b39ac64acd02dc908ce--7bbbce9e444a49ceb9d009a87f2c32e1 5feec9bdb79040aa8ca66f035f017046 7bbbce9e444a49ceb9d009a87f2c32e1--5feec9bdb79040aa8ca66f035f017046 7cc754e3c98144aa895ea03a44bc9c13 5feec9bdb79040aa8ca66f035f017046--7cc754e3c98144aa895ea03a44bc9c13 438b911afd8142fd8a5edb84964e2178 7cc754e3c98144aa895ea03a44bc9c13--438b911afd8142fd8a5edb84964e2178 b87f004ffea64b9f9b77eef83baa80ec 438b911afd8142fd8a5edb84964e2178--b87f004ffea64b9f9b77eef83baa80ec a6c30514288d429386d094de6d82d5f5 b87f004ffea64b9f9b77eef83baa80ec--a6c30514288d429386d094de6d82d5f5 52c591340b834bbfa20a1dd79e7ed806 a6c30514288d429386d094de6d82d5f5--52c591340b834bbfa20a1dd79e7ed806 5a0fd546f7fb4db2986b9991e3719527 52c591340b834bbfa20a1dd79e7ed806--5a0fd546f7fb4db2986b9991e3719527 9ff0d43c72ae4330933f28a22c5635e4 5a0fd546f7fb4db2986b9991e3719527--9ff0d43c72ae4330933f28a22c5635e4 968afe2ce0b7492ba3f4b552f9458c8c 9ff0d43c72ae4330933f28a22c5635e4--968afe2ce0b7492ba3f4b552f9458c8c 6ec3b1dd4b4e4dc581584de23d80f7d5 968afe2ce0b7492ba3f4b552f9458c8c--6ec3b1dd4b4e4dc581584de23d80f7d5 183a4ae15e874dba8e266bbf0f063cfd 6ec3b1dd4b4e4dc581584de23d80f7d5--183a4ae15e874dba8e266bbf0f063cfd 49caf813ade74673adab5c283e04d9e9 183a4ae15e874dba8e266bbf0f063cfd--49caf813ade74673adab5c283e04d9e9 dd32547f631845758b753c2a10a0a3b8 49caf813ade74673adab5c283e04d9e9--dd32547f631845758b753c2a10a0a3b8 654895568cf14f9da071fc10d55844bf dd32547f631845758b753c2a10a0a3b8--654895568cf14f9da071fc10d55844bf 2cea0dba0c3749639b37250d33db64a4 654895568cf14f9da071fc10d55844bf--2cea0dba0c3749639b37250d33db64a4 e19ce96d21424ff8813a843eec9ed5c3 2cea0dba0c3749639b37250d33db64a4--e19ce96d21424ff8813a843eec9ed5c3 d901ccbf29b44be2ab60580d901090be e19ce96d21424ff8813a843eec9ed5c3--d901ccbf29b44be2ab60580d901090be 5311b699047649a5996d8be0ee5df579 d901ccbf29b44be2ab60580d901090be--5311b699047649a5996d8be0ee5df579 cff09dfa1fc14eca809405fed3f6cb1f 5311b699047649a5996d8be0ee5df579--cff09dfa1fc14eca809405fed3f6cb1f 87b70a970e1344248d190b87fe8b75fc cff09dfa1fc14eca809405fed3f6cb1f--87b70a970e1344248d190b87fe8b75fc 2b3f4233da394157975d2029de014bda 87b70a970e1344248d190b87fe8b75fc--2b3f4233da394157975d2029de014bda 6865ef1ba0f64bb180cac156301f4b72 2b3f4233da394157975d2029de014bda--6865ef1ba0f64bb180cac156301f4b72 420f1c5e23fe4bf59d66f1910425dc00 6865ef1ba0f64bb180cac156301f4b72--420f1c5e23fe4bf59d66f1910425dc00 5ab14b5b28fe4105a69c87d034425bd0 420f1c5e23fe4bf59d66f1910425dc00--5ab14b5b28fe4105a69c87d034425bd0 3bdce586e205474aa6dd7dc1e8feea91 5ab14b5b28fe4105a69c87d034425bd0--3bdce586e205474aa6dd7dc1e8feea91 f3ad963ce3d94f7dab059e2a41df82bc 3bdce586e205474aa6dd7dc1e8feea91--f3ad963ce3d94f7dab059e2a41df82bc cfa8d4db0c214009886102204c2ccc0b f3ad963ce3d94f7dab059e2a41df82bc--cfa8d4db0c214009886102204c2ccc0b 733ef44ecf64435dab729293ffbdd842 cfa8d4db0c214009886102204c2ccc0b--733ef44ecf64435dab729293ffbdd842 682bb12c73f24105a5d0693f87a29a0e X 733ef44ecf64435dab729293ffbdd842--682bb12c73f24105a5d0693f87a29a0e 682bb12c73f24105a5d0693f87a29a0e--eb471f9da90440cfb83e78195b1a2f28 fdc4b974e88d421eb2a76620730e28a6 RZ(-1.0*g1) 682bb12c73f24105a5d0693f87a29a0e--fdc4b974e88d421eb2a76620730e28a6 0ef8fe6b25bf4461944e11bd1186d2c9 X fdc4b974e88d421eb2a76620730e28a6--0ef8fe6b25bf4461944e11bd1186d2c9 0ef8fe6b25bf4461944e11bd1186d2c9--c9d750d7acd7430ea0121c784f188cc0 a9c0d0e4abc0405886b273939722d565 0ef8fe6b25bf4461944e11bd1186d2c9--a9c0d0e4abc0405886b273939722d565 c45afdce0ddb485c8c7f6f558fa84565 a9c0d0e4abc0405886b273939722d565--c45afdce0ddb485c8c7f6f558fa84565 46e78329eca647469ec4f8ddd8bd83af c45afdce0ddb485c8c7f6f558fa84565--46e78329eca647469ec4f8ddd8bd83af 3f26f75b31824ba8bd905b59f5a6faf0 46e78329eca647469ec4f8ddd8bd83af--3f26f75b31824ba8bd905b59f5a6faf0 f97d50ef68c449f887410e234b6e7f46 3f26f75b31824ba8bd905b59f5a6faf0--f97d50ef68c449f887410e234b6e7f46 41f9453d42894264862979e33a5cb878 f97d50ef68c449f887410e234b6e7f46--41f9453d42894264862979e33a5cb878 d24a13d163c14d13ae71f9e0c746649a 41f9453d42894264862979e33a5cb878--d24a13d163c14d13ae71f9e0c746649a 287c8e0aa1ee40adb096d20d9ee99e9f d24a13d163c14d13ae71f9e0c746649a--287c8e0aa1ee40adb096d20d9ee99e9f 871f2c2886984690a7741cf8e4c250fa 287c8e0aa1ee40adb096d20d9ee99e9f--871f2c2886984690a7741cf8e4c250fa a3e8b9a387014b269caba4403daf7ee7 871f2c2886984690a7741cf8e4c250fa--a3e8b9a387014b269caba4403daf7ee7 19fa1056728b42ff839e64d442f93d8d a3e8b9a387014b269caba4403daf7ee7--19fa1056728b42ff839e64d442f93d8d 84f170cd516b4960b1824b3feb5c7685 19fa1056728b42ff839e64d442f93d8d--84f170cd516b4960b1824b3feb5c7685 5215e68ff3a6423c9b52b7071af832a9 84f170cd516b4960b1824b3feb5c7685--5215e68ff3a6423c9b52b7071af832a9 1a4e77d262664f5ea76ca03270bf61a9 5215e68ff3a6423c9b52b7071af832a9--1a4e77d262664f5ea76ca03270bf61a9 47db10b1a59348038c80a477a11ffaa6 1a4e77d262664f5ea76ca03270bf61a9--47db10b1a59348038c80a477a11ffaa6 fea38a500890434ea9c38e8d99a886e0 47db10b1a59348038c80a477a11ffaa6--fea38a500890434ea9c38e8d99a886e0 cfe11855792745a8ab287304977b41c6 fea38a500890434ea9c38e8d99a886e0--cfe11855792745a8ab287304977b41c6 9b214237aa3646c6973a649b2da14421 cfe11855792745a8ab287304977b41c6--9b214237aa3646c6973a649b2da14421 a0763c5ed7524d1db5bf2827f66e2788 9b214237aa3646c6973a649b2da14421--a0763c5ed7524d1db5bf2827f66e2788 12753c046341409984202b1d4fd9d24a a0763c5ed7524d1db5bf2827f66e2788--12753c046341409984202b1d4fd9d24a 7e6f5d3134ec45d4b06449886d44b35c 12753c046341409984202b1d4fd9d24a--7e6f5d3134ec45d4b06449886d44b35c e8187de4c4024ff2a54d0962ab4ab360 7e6f5d3134ec45d4b06449886d44b35c--e8187de4c4024ff2a54d0962ab4ab360 c03809add5be475a93bde21c3090d2d4 e8187de4c4024ff2a54d0962ab4ab360--c03809add5be475a93bde21c3090d2d4 48c287f4587a48239cb20e6e4eaa4698 c03809add5be475a93bde21c3090d2d4--48c287f4587a48239cb20e6e4eaa4698 e59c6244b51d44db9b097400747ec03a 48c287f4587a48239cb20e6e4eaa4698--e59c6244b51d44db9b097400747ec03a 24610e37aab94203b5a1917e74f36090 e59c6244b51d44db9b097400747ec03a--24610e37aab94203b5a1917e74f36090 973d415e757e4c2db1554b22fdff576d 24610e37aab94203b5a1917e74f36090--973d415e757e4c2db1554b22fdff576d 3206eb0342cd41e4b287eb17786ab773 973d415e757e4c2db1554b22fdff576d--3206eb0342cd41e4b287eb17786ab773 54b96b6cabb548ee8edbb84829e1fc45 3206eb0342cd41e4b287eb17786ab773--54b96b6cabb548ee8edbb84829e1fc45 2e2107f13360493886bdd133ec2981b3 54b96b6cabb548ee8edbb84829e1fc45--2e2107f13360493886bdd133ec2981b3 cc9e9aeeb1f24d23a0b0b2e78ce24a1c 2e2107f13360493886bdd133ec2981b3--cc9e9aeeb1f24d23a0b0b2e78ce24a1c 27db6aac9d8844eaa912bd173e19b0bb cc9e9aeeb1f24d23a0b0b2e78ce24a1c--27db6aac9d8844eaa912bd173e19b0bb dc838c2b08694729bb05cc4ce02d7399 27db6aac9d8844eaa912bd173e19b0bb--dc838c2b08694729bb05cc4ce02d7399 26d140beee224aa89f2674d47b413cac dc838c2b08694729bb05cc4ce02d7399--26d140beee224aa89f2674d47b413cac 39ad513e493b4ca9983f9d43d4469f26 26d140beee224aa89f2674d47b413cac--39ad513e493b4ca9983f9d43d4469f26 f2e5f918a0ac42c983a12a492e94d128 X 39ad513e493b4ca9983f9d43d4469f26--f2e5f918a0ac42c983a12a492e94d128 f2e5f918a0ac42c983a12a492e94d128--662c85fbe18c47ce963aa30b2f09dc45 9746a12c45144bd99277935202cddba3 RZ(-1.0*g1) f2e5f918a0ac42c983a12a492e94d128--9746a12c45144bd99277935202cddba3 11ed3ac7608b4fc8a91f50af6ff3b9bf X 9746a12c45144bd99277935202cddba3--11ed3ac7608b4fc8a91f50af6ff3b9bf 11ed3ac7608b4fc8a91f50af6ff3b9bf--5968ea2148b144ababb376ce7bc0127a 57ecdcbda4de43c6982c4779e4cd272d RX(b17) 11ed3ac7608b4fc8a91f50af6ff3b9bf--57ecdcbda4de43c6982c4779e4cd272d 57ecdcbda4de43c6982c4779e4cd272d--080aa0114186400cb6fcb2323ec4905c"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -3.6596938084588895\nMaxCut cost at iteration 10: 7.851113181689655\nMaxCut cost at iteration 20: 7.992838739186631\nMaxCut cost at iteration 30: 7.999993045144414\nMaxCut cost at iteration 40: 7.999999246572711\nMaxCut cost at iteration 50: 7.999999904590818\nMaxCut cost at iteration 60: 7.999999987916163\nMaxCut cost at iteration 70: 7.999999998469495\nMaxCut cost at iteration 80: 7.999999999806146\nMaxCut cost at iteration 90: 7.9999999999754445\nMaxCut cost at iteration 100: 7.99999999999689\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 01100110  2024-01-30T10:16:37.744767 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2024-01-30T10:16:41.961443 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_a01d77cbab5f44f182281af5258bc052 Constant Chebyshev FM cluster_7f2cbf4c4da548f581f014529bc22097 Constant Fourier FM a77258677bd6490fbe4d69815575de28 0 bd6e9ac71d814f0ca4ea526d604efc50 RX(phi) a77258677bd6490fbe4d69815575de28--bd6e9ac71d814f0ca4ea526d604efc50 3b769d6c6c594313bc388d87bc55e431 1 505a35bd1b6048d9861549dd9a3e64f9 RX(acos(phi)) bd6e9ac71d814f0ca4ea526d604efc50--505a35bd1b6048d9861549dd9a3e64f9 ccd939ce92be41bb8be0762c1a54aea9 505a35bd1b6048d9861549dd9a3e64f9--ccd939ce92be41bb8be0762c1a54aea9 9cc0ed3decae43ddaebc5afac729a750 c1940c4516a14e58be5e6757607e3643 RX(phi) 3b769d6c6c594313bc388d87bc55e431--c1940c4516a14e58be5e6757607e3643 1cd49376d2554e6391de4f3697edc584 2 a81b1742c6014efa9bf88fcfce67d36e RX(acos(phi)) c1940c4516a14e58be5e6757607e3643--a81b1742c6014efa9bf88fcfce67d36e a81b1742c6014efa9bf88fcfce67d36e--9cc0ed3decae43ddaebc5afac729a750 3f2b488ed7b54016ab2da4eec4e69d20 f47271448b4141148f1fc32153673607 RX(phi) 1cd49376d2554e6391de4f3697edc584--f47271448b4141148f1fc32153673607 03e633ca3504442f85be0755d9daaa69 RX(acos(phi)) f47271448b4141148f1fc32153673607--03e633ca3504442f85be0755d9daaa69 03e633ca3504442f85be0755d9daaa69--3f2b488ed7b54016ab2da4eec4e69d20 <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom function\ndef custom_fn(x):\n    return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_fn)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_eb3ab0d52f734ed49d6cb0f31cd117f1 Constant &lt;function custom_fn at 0x7ff8e732f130&gt; FM cluster_4ac4c05f88774026950b13993b7e86e0 Constant asin FM d2e47e68ab8b4d4d90cb28670a4aa711 0 3524a4a19deb4a2c86311228f25a237f RX(asin(phi)) d2e47e68ab8b4d4d90cb28670a4aa711--3524a4a19deb4a2c86311228f25a237f d2ebc6115ed14110b2dd0e6a8f9aad57 1 48e391115f96486d9e6ee38638f5a2b6 RX(phi**2 + asin(phi)) 3524a4a19deb4a2c86311228f25a237f--48e391115f96486d9e6ee38638f5a2b6 4c385a0f5b574d908f7e989b19537660 48e391115f96486d9e6ee38638f5a2b6--4c385a0f5b574d908f7e989b19537660 66c9a67892cc4b45924ada9c56539084 7e2dcd676b9a4faa91f7efad7eebd1c0 RX(asin(phi)) d2ebc6115ed14110b2dd0e6a8f9aad57--7e2dcd676b9a4faa91f7efad7eebd1c0 2a4574cb65cb4fb187b68c619cc699fb 2 5e59cbfaf055410e947bc0d78bef0dd2 RX(phi**2 + asin(phi)) 7e2dcd676b9a4faa91f7efad7eebd1c0--5e59cbfaf055410e947bc0d78bef0dd2 5e59cbfaf055410e947bc0d78bef0dd2--66c9a67892cc4b45924ada9c56539084 0ee030624cb9419d8cd867ac43dcfb70 829d3a5c60934984a8169fbc1cfc2a01 RX(asin(phi)) 2a4574cb65cb4fb187b68c619cc699fb--829d3a5c60934984a8169fbc1cfc2a01 650219d7b48c4937af2a8c7fbb6ea9dd RX(phi**2 + asin(phi)) 829d3a5c60934984a8169fbc1cfc2a01--650219d7b48c4937af2a8c7fbb6ea9dd 650219d7b48c4937af2a8c7fbb6ea9dd--0ee030624cb9419d8cd867ac43dcfb70 <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_6943bea763e84460835fdb91693999cc Exponential Fourier FM cluster_cae628987b6b44f99070bcf5b0f454bd Constant Fourier FM cluster_62d07e02fd9c4cac862f4936c3dd6ba2 Tower Fourier FM 06138e893a604b31b50482edad643929 0 f23ec2f32f234a5da8665dad4e0feaf9 RX(phi) 06138e893a604b31b50482edad643929--f23ec2f32f234a5da8665dad4e0feaf9 15bfe2c11fa841c785d5e226647399e3 1 31dabec33b3d4d13afc212736c87c7d3 RX(1.0*phi) f23ec2f32f234a5da8665dad4e0feaf9--31dabec33b3d4d13afc212736c87c7d3 a84a6749e85a4d08b2c53f31e12756fb RX(1.0*phi) 31dabec33b3d4d13afc212736c87c7d3--a84a6749e85a4d08b2c53f31e12756fb c9521fff60dc412e9680db91b7e82627 a84a6749e85a4d08b2c53f31e12756fb--c9521fff60dc412e9680db91b7e82627 103b71cc2fd845f58c5d381eeffe2d19 1a34ecabecc344708f7987fe79133396 RX(phi) 15bfe2c11fa841c785d5e226647399e3--1a34ecabecc344708f7987fe79133396 f862ccadddba49779f2f7aa6d84a7c60 2 238c0f8de06244e284e2560aba06b74e RX(2.0*phi) 1a34ecabecc344708f7987fe79133396--238c0f8de06244e284e2560aba06b74e 8a63cf76e87a453e8297d564e5a294ac RX(2.0*phi) 238c0f8de06244e284e2560aba06b74e--8a63cf76e87a453e8297d564e5a294ac 8a63cf76e87a453e8297d564e5a294ac--103b71cc2fd845f58c5d381eeffe2d19 d0715306f5054bca85724cb9f2809e12 4e9212d8367d482ea58db7758f67da56 RX(phi) f862ccadddba49779f2f7aa6d84a7c60--4e9212d8367d482ea58db7758f67da56 163883b054e0415e9faa0bd644a178ce 3 52dd5015ccf64224b8b2a26af3631014 RX(3.0*phi) 4e9212d8367d482ea58db7758f67da56--52dd5015ccf64224b8b2a26af3631014 b68ffbbad98543b09936dee2c957fb8f RX(4.0*phi) 52dd5015ccf64224b8b2a26af3631014--b68ffbbad98543b09936dee2c957fb8f b68ffbbad98543b09936dee2c957fb8f--d0715306f5054bca85724cb9f2809e12 3ac899b379314afebe43b4e024b83d0e d3498cf36cd74b128b3a22564bd1f230 RX(phi) 163883b054e0415e9faa0bd644a178ce--d3498cf36cd74b128b3a22564bd1f230 70c3c510c1a645d3b78bb3f2c22b8efd 4 f2d7fe60635e4590b9e114365d4ed393 RX(4.0*phi) d3498cf36cd74b128b3a22564bd1f230--f2d7fe60635e4590b9e114365d4ed393 2c2a2112c64d40739143f6e232e9d452 RX(8.0*phi) f2d7fe60635e4590b9e114365d4ed393--2c2a2112c64d40739143f6e232e9d452 2c2a2112c64d40739143f6e232e9d452--3ac899b379314afebe43b4e024b83d0e 95567bbe2b5b4e1eaa8b196ddf011858 7a819b2d359143c88a5df1edda001c19 RX(phi) 70c3c510c1a645d3b78bb3f2c22b8efd--7a819b2d359143c88a5df1edda001c19 424884e9473e4583bc99858cc224fc91 RX(5.0*phi) 7a819b2d359143c88a5df1edda001c19--424884e9473e4583bc99858cc224fc91 30cffcd333e441d3b19b616948fb2464 RX(16.0*phi) 424884e9473e4583bc99858cc224fc91--30cffcd333e441d3b19b616948fb2464 30cffcd333e441d3b19b616948fb2464--95567bbe2b5b4e1eaa8b196ddf011858 <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 9780ad9b941546ca806c5dd980dc7b2b 0 588ba8b33dc84d8c8ce4954bc972a840 RX(1.0*acos(phi)) 9780ad9b941546ca806c5dd980dc7b2b--588ba8b33dc84d8c8ce4954bc972a840 7b852cbce5af48e487ad5893b25226c9 1 a88ab5aa1fea405487d96b168f0e5a2c 588ba8b33dc84d8c8ce4954bc972a840--a88ab5aa1fea405487d96b168f0e5a2c 3b7895e967a248d88a9ae742fd6bb570 3c1081d7617a440d8c5f436145b5a45d RX(1.414*acos(phi)) 7b852cbce5af48e487ad5893b25226c9--3c1081d7617a440d8c5f436145b5a45d 2cf3eab5548846a084060b70f98487c7 2 3c1081d7617a440d8c5f436145b5a45d--3b7895e967a248d88a9ae742fd6bb570 e031b58f21e447338720c2b5a4e39d73 40fa31934eb34f78ae8ad387c8d70757 RX(1.732*acos(phi)) 2cf3eab5548846a084060b70f98487c7--40fa31934eb34f78ae8ad387c8d70757 f2511e4bdfbd42578585352cf6cc8b4c 3 40fa31934eb34f78ae8ad387c8d70757--e031b58f21e447338720c2b5a4e39d73 3215af52a36446ddb2ac4563bb1b948c e3004141409d423fb3898b011dbc7f6a RX(2.0*acos(phi)) f2511e4bdfbd42578585352cf6cc8b4c--e3004141409d423fb3898b011dbc7f6a 7091e842238640878ea577bd2a1fa3f6 4 e3004141409d423fb3898b011dbc7f6a--3215af52a36446ddb2ac4563bb1b948c ab699ef5649641508ea42874aeafe769 0591587508864955b1423b31559f2905 RX(2.236*acos(phi)) 7091e842238640878ea577bd2a1fa3f6--0591587508864955b1423b31559f2905 0591587508864955b1423b31559f2905--ab699ef5649641508ea42874aeafe769 <p>To add a trainable parameter that multiplies the feature parameter inside the encoding function, simply pass a <code>param_prefix</code> string:</p> <pre><code>n_qubits = 5\n\nfm_trainable = feature_map(\n    n_qubits,\n    fm_type=BasisSet.FOURIER,\n    reupload_scaling=ReuploadScaling.EXP,\n    param_prefix = \"w\",\n)\n</code></pre> %3 cfa7a8721c7a4228a3e6ed7aadd349f8 0 cf8115dcfb804ef7b82d9bfc152f2e4e RX(1.0*phi*w\u2080) cfa7a8721c7a4228a3e6ed7aadd349f8--cf8115dcfb804ef7b82d9bfc152f2e4e 631548f5b3d445739d64b8682aacf2dd 1 5edbea27a0934b2c8d256b6378c7ba7a cf8115dcfb804ef7b82d9bfc152f2e4e--5edbea27a0934b2c8d256b6378c7ba7a b466cd532303477ebea4dd0909bc94b2 eb5f85f7465244f2b92e9b1f75d18200 RX(2.0*phi*w\u2081) 631548f5b3d445739d64b8682aacf2dd--eb5f85f7465244f2b92e9b1f75d18200 56b9311f1bf2475a9ce8afbc7dca43e1 2 eb5f85f7465244f2b92e9b1f75d18200--b466cd532303477ebea4dd0909bc94b2 90398aea4b7640bb8ae9aee099e0b0ed 59e92d6cb6c74a4f887e239d49e926a0 RX(4.0*phi*w\u2082) 56b9311f1bf2475a9ce8afbc7dca43e1--59e92d6cb6c74a4f887e239d49e926a0 26c9394084264097b2c5816fd8a91cd3 3 59e92d6cb6c74a4f887e239d49e926a0--90398aea4b7640bb8ae9aee099e0b0ed 3d54e8c6ba194833a640567c6eb4291a dd7d19a92f6147079a6f9363b38adc33 RX(8.0*phi*w\u2083) 26c9394084264097b2c5816fd8a91cd3--dd7d19a92f6147079a6f9363b38adc33 ef89c20d5df34ac3aaa9778b72e7105d 4 dd7d19a92f6147079a6f9363b38adc33--3d54e8c6ba194833a640567c6eb4291a d7cbf2fec6894c1eb2b83c38899348d8 8cf699a4536b4a6cb4c029f960057447 RX(16.0*phi*w\u2084) ef89c20d5df34ac3aaa9778b72e7105d--8cf699a4536b4a6cb4c029f960057447 8cf699a4536b4a6cb4c029f960057447--d7cbf2fec6894c1eb2b83c38899348d8 <p>Note that for the Fourier feature map, the encoding function is simply \\(f(x)=x\\). For other cases, like the Chebyshev <code>acos()</code> encoding, the trainable parameter may cause the feature value to be outside the domain of the encoding function. This will eventually be fixed by adding range constraints to trainable parameters in Qadence.</p> <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0, # Extra multiplier, which can also be a Parameter\n    param_prefix = \"w\", # Add trainable parameters\n)\n</code></pre> %3 d5d16e22e1cf4bb6bad81b1ae2d26c83 0 e1d02fe854ac4393aced4eda8cb0a43f RY(80.0*acos(w\u2084*(0.667*x + 1.667))) d5d16e22e1cf4bb6bad81b1ae2d26c83--e1d02fe854ac4393aced4eda8cb0a43f f459f99b912142c69e9d49c9d7c5ddf7 1 db1cfff9a34b41cd90160e8613632fae e1d02fe854ac4393aced4eda8cb0a43f--db1cfff9a34b41cd90160e8613632fae aa5ec6c71e7d4f6ab8c468d7e33410dc fa0a998cda334e4db041bb3d97719461 RY(40.0*acos(w\u2083*(0.667*x + 1.667))) f459f99b912142c69e9d49c9d7c5ddf7--fa0a998cda334e4db041bb3d97719461 79058c1d4c6d464aa99d8990ebfb46ce 2 fa0a998cda334e4db041bb3d97719461--aa5ec6c71e7d4f6ab8c468d7e33410dc fdef466d00314e068349e767dccc1f88 de83469fc0ac459394bf2fdf6948af4d RY(20.0*acos(w\u2082*(0.667*x + 1.667))) 79058c1d4c6d464aa99d8990ebfb46ce--de83469fc0ac459394bf2fdf6948af4d 00db2d885ba4490494dd4312438a1696 3 de83469fc0ac459394bf2fdf6948af4d--fdef466d00314e068349e767dccc1f88 cad613a7e0f34d899fda20e810f9ce19 974f9a9a03ed420bb1e126e7a7eb339f RY(10.0*acos(w\u2081*(0.667*x + 1.667))) 00db2d885ba4490494dd4312438a1696--974f9a9a03ed420bb1e126e7a7eb339f bda7a7198f134c8ba6ffbc70067827f6 4 974f9a9a03ed420bb1e126e7a7eb339f--cad613a7e0f34d899fda20e810f9ce19 1836b4d35d66432db3fa9f8b9b0105f1 7ba1da1568534da29aa4bea9f5d9e0b0 RY(5.0*acos(w\u2080*(0.667*x + 1.667))) bda7a7198f134c8ba6ffbc70067827f6--7ba1da1568534da29aa4bea9f5d9e0b0 7ba1da1568534da29aa4bea9f5d9e0b0--1836b4d35d66432db3fa9f8b9b0105f1"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 670653760ba44d3db5792c7c55e87028 0 96aabf493a804532a7b45a4414d52a04 RX(theta\u2080) 670653760ba44d3db5792c7c55e87028--96aabf493a804532a7b45a4414d52a04 62fd1edd708c451986bf293ba8326a84 1 a5abb2902af443999e79b5ccb139460b RY(theta\u2083) 96aabf493a804532a7b45a4414d52a04--a5abb2902af443999e79b5ccb139460b d5f59c4748954a8e8a75440922e23d9e RX(theta\u2086) a5abb2902af443999e79b5ccb139460b--d5f59c4748954a8e8a75440922e23d9e 0d5e97191f9240efbaa2c77121855a1e d5f59c4748954a8e8a75440922e23d9e--0d5e97191f9240efbaa2c77121855a1e ecbc32c34c2a4d89b185346efc1f0216 0d5e97191f9240efbaa2c77121855a1e--ecbc32c34c2a4d89b185346efc1f0216 03f284a1d6964e0b940e48f715499fcc RX(theta\u2089) ecbc32c34c2a4d89b185346efc1f0216--03f284a1d6964e0b940e48f715499fcc 240340b428214cfda94a312e19fc4d04 RY(theta\u2081\u2082) 03f284a1d6964e0b940e48f715499fcc--240340b428214cfda94a312e19fc4d04 c2316d67c5474932bd00aef2e7cc7396 RX(theta\u2081\u2085) 240340b428214cfda94a312e19fc4d04--c2316d67c5474932bd00aef2e7cc7396 11db2fce240c43039ac4f9514fcf6fec c2316d67c5474932bd00aef2e7cc7396--11db2fce240c43039ac4f9514fcf6fec 354ebcc44f384920aae8eae518c75d02 11db2fce240c43039ac4f9514fcf6fec--354ebcc44f384920aae8eae518c75d02 b0d5ec8939654f76a4c34ba58ba02fca 354ebcc44f384920aae8eae518c75d02--b0d5ec8939654f76a4c34ba58ba02fca 66fefd07668b48be87f5bcae12ecaebc 4b3940cc63a046a1aa437782906e4c0d RX(theta\u2081) 62fd1edd708c451986bf293ba8326a84--4b3940cc63a046a1aa437782906e4c0d 118b14e3efd74f4cba7f96a48bb438d2 2 b9140f02b4f44c2dbec9e817c6edfe48 RY(theta\u2084) 4b3940cc63a046a1aa437782906e4c0d--b9140f02b4f44c2dbec9e817c6edfe48 286032110a654762a76f40bc894ab5e0 RX(theta\u2087) b9140f02b4f44c2dbec9e817c6edfe48--286032110a654762a76f40bc894ab5e0 ac524c6a45ff42baa9613971b41d7a3e X 286032110a654762a76f40bc894ab5e0--ac524c6a45ff42baa9613971b41d7a3e ac524c6a45ff42baa9613971b41d7a3e--0d5e97191f9240efbaa2c77121855a1e 4373593b01d8491cac4c13ff45cb5244 ac524c6a45ff42baa9613971b41d7a3e--4373593b01d8491cac4c13ff45cb5244 9993164f57664c7b881c3eea2dfb0562 RX(theta\u2081\u2080) 4373593b01d8491cac4c13ff45cb5244--9993164f57664c7b881c3eea2dfb0562 cc16832760b24cc7a123d6a8185d77a7 RY(theta\u2081\u2083) 9993164f57664c7b881c3eea2dfb0562--cc16832760b24cc7a123d6a8185d77a7 969cc9fc999c416d99425a5f4efd623d RX(theta\u2081\u2086) cc16832760b24cc7a123d6a8185d77a7--969cc9fc999c416d99425a5f4efd623d b5897ce6e8df41a3b6d2084c14bc2564 X 969cc9fc999c416d99425a5f4efd623d--b5897ce6e8df41a3b6d2084c14bc2564 b5897ce6e8df41a3b6d2084c14bc2564--11db2fce240c43039ac4f9514fcf6fec 6ca4712bd9e74650a6006af2c74c58e9 b5897ce6e8df41a3b6d2084c14bc2564--6ca4712bd9e74650a6006af2c74c58e9 6ca4712bd9e74650a6006af2c74c58e9--66fefd07668b48be87f5bcae12ecaebc fae65e8662f3405ea5d78664557eed72 81461467498e4a63bf8b4695b0623ecd RX(theta\u2082) 118b14e3efd74f4cba7f96a48bb438d2--81461467498e4a63bf8b4695b0623ecd eb902316697d49d9b3d10788de587178 RY(theta\u2085) 81461467498e4a63bf8b4695b0623ecd--eb902316697d49d9b3d10788de587178 9d4b12a1fef44bf0a3b44669424f9b76 RX(theta\u2088) eb902316697d49d9b3d10788de587178--9d4b12a1fef44bf0a3b44669424f9b76 d629f5fcc523424a970b0e2b83a6cf2f 9d4b12a1fef44bf0a3b44669424f9b76--d629f5fcc523424a970b0e2b83a6cf2f 29f0d992a26740008dff0eb1fbfda36f X d629f5fcc523424a970b0e2b83a6cf2f--29f0d992a26740008dff0eb1fbfda36f 29f0d992a26740008dff0eb1fbfda36f--4373593b01d8491cac4c13ff45cb5244 dde0ca9602af46c3929d0f43cbef5fcd RX(theta\u2081\u2081) 29f0d992a26740008dff0eb1fbfda36f--dde0ca9602af46c3929d0f43cbef5fcd 155228b4b7124283800e03bf99d95833 RY(theta\u2081\u2084) dde0ca9602af46c3929d0f43cbef5fcd--155228b4b7124283800e03bf99d95833 0d917fd15b6c4f27a7149efb95f4825d RX(theta\u2081\u2087) 155228b4b7124283800e03bf99d95833--0d917fd15b6c4f27a7149efb95f4825d 6c05cf41cbcd48fab270047727863065 0d917fd15b6c4f27a7149efb95f4825d--6c05cf41cbcd48fab270047727863065 9552f590c7c9446ebe8582444bec38a1 X 6c05cf41cbcd48fab270047727863065--9552f590c7c9446ebe8582444bec38a1 9552f590c7c9446ebe8582444bec38a1--6ca4712bd9e74650a6006af2c74c58e9 9552f590c7c9446ebe8582444bec38a1--fae65e8662f3405ea5d78664557eed72 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 11aea1435518446c91889537516c91d8 0 727883dc01254158b9314408918a2133 RX(phi\u2080) 11aea1435518446c91889537516c91d8--727883dc01254158b9314408918a2133 f20f7b504003477c9d76c1a6bee440fb 1 a9a3cfc6c90e4583b9336604fe102459 RY(phi\u2083) 727883dc01254158b9314408918a2133--a9a3cfc6c90e4583b9336604fe102459 55a21b452e854f5089a407a15bf10cd0 RX(phi\u2086) a9a3cfc6c90e4583b9336604fe102459--55a21b452e854f5089a407a15bf10cd0 1591d4a0f38e4e0d8d74952848704f45 55a21b452e854f5089a407a15bf10cd0--1591d4a0f38e4e0d8d74952848704f45 f5aa470db14e4396956a4e66645b8cfe 1591d4a0f38e4e0d8d74952848704f45--f5aa470db14e4396956a4e66645b8cfe 1e5573b4843344208bcc466b266cd096 RX(phi\u2089) f5aa470db14e4396956a4e66645b8cfe--1e5573b4843344208bcc466b266cd096 e0c5871b73d548aea17e54e6e328890c RY(phi\u2081\u2082) 1e5573b4843344208bcc466b266cd096--e0c5871b73d548aea17e54e6e328890c c1e508fb4c9e4dbeb0078e356aafbe18 RX(phi\u2081\u2085) e0c5871b73d548aea17e54e6e328890c--c1e508fb4c9e4dbeb0078e356aafbe18 d210b7608cf04e7599c31456ddd06ae9 c1e508fb4c9e4dbeb0078e356aafbe18--d210b7608cf04e7599c31456ddd06ae9 fa0969e051f940f0ab6ba2f0ef500bb9 d210b7608cf04e7599c31456ddd06ae9--fa0969e051f940f0ab6ba2f0ef500bb9 e9aceaa5dd824f89b88629458ae31715 fa0969e051f940f0ab6ba2f0ef500bb9--e9aceaa5dd824f89b88629458ae31715 01824c86dd2e40b2bd72adecaae368cb e9d8f7d02d244801b04db780d3fbd83a RX(phi\u2081) f20f7b504003477c9d76c1a6bee440fb--e9d8f7d02d244801b04db780d3fbd83a a037ad7de5e847619fdc2f7064a143d8 2 4c2330a5ec5c423fbe1c4579df781799 RY(phi\u2084) e9d8f7d02d244801b04db780d3fbd83a--4c2330a5ec5c423fbe1c4579df781799 e531796f5d904cc3ac76d6602855f5be RX(phi\u2087) 4c2330a5ec5c423fbe1c4579df781799--e531796f5d904cc3ac76d6602855f5be 526868869b8b4cb4a1567ad05a7cd10a PHASE(phi_ent\u2080) e531796f5d904cc3ac76d6602855f5be--526868869b8b4cb4a1567ad05a7cd10a 526868869b8b4cb4a1567ad05a7cd10a--1591d4a0f38e4e0d8d74952848704f45 c7afbb5f27034b7c8598a4297024c95f 526868869b8b4cb4a1567ad05a7cd10a--c7afbb5f27034b7c8598a4297024c95f a47ef196b7f442b295402d0102e5bff2 RX(phi\u2081\u2080) c7afbb5f27034b7c8598a4297024c95f--a47ef196b7f442b295402d0102e5bff2 09b7876a7047400687d8e779a88d8aa2 RY(phi\u2081\u2083) a47ef196b7f442b295402d0102e5bff2--09b7876a7047400687d8e779a88d8aa2 a60e979e35524a5587d0fbde5f11751f RX(phi\u2081\u2086) 09b7876a7047400687d8e779a88d8aa2--a60e979e35524a5587d0fbde5f11751f 211a61e3a3c6475aab4460141a847254 PHASE(phi_ent\u2082) a60e979e35524a5587d0fbde5f11751f--211a61e3a3c6475aab4460141a847254 211a61e3a3c6475aab4460141a847254--d210b7608cf04e7599c31456ddd06ae9 950147df611b47589c74bcc3f7887929 211a61e3a3c6475aab4460141a847254--950147df611b47589c74bcc3f7887929 950147df611b47589c74bcc3f7887929--01824c86dd2e40b2bd72adecaae368cb da9257150d814685a21ac6de99ee8325 4f0048557555466183af973dddffd3bb RX(phi\u2082) a037ad7de5e847619fdc2f7064a143d8--4f0048557555466183af973dddffd3bb 7e6bfec6d67e4a0b9675682a47688b31 RY(phi\u2085) 4f0048557555466183af973dddffd3bb--7e6bfec6d67e4a0b9675682a47688b31 4cd134b5c7ca4ba68ab72388a5a4177d RX(phi\u2088) 7e6bfec6d67e4a0b9675682a47688b31--4cd134b5c7ca4ba68ab72388a5a4177d 9c9e79e5717c456da8de473f9f408fbe 4cd134b5c7ca4ba68ab72388a5a4177d--9c9e79e5717c456da8de473f9f408fbe 4253df03973443d685d4f6c44a0d61ae PHASE(phi_ent\u2081) 9c9e79e5717c456da8de473f9f408fbe--4253df03973443d685d4f6c44a0d61ae 4253df03973443d685d4f6c44a0d61ae--c7afbb5f27034b7c8598a4297024c95f 0cfe98ba7efc4b2c9818f2ae7c2ba419 RX(phi\u2081\u2081) 4253df03973443d685d4f6c44a0d61ae--0cfe98ba7efc4b2c9818f2ae7c2ba419 454f771aeb964084a1ac5cf5c0554bfa RY(phi\u2081\u2084) 0cfe98ba7efc4b2c9818f2ae7c2ba419--454f771aeb964084a1ac5cf5c0554bfa 5fb6edffcc894992bf7919ae35b27bbc RX(phi\u2081\u2087) 454f771aeb964084a1ac5cf5c0554bfa--5fb6edffcc894992bf7919ae35b27bbc f16c8e13cb6846d6b65ca8f0fba9f1fd 5fb6edffcc894992bf7919ae35b27bbc--f16c8e13cb6846d6b65ca8f0fba9f1fd a32c594e494e44ad80604fdf588bc1dd PHASE(phi_ent\u2083) f16c8e13cb6846d6b65ca8f0fba9f1fd--a32c594e494e44ad80604fdf588bc1dd a32c594e494e44ad80604fdf588bc1dd--950147df611b47589c74bcc3f7887929 a32c594e494e44ad80604fdf588bc1dd--da9257150d814685a21ac6de99ee8325 <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_4eeb64b5ddcb44aa84b7c0236e6be4f0 cluster_261f33b0d3df45b9946c1fcbf89d179a e034452c1fd84b3aaaa267df7e9c9b38 0 def744dec5e843d18440467f064990f9 RX(theta\u2080) e034452c1fd84b3aaaa267df7e9c9b38--def744dec5e843d18440467f064990f9 2cdb000eaf904740b57830c26c889542 1 c9789ab4db1547f7b0ff8cea5dc9fd4e RY(theta\u2083) def744dec5e843d18440467f064990f9--c9789ab4db1547f7b0ff8cea5dc9fd4e 09795f0c978d4cce95c04e52c4788efa RX(theta\u2086) c9789ab4db1547f7b0ff8cea5dc9fd4e--09795f0c978d4cce95c04e52c4788efa 9344978b75064087b34a020163aafd5f HamEvo 09795f0c978d4cce95c04e52c4788efa--9344978b75064087b34a020163aafd5f 5ae450204d0f42d896414cec9d4131e7 RX(theta\u2089) 9344978b75064087b34a020163aafd5f--5ae450204d0f42d896414cec9d4131e7 dc77e8ce29274905ba7ff9442a9f5daa RY(theta\u2081\u2082) 5ae450204d0f42d896414cec9d4131e7--dc77e8ce29274905ba7ff9442a9f5daa eaf0b869bfb34b73ae5635808db83cff RX(theta\u2081\u2085) dc77e8ce29274905ba7ff9442a9f5daa--eaf0b869bfb34b73ae5635808db83cff 0453265196ae493090d0b305d125f44f HamEvo eaf0b869bfb34b73ae5635808db83cff--0453265196ae493090d0b305d125f44f ac0a4045c1184a2ba5c6faf4ddfbeeed 0453265196ae493090d0b305d125f44f--ac0a4045c1184a2ba5c6faf4ddfbeeed 12ec117db9c34a4eb51b12faaf446c5c 8f46392af1644e13a3d2bfbd4c8edb65 RX(theta\u2081) 2cdb000eaf904740b57830c26c889542--8f46392af1644e13a3d2bfbd4c8edb65 1411c90722244da080b6480b4831b882 2 6d098eff857747dcad1cb50aa6c241c3 RY(theta\u2084) 8f46392af1644e13a3d2bfbd4c8edb65--6d098eff857747dcad1cb50aa6c241c3 e20b9c679b2d413285696b67c2dadda1 RX(theta\u2087) 6d098eff857747dcad1cb50aa6c241c3--e20b9c679b2d413285696b67c2dadda1 eb4b9f8604dd49aab7d6719a7375bb9c t = theta_t\u2080 e20b9c679b2d413285696b67c2dadda1--eb4b9f8604dd49aab7d6719a7375bb9c 153f007f0c6045199f6cc77d68e16031 RX(theta\u2081\u2080) eb4b9f8604dd49aab7d6719a7375bb9c--153f007f0c6045199f6cc77d68e16031 7107e13db799445aba124f77d36cfbda RY(theta\u2081\u2083) 153f007f0c6045199f6cc77d68e16031--7107e13db799445aba124f77d36cfbda 4b87be0283064527985349ecf7f3cfda RX(theta\u2081\u2086) 7107e13db799445aba124f77d36cfbda--4b87be0283064527985349ecf7f3cfda 83976e44ea5440acbeb60a504f7ab3bd t = theta_t\u2081 4b87be0283064527985349ecf7f3cfda--83976e44ea5440acbeb60a504f7ab3bd 83976e44ea5440acbeb60a504f7ab3bd--12ec117db9c34a4eb51b12faaf446c5c 6fe97c334a274a1abc4e6832ad733ac2 6989698c71f442af82418452268a4228 RX(theta\u2082) 1411c90722244da080b6480b4831b882--6989698c71f442af82418452268a4228 1c1237c0a22742708fe7432d71f7612b RY(theta\u2085) 6989698c71f442af82418452268a4228--1c1237c0a22742708fe7432d71f7612b 36188d30877e4167a3fa26e11cfab8ed RX(theta\u2088) 1c1237c0a22742708fe7432d71f7612b--36188d30877e4167a3fa26e11cfab8ed c472e9dc5f3c4f96a9db4a55d52a317a 36188d30877e4167a3fa26e11cfab8ed--c472e9dc5f3c4f96a9db4a55d52a317a b9be27498ce14b939e0cbb5229b1d430 RX(theta\u2081\u2081) c472e9dc5f3c4f96a9db4a55d52a317a--b9be27498ce14b939e0cbb5229b1d430 ec80aae2276047c787a327ab4eb80aec RY(theta\u2081\u2084) b9be27498ce14b939e0cbb5229b1d430--ec80aae2276047c787a327ab4eb80aec a1673700ec6a4ec2a93b26f9f9bf4af0 RX(theta\u2081\u2087) ec80aae2276047c787a327ab4eb80aec--a1673700ec6a4ec2a93b26f9f9bf4af0 5971e6c55eee417aa6c6f902c9dd5eee a1673700ec6a4ec2a93b26f9f9bf4af0--5971e6c55eee417aa6c6f902c9dd5eee 5971e6c55eee417aa6c6f902c9dd5eee--6fe97c334a274a1abc4e6832ad733ac2 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_771852f2d2494c68be51cbc1eb9d2f17 cluster_ce9e99fb90bb46928732b53d33681ab8 9b3b6d89c0144282b01af3312038966e 0 5590ff50da8d409787010d0cbfc7cdb5 RX(theta\u2080) 9b3b6d89c0144282b01af3312038966e--5590ff50da8d409787010d0cbfc7cdb5 c31c434907594ba4a0c7bb276b0aae1c 1 832e4fa43a0046b6a960a1f165638157 RY(theta\u2086) 5590ff50da8d409787010d0cbfc7cdb5--832e4fa43a0046b6a960a1f165638157 f5533adae6e444b89842ebb93ce2f736 RX(theta\u2081\u2082) 832e4fa43a0046b6a960a1f165638157--f5533adae6e444b89842ebb93ce2f736 9cefdef6a6ae4ce3a10def286b924bef f5533adae6e444b89842ebb93ce2f736--9cefdef6a6ae4ce3a10def286b924bef 255abbf6606d4f55bf0a631c9d72d83b RX(theta\u2081\u2088) 9cefdef6a6ae4ce3a10def286b924bef--255abbf6606d4f55bf0a631c9d72d83b 964192453a00491a8ba28f7cfe8813e3 RY(theta\u2082\u2084) 255abbf6606d4f55bf0a631c9d72d83b--964192453a00491a8ba28f7cfe8813e3 da40eb4d345d481a93c68cfba9416a3d RX(theta\u2083\u2080) 964192453a00491a8ba28f7cfe8813e3--da40eb4d345d481a93c68cfba9416a3d 8a7f4db4b00844f58c932430b3571edd da40eb4d345d481a93c68cfba9416a3d--8a7f4db4b00844f58c932430b3571edd e1ef52e85e774b56ae070286b3b9b784 8a7f4db4b00844f58c932430b3571edd--e1ef52e85e774b56ae070286b3b9b784 b671f36564944463898a4fcd4fe80671 e10a19eb369841a7900206659dd1146c RX(theta\u2081) c31c434907594ba4a0c7bb276b0aae1c--e10a19eb369841a7900206659dd1146c 0c958f8c58a347aa964ea86d29d9e1bb 2 f66e8da6835c4707baff89752f6b511c RY(theta\u2087) e10a19eb369841a7900206659dd1146c--f66e8da6835c4707baff89752f6b511c 9242cf3607894e5f84d3bd362355a605 RX(theta\u2081\u2083) f66e8da6835c4707baff89752f6b511c--9242cf3607894e5f84d3bd362355a605 14ff5d8c959d41ceac640b1ff098f600 9242cf3607894e5f84d3bd362355a605--14ff5d8c959d41ceac640b1ff098f600 743eee8040e14adb80847ce3ef196362 RX(theta\u2081\u2089) 14ff5d8c959d41ceac640b1ff098f600--743eee8040e14adb80847ce3ef196362 90187b34f603464db8298e818eb5049e RY(theta\u2082\u2085) 743eee8040e14adb80847ce3ef196362--90187b34f603464db8298e818eb5049e a5c158a260584406ae02401add363038 RX(theta\u2083\u2081) 90187b34f603464db8298e818eb5049e--a5c158a260584406ae02401add363038 b7b3ee5fda984b2aa71e0926cb27a18b a5c158a260584406ae02401add363038--b7b3ee5fda984b2aa71e0926cb27a18b b7b3ee5fda984b2aa71e0926cb27a18b--b671f36564944463898a4fcd4fe80671 2de4eb46c3b3462e80571ca8868654c5 868c89fd7e95495a88486c1946cc54c8 RX(theta\u2082) 0c958f8c58a347aa964ea86d29d9e1bb--868c89fd7e95495a88486c1946cc54c8 9635e892ecde48b3a556a8d686ca9b8b 3 8ade1652f2fe4186a81c0d71ecc69751 RY(theta\u2088) 868c89fd7e95495a88486c1946cc54c8--8ade1652f2fe4186a81c0d71ecc69751 60ffe4fe0065412da3f9c9fe14ea9402 RX(theta\u2081\u2084) 8ade1652f2fe4186a81c0d71ecc69751--60ffe4fe0065412da3f9c9fe14ea9402 8c42fd2ff1dd4071bb45eb759af18451 HamEvo 60ffe4fe0065412da3f9c9fe14ea9402--8c42fd2ff1dd4071bb45eb759af18451 848d46ab21f54cbf8725ae9b7854bffd RX(theta\u2082\u2080) 8c42fd2ff1dd4071bb45eb759af18451--848d46ab21f54cbf8725ae9b7854bffd 3340a8b4be7244c09e9f0f9ef3545bc9 RY(theta\u2082\u2086) 848d46ab21f54cbf8725ae9b7854bffd--3340a8b4be7244c09e9f0f9ef3545bc9 e1c4a431584041b3a501268516f08b6f RX(theta\u2083\u2082) 3340a8b4be7244c09e9f0f9ef3545bc9--e1c4a431584041b3a501268516f08b6f 442e34df95f5480f9556d815651cf182 HamEvo e1c4a431584041b3a501268516f08b6f--442e34df95f5480f9556d815651cf182 442e34df95f5480f9556d815651cf182--2de4eb46c3b3462e80571ca8868654c5 c24fde860b3e4e6baada1398e595701c e6111ace6d98405c9d9720bc28f0e885 RX(theta\u2083) 9635e892ecde48b3a556a8d686ca9b8b--e6111ace6d98405c9d9720bc28f0e885 50987744659947a89c080a449f1f00ac 4 26ac5986213d46b6b76a129293125119 RY(theta\u2089) e6111ace6d98405c9d9720bc28f0e885--26ac5986213d46b6b76a129293125119 fe6581b717fd406cace215cf7030a030 RX(theta\u2081\u2085) 26ac5986213d46b6b76a129293125119--fe6581b717fd406cace215cf7030a030 fda64a2a6f9446b4b7f433d6a67650e7 t = theta_t\u2080 fe6581b717fd406cace215cf7030a030--fda64a2a6f9446b4b7f433d6a67650e7 37d6ea742f574d3b85b0c0647f151125 RX(theta\u2082\u2081) fda64a2a6f9446b4b7f433d6a67650e7--37d6ea742f574d3b85b0c0647f151125 0bef5f811cb64824b263e7c7c4aec461 RY(theta\u2082\u2087) 37d6ea742f574d3b85b0c0647f151125--0bef5f811cb64824b263e7c7c4aec461 40ac6e70946c431fb498d4d9344c7c83 RX(theta\u2083\u2083) 0bef5f811cb64824b263e7c7c4aec461--40ac6e70946c431fb498d4d9344c7c83 89bdcc5c8273457bad869cca443065d0 t = theta_t\u2081 40ac6e70946c431fb498d4d9344c7c83--89bdcc5c8273457bad869cca443065d0 89bdcc5c8273457bad869cca443065d0--c24fde860b3e4e6baada1398e595701c d81d71644b624518839d6993d8030fb6 35b6f6d237054533ab75363b3566fb4c RX(theta\u2084) 50987744659947a89c080a449f1f00ac--35b6f6d237054533ab75363b3566fb4c 2c7e9874c9164ac5a02e1e9d36bbda61 5 91db015202974432b3c67834e1566f19 RY(theta\u2081\u2080) 35b6f6d237054533ab75363b3566fb4c--91db015202974432b3c67834e1566f19 bebdf576e84c42f99fe4ab96a751db08 RX(theta\u2081\u2086) 91db015202974432b3c67834e1566f19--bebdf576e84c42f99fe4ab96a751db08 ba0693bb676e47eca98adc4e4620d792 bebdf576e84c42f99fe4ab96a751db08--ba0693bb676e47eca98adc4e4620d792 237ec5a34fc6450687a98b7bdfbac108 RX(theta\u2082\u2082) ba0693bb676e47eca98adc4e4620d792--237ec5a34fc6450687a98b7bdfbac108 657ad305df4e4ba0b29fbdfa6b03a5c2 RY(theta\u2082\u2088) 237ec5a34fc6450687a98b7bdfbac108--657ad305df4e4ba0b29fbdfa6b03a5c2 77cb3449b36d42ddbe20250bb0f58760 RX(theta\u2083\u2084) 657ad305df4e4ba0b29fbdfa6b03a5c2--77cb3449b36d42ddbe20250bb0f58760 2d9bd4ca24674ede86e582b5b8de7aca 77cb3449b36d42ddbe20250bb0f58760--2d9bd4ca24674ede86e582b5b8de7aca 2d9bd4ca24674ede86e582b5b8de7aca--d81d71644b624518839d6993d8030fb6 1321b8cc70904491a222e80abf91d3ed fea6294cb5764f52a4952fad4ab85f22 RX(theta\u2085) 2c7e9874c9164ac5a02e1e9d36bbda61--fea6294cb5764f52a4952fad4ab85f22 0dcf005b960b48d2969014577b7ad673 RY(theta\u2081\u2081) fea6294cb5764f52a4952fad4ab85f22--0dcf005b960b48d2969014577b7ad673 baf46d13a7c54d0db45bfb0ab939dba8 RX(theta\u2081\u2087) 0dcf005b960b48d2969014577b7ad673--baf46d13a7c54d0db45bfb0ab939dba8 2df71671bb114100902ad9917c5524a2 baf46d13a7c54d0db45bfb0ab939dba8--2df71671bb114100902ad9917c5524a2 1daebf39a9974b5aa192fcf029008e28 RX(theta\u2082\u2083) 2df71671bb114100902ad9917c5524a2--1daebf39a9974b5aa192fcf029008e28 1ec78582780a4a218bf4797f1a1c357a RY(theta\u2082\u2089) 1daebf39a9974b5aa192fcf029008e28--1ec78582780a4a218bf4797f1a1c357a 7b1832b7dcc74dd9b6075e122acb1f4b RX(theta\u2083\u2085) 1ec78582780a4a218bf4797f1a1c357a--7b1832b7dcc74dd9b6075e122acb1f4b c4f9ad90be234926b80c28165031388a 7b1832b7dcc74dd9b6075e122acb1f4b--c4f9ad90be234926b80c28165031388a c4f9ad90be234926b80c28165031388a--1321b8cc70904491a222e80abf91d3ed"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_40771e4e68bc4c00a72bd371c3ed8b5b BPMA-1 cluster_48e76593b98b41e0b611edb9f215f130 BPMA-0 3a92cbcf0fdf42d9b4dc706e9b8a12e1 0 4e24e84cbcca495096aaf3777f9b588d RX(iia_\u03b1\u2080\u2080) 3a92cbcf0fdf42d9b4dc706e9b8a12e1--4e24e84cbcca495096aaf3777f9b588d e6b166c343c84696b1a6a3994edc4ace 1 bc902ec8f02a4aad971e9a4725a8aed9 RY(iia_\u03b1\u2080\u2083) 4e24e84cbcca495096aaf3777f9b588d--bc902ec8f02a4aad971e9a4725a8aed9 dacbde53a22c48f79fe60ec13951151a bc902ec8f02a4aad971e9a4725a8aed9--dacbde53a22c48f79fe60ec13951151a 9464e52c9613422e8ebd92922bad648f dacbde53a22c48f79fe60ec13951151a--9464e52c9613422e8ebd92922bad648f 4c3b2fb9d7cc47a1ae12339675379d17 RX(iia_\u03b3\u2080\u2080) 9464e52c9613422e8ebd92922bad648f--4c3b2fb9d7cc47a1ae12339675379d17 a76dd6977ee84ab9a3e68f62d8270f19 4c3b2fb9d7cc47a1ae12339675379d17--a76dd6977ee84ab9a3e68f62d8270f19 8d7db060377e46de9743373762267808 a76dd6977ee84ab9a3e68f62d8270f19--8d7db060377e46de9743373762267808 448202e6d6f642948e1801fa9b4a330f RY(iia_\u03b2\u2080\u2083) 8d7db060377e46de9743373762267808--448202e6d6f642948e1801fa9b4a330f 40d5844bae36408282f1f50bda135261 RX(iia_\u03b2\u2080\u2080) 448202e6d6f642948e1801fa9b4a330f--40d5844bae36408282f1f50bda135261 0090409183824fb3a498ac3fcc45f240 RX(iia_\u03b1\u2081\u2080) 40d5844bae36408282f1f50bda135261--0090409183824fb3a498ac3fcc45f240 87609fd3bba04307ae9ec1ac5e659d08 RY(iia_\u03b1\u2081\u2083) 0090409183824fb3a498ac3fcc45f240--87609fd3bba04307ae9ec1ac5e659d08 2c0e4fb8c09d4b098c6d1fe23059498b 87609fd3bba04307ae9ec1ac5e659d08--2c0e4fb8c09d4b098c6d1fe23059498b 55d4b9f674974bd19c8edf7f6f2a5c9f 2c0e4fb8c09d4b098c6d1fe23059498b--55d4b9f674974bd19c8edf7f6f2a5c9f c7ea74926b8441f1848030123e976822 RX(iia_\u03b3\u2081\u2080) 55d4b9f674974bd19c8edf7f6f2a5c9f--c7ea74926b8441f1848030123e976822 1d11a3a1a4654002b055dd6b280011b5 c7ea74926b8441f1848030123e976822--1d11a3a1a4654002b055dd6b280011b5 98771bc9d3044e8aa1a598fe3be27fe3 1d11a3a1a4654002b055dd6b280011b5--98771bc9d3044e8aa1a598fe3be27fe3 41225dbb97c14135943d80d45f3b3678 RY(iia_\u03b2\u2081\u2083) 98771bc9d3044e8aa1a598fe3be27fe3--41225dbb97c14135943d80d45f3b3678 63126ce36b81496cb7920778a3f0c2ed RX(iia_\u03b2\u2081\u2080) 41225dbb97c14135943d80d45f3b3678--63126ce36b81496cb7920778a3f0c2ed 35f09e1c62df4131ab2a62206821890d 63126ce36b81496cb7920778a3f0c2ed--35f09e1c62df4131ab2a62206821890d 4be7965ce53b4c28a479aa888de70bc8 eaa568aa9a5948e8ba2708dce78d69ff RX(iia_\u03b1\u2080\u2081) e6b166c343c84696b1a6a3994edc4ace--eaa568aa9a5948e8ba2708dce78d69ff bf0ab2a0378d45fd8eed69d8f2f4cbe6 2 0a9549e94fdd4a238e0a20a3211e2616 RY(iia_\u03b1\u2080\u2084) eaa568aa9a5948e8ba2708dce78d69ff--0a9549e94fdd4a238e0a20a3211e2616 f6af7c656c5f4e489bbd14c25c76172a X 0a9549e94fdd4a238e0a20a3211e2616--f6af7c656c5f4e489bbd14c25c76172a f6af7c656c5f4e489bbd14c25c76172a--dacbde53a22c48f79fe60ec13951151a ec4841bda8994e96b0a6f633bdd514eb f6af7c656c5f4e489bbd14c25c76172a--ec4841bda8994e96b0a6f633bdd514eb bdcc1224e3104dbb89a78b772e101756 RX(iia_\u03b3\u2080\u2081) ec4841bda8994e96b0a6f633bdd514eb--bdcc1224e3104dbb89a78b772e101756 9dbeb549c924484788d73516396c982c bdcc1224e3104dbb89a78b772e101756--9dbeb549c924484788d73516396c982c 02c9b754ad4b451f8b011fe998d7cc45 X 9dbeb549c924484788d73516396c982c--02c9b754ad4b451f8b011fe998d7cc45 02c9b754ad4b451f8b011fe998d7cc45--8d7db060377e46de9743373762267808 88c1755a25da4a9584b3484c0b40c01e RY(iia_\u03b2\u2080\u2084) 02c9b754ad4b451f8b011fe998d7cc45--88c1755a25da4a9584b3484c0b40c01e f41e60582c624533a52b76476fa110a4 RX(iia_\u03b2\u2080\u2081) 88c1755a25da4a9584b3484c0b40c01e--f41e60582c624533a52b76476fa110a4 a12e35ce1a9b4ffebeea28fe74f6f456 RX(iia_\u03b1\u2081\u2081) f41e60582c624533a52b76476fa110a4--a12e35ce1a9b4ffebeea28fe74f6f456 5fcefdf4c1354d3697128e1f520db66e RY(iia_\u03b1\u2081\u2084) a12e35ce1a9b4ffebeea28fe74f6f456--5fcefdf4c1354d3697128e1f520db66e 380c3afefa77487a993c5e6ac55a3106 X 5fcefdf4c1354d3697128e1f520db66e--380c3afefa77487a993c5e6ac55a3106 380c3afefa77487a993c5e6ac55a3106--2c0e4fb8c09d4b098c6d1fe23059498b d368cae96a9e415d93953f783a88f722 380c3afefa77487a993c5e6ac55a3106--d368cae96a9e415d93953f783a88f722 7653199d26d74cb2a7881284458283b9 RX(iia_\u03b3\u2081\u2081) d368cae96a9e415d93953f783a88f722--7653199d26d74cb2a7881284458283b9 aab93b3c343546dabc814e927a6a1de2 7653199d26d74cb2a7881284458283b9--aab93b3c343546dabc814e927a6a1de2 f2151f0107014d119d6e284223e6da32 X aab93b3c343546dabc814e927a6a1de2--f2151f0107014d119d6e284223e6da32 f2151f0107014d119d6e284223e6da32--98771bc9d3044e8aa1a598fe3be27fe3 5680bec9beb54e439045a3a10838073a RY(iia_\u03b2\u2081\u2084) f2151f0107014d119d6e284223e6da32--5680bec9beb54e439045a3a10838073a cb25269c71054d34b45269bb5d8ee14f RX(iia_\u03b2\u2081\u2081) 5680bec9beb54e439045a3a10838073a--cb25269c71054d34b45269bb5d8ee14f cb25269c71054d34b45269bb5d8ee14f--4be7965ce53b4c28a479aa888de70bc8 4b078464a884409ba31ddd1076898866 a5c7dbc6fe6e47a6992a0ca1d62630d8 RX(iia_\u03b1\u2080\u2082) bf0ab2a0378d45fd8eed69d8f2f4cbe6--a5c7dbc6fe6e47a6992a0ca1d62630d8 1c52fff534064db4be45da85a5776b83 RY(iia_\u03b1\u2080\u2085) a5c7dbc6fe6e47a6992a0ca1d62630d8--1c52fff534064db4be45da85a5776b83 fe9bad1b814f4b19928d19f462a97e3a 1c52fff534064db4be45da85a5776b83--fe9bad1b814f4b19928d19f462a97e3a 2001f0296230497884959b9680f2a53d X fe9bad1b814f4b19928d19f462a97e3a--2001f0296230497884959b9680f2a53d 2001f0296230497884959b9680f2a53d--ec4841bda8994e96b0a6f633bdd514eb f02ebbf0ff42421db5faca04ad2d9ab4 RX(iia_\u03b3\u2080\u2082) 2001f0296230497884959b9680f2a53d--f02ebbf0ff42421db5faca04ad2d9ab4 76bbc957418f47c59ae460f7dfdf4744 X f02ebbf0ff42421db5faca04ad2d9ab4--76bbc957418f47c59ae460f7dfdf4744 76bbc957418f47c59ae460f7dfdf4744--9dbeb549c924484788d73516396c982c d63bdecf571c4b84ad48cba8a56fa879 76bbc957418f47c59ae460f7dfdf4744--d63bdecf571c4b84ad48cba8a56fa879 44d5b9ea1dae4e90826e21a3eb854a90 RY(iia_\u03b2\u2080\u2085) d63bdecf571c4b84ad48cba8a56fa879--44d5b9ea1dae4e90826e21a3eb854a90 18f0539001ba48f9baee3a457ff96ab9 RX(iia_\u03b2\u2080\u2082) 44d5b9ea1dae4e90826e21a3eb854a90--18f0539001ba48f9baee3a457ff96ab9 4b2b88a0fba743099156db90c10ce822 RX(iia_\u03b1\u2081\u2082) 18f0539001ba48f9baee3a457ff96ab9--4b2b88a0fba743099156db90c10ce822 f3fd2c3f900a445986a90986c5fb0dc3 RY(iia_\u03b1\u2081\u2085) 4b2b88a0fba743099156db90c10ce822--f3fd2c3f900a445986a90986c5fb0dc3 d3ab4dc3fa5b4a74b38b5fabc2033d5a f3fd2c3f900a445986a90986c5fb0dc3--d3ab4dc3fa5b4a74b38b5fabc2033d5a 97d9b9f951154e35a966be01bf75ac02 X d3ab4dc3fa5b4a74b38b5fabc2033d5a--97d9b9f951154e35a966be01bf75ac02 97d9b9f951154e35a966be01bf75ac02--d368cae96a9e415d93953f783a88f722 d88dde6fa1dd4c2bbb41ed66679f671f RX(iia_\u03b3\u2081\u2082) 97d9b9f951154e35a966be01bf75ac02--d88dde6fa1dd4c2bbb41ed66679f671f ceb9a21768b549ad85e9d004698e4436 X d88dde6fa1dd4c2bbb41ed66679f671f--ceb9a21768b549ad85e9d004698e4436 ceb9a21768b549ad85e9d004698e4436--aab93b3c343546dabc814e927a6a1de2 02339f6075a34973bd6d4e094b3d0341 ceb9a21768b549ad85e9d004698e4436--02339f6075a34973bd6d4e094b3d0341 296cf1fb869048cc94827443380f9137 RY(iia_\u03b2\u2081\u2085) 02339f6075a34973bd6d4e094b3d0341--296cf1fb869048cc94827443380f9137 9c638c7406a64a7fabeec358f8c4a8d4 RX(iia_\u03b2\u2081\u2082) 296cf1fb869048cc94827443380f9137--9c638c7406a64a7fabeec358f8c4a8d4 9c638c7406a64a7fabeec358f8c4a8d4--4b078464a884409ba31ddd1076898866"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>Sample-based measurement protocols are fundamental tools for the prediction and estimation of a quantum state as the result of NISQ programs executions. Their resource efficient implementation is a current and active research field. Qadence offers two main measurement protocols: quantum state tomography and classical shadows.</p>"},{"location":"realistic_sims/measurements/#quantum-state-tomography","title":"Quantum state tomography","text":"<p>The fundamental task of quantum state tomography is to learn an approximate classical description of an output quantum state described by a density matrix \\(\\rho\\), from repeated measurements of copies on a chosen basis. To do so, \\(\\rho\\) is expanded in a basis of observables (the tomography step) and for a given observable \\(\\hat{\\mathcal{O}}\\), the expectation value is calculated with \\(\\langle \\hat{\\mathcal{O}} \\rangle=\\textrm{Tr}(\\hat{\\mathcal{O}}\\rho)\\). A number of measurement repetitions in a suitable basis is then required to estimate \\(\\langle \\hat{\\mathcal{O}} \\rangle\\).</p> <p>The main drawback is the scaling in measurements for the retrieval of the classical expression for a \\(n\\)-qubit quantum state as \\(2^n \\times 2^n\\), together with a large amount of classical post-processing.</p> <p>For an observable expressed as a Pauli string \\(\\hat{\\mathcal{P}}\\), the expectation value for a state \\(|\\psi \\rangle\\) can be derived as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\langle \\psi | \\hat{\\mathcal{P}} |\\psi \\rangle=\\langle \\psi | \\hat{\\mathcal{R}}^\\dagger \\hat{\\mathcal{D}} \\hat{\\mathcal{R}} |\\psi \\rangle \\] <p>The operator \\(\\hat{\\mathcal{R}}\\) diagonalizes \\(\\hat{\\mathcal{P}}\\) and rotates the state into an eigenstate in the computational basis. Therefore, \\(\\hat{\\mathcal{R}}|\\psi \\rangle=\\sum\\limits_{z}a_z|z\\rangle\\) and the expectation value can finally be expressed as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\sum_{z,z'}\\langle z |\\bar{a}_z\\hat{\\mathcal{D}}a_{z'}|z'\\rangle = \\sum_{z}|a_z|^2(-1)^{\\phi_z(\\hat{\\mathcal{P}})} \\] <p>In Qadence, running a tomographical experiment is made simple by defining a <code>Measurements</code> object that captures all options for execution:</p> <pre><code>from torch import tensor\nfrom qadence import hamiltonian_factory, BackendName, DiffMode\nfrom qadence import Parameter, chain, kron, RX, RY, Z, QuantumCircuit, QuantumModel\nfrom qadence.measurements import Measurements\n\n# Define parameters for a circuit.\ntheta1 = Parameter(\"theta1\", trainable=False)\ntheta2 = Parameter(\"theta2\", trainable=False)\ntheta3 = Parameter(\"theta3\", trainable=False)\ntheta4 = Parameter(\"theta4\", trainable=False)\n\nblocks = chain(\n    kron(RX(0, theta1), RY(1, theta2)),\n    kron(RX(0, theta3), RY(1, theta4)),\n)\n\nvalues = {\n    \"theta1\": tensor([0.5]),\n    \"theta2\": tensor([1.5]),\n    \"theta3\": tensor([2.0]),\n    \"theta4\": tensor([2.5]),\n}\n\n# Create a circuit and an observable.\ncircuit = QuantumCircuit(2, blocks)\nobservable = hamiltonian_factory(2, detuning=Z)\n\n# Create a model.\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n)\n\n# Define a measurement protocol by passing the shot budget as an option.\ntomo_options = {\"n_shots\": 100000}\ntomo_measurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=tomo_options)\n\n# Get the exact expectation value.\nexact_values = model.expectation(\n    values=values,\n)\n\n# Run the tomography experiment.\nestimated_values_tomo = model.expectation(\n    values=values,\n    measurement=tomo_measurement,\n)\n</code></pre> <pre><code>Exact expectation value = tensor([[-1.4548]])\nEstimated expectation value tomo = tensor([[-1.4503]])\n</code></pre>"},{"location":"realistic_sims/measurements/#classical-shadows","title":"Classical shadows","text":"<p>Recently, a much less resource demanding protocol based on classical shadows has been proposed<sup>1</sup>. It combines ideas from shadow tomography<sup>2</sup> and randomized measurement protocols capable of learning a classical shadow of an unknown quantum state \\(\\rho\\). It relies on deliberately discarding the full classical characterization of the quantum state, and instead focuses on accurately predicting a restricted set of properties that provide efficient protocols for the study of the system.</p> <p>A random measurement consists of applying random unitary rotations before a fixed measurement on each copy of a state. Appropriately averaging over these measurements produces an efficient estimator for the expectation value of an observable. This protocol therefore creates a robust classical representation of the quantum state or classical shadow. The captured measurement information is then reuseable for multiple purposes, i.e. any observable expected value and available for noise mitigation postprocessing.</p> <p>A classical shadow is therefore an unbiased estimator of a quantum state \\(\\rho\\). Such an estimator is obtained with the following procedure<sup>1</sup>: first, apply a random unitary gate \\(U\\) to rotate the state: \\(\\rho \\rightarrow U \\rho U^\\dagger\\) and then perform a basis measurement to obtain a \\(n\\)-bit measurement \\(|\\hat{b}\\rangle \\in \\{0, 1\\}^n\\). Both unitary gates \\(U\\) and the measurement outcomes \\(|\\hat{b}\\rangle\\) are stored on a classical computer for postprocessing v \\(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U\\), a classical snapshot of the state \\(\\rho\\). The whole procedure can be seen as a quantum channel \\(\\mathcal{M}\\) that maps the initial unknown quantum state \\(\\rho\\) to the average result of the measurement protocol:</p> \\[ \\mathbb{E}[U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U] = \\mathcal{M}(\\rho) \\Rightarrow \\rho = \\mathbb{E}[\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)] \\] <p>It is worth noting that the single classical snapshot \\(\\hat{\\rho}=\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)\\) equals \\(\\rho\\) in expectation: \\(\\mathbb{E}[\\hat{\\rho}]=\\rho\\) despite \\(\\mathcal{M}^{-1}\\) not being a completely positive map. Repeating this procedure \\(N\\) times results in an array of \\(N\\) independent, classical snapshots of \\(\\rho\\) called the classical shadow:</p> \\[ S(\\rho, N) = \\{ \\hat{\\rho}_1=\\mathcal{M}^{-1}(U_1^\\dagger |\\hat{b}_1\\rangle\\langle \\hat{b}_1|U_1),\\cdots,\\hat{\\rho}_N=\\mathcal{M}^{-1}(U_N^\\dagger |\\hat{b}_N\\rangle\\langle \\hat{b}_N|U_N)\\} \\] <p>Along the same lines as the example before, estimating the expectation value using classical shadows in Qadence only requires to pass the right set of parameters to the <code>Measurements</code> object:</p> <pre><code># Classical shadows are defined up to some accuracy and confidence.\nshadow_options = {\"accuracy\": 0.1, \"confidence\": 0.1}  # Shadow size N=54400.\nshadow_measurement = Measurements(protocol=Measurements.SHADOW, options=shadow_options)\n\n# Run the experiment with classical shadows.\nestimated_values_shadow = model.expectation(\n    values=values,\n    measurement=shadow_measurement,\n)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-1.5018]])\n</code></pre>"},{"location":"realistic_sims/measurements/#references","title":"References","text":"<ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9\u21a9</p> </li> <li> <p>S. Aaronson. Shadow tomography of quantum states. In Proceedings of the 50th Annual A ACM SIGACT Symposium on Theory of Computing, STOC 2018, pages 325\u2013338, New York, NY, USA, 2018. ACM\u00a0\u21a9</p> </li> </ol>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>Beyond running noisy simulations, Qadence offers a number of noise mitigation techniques to achieve better accuracy of simulation outputs. Currently, mitigation addresses readout errors and depolarizing and dephasing noise for analog blocks.</p>"},{"location":"realistic_sims/mitigation/#readout-error-mitigation","title":"Readout error mitigation","text":"<p>The complete implementation of the mitigation technique is to measure \\(T\\) and classically apply \\(T^{\u22121}\\) to measured probability distributions. However there are several limitations of this approach:</p> <ul> <li>The complete implementation requires \\(2^n\\) characterization experiments (probability measurements), which is not scalable. The classical processing of the calibration data is also inefficient.</li> <li>The matrix \\(T\\) may become singular for large \\(n\\), preventing direct inversion.</li> <li>The inverse \\(T^{\u22121}\\) might not be a stochastic matrix, meaning that it can produce negative corrected probabilities.</li> <li>The correction is not rigorously justified, so we cannot be sure that we are only removing SPAM errors and not otherwise corrupting an estimated probability distribution.</li> </ul> <p>Qadence relies on the assumption of uncorrelated readout errors:</p> \\[ T=T_1\\otimes T_2\\otimes \\dots \\otimes T_n \\] <p>for which the inversion is straightforward:</p> \\[ T^{-1}=T_1^{-1}\\otimes T_2^{-1}\\otimes \\dots \\otimes T_n^{-1} \\] <p>However, even for a reduced \\(n\\) the third limitation holds. This can be avoided by reformulating into a minimization problem<sup>1</sup>:</p> \\[ \\lVert Tp_{\\textrm{corr}}-p_{\\textrm{raw}}\\rVert_{2}^{2} \\] <p>subjected to physicality constraints \\(0 \\leq p_{corr}(x) \\leq 1\\) and \\(\\lVert p_{corr} \\rVert = 1\\). At this point, two methods are implemented to solve this problem. The first one relies on solving using standard optimization tools, the second on Maximum-Likelihood Estimation<sup>2</sup>. In Qadence, this can be user defined using the mitigation protocol:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\nfrom qadence.mitigations import Mitigations\nfrom qadence.types import ReadOutOptimization\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use:\nnoise = Noise(protocol=Noise.READOUT)\n# Define the mitigation method solving the minimization problem:\noptions={\"optimization_type\": ReadOutOptimization.CONSTRAINED}  # ReadOutOptimization.MLE for the alternative method.\nmitigation = Mitigations(protocol=Mitigations.READOUT, options=options)\n\n# Run noiseless, noisy and mitigated simulations.\nn_shots = 100\nnoiseless_samples = model.sample(n_shots=n_shots)\nnoisy_samples = model.sample(noise=noise, n_shots=n_shots)\nmitigated_samples = model.sample(\n    noise=noise, mitigation=mitigation, n_shots=n_shots\n)\n\nprint(f\"noiseless {noiseless_samples}\")\nprint(f\"noisy {noisy_samples}\")\nprint(f\"mitigated {mitigated_samples}\")\n</code></pre> <pre><code>noiseless [Counter({'10': 54, '00': 46})]\nnoisy [Counter({'10': 52, '00': 39, '01': 6, '11': 3})]\nmitigated [Counter({'10': 44, '00': 43, '11': 7, '01': 6})]\n</code></pre>"},{"location":"realistic_sims/mitigation/#wip-zero-noise-extrapolation-for-analog-blocks","title":"[WIP] Zero-noise extrapolation for analog blocks","text":"<p>Zero-noise extrapolation (ZNE) is an error mitigation technique in which an expectation value is computed at different noise levels and, as a second step, the ideal expectation value is inferred by extrapolating the measured results to the zero-noise limit. In digital computing, this is typically implemented by \"folding\" the circuit and its dagger to artificially increase the noise through sequences of identities<sup>3</sup>. In the analog ZNE variation, analog blocks are time stretched to again artificially increase noise<sup>3</sup>.</p>"},{"location":"realistic_sims/mitigation/#references","title":"References","text":"<ol> <li> <p>Michael R. Geller and Mingyu Sun, Efficient correction of multiqubit measurement errors, (2020) \u21a9</p> </li> <li> <p>Smolin et al., Maximum Likelihood, Minimum Effort, (2011) \u21a9</p> </li> <li> <p>Mitiq: What's the theory behind ZNE? \u21a9\u21a9</p> </li> </ol>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. They are typically described using confusion matrices of the form:</p> \\[ T(x|x')=\\delta_{xx'} \\] <p>Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'10': 55, '00': 45})]\nnoisy = [Counter({'00': 49, '10': 46, '11': 4, '01': 1})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[1.0126]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9760]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': e773e66d-e2b4-4146-85cb-923e93f262f6, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': c6f81eee-f268-49e3-84a9-0f61f5c4ff53, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 97513d3e-0ceb-49e1-a255-483fd361da38, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 98c90f12-f3a8-478b-8583-68a3b019bec6, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': ab9ed322-db5e-41e5-b349-c069a7b456cb, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 1bbe9eb7-b624-42c6-87f8-6f528eb3e558, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': fe545bd9-2d0f-4558-89fb-44865cfa3b3e, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 4a585fa2-d369-491d-911a-4a92a6c83d2c, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 9ad9959f-bb32-4303-bc64-2abe439ed0b1, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': b8b43d0e-84e4-4915-ba66-4a2a3a869c04, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': c3fa94b0-21ff-424e-9e3b-0a3a5df1ccb4, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_6: tensor([0.3384], requires_grad=True)\n  theta_0: tensor([0.2443], requires_grad=True)\n  theta_3: tensor([0.9100], requires_grad=True)\n  theta_8: tensor([0.4730], requires_grad=True)\n  theta_5: tensor([0.1901], requires_grad=True)\n  theta_7: tensor([0.5714], requires_grad=True)\n  theta_4: tensor([0.4681], requires_grad=True)\n  theta_1: tensor([0.0567], requires_grad=True)\n  theta_2: tensor([0.0286], requires_grad=True)\n}\nembedded = {\n  e773e66d-e2b4-4146-85cb-923e93f262f6: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  c6f81eee-f268-49e3-84a9-0f61f5c4ff53: tensor([2., 2.])\n  97513d3e-0ceb-49e1-a255-483fd361da38: tensor([0.2443], grad_fn=&lt;ViewBackward0&gt;)\n  98c90f12-f3a8-478b-8583-68a3b019bec6: tensor([0.0567], grad_fn=&lt;ViewBackward0&gt;)\n  ab9ed322-db5e-41e5-b349-c069a7b456cb: tensor([0.0286], grad_fn=&lt;ViewBackward0&gt;)\n  1bbe9eb7-b624-42c6-87f8-6f528eb3e558: tensor([0.9100], grad_fn=&lt;ViewBackward0&gt;)\n  fe545bd9-2d0f-4558-89fb-44865cfa3b3e: tensor([0.4681], grad_fn=&lt;ViewBackward0&gt;)\n  4a585fa2-d369-491d-911a-4a92a6c83d2c: tensor([0.1901], grad_fn=&lt;ViewBackward0&gt;)\n  9ad9959f-bb32-4303-bc64-2abe439ed0b1: tensor([0.3384], grad_fn=&lt;ViewBackward0&gt;)\n  b8b43d0e-84e4-4915-ba66-4a2a3a869c04: tensor([0.5714], grad_fn=&lt;ViewBackward0&gt;)\n  c3fa94b0-21ff-424e-9e3b-0a3a5df1ccb4: tensor([0.4730], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  theta_0: tensor([0.2443], grad_fn=&lt;ViewBackward0&gt;)\n  theta_3: tensor([0.9100], grad_fn=&lt;ViewBackward0&gt;)\n  y: tensor([2., 2.])\n  theta_8: tensor([0.4730], grad_fn=&lt;ViewBackward0&gt;)\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.1901], grad_fn=&lt;ViewBackward0&gt;)\n  theta_7: tensor([0.5714], grad_fn=&lt;ViewBackward0&gt;)\n  theta_4: tensor([0.4681], grad_fn=&lt;ViewBackward0&gt;)\n  theta_6: tensor([0.3384], grad_fn=&lt;ViewBackward0&gt;)\n  theta_1: tensor([0.0567], grad_fn=&lt;ViewBackward0&gt;)\n  theta_2: tensor([0.0286], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.1024-0.2150j, -0.0442-0.0478j,  0.1181-0.0056j,  0.1793+0.3932j,\n         -0.6275-0.4645j, -0.1817+0.1123j,  0.0725+0.0232j,  0.0196+0.2776j],\n        [ 0.1024-0.2150j, -0.0442-0.0478j,  0.1181-0.0056j,  0.1793+0.3932j,\n         -0.6275-0.4645j, -0.1817+0.1123j,  0.0725+0.0232j,  0.0196+0.2776j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 250, '100': 190, '011': 145, '111': 140, '001': 88, '110': 67, '101': 62, '010': 58})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(e773e66d-e2b4-4146-85cb-923e93f262f6)-C----------------------------------------Rx(97513d3e-0ceb-49e1-a255-483fd361da38)-Ry(1bbe9eb7-b624-42c6-87f8-6f528eb3e558)-Rx(9ad9959f-bb32-4303-bc64-2abe439ed0b1)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(c6f81eee-f268-49e3-84a9-0f61f5c4ff53)-X----------------------------------------Rx(98c90f12-f3a8-478b-8583-68a3b019bec6)-Ry(fe545bd9-2d0f-4558-89fb-44865cfa3b3e)-Rx(b8b43d0e-84e4-4915-ba66-4a2a3a869c04)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(ab9ed322-db5e-41e5-b349-c069a7b456cb)-Ry(4a585fa2-d369-491d-911a-4a92a6c83d2c)-Rx(c3fa94b0-21ff-424e-9e3b-0a3a5df1ccb4)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [1bbe9eb7-b624-42c6-87f8-6f528eb3e558, 4a585fa2-d369-491d-911a-4a92a6c83d2c, 97513d3e-0ceb-49e1-a255-483fd361da38, 98c90f12-f3a8-478b-8583-68a3b019bec6, 9ad9959f-bb32-4303-bc64-2abe439ed0b1, ab9ed322-db5e-41e5-b349-c069a7b456cb, b8b43d0e-84e4-4915-ba66-4a2a3a869c04, c3fa94b0-21ff-424e-9e3b-0a3a5df1ccb4, c6f81eee-f268-49e3-84a9-0f61f5c4ff53, e773e66d-e2b4-4146-85cb-923e93f262f6, fe545bd9-2d0f-4558-89fb-44865cfa3b3e].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(1.23)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.24)-DEPO(0.1)-Ry(0.91)-DEPO(0.1)-Rx(0.34)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.83)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.06)-DEPO(0.1)-Ry(0.47)-DEPO(0.1)-Rx(0.57)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.03)-DEPO(0.1)-Ry(0.19)-DEPO(0.1)-Rx(0.47)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 5d0aa1675a3745a8958d7ac60d97c5ed 0 aa5b2a53422440cfa46214a457680dd9 X 5d0aa1675a3745a8958d7ac60d97c5ed--aa5b2a53422440cfa46214a457680dd9 b36ede26dd4b4eedb03cd48fb0b4153f 1 cf64ac361c39457db819630e3f97972d aa5b2a53422440cfa46214a457680dd9--cf64ac361c39457db819630e3f97972d af986badd56645c4ac530d49b9d846d3 2eaaec1ef1314396988e73b80708491c Y b36ede26dd4b4eedb03cd48fb0b4153f--2eaaec1ef1314396988e73b80708491c 2eaaec1ef1314396988e73b80708491c--af986badd56645c4ac530d49b9d846d3 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 fe6904489dd2435e966bc034720d1cb0 0 824326cb79454d06973259fbb6c9d8ea RX(0.5) fe6904489dd2435e966bc034720d1cb0--824326cb79454d06973259fbb6c9d8ea c1941b1ad77b44cc9feab0bd765b2814 824326cb79454d06973259fbb6c9d8ea--c1941b1ad77b44cc9feab0bd765b2814 <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 c67f5647901047e8937439d45d8dc2a9 0 e6b34dd476ff4f6883257597595faca4 c67f5647901047e8937439d45d8dc2a9--e6b34dd476ff4f6883257597595faca4 36276a2de9114029af6218f1d546d559 1 7fee931e8c754cefbbd18f98fa433aa0 e6b34dd476ff4f6883257597595faca4--7fee931e8c754cefbbd18f98fa433aa0 176d550e121a4ad0b8619785a6869975 6174e1a2c0eb4335b85d8f1b7d812d01 X 36276a2de9114029af6218f1d546d559--6174e1a2c0eb4335b85d8f1b7d812d01 6174e1a2c0eb4335b85d8f1b7d812d01--e6b34dd476ff4f6883257597595faca4 6174e1a2c0eb4335b85d8f1b7d812d01--176d550e121a4ad0b8619785a6869975 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 9854b569a37849929217873a95ef7218 0 dfb43223bf6b4133af443cb970d46b38 X 9854b569a37849929217873a95ef7218--dfb43223bf6b4133af443cb970d46b38 d4e582558d3d4ee4902da1cda8e70fd4 X dfb43223bf6b4133af443cb970d46b38--d4e582558d3d4ee4902da1cda8e70fd4 198bb08ee8bb43f8926602ffea18db40 d4e582558d3d4ee4902da1cda8e70fd4--198bb08ee8bb43f8926602ffea18db40 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 6e728cb5ce174cbfb5e6b34022918332 0 1ea4f9dcc4b74e928d4ceab84e91e841 X 6e728cb5ce174cbfb5e6b34022918332--1ea4f9dcc4b74e928d4ceab84e91e841 706e624ce88440639ff0cff699cbb0cc 1 e2bb9a60f58a42948abd78699a39c7bc 1ea4f9dcc4b74e928d4ceab84e91e841--e2bb9a60f58a42948abd78699a39c7bc e1c3e2dde07c4a2fa697a87687fbf83c e2bb9a60f58a42948abd78699a39c7bc--e1c3e2dde07c4a2fa697a87687fbf83c 8585bdff16e141819b27046aaa2d6844 9b9ace5d59c245fbb1b4ce2203454fd9 706e624ce88440639ff0cff699cbb0cc--9b9ace5d59c245fbb1b4ce2203454fd9 0b907e296cf6454da19ec289d1d265f1 X 9b9ace5d59c245fbb1b4ce2203454fd9--0b907e296cf6454da19ec289d1d265f1 0b907e296cf6454da19ec289d1d265f1--8585bdff16e141819b27046aaa2d6844 </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 2176be6a38724f039c5a72fe8697a949 0 4f416f9454de461ebb6ebcb5761d8506 X 2176be6a38724f039c5a72fe8697a949--4f416f9454de461ebb6ebcb5761d8506 fafd22063692493a8624b3238b0fae61 1 39f66708779d498fb4df4c7aac644c51 4f416f9454de461ebb6ebcb5761d8506--39f66708779d498fb4df4c7aac644c51 34d31280b73d4ed080dac5c42485e089 3f45d22b295a455fa6feab44e4b1e8b8 X fafd22063692493a8624b3238b0fae61--3f45d22b295a455fa6feab44e4b1e8b8 3f45d22b295a455fa6feab44e4b1e8b8--34d31280b73d4ed080dac5c42485e089 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_df49a8b0f4b848c8b9084c190e3f16ad subblock cluster_84267126be224804ba44ca30fcb5981e subblock 608c1ed66a56407abe93ae78ab587d34 0 df69956b87c744e7be48e915eb976879 X 608c1ed66a56407abe93ae78ab587d34--df69956b87c744e7be48e915eb976879 79ad3b85990f47dbb4530411b0b31da5 1 80f9e61a6b244a80912dd39482015bd3 X df69956b87c744e7be48e915eb976879--80f9e61a6b244a80912dd39482015bd3 53d28a56fb4b40fead534878a0860201 80f9e61a6b244a80912dd39482015bd3--53d28a56fb4b40fead534878a0860201 24e40ffbba454380a408f868936e3c6f 2628edd55d8d4ea481deee21dd648e4f Y 79ad3b85990f47dbb4530411b0b31da5--2628edd55d8d4ea481deee21dd648e4f bbb9a528efa64660963d0eea094a7a28 2 b1e5bc6f266b4b2784338785fd69c7df Y 2628edd55d8d4ea481deee21dd648e4f--b1e5bc6f266b4b2784338785fd69c7df b1e5bc6f266b4b2784338785fd69c7df--24e40ffbba454380a408f868936e3c6f ba523cd8a9a74d1491b39f6fdc0abde7 2208577595264e9aae7c950261902256 bbb9a528efa64660963d0eea094a7a28--2208577595264e9aae7c950261902256 bc33b7da0db44eb38e3f8cb57a84e97c 3 3a5235e574f341de8816632051fc4539 2208577595264e9aae7c950261902256--3a5235e574f341de8816632051fc4539 3a5235e574f341de8816632051fc4539--ba523cd8a9a74d1491b39f6fdc0abde7 e0a1bcfd59164359bbb5b90b7bc786a0 364cd2c3e34b4b4c89f40f92f7ef4fc0 bc33b7da0db44eb38e3f8cb57a84e97c--364cd2c3e34b4b4c89f40f92f7ef4fc0 86c2c06d4e074915b31fd087336cedfc 4 cfa31ff102df4c82a44f925c042223f4 364cd2c3e34b4b4c89f40f92f7ef4fc0--cfa31ff102df4c82a44f925c042223f4 cfa31ff102df4c82a44f925c042223f4--e0a1bcfd59164359bbb5b90b7bc786a0 ee26465371f34effa143a9b49704e03b e192932d11d84f92b95633a4b44697ba X 86c2c06d4e074915b31fd087336cedfc--e192932d11d84f92b95633a4b44697ba e192932d11d84f92b95633a4b44697ba--364cd2c3e34b4b4c89f40f92f7ef4fc0 05b48ed02c114f18ab9dcfb25ae8c758 X e192932d11d84f92b95633a4b44697ba--05b48ed02c114f18ab9dcfb25ae8c758 05b48ed02c114f18ab9dcfb25ae8c758--cfa31ff102df4c82a44f925c042223f4 05b48ed02c114f18ab9dcfb25ae8c758--ee26465371f34effa143a9b49704e03b"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'11': 262, '00': 249, '10': 248, '01': 241})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'100': 30, '010': 27, '000': 24, '110': 19})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Alternatively, a custom interaction function can also be defined. The input should be two integer indices \\(i\\) and \\(j\\) and it should return a composition of pauli terms representing the interaction between qubits \\(i\\) and \\(j\\):</p> <pre><code>def custom_int(i: int, j: int):\n    return X(i) @ X(j) + Y(i) @ Y(j)\n\nn_qubits = 2\n\nhamilt = hamiltonian_factory(n_qubits, interaction=custom_int)\n</code></pre> <pre><code>AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 AddBlock(0,1)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u251c\u2500\u2500 X(0)\n        \u2502   \u2514\u2500\u2500 X(1)\n        \u2514\u2500\u2500 KronBlock(0,1)\n            \u251c\u2500\u2500 Y(0)\n            \u2514\u2500\u2500 Y(1)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(1)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import numpy as np\nfrom torch import tensor\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea, PI\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": tensor([PI / 2, PI])}\nvalues_ket = {\"psi\": tensor([PI / 2, PI])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[0.2568, 0.0030],\n        [0.0140, 0.0074]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from qadence import RX, run, PI\n\n# Let's use a torch type.\nblock = RX(0, PI)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9048+0.0000j, 0.0000-0.4258j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.9633+0.0000j, 0.0000-0.2685j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.8746+0.0000j, 0.3181+0.0000j, 0.0000-0.3439j, 0.0000-0.1251j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_fd2e3f9611aa4370918c0d76c032e7e5 [* 2] cluster_3764877a1a88457eacc28fb9cbd29ebf Rotations 959ae593f7c04b8da01d231fc45382b5 0 e665ba6f3f1747bea84616d630936a2d RX(phi/theta) 959ae593f7c04b8da01d231fc45382b5--e665ba6f3f1747bea84616d630936a2d 928eb6cce00a42c2a5d908457ee374b8 1 bfd50508c03c4e89bc057bd75d74a82b RX(phi) e665ba6f3f1747bea84616d630936a2d--bfd50508c03c4e89bc057bd75d74a82b 90c2f0fa446a488282bf0ff137bb7cf8 RX(phi) bfd50508c03c4e89bc057bd75d74a82b--90c2f0fa446a488282bf0ff137bb7cf8 f1ccd4e4e4444e40b259897a16cb9b3d RX(phi + theta) 90c2f0fa446a488282bf0ff137bb7cf8--f1ccd4e4e4444e40b259897a16cb9b3d 43b0e82569c949e6b9e5a6e541c68e2c f1ccd4e4e4444e40b259897a16cb9b3d--43b0e82569c949e6b9e5a6e541c68e2c a5941e8c57ad457a988100a38c578153 43b0e82569c949e6b9e5a6e541c68e2c--a5941e8c57ad457a988100a38c578153 7fa6ecf999a6472498ff4c58c049c73c Z a5941e8c57ad457a988100a38c578153--7fa6ecf999a6472498ff4c58c049c73c d019727e4f584cd58ee512d2f2a4c119 7fa6ecf999a6472498ff4c58c049c73c--d019727e4f584cd58ee512d2f2a4c119 c7091a8527e248f6941bb82d1cafafdf 41fd506eed0c46619a6ef32b6aae5eff RY(2*theta) 928eb6cce00a42c2a5d908457ee374b8--41fd506eed0c46619a6ef32b6aae5eff 89d54b9923c446b78f91a94062aa5a18 2 cfe72fc204c84f49b49aad9fe23decd4 RY(theta) 41fd506eed0c46619a6ef32b6aae5eff--cfe72fc204c84f49b49aad9fe23decd4 3c5fff976a0b4ee7bf65f27113e72145 RY(theta) cfe72fc204c84f49b49aad9fe23decd4--3c5fff976a0b4ee7bf65f27113e72145 410bd9de23b24f7595533ab8ad610cae RY(theta**2) 3c5fff976a0b4ee7bf65f27113e72145--410bd9de23b24f7595533ab8ad610cae b26b02dc6c6b4b69ade0eb24c0c1616a X 410bd9de23b24f7595533ab8ad610cae--b26b02dc6c6b4b69ade0eb24c0c1616a b26b02dc6c6b4b69ade0eb24c0c1616a--43b0e82569c949e6b9e5a6e541c68e2c da2cdad985994dc78eb4734a2736ca64 b26b02dc6c6b4b69ade0eb24c0c1616a--da2cdad985994dc78eb4734a2736ca64 657d13599ade4040a136b29bd01d2489 Z da2cdad985994dc78eb4734a2736ca64--657d13599ade4040a136b29bd01d2489 657d13599ade4040a136b29bd01d2489--c7091a8527e248f6941bb82d1cafafdf 3ae17a6f315941af8f53654fb5bee9d8 de4e0a7c9176449c84a76eb0d9297f0b RZ(cos(phi)) 89d54b9923c446b78f91a94062aa5a18--de4e0a7c9176449c84a76eb0d9297f0b 676e117c19ef4c71994ce58698ad45d6 RZ(phi) de4e0a7c9176449c84a76eb0d9297f0b--676e117c19ef4c71994ce58698ad45d6 978c3aaaebfc4dc48fc2297e5e44a50b RZ(phi) 676e117c19ef4c71994ce58698ad45d6--978c3aaaebfc4dc48fc2297e5e44a50b d0a52d2565294dc79571c3b3ba79774d RZ(cos(phi)) 978c3aaaebfc4dc48fc2297e5e44a50b--d0a52d2565294dc79571c3b3ba79774d 2e0f6808a28a43d48a13054d067ac45d d0a52d2565294dc79571c3b3ba79774d--2e0f6808a28a43d48a13054d067ac45d b15cde9a6b1647e28db3a38a3ad0b355 X 2e0f6808a28a43d48a13054d067ac45d--b15cde9a6b1647e28db3a38a3ad0b355 b15cde9a6b1647e28db3a38a3ad0b355--da2cdad985994dc78eb4734a2736ca64 bbbaa276a0174768a92ce26596a0b5f2 Z b15cde9a6b1647e28db3a38a3ad0b355--bbbaa276a0174768a92ce26596a0b5f2 bbbaa276a0174768a92ce26596a0b5f2--3ae17a6f315941af8f53654fb5bee9d8 <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.6122]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.8583+0.0000j, 0.3487+0.0000j, 0.0000-0.3487j, 0.0000-0.1417j],\n        [0.9034+0.0000j, 0.2954+0.0000j, 0.0000-0.2954j, 0.0000-0.0966j],\n        [0.6968+0.0000j, 0.4597+0.0000j, 0.0000-0.4597j, 0.0000-0.3032j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 282fe5d51fe840f0849e586ea168c478 0 064f8fc05eeb4d6792fb35b74f9eca8c RX(theta\u2080) 282fe5d51fe840f0849e586ea168c478--064f8fc05eeb4d6792fb35b74f9eca8c ed6d77d45b704b0a834a0b263915821c 1 2be0c06547fa4a63806b23f472f54614 RY(theta\u2084) 064f8fc05eeb4d6792fb35b74f9eca8c--2be0c06547fa4a63806b23f472f54614 a6ea5e77506e427e835f572759f9d6c9 RX(theta\u2088) 2be0c06547fa4a63806b23f472f54614--a6ea5e77506e427e835f572759f9d6c9 e6f2739d16e94cc0833a9d07fd0af517 a6ea5e77506e427e835f572759f9d6c9--e6f2739d16e94cc0833a9d07fd0af517 82355716099f46e18d548f61a461f812 e6f2739d16e94cc0833a9d07fd0af517--82355716099f46e18d548f61a461f812 b46a36c1205b4a8ea55965da5f015b9b RX(theta\u2081\u2082) 82355716099f46e18d548f61a461f812--b46a36c1205b4a8ea55965da5f015b9b 50dafcc9a9f64668bc345bc6b7f3cde6 RY(theta\u2081\u2086) b46a36c1205b4a8ea55965da5f015b9b--50dafcc9a9f64668bc345bc6b7f3cde6 772446f072d34b36b8f2eb9a064789c0 RX(theta\u2082\u2080) 50dafcc9a9f64668bc345bc6b7f3cde6--772446f072d34b36b8f2eb9a064789c0 1d7c3955c2334b719ad482a817905356 772446f072d34b36b8f2eb9a064789c0--1d7c3955c2334b719ad482a817905356 3b85fdf5b90d434a976dd377751ee62c 1d7c3955c2334b719ad482a817905356--3b85fdf5b90d434a976dd377751ee62c 2ef74d9e21a64a8da8a682ac561aaff6 3b85fdf5b90d434a976dd377751ee62c--2ef74d9e21a64a8da8a682ac561aaff6 2b09dbf54c784137a66b144c67b5e7b5 8fb7f16220554aa7abc280392e3fd036 RX(theta\u2081) ed6d77d45b704b0a834a0b263915821c--8fb7f16220554aa7abc280392e3fd036 55a84e121c994f3da5ad0a658885132c 2 276d374e391d405a8076adba14361795 RY(theta\u2085) 8fb7f16220554aa7abc280392e3fd036--276d374e391d405a8076adba14361795 00268d5cf1744dc5811ae0c31921cfde RX(theta\u2089) 276d374e391d405a8076adba14361795--00268d5cf1744dc5811ae0c31921cfde 3d938e32e72d4709986b7fc669c48104 X 00268d5cf1744dc5811ae0c31921cfde--3d938e32e72d4709986b7fc669c48104 3d938e32e72d4709986b7fc669c48104--e6f2739d16e94cc0833a9d07fd0af517 e9bbda08277b4a10a4529ae97aee3218 3d938e32e72d4709986b7fc669c48104--e9bbda08277b4a10a4529ae97aee3218 f380b72b82cc4ea6bcda7de9c6994b7a RX(theta\u2081\u2083) e9bbda08277b4a10a4529ae97aee3218--f380b72b82cc4ea6bcda7de9c6994b7a 1b214424f7d5495d974ff967faedbb49 RY(theta\u2081\u2087) f380b72b82cc4ea6bcda7de9c6994b7a--1b214424f7d5495d974ff967faedbb49 a6f4a035ced541fc9eed001e8ba1b89a RX(theta\u2082\u2081) 1b214424f7d5495d974ff967faedbb49--a6f4a035ced541fc9eed001e8ba1b89a e59654830e084a95a872979c5ad565d5 X a6f4a035ced541fc9eed001e8ba1b89a--e59654830e084a95a872979c5ad565d5 e59654830e084a95a872979c5ad565d5--1d7c3955c2334b719ad482a817905356 c6b86351d5c34722b0a476fb8d85cf29 e59654830e084a95a872979c5ad565d5--c6b86351d5c34722b0a476fb8d85cf29 c6b86351d5c34722b0a476fb8d85cf29--2b09dbf54c784137a66b144c67b5e7b5 9c8f59e646ca4980b11d1c7fe200ca12 36f755c4720344d1ac82d7ca71d52e8f RX(theta\u2082) 55a84e121c994f3da5ad0a658885132c--36f755c4720344d1ac82d7ca71d52e8f 483eb80cd01545eda1fbdee090f69333 3 c4ec252568e34e609594dafa992f84d3 RY(theta\u2086) 36f755c4720344d1ac82d7ca71d52e8f--c4ec252568e34e609594dafa992f84d3 1311f5bfc96242ffb93a75d7a871d141 RX(theta\u2081\u2080) c4ec252568e34e609594dafa992f84d3--1311f5bfc96242ffb93a75d7a871d141 dc9e620cfc2e41b48f085a37205cf503 1311f5bfc96242ffb93a75d7a871d141--dc9e620cfc2e41b48f085a37205cf503 5ee05b5dd8e742b08291d555fd3546c4 X dc9e620cfc2e41b48f085a37205cf503--5ee05b5dd8e742b08291d555fd3546c4 5ee05b5dd8e742b08291d555fd3546c4--e9bbda08277b4a10a4529ae97aee3218 23b907b4aaab47df8f4d370a879cea5e RX(theta\u2081\u2084) 5ee05b5dd8e742b08291d555fd3546c4--23b907b4aaab47df8f4d370a879cea5e aceb7ad59dec4f7993f62614b9a39e5f RY(theta\u2081\u2088) 23b907b4aaab47df8f4d370a879cea5e--aceb7ad59dec4f7993f62614b9a39e5f b160135dc75e4a96afb853c9d57ec6ce RX(theta\u2082\u2082) aceb7ad59dec4f7993f62614b9a39e5f--b160135dc75e4a96afb853c9d57ec6ce dc7dec60be1940e1b91513b81ae3f604 b160135dc75e4a96afb853c9d57ec6ce--dc7dec60be1940e1b91513b81ae3f604 a49c43e2cf674ef08a0ea15c143a9c63 X dc7dec60be1940e1b91513b81ae3f604--a49c43e2cf674ef08a0ea15c143a9c63 a49c43e2cf674ef08a0ea15c143a9c63--c6b86351d5c34722b0a476fb8d85cf29 a49c43e2cf674ef08a0ea15c143a9c63--9c8f59e646ca4980b11d1c7fe200ca12 4420324410e94d639d7b41ffc098dbb7 711a893d2603416c8d6f00e30fec847d RX(theta\u2083) 483eb80cd01545eda1fbdee090f69333--711a893d2603416c8d6f00e30fec847d 4e29f13c6aba43779cc70a716a255ed0 RY(theta\u2087) 711a893d2603416c8d6f00e30fec847d--4e29f13c6aba43779cc70a716a255ed0 efe22968d2874310889124c7e81a10e3 RX(theta\u2081\u2081) 4e29f13c6aba43779cc70a716a255ed0--efe22968d2874310889124c7e81a10e3 80440e51859849faa980a57e8e3a8d3e X efe22968d2874310889124c7e81a10e3--80440e51859849faa980a57e8e3a8d3e 80440e51859849faa980a57e8e3a8d3e--dc9e620cfc2e41b48f085a37205cf503 4f33f14a09444c34953d84e407e47b00 80440e51859849faa980a57e8e3a8d3e--4f33f14a09444c34953d84e407e47b00 578a133cac55487296b1490056ee4a4a RX(theta\u2081\u2085) 4f33f14a09444c34953d84e407e47b00--578a133cac55487296b1490056ee4a4a 4c36a05438bd4727af063740210028cd RY(theta\u2081\u2089) 578a133cac55487296b1490056ee4a4a--4c36a05438bd4727af063740210028cd eb294b46f8344665b27f2fda47592269 RX(theta\u2082\u2083) 4c36a05438bd4727af063740210028cd--eb294b46f8344665b27f2fda47592269 3ff65bdf7ec648d8aafab4e83f23d254 X eb294b46f8344665b27f2fda47592269--3ff65bdf7ec648d8aafab4e83f23d254 3ff65bdf7ec648d8aafab4e83f23d254--dc7dec60be1940e1b91513b81ae3f604 256ec9ebd8174dce8ca4d2a2174a4f5d 3ff65bdf7ec648d8aafab4e83f23d254--256ec9ebd8174dce8ca4d2a2174a4f5d 256ec9ebd8174dce8ca4d2a2174a4f5d--4420324410e94d639d7b41ffc098dbb7 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_25327fba1c3f4bc9b517ddc19a8c1341 HEA cluster_94cd0ea057364a83bf7a1777a7463358 HEA 8c18d36f3e884ae087f03dca5a325516 0 b7511f7289af43f38be01d456a8a9a22 RX(theta\u2080) 8c18d36f3e884ae087f03dca5a325516--b7511f7289af43f38be01d456a8a9a22 5c926323af144ef786b999063cda7750 1 02ab5a4084284a639433db2713d15af8 RY(theta\u2084) b7511f7289af43f38be01d456a8a9a22--02ab5a4084284a639433db2713d15af8 c8e60409371c40cda4bce33595c83994 RX(theta\u2088) 02ab5a4084284a639433db2713d15af8--c8e60409371c40cda4bce33595c83994 efb26172055e4b14accce486feea8cce c8e60409371c40cda4bce33595c83994--efb26172055e4b14accce486feea8cce cc83a70e77684198855cf184e3e0c7b4 efb26172055e4b14accce486feea8cce--cc83a70e77684198855cf184e3e0c7b4 71c5109d6e934ff98433d1d63dd31371 RX(theta\u2081\u2082) cc83a70e77684198855cf184e3e0c7b4--71c5109d6e934ff98433d1d63dd31371 7d88750c9561418a9e9ee1137804cdd9 RY(theta\u2081\u2086) 71c5109d6e934ff98433d1d63dd31371--7d88750c9561418a9e9ee1137804cdd9 9a31f94ef24a488882543c782651a9f6 RX(theta\u2082\u2080) 7d88750c9561418a9e9ee1137804cdd9--9a31f94ef24a488882543c782651a9f6 18f3e1a31f8149688a1a5cb91159987c 9a31f94ef24a488882543c782651a9f6--18f3e1a31f8149688a1a5cb91159987c 9fbe7f69c8fb4d16b6570f5e2eabf04c 18f3e1a31f8149688a1a5cb91159987c--9fbe7f69c8fb4d16b6570f5e2eabf04c d158f3875db945bf852793014d2daf2e RX(theta\u2080) 9fbe7f69c8fb4d16b6570f5e2eabf04c--d158f3875db945bf852793014d2daf2e eb79475c0e4a459eb5eec5f5b57769f6 RY(theta\u2084) d158f3875db945bf852793014d2daf2e--eb79475c0e4a459eb5eec5f5b57769f6 ac3ef688cf614c98a69d74086e84a52c RX(theta\u2088) eb79475c0e4a459eb5eec5f5b57769f6--ac3ef688cf614c98a69d74086e84a52c 3b187b6b8ed441e3b6c8d3caee259235 ac3ef688cf614c98a69d74086e84a52c--3b187b6b8ed441e3b6c8d3caee259235 742a8a5dc7f54a288ec2f84228da3825 3b187b6b8ed441e3b6c8d3caee259235--742a8a5dc7f54a288ec2f84228da3825 b8b4882334c1497897ede7a504bc9acd RX(theta\u2081\u2082) 742a8a5dc7f54a288ec2f84228da3825--b8b4882334c1497897ede7a504bc9acd 3da6713ffecd43f5b5f13f505dab5bdb RY(theta\u2081\u2086) b8b4882334c1497897ede7a504bc9acd--3da6713ffecd43f5b5f13f505dab5bdb 8e1a5cf6760943f9b30f0afb63c9b1b5 RX(theta\u2082\u2080) 3da6713ffecd43f5b5f13f505dab5bdb--8e1a5cf6760943f9b30f0afb63c9b1b5 a578a7617f504ea98625ee22c0a096d9 8e1a5cf6760943f9b30f0afb63c9b1b5--a578a7617f504ea98625ee22c0a096d9 1c11c8895571430ba9b506634ee89a40 a578a7617f504ea98625ee22c0a096d9--1c11c8895571430ba9b506634ee89a40 74ab88031816461d807a006ca92a94f1 1c11c8895571430ba9b506634ee89a40--74ab88031816461d807a006ca92a94f1 95f4925e8eb84e099a32242187eee972 0c99c41e46754dbf9b5e3861f61146d2 RX(theta\u2081) 5c926323af144ef786b999063cda7750--0c99c41e46754dbf9b5e3861f61146d2 62c939638b8f4c1f9b6308a0da3ca2d7 2 bedafb52c080419ba1382d67cbbda4f0 RY(theta\u2085) 0c99c41e46754dbf9b5e3861f61146d2--bedafb52c080419ba1382d67cbbda4f0 81362af9203a4d3aa3eb5654c133ab33 RX(theta\u2089) bedafb52c080419ba1382d67cbbda4f0--81362af9203a4d3aa3eb5654c133ab33 7dd536a8520d48bdb730c4e49f093bce X 81362af9203a4d3aa3eb5654c133ab33--7dd536a8520d48bdb730c4e49f093bce 7dd536a8520d48bdb730c4e49f093bce--efb26172055e4b14accce486feea8cce ab30c18966b74547b7bb67063ea6a262 7dd536a8520d48bdb730c4e49f093bce--ab30c18966b74547b7bb67063ea6a262 27c32c0c62bd4d208e9b2dd52280a313 RX(theta\u2081\u2083) ab30c18966b74547b7bb67063ea6a262--27c32c0c62bd4d208e9b2dd52280a313 404dadd877d84f8190f56d9e686d84c5 RY(theta\u2081\u2087) 27c32c0c62bd4d208e9b2dd52280a313--404dadd877d84f8190f56d9e686d84c5 c86ee4dde04b4844b9f9949896c291e9 RX(theta\u2082\u2081) 404dadd877d84f8190f56d9e686d84c5--c86ee4dde04b4844b9f9949896c291e9 0445e9999a054bc7b2387e99a208470c X c86ee4dde04b4844b9f9949896c291e9--0445e9999a054bc7b2387e99a208470c 0445e9999a054bc7b2387e99a208470c--18f3e1a31f8149688a1a5cb91159987c 241a7bc4674647c4af95a7bd9d9203b6 0445e9999a054bc7b2387e99a208470c--241a7bc4674647c4af95a7bd9d9203b6 0fe35bdcfa534c3e92133017921f9b09 RX(theta\u2081) 241a7bc4674647c4af95a7bd9d9203b6--0fe35bdcfa534c3e92133017921f9b09 e43666915fe847b6bc87d95611a2e1a2 RY(theta\u2085) 0fe35bdcfa534c3e92133017921f9b09--e43666915fe847b6bc87d95611a2e1a2 07338e13c3fd4694b79fbd92f8f8ddf7 RX(theta\u2089) e43666915fe847b6bc87d95611a2e1a2--07338e13c3fd4694b79fbd92f8f8ddf7 f2ec3269ab0241f8b98727ee954e04e5 X 07338e13c3fd4694b79fbd92f8f8ddf7--f2ec3269ab0241f8b98727ee954e04e5 f2ec3269ab0241f8b98727ee954e04e5--3b187b6b8ed441e3b6c8d3caee259235 cc80e69312f7402fbb83932408ca021e f2ec3269ab0241f8b98727ee954e04e5--cc80e69312f7402fbb83932408ca021e 2c2f093ad14a46a39c0e0b5fb0e6dff6 RX(theta\u2081\u2083) cc80e69312f7402fbb83932408ca021e--2c2f093ad14a46a39c0e0b5fb0e6dff6 b08069fa223143ea92f6775bbfa6f07f RY(theta\u2081\u2087) 2c2f093ad14a46a39c0e0b5fb0e6dff6--b08069fa223143ea92f6775bbfa6f07f 588595d21bba407687ac36943f0a9636 RX(theta\u2082\u2081) b08069fa223143ea92f6775bbfa6f07f--588595d21bba407687ac36943f0a9636 b05382d93c2c4e4e9948d0931fd0d696 X 588595d21bba407687ac36943f0a9636--b05382d93c2c4e4e9948d0931fd0d696 b05382d93c2c4e4e9948d0931fd0d696--a578a7617f504ea98625ee22c0a096d9 47869ed852b34b2787befb2de1d0e329 b05382d93c2c4e4e9948d0931fd0d696--47869ed852b34b2787befb2de1d0e329 47869ed852b34b2787befb2de1d0e329--95f4925e8eb84e099a32242187eee972 301d28a7c8334e4fa2c58550fa4e44c9 91db2687d51f4f8eb500f9786e5f703e RX(theta\u2082) 62c939638b8f4c1f9b6308a0da3ca2d7--91db2687d51f4f8eb500f9786e5f703e 2e3c2370cc7a4aec810d31fa6330e1f4 3 2096b8e977b54aac816d096ca17f51b6 RY(theta\u2086) 91db2687d51f4f8eb500f9786e5f703e--2096b8e977b54aac816d096ca17f51b6 42b569ff06ae459c9f0521583eb19028 RX(theta\u2081\u2080) 2096b8e977b54aac816d096ca17f51b6--42b569ff06ae459c9f0521583eb19028 a0196f32f3c94683b692be1320d8b7f0 42b569ff06ae459c9f0521583eb19028--a0196f32f3c94683b692be1320d8b7f0 fd295cff8ab14724afa025a41b390dcc X a0196f32f3c94683b692be1320d8b7f0--fd295cff8ab14724afa025a41b390dcc fd295cff8ab14724afa025a41b390dcc--ab30c18966b74547b7bb67063ea6a262 8dd6705c375b4d5ea6548bd74f9a4425 RX(theta\u2081\u2084) fd295cff8ab14724afa025a41b390dcc--8dd6705c375b4d5ea6548bd74f9a4425 b0c3b3a8110d421d9ab0103d5369b451 RY(theta\u2081\u2088) 8dd6705c375b4d5ea6548bd74f9a4425--b0c3b3a8110d421d9ab0103d5369b451 a537e1545b924dca985d37a416cd6d6a RX(theta\u2082\u2082) b0c3b3a8110d421d9ab0103d5369b451--a537e1545b924dca985d37a416cd6d6a 4a2d52ef40994027815e8f47cd9b0417 a537e1545b924dca985d37a416cd6d6a--4a2d52ef40994027815e8f47cd9b0417 b059af3e30694dd9a977f51117575c7e X 4a2d52ef40994027815e8f47cd9b0417--b059af3e30694dd9a977f51117575c7e b059af3e30694dd9a977f51117575c7e--241a7bc4674647c4af95a7bd9d9203b6 7fdee82e0f3b4cbbb9bc60b55122541e RX(theta\u2082) b059af3e30694dd9a977f51117575c7e--7fdee82e0f3b4cbbb9bc60b55122541e b4af05d62ee54c24acc979b185addfca RY(theta\u2086) 7fdee82e0f3b4cbbb9bc60b55122541e--b4af05d62ee54c24acc979b185addfca 491eef480025453098299ce4401fdfeb RX(theta\u2081\u2080) b4af05d62ee54c24acc979b185addfca--491eef480025453098299ce4401fdfeb 80a1a0b532dc46e4bbadde7549237851 491eef480025453098299ce4401fdfeb--80a1a0b532dc46e4bbadde7549237851 3f12b352649a41e9af7c45643c9c495f X 80a1a0b532dc46e4bbadde7549237851--3f12b352649a41e9af7c45643c9c495f 3f12b352649a41e9af7c45643c9c495f--cc80e69312f7402fbb83932408ca021e ba890995c0c944d1a144928f77e17c90 RX(theta\u2081\u2084) 3f12b352649a41e9af7c45643c9c495f--ba890995c0c944d1a144928f77e17c90 62db3fc239bd47b9a496d9b4a570e0f1 RY(theta\u2081\u2088) ba890995c0c944d1a144928f77e17c90--62db3fc239bd47b9a496d9b4a570e0f1 2e26e2c89ce34f46b1db4ae19f99dd35 RX(theta\u2082\u2082) 62db3fc239bd47b9a496d9b4a570e0f1--2e26e2c89ce34f46b1db4ae19f99dd35 52f94fa19c0b470b8d0ab05db279663e 2e26e2c89ce34f46b1db4ae19f99dd35--52f94fa19c0b470b8d0ab05db279663e ca033e376d6746b1af971798fd09f85d X 52f94fa19c0b470b8d0ab05db279663e--ca033e376d6746b1af971798fd09f85d ca033e376d6746b1af971798fd09f85d--47869ed852b34b2787befb2de1d0e329 ca033e376d6746b1af971798fd09f85d--301d28a7c8334e4fa2c58550fa4e44c9 47932cab833147bfb807156f7b052955 a46d8053da224bce92df12871d7f388b RX(theta\u2083) 2e3c2370cc7a4aec810d31fa6330e1f4--a46d8053da224bce92df12871d7f388b 1f8c6f803d084c61bde140e85dd28c11 RY(theta\u2087) a46d8053da224bce92df12871d7f388b--1f8c6f803d084c61bde140e85dd28c11 5067b66a1d01449793a585402d2efa2b RX(theta\u2081\u2081) 1f8c6f803d084c61bde140e85dd28c11--5067b66a1d01449793a585402d2efa2b 0c930bf0c0c04440a4611fb6d97dc30f X 5067b66a1d01449793a585402d2efa2b--0c930bf0c0c04440a4611fb6d97dc30f 0c930bf0c0c04440a4611fb6d97dc30f--a0196f32f3c94683b692be1320d8b7f0 c17a6961641f4f2c875ea3afe4938e4b 0c930bf0c0c04440a4611fb6d97dc30f--c17a6961641f4f2c875ea3afe4938e4b cc752148735c4259b8bc04d02d0fc752 RX(theta\u2081\u2085) c17a6961641f4f2c875ea3afe4938e4b--cc752148735c4259b8bc04d02d0fc752 cfb4c1c563ec4012a08265fa1f337d4e RY(theta\u2081\u2089) cc752148735c4259b8bc04d02d0fc752--cfb4c1c563ec4012a08265fa1f337d4e ac5714d353974c879af375b458c5e5e8 RX(theta\u2082\u2083) cfb4c1c563ec4012a08265fa1f337d4e--ac5714d353974c879af375b458c5e5e8 a1e829218b014ff7972f3f7f84b0a1fa X ac5714d353974c879af375b458c5e5e8--a1e829218b014ff7972f3f7f84b0a1fa a1e829218b014ff7972f3f7f84b0a1fa--4a2d52ef40994027815e8f47cd9b0417 e9587b242024474cafd99275846fa90f a1e829218b014ff7972f3f7f84b0a1fa--e9587b242024474cafd99275846fa90f 851f49265bb946d4bbf4622b175d9e01 RX(theta\u2083) e9587b242024474cafd99275846fa90f--851f49265bb946d4bbf4622b175d9e01 2ae6f8cfe5d24c7f9080b157606a6e7f RY(theta\u2087) 851f49265bb946d4bbf4622b175d9e01--2ae6f8cfe5d24c7f9080b157606a6e7f 2572f509fc6846bcae103d6593143f75 RX(theta\u2081\u2081) 2ae6f8cfe5d24c7f9080b157606a6e7f--2572f509fc6846bcae103d6593143f75 7194b008aca240b496312fa19a697d5b X 2572f509fc6846bcae103d6593143f75--7194b008aca240b496312fa19a697d5b 7194b008aca240b496312fa19a697d5b--80a1a0b532dc46e4bbadde7549237851 e710c06a2dec448285fca0e0f251e271 7194b008aca240b496312fa19a697d5b--e710c06a2dec448285fca0e0f251e271 218f07ef64c04860b65ab8cc3ec5ff65 RX(theta\u2081\u2085) e710c06a2dec448285fca0e0f251e271--218f07ef64c04860b65ab8cc3ec5ff65 73b970fc14ec4abe9eccc0bc030cda9c RY(theta\u2081\u2089) 218f07ef64c04860b65ab8cc3ec5ff65--73b970fc14ec4abe9eccc0bc030cda9c 76dae23ee83a4cd8ab2ff04ba127aace RX(theta\u2082\u2083) 73b970fc14ec4abe9eccc0bc030cda9c--76dae23ee83a4cd8ab2ff04ba127aace 4a16eb62a7e348b49153dfd3aa355eeb X 76dae23ee83a4cd8ab2ff04ba127aace--4a16eb62a7e348b49153dfd3aa355eeb 4a16eb62a7e348b49153dfd3aa355eeb--52f94fa19c0b470b8d0ab05db279663e d3ef7271f0204644bef67162a693ef1e 4a16eb62a7e348b49153dfd3aa355eeb--d3ef7271f0204644bef67162a693ef1e d3ef7271f0204644bef67162a693ef1e--47932cab833147bfb807156f7b052955 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_4e450df5efe24faa9086c864a4e3e5bd HEA cluster_68245fbaba734c8cb1cb77a377c3b11c HEA b36fb2f289244e24a730f8fb5efe9268 0 271b3672aa6d49a4a2edaef84313cc34 RX(p1\u2080) b36fb2f289244e24a730f8fb5efe9268--271b3672aa6d49a4a2edaef84313cc34 2b193c1f347847e9962bbbb2678466e4 1 bf484086035f4517bdd3c3f15df28921 RY(p1\u2084) 271b3672aa6d49a4a2edaef84313cc34--bf484086035f4517bdd3c3f15df28921 99298681d84942f6829262955e862e76 RX(p1\u2088) bf484086035f4517bdd3c3f15df28921--99298681d84942f6829262955e862e76 9468f8c13baa48329a040d7fe422ad61 99298681d84942f6829262955e862e76--9468f8c13baa48329a040d7fe422ad61 5034d8d8d5b846a0b460f5656776964c 9468f8c13baa48329a040d7fe422ad61--5034d8d8d5b846a0b460f5656776964c 2a7ca364975945b8ae4554c14af7064c RX(p1\u2081\u2082) 5034d8d8d5b846a0b460f5656776964c--2a7ca364975945b8ae4554c14af7064c 49686c716047446083aebed07e54e997 RY(p1\u2081\u2086) 2a7ca364975945b8ae4554c14af7064c--49686c716047446083aebed07e54e997 47a624b21c01497babb301a0e587a8d6 RX(p1\u2082\u2080) 49686c716047446083aebed07e54e997--47a624b21c01497babb301a0e587a8d6 b4e032f8b7a1472294272a6d878850c6 47a624b21c01497babb301a0e587a8d6--b4e032f8b7a1472294272a6d878850c6 5d5009a244fb4ccaa30ff5f8f130d886 b4e032f8b7a1472294272a6d878850c6--5d5009a244fb4ccaa30ff5f8f130d886 8abb290ec39944eb9e29949d6cdcbb42 RX(p2\u2080) 5d5009a244fb4ccaa30ff5f8f130d886--8abb290ec39944eb9e29949d6cdcbb42 1b58a905ce244a9da4e5e1c72e55d4b2 RY(p2\u2084) 8abb290ec39944eb9e29949d6cdcbb42--1b58a905ce244a9da4e5e1c72e55d4b2 22cfbb1d946449e78c0946e3ce5bc43b RX(p2\u2088) 1b58a905ce244a9da4e5e1c72e55d4b2--22cfbb1d946449e78c0946e3ce5bc43b 96deac68cab14eff9ec2a8aa106218ac 22cfbb1d946449e78c0946e3ce5bc43b--96deac68cab14eff9ec2a8aa106218ac 5a194886a67c457c90d17c831c4917ff 96deac68cab14eff9ec2a8aa106218ac--5a194886a67c457c90d17c831c4917ff 78a4a2d8763d41119d7903bf41ab7571 RX(p2\u2081\u2082) 5a194886a67c457c90d17c831c4917ff--78a4a2d8763d41119d7903bf41ab7571 7719f58f27f04feb942f6e4b866c5c04 RY(p2\u2081\u2086) 78a4a2d8763d41119d7903bf41ab7571--7719f58f27f04feb942f6e4b866c5c04 025659bb1a924f288a16d3a4a20a2648 RX(p2\u2082\u2080) 7719f58f27f04feb942f6e4b866c5c04--025659bb1a924f288a16d3a4a20a2648 a6b1dfe174134c7cac6269fa38fd2428 025659bb1a924f288a16d3a4a20a2648--a6b1dfe174134c7cac6269fa38fd2428 030a719f5f1e4e0b91f192b6cf086ddd a6b1dfe174134c7cac6269fa38fd2428--030a719f5f1e4e0b91f192b6cf086ddd 3d85c4167e74427aaff97307598aef2a 030a719f5f1e4e0b91f192b6cf086ddd--3d85c4167e74427aaff97307598aef2a ca314e6290c9446eaf08debe0df92ec3 45e42004e44941038349a0aebdcc1307 RX(p1\u2081) 2b193c1f347847e9962bbbb2678466e4--45e42004e44941038349a0aebdcc1307 a0df2ecaaa284fab9a75ae5b1f75a532 2 97fe7cc4ad5a4baeac583b7803c8245f RY(p1\u2085) 45e42004e44941038349a0aebdcc1307--97fe7cc4ad5a4baeac583b7803c8245f 0eee308a48e54db0989d49e636124398 RX(p1\u2089) 97fe7cc4ad5a4baeac583b7803c8245f--0eee308a48e54db0989d49e636124398 7762bc0d00964c21b246b02e5de20e15 X 0eee308a48e54db0989d49e636124398--7762bc0d00964c21b246b02e5de20e15 7762bc0d00964c21b246b02e5de20e15--9468f8c13baa48329a040d7fe422ad61 55b88f51407e403a81a739026488135b 7762bc0d00964c21b246b02e5de20e15--55b88f51407e403a81a739026488135b 445383d4a18c4f25af4b26b710839d61 RX(p1\u2081\u2083) 55b88f51407e403a81a739026488135b--445383d4a18c4f25af4b26b710839d61 ef73c6e632d34319aea4f9da32c69222 RY(p1\u2081\u2087) 445383d4a18c4f25af4b26b710839d61--ef73c6e632d34319aea4f9da32c69222 4247f7ebd3be4d55a7ac9f9118f2d8cb RX(p1\u2082\u2081) ef73c6e632d34319aea4f9da32c69222--4247f7ebd3be4d55a7ac9f9118f2d8cb 66c5d797cb01426f816a94072eb40d3a X 4247f7ebd3be4d55a7ac9f9118f2d8cb--66c5d797cb01426f816a94072eb40d3a 66c5d797cb01426f816a94072eb40d3a--b4e032f8b7a1472294272a6d878850c6 26d006daa06548ce9b2ef45f8630ce49 66c5d797cb01426f816a94072eb40d3a--26d006daa06548ce9b2ef45f8630ce49 e74cd0075eb64fa18e669ddce89cdd07 RX(p2\u2081) 26d006daa06548ce9b2ef45f8630ce49--e74cd0075eb64fa18e669ddce89cdd07 3cb5b67e3bbc48b78ca4fabb7d9aeac5 RY(p2\u2085) e74cd0075eb64fa18e669ddce89cdd07--3cb5b67e3bbc48b78ca4fabb7d9aeac5 1af076630afb4160be60e093616edcf2 RX(p2\u2089) 3cb5b67e3bbc48b78ca4fabb7d9aeac5--1af076630afb4160be60e093616edcf2 ce597f12180142589a7041cb7d0e9d0d X 1af076630afb4160be60e093616edcf2--ce597f12180142589a7041cb7d0e9d0d ce597f12180142589a7041cb7d0e9d0d--96deac68cab14eff9ec2a8aa106218ac ec8597d537bc46f7a30ac7568a520212 ce597f12180142589a7041cb7d0e9d0d--ec8597d537bc46f7a30ac7568a520212 acb3fbfef5fe4cd9b6a30304b88d7db3 RX(p2\u2081\u2083) ec8597d537bc46f7a30ac7568a520212--acb3fbfef5fe4cd9b6a30304b88d7db3 7cef317830504c8fb476388e193f6496 RY(p2\u2081\u2087) acb3fbfef5fe4cd9b6a30304b88d7db3--7cef317830504c8fb476388e193f6496 42ec8761dea44e0abac9dedd5ca4515a RX(p2\u2082\u2081) 7cef317830504c8fb476388e193f6496--42ec8761dea44e0abac9dedd5ca4515a 7f792e188bbc463bbcee1385a1219ecc X 42ec8761dea44e0abac9dedd5ca4515a--7f792e188bbc463bbcee1385a1219ecc 7f792e188bbc463bbcee1385a1219ecc--a6b1dfe174134c7cac6269fa38fd2428 1505ae4e5bf644ab887f1624cd69a5e5 7f792e188bbc463bbcee1385a1219ecc--1505ae4e5bf644ab887f1624cd69a5e5 1505ae4e5bf644ab887f1624cd69a5e5--ca314e6290c9446eaf08debe0df92ec3 c95ba5c17a35470d946971957557b501 dc6725a2784444fb8cecf67adff5a582 RX(p1\u2082) a0df2ecaaa284fab9a75ae5b1f75a532--dc6725a2784444fb8cecf67adff5a582 be5082ab97204f2493ae2b795ae1e75f 3 b6061167df354f869d5ca2eb436ba360 RY(p1\u2086) dc6725a2784444fb8cecf67adff5a582--b6061167df354f869d5ca2eb436ba360 08ae83c80b34440786064a015da19e26 RX(p1\u2081\u2080) b6061167df354f869d5ca2eb436ba360--08ae83c80b34440786064a015da19e26 ce54f5d91bd74a03b230c41160580a1f 08ae83c80b34440786064a015da19e26--ce54f5d91bd74a03b230c41160580a1f a9369f62136446799fca6da484f34a07 X ce54f5d91bd74a03b230c41160580a1f--a9369f62136446799fca6da484f34a07 a9369f62136446799fca6da484f34a07--55b88f51407e403a81a739026488135b a5ac849498ee49399f35d014cb5a908d RX(p1\u2081\u2084) a9369f62136446799fca6da484f34a07--a5ac849498ee49399f35d014cb5a908d 3065223da0cb406e8497ca8f20ada009 RY(p1\u2081\u2088) a5ac849498ee49399f35d014cb5a908d--3065223da0cb406e8497ca8f20ada009 bae05a60407942cc9eaf3319c072d6d2 RX(p1\u2082\u2082) 3065223da0cb406e8497ca8f20ada009--bae05a60407942cc9eaf3319c072d6d2 6c7e056c44fa446eb6a2ec0ac611f158 bae05a60407942cc9eaf3319c072d6d2--6c7e056c44fa446eb6a2ec0ac611f158 ee7106fb7fd74a5f9c2ddd9023c97505 X 6c7e056c44fa446eb6a2ec0ac611f158--ee7106fb7fd74a5f9c2ddd9023c97505 ee7106fb7fd74a5f9c2ddd9023c97505--26d006daa06548ce9b2ef45f8630ce49 faadff439ff94cc78259777b82b633ff RX(p2\u2082) ee7106fb7fd74a5f9c2ddd9023c97505--faadff439ff94cc78259777b82b633ff 05f6d83b525d40fca790d1db19397f3a RY(p2\u2086) faadff439ff94cc78259777b82b633ff--05f6d83b525d40fca790d1db19397f3a 208819b270474768b79ffc4d1c6225cf RX(p2\u2081\u2080) 05f6d83b525d40fca790d1db19397f3a--208819b270474768b79ffc4d1c6225cf 288f361b5cb741cbaec09ccd8306cf4f 208819b270474768b79ffc4d1c6225cf--288f361b5cb741cbaec09ccd8306cf4f 0bc18ee7b88641128abf96a25105d827 X 288f361b5cb741cbaec09ccd8306cf4f--0bc18ee7b88641128abf96a25105d827 0bc18ee7b88641128abf96a25105d827--ec8597d537bc46f7a30ac7568a520212 4f3199a08c3843e98c4e140a4a905431 RX(p2\u2081\u2084) 0bc18ee7b88641128abf96a25105d827--4f3199a08c3843e98c4e140a4a905431 0c14e88f068446978c5778e68e877c43 RY(p2\u2081\u2088) 4f3199a08c3843e98c4e140a4a905431--0c14e88f068446978c5778e68e877c43 0c11f64099bd4c69b7387f6bdac2f183 RX(p2\u2082\u2082) 0c14e88f068446978c5778e68e877c43--0c11f64099bd4c69b7387f6bdac2f183 5f5458af301143f2adce48045870e5a6 0c11f64099bd4c69b7387f6bdac2f183--5f5458af301143f2adce48045870e5a6 df8b04a6a5e34437a03884b6b30b9b02 X 5f5458af301143f2adce48045870e5a6--df8b04a6a5e34437a03884b6b30b9b02 df8b04a6a5e34437a03884b6b30b9b02--1505ae4e5bf644ab887f1624cd69a5e5 df8b04a6a5e34437a03884b6b30b9b02--c95ba5c17a35470d946971957557b501 a4c8ae104c8944768dce8c4f40030daf a6ff7821217b46f6bca46cd4ffe70805 RX(p1\u2083) be5082ab97204f2493ae2b795ae1e75f--a6ff7821217b46f6bca46cd4ffe70805 742e6d8cc2044510b4255aa2e2464815 RY(p1\u2087) a6ff7821217b46f6bca46cd4ffe70805--742e6d8cc2044510b4255aa2e2464815 f5baedd6196c4c4386dbc5148620bb26 RX(p1\u2081\u2081) 742e6d8cc2044510b4255aa2e2464815--f5baedd6196c4c4386dbc5148620bb26 848811f80ea44813aa2f2034f40ab990 X f5baedd6196c4c4386dbc5148620bb26--848811f80ea44813aa2f2034f40ab990 848811f80ea44813aa2f2034f40ab990--ce54f5d91bd74a03b230c41160580a1f e82d92d7e41f4e28883a149da0346c8a 848811f80ea44813aa2f2034f40ab990--e82d92d7e41f4e28883a149da0346c8a 29b13fa04b4e4c0ea06880a55ea00607 RX(p1\u2081\u2085) e82d92d7e41f4e28883a149da0346c8a--29b13fa04b4e4c0ea06880a55ea00607 9dae632c4791498f821c5e565d40139f RY(p1\u2081\u2089) 29b13fa04b4e4c0ea06880a55ea00607--9dae632c4791498f821c5e565d40139f 87b49ed7d8b646309ba8c3110d3d7a8c RX(p1\u2082\u2083) 9dae632c4791498f821c5e565d40139f--87b49ed7d8b646309ba8c3110d3d7a8c 64d01f95754740f08bb160a504c6bf7a X 87b49ed7d8b646309ba8c3110d3d7a8c--64d01f95754740f08bb160a504c6bf7a 64d01f95754740f08bb160a504c6bf7a--6c7e056c44fa446eb6a2ec0ac611f158 a31fe305290445c8b0ab0bbef225b6c2 64d01f95754740f08bb160a504c6bf7a--a31fe305290445c8b0ab0bbef225b6c2 7ec6e389c5f2411db4bcbf71f6be9c7d RX(p2\u2083) a31fe305290445c8b0ab0bbef225b6c2--7ec6e389c5f2411db4bcbf71f6be9c7d 2595f52e63de4378bd13cd3d836aaae7 RY(p2\u2087) 7ec6e389c5f2411db4bcbf71f6be9c7d--2595f52e63de4378bd13cd3d836aaae7 e80281fc3a76491cb1e175f694705c99 RX(p2\u2081\u2081) 2595f52e63de4378bd13cd3d836aaae7--e80281fc3a76491cb1e175f694705c99 9c726c7e229b491db663600199c06907 X e80281fc3a76491cb1e175f694705c99--9c726c7e229b491db663600199c06907 9c726c7e229b491db663600199c06907--288f361b5cb741cbaec09ccd8306cf4f 51dccfd4b249436fb0ff660904319696 9c726c7e229b491db663600199c06907--51dccfd4b249436fb0ff660904319696 3730b1c7f3a7493e98dac1b518180c6d RX(p2\u2081\u2085) 51dccfd4b249436fb0ff660904319696--3730b1c7f3a7493e98dac1b518180c6d 797c357a62054d9a8f7d7191a8e27fc6 RY(p2\u2081\u2089) 3730b1c7f3a7493e98dac1b518180c6d--797c357a62054d9a8f7d7191a8e27fc6 8ad1ec734bcb47e4bda63e290fc94cb4 RX(p2\u2082\u2083) 797c357a62054d9a8f7d7191a8e27fc6--8ad1ec734bcb47e4bda63e290fc94cb4 b5bb1306f98d42afa7d0d31f1bee9a6d X 8ad1ec734bcb47e4bda63e290fc94cb4--b5bb1306f98d42afa7d0d31f1bee9a6d b5bb1306f98d42afa7d0d31f1bee9a6d--5f5458af301143f2adce48045870e5a6 b10fc4f195224a8bbd986314d10cec23 b5bb1306f98d42afa7d0d31f1bee9a6d--b10fc4f195224a8bbd986314d10cec23 b10fc4f195224a8bbd986314d10cec23--a4c8ae104c8944768dce8c4f40030daf </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.0855])), ('theta_0', tensor([0.5155])), ('theta_1', tensor([0.9281])), ('theta_10', tensor([0.9866])), ('theta_11', tensor([0.2450])), ('theta_12', tensor([0.4834])), ('theta_13', tensor([0.1215])), ('theta_14', tensor([0.0793])), ('theta_15', tensor([0.7420])), ('theta_16', tensor([0.6813])), ('theta_17', tensor([0.5558])), ('theta_18', tensor([0.9943])), ('theta_19', tensor([0.4941])), ('theta_2', tensor([0.8950])), ('theta_20', tensor([0.5997])), ('theta_21', tensor([0.0895])), ('theta_22', tensor([0.9110])), ('theta_23', tensor([0.1405])), ('theta_3', tensor([0.2954])), ('theta_4', tensor([0.5823])), ('theta_5', tensor([0.5412])), ('theta_6', tensor([0.5837])), ('theta_7', tensor([0.3800])), ('theta_8', tensor([0.2195])), ('theta_9', tensor([0.9872]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.0845])), ('theta_0', tensor([0.5145])), ('theta_1', tensor([0.9291])), ('theta_10', tensor([0.9876])), ('theta_11', tensor([0.2440])), ('theta_12', tensor([0.4844])), ('theta_13', tensor([0.1225])), ('theta_14', tensor([0.0803])), ('theta_15', tensor([0.7410])), ('theta_16', tensor([0.6803])), ('theta_17', tensor([0.5568])), ('theta_18', tensor([0.9933])), ('theta_19', tensor([0.4951])), ('theta_2', tensor([0.8960])), ('theta_20', tensor([0.6007])), ('theta_21', tensor([0.0905])), ('theta_22', tensor([0.9120])), ('theta_23', tensor([0.1395])), ('theta_3', tensor([0.2944])), ('theta_4', tensor([0.5833])), ('theta_5', tensor([0.5422])), ('theta_6', tensor([0.5827])), ('theta_7', tensor([0.3790])), ('theta_8', tensor([0.2205])), ('theta_9', tensor([0.9882]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 9.9885e-01+0.0000j,  0.0000e+00-0.0338j,  0.0000e+00-0.0338j,\n         -1.1468e-03+0.0000j],\n        [ 9.9919e-01+0.0000j,  0.0000e+00-0.0284j,  0.0000e+00-0.0284j,\n         -8.0882e-04+0.0000j],\n        [ 9.8061e-01+0.0000j,  0.0000e+00-0.1379j,  0.0000e+00-0.1379j,\n         -1.9395e-02+0.0000j]])\nxs = [Counter({'00': 100}), Counter({'00': 100}), Counter({'00': 97, '01': 2, '10': 1})]\nex = tensor([[0.9977],\n        [0.9984],\n        [0.9612]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9977, 0.9977],\n        [0.9984, 0.9984],\n        [0.9612, 0.9612]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2024-01-30T10:17:18.155235 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register, PI\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*PI, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2024-01-30T10:17:18.495743 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'00': 55, '01': 45})]\nSample in little endian = [Counter({'00': 52, '10': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'00': 55, '10': 45})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample, PI\n\n# RX(PI/4) on qubit 1\nn_qubits = 2\nop = RX(1, PI/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 84, '01': 16})]\nOn Braket = [Counter({'00': 84, '01': 16})]\nOn Pulser = [Counter({'00': 82, '01': 18})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [ 0.92861342+0.j  0.36763729+0.j -0.04667426+0.j -0.0184783 +0.j]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_26f18de5d7ed4abb9871b821baeb2b43 Circuit block cluster_e43706f9a848402f9e5cd8b34f44960f Prep block 2fa9dc8de9f34fb49ea27bf1387bdd40 0 a6ad8eda80604add819b50aadc0fd9d7 2fa9dc8de9f34fb49ea27bf1387bdd40--a6ad8eda80604add819b50aadc0fd9d7 aec10b8d4a594bed9f11859cf0bda35b 1 cf36fbbd800e4cdda85395d88535958d RX(theta\u2080) a6ad8eda80604add819b50aadc0fd9d7--cf36fbbd800e4cdda85395d88535958d b83f5d4098e246f6ba37950b6aeee2ad RY(theta\u2084) cf36fbbd800e4cdda85395d88535958d--b83f5d4098e246f6ba37950b6aeee2ad 57cec917e1d5475c8b01dbbbe850b9cb RX(theta\u2088) b83f5d4098e246f6ba37950b6aeee2ad--57cec917e1d5475c8b01dbbbe850b9cb ea462195c6364ca381cb25d37a5beced 57cec917e1d5475c8b01dbbbe850b9cb--ea462195c6364ca381cb25d37a5beced 3c3471db2a964962aec9c7c026396125 ea462195c6364ca381cb25d37a5beced--3c3471db2a964962aec9c7c026396125 604ebe925ba2494b96dffefb2d65f6f4 RX(theta\u2081\u2082) 3c3471db2a964962aec9c7c026396125--604ebe925ba2494b96dffefb2d65f6f4 4e703c8ad78c45efb0af9eb8e0c71c2c RY(theta\u2081\u2086) 604ebe925ba2494b96dffefb2d65f6f4--4e703c8ad78c45efb0af9eb8e0c71c2c 0d7331a7c3d047638ce28bc43f901369 RX(theta\u2082\u2080) 4e703c8ad78c45efb0af9eb8e0c71c2c--0d7331a7c3d047638ce28bc43f901369 67275c467d904137bcd996fc2332607c 0d7331a7c3d047638ce28bc43f901369--67275c467d904137bcd996fc2332607c edef43d14cff4b3fb8a3548a83fc9ee3 67275c467d904137bcd996fc2332607c--edef43d14cff4b3fb8a3548a83fc9ee3 0fbd22ceeef14f13886afe452ea2c578 edef43d14cff4b3fb8a3548a83fc9ee3--0fbd22ceeef14f13886afe452ea2c578 53e4940b89b4466b8f880144ef73f87d 90401d48597e4782a12601b6a7a23aa4 aec10b8d4a594bed9f11859cf0bda35b--90401d48597e4782a12601b6a7a23aa4 a70069f1501c4beb9669ced4a496a08e 2 7488ed6bc9964e32865bbe8de13436e8 RX(theta\u2081) 90401d48597e4782a12601b6a7a23aa4--7488ed6bc9964e32865bbe8de13436e8 8c21452d29db40f591b0a0d952c4659e RY(theta\u2085) 7488ed6bc9964e32865bbe8de13436e8--8c21452d29db40f591b0a0d952c4659e 7f0f71df208c4be5904bd0ffec524b90 RX(theta\u2089) 8c21452d29db40f591b0a0d952c4659e--7f0f71df208c4be5904bd0ffec524b90 36d3a872a400414ba5a71543fa17079c X 7f0f71df208c4be5904bd0ffec524b90--36d3a872a400414ba5a71543fa17079c 36d3a872a400414ba5a71543fa17079c--ea462195c6364ca381cb25d37a5beced 6b15107f32004303b6b8f79770ff6715 36d3a872a400414ba5a71543fa17079c--6b15107f32004303b6b8f79770ff6715 2cd9b1f9355d4272afdb90ef8bc89b46 RX(theta\u2081\u2083) 6b15107f32004303b6b8f79770ff6715--2cd9b1f9355d4272afdb90ef8bc89b46 9e92e73b735e4c49aa27833c39b467c0 RY(theta\u2081\u2087) 2cd9b1f9355d4272afdb90ef8bc89b46--9e92e73b735e4c49aa27833c39b467c0 f910552b4c7f4c8385e44abb94e5ff4c RX(theta\u2082\u2081) 9e92e73b735e4c49aa27833c39b467c0--f910552b4c7f4c8385e44abb94e5ff4c b0725e5c70524c27876d572aec41de0e X f910552b4c7f4c8385e44abb94e5ff4c--b0725e5c70524c27876d572aec41de0e b0725e5c70524c27876d572aec41de0e--67275c467d904137bcd996fc2332607c ad3597df04ef461ca2cd836d1f5347c2 b0725e5c70524c27876d572aec41de0e--ad3597df04ef461ca2cd836d1f5347c2 ad3597df04ef461ca2cd836d1f5347c2--53e4940b89b4466b8f880144ef73f87d 9d7d1c5c30a341b6ba2c340c9f3015bd 814ad8d50adb4dd3a650c8af0a95c9f7 a70069f1501c4beb9669ced4a496a08e--814ad8d50adb4dd3a650c8af0a95c9f7 7dee45c279f94cfa8009be303acce868 3 257e41edaa024b52bcba26793f0c2603 RX(theta\u2082) 814ad8d50adb4dd3a650c8af0a95c9f7--257e41edaa024b52bcba26793f0c2603 2daa8594c2aa4b2dbb2255231ea8ad58 RY(theta\u2086) 257e41edaa024b52bcba26793f0c2603--2daa8594c2aa4b2dbb2255231ea8ad58 ecd97ee9a250462990c5f9e353799ced RX(theta\u2081\u2080) 2daa8594c2aa4b2dbb2255231ea8ad58--ecd97ee9a250462990c5f9e353799ced a7a9805b008048dcb5b67de18d705fbd ecd97ee9a250462990c5f9e353799ced--a7a9805b008048dcb5b67de18d705fbd d38a48ac2003419089f3bf2d88a566b7 X a7a9805b008048dcb5b67de18d705fbd--d38a48ac2003419089f3bf2d88a566b7 d38a48ac2003419089f3bf2d88a566b7--6b15107f32004303b6b8f79770ff6715 7eb1605e72e0499c97ef8bb31c2dbe34 RX(theta\u2081\u2084) d38a48ac2003419089f3bf2d88a566b7--7eb1605e72e0499c97ef8bb31c2dbe34 8d8df817d5624f26add835b6cdce4e6d RY(theta\u2081\u2088) 7eb1605e72e0499c97ef8bb31c2dbe34--8d8df817d5624f26add835b6cdce4e6d 8de0fe047c484a0d9d40b776d96f462a RX(theta\u2082\u2082) 8d8df817d5624f26add835b6cdce4e6d--8de0fe047c484a0d9d40b776d96f462a a464fbaaaf924d5d8714639fd735f3aa 8de0fe047c484a0d9d40b776d96f462a--a464fbaaaf924d5d8714639fd735f3aa d6701d8e44374b65bce33c8b0e5613cf X a464fbaaaf924d5d8714639fd735f3aa--d6701d8e44374b65bce33c8b0e5613cf d6701d8e44374b65bce33c8b0e5613cf--ad3597df04ef461ca2cd836d1f5347c2 d6701d8e44374b65bce33c8b0e5613cf--9d7d1c5c30a341b6ba2c340c9f3015bd d615bedc690240d39cb6f48e49b3b5b3 079ef52bd33a4301bb54d00422d95b43 X 7dee45c279f94cfa8009be303acce868--079ef52bd33a4301bb54d00422d95b43 b3749076d3824179b391123261a4a867 RX(theta\u2083) 079ef52bd33a4301bb54d00422d95b43--b3749076d3824179b391123261a4a867 92c5b1876d424382bb40e135abdd76f3 RY(theta\u2087) b3749076d3824179b391123261a4a867--92c5b1876d424382bb40e135abdd76f3 a2728a9b56254a8ea9be8ab34ef48306 RX(theta\u2081\u2081) 92c5b1876d424382bb40e135abdd76f3--a2728a9b56254a8ea9be8ab34ef48306 74907c24fb294163b7e28869495f2a57 X a2728a9b56254a8ea9be8ab34ef48306--74907c24fb294163b7e28869495f2a57 74907c24fb294163b7e28869495f2a57--a7a9805b008048dcb5b67de18d705fbd 5d1b4f53695141a48f04a6313bf79c6b 74907c24fb294163b7e28869495f2a57--5d1b4f53695141a48f04a6313bf79c6b 1325e40ac3a44b39b3ae86b1bf2df8b4 RX(theta\u2081\u2085) 5d1b4f53695141a48f04a6313bf79c6b--1325e40ac3a44b39b3ae86b1bf2df8b4 58739be90b8348ba96a83ae093068e9b RY(theta\u2081\u2089) 1325e40ac3a44b39b3ae86b1bf2df8b4--58739be90b8348ba96a83ae093068e9b 28440f4e3785414f8976b089ef13a065 RX(theta\u2082\u2083) 58739be90b8348ba96a83ae093068e9b--28440f4e3785414f8976b089ef13a065 e90dc05f28e344b49f1f9458675aeced X 28440f4e3785414f8976b089ef13a065--e90dc05f28e344b49f1f9458675aeced e90dc05f28e344b49f1f9458675aeced--a464fbaaaf924d5d8714639fd735f3aa 6beb9df2063d4bc8be1e6aebe4683003 e90dc05f28e344b49f1f9458675aeced--6beb9df2063d4bc8be1e6aebe4683003 6beb9df2063d4bc8be1e6aebe4683003--d615bedc690240d39cb6f48e49b3b5b3  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[ 0.4778-0.3032j, -0.2188+0.0063j, -0.5854+0.1054j, -0.0209+0.1171j,\n         -0.1233+0.1146j,  0.2949-0.1529j,  0.2178+0.2514j,  0.0053+0.1206j],\n        [ 0.0060+0.1147j,  0.1033+0.1432j, -0.2309+0.3088j, -0.2681+0.2402j,\n         -0.2283-0.2065j, -0.4066+0.1532j, -0.5098-0.1379j,  0.2512-0.2275j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}