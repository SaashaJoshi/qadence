{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>For a high-level overview of Qadence features, check out our white paper.</p> <p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from qadence import X, Y, HamEvo, Register, product_state, sample, add, PI\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = PI / (2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from qadence import Register, AnalogRX, sample, PI\n\n# Global analog RX block.\nblock = AnalogRX(PI)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(PI))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 43, '10': 32, '01': 25})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@article{qadence2024pasqal,\n  title = {Qadence: a differentiable interface for digital-analog programs.},\n  author={Dominik Seitz and Niklas Heim and Jo\u00e3o P. Moutinho and Roland Guichard and Vytautas Abramavicius and Aleksander Wennersteen and Gert-Jan Both and Anton Quelle and Caroline de Groot and Gergana V. Velikova and Vincent E. Elfving and Mario Dagrada},\n  journal={arXiv:2401.09915},\n  url = {https://github.com/pasqal-io/qadence},\n  year = {2024}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    def _is_feature_param(p: Parameter) -&gt; bool:\n        return not p.trainable and not p.is_number\n\n    if observable is None:\n        self.inputs = list(filter(_is_feature_param, circuit.unique_parameters))\n    else:\n        uparams = unique_parameters(chain(circuit.block, *observable))\n        self.inputs = list(filter(_is_feature_param, uparams))\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    else:\n        self._noise = noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/","title":"Advanced Tutorials","text":"<p>In this section, advanced programming concepts and implementations in Qadence are examplified.</p>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available via the PyQTorch or Horqrux backends</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> or <code>horqrux</code> backends are selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#adjoint-differentiation","title":"Adjoint Differentiation","text":"<p>Qadence also offers a memory-efficient, non-device compatible alternative to automatic differentation, called 'Adjoint Differentiation' <sup>4</sup> and allows for precisely calculating the gradients of variational parameters in O(P) time and using O(1) state-vectors. Adjoint Differentation is currently only supported by the Torch Engine and allows for first-order derivatives only.</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the differentiation modes can be selected via the <code>diff_mode</code> argument of the QuantumModel class. It either accepts a <code>DiffMode</code>(<code>DiffMode.GSPR</code>, <code>DiffMode.AD</code> or <code>DiffMode.ADJOINT</code>) or a string (<code>\"gpsr\"\"</code>, <code>\"ad\"</code> or <code>\"adjoint\"</code>). The code in the box below shows how to create <code>QuantumModel</code> instances with all available differentiation modes.</p> <pre><code>from qadence import (FeatureParameter, RX, Z, hea, chain,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# Define a symbolic parameter to differentiate with respect to\nx = FeatureParameter(\"x\")\n\nblock = chain(hea(n_qubits, 1), RX(0, x))\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD, ADJOINT and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_adjoint = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.ADJOINT)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# Create concrete values for the parameter we want to differentiate with respect to\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_adjoint = model_adjoint.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_adjoint = torch.autograd.grad(\n    exp_val_adjoint, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD ,ADJOINT and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_adjoint.detach().numpy(),\n           label=\"df/dx ADJOINT\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2024-02-01T18:45:07.675936 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence.engines.torch import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#low-level-differentiation-of-qadence-circuits-using-jax","title":"Low-level differentiation of qadence circuits using JAX","text":"<p>For users interested in using the <code>JAX</code> engine instead, we show how to run and differentiate qadence programs using the <code>horqrux</code> backend under qadence examples.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> <li> <p>Tyson et al., Efficient calculation of gradients in classical simulations of variational quantum algorithms \u21a9</p> </li> </ol>"},{"location":"advanced_tutorials/projectors/","title":"Projector blocks","text":"<p>This section introduces the <code>ProjectorBlock</code> as an implementation for the quantum mechanical projection operation onto the subspace spanned by \\(|a\\rangle\\): \\(\\mathbb{\\hat{P}}=|a\\rangle \\langle a|\\). It evaluates the outer product for bras and kets expressed as bitstrings for a given qubit support. They have to possess matching lengths.</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence.operations import Projector  # Projector as an operation.\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# As any block, the matrix representation can be retrieved.\nprojector_matrix = block_to_tensor(projector_block)\n</code></pre> <pre><code>projector matrix = tensor([[[0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\n</code></pre> <p>Other standard operations are expressed as projectors in Qadence. For instance, the number operator is the projector onto the 1-subspace, \\(N=|1\\rangle\\langle 1|\\).</p> <p>In fact, projectors can be used to compose any arbitrary operator. For example, the <code>CNOT</code> can be defined as \\(\\textrm{CNOT}(i,j)=|0\\rangle\\langle 0|_i\\otimes \\mathbb{I}_j+|1\\rangle\\langle 1|_i\\otimes X_j\\) and we can compare its matrix representation with the native one in Qadence:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import kron, I, X, CNOT\n\n# Define a projector for |0&gt; onto the qubit labelled 0.\nprojector0 = Projector(ket=\"0\", bra=\"0\", qubit_support=0)\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector1 = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# Construct the projector controlled CNOT.\nprojector_cnot = kron(projector0, I(1)) + kron(projector1, X(1))\n\n# Get the underlying unitary.\nprojector_cnot_matrix = block_to_tensor(projector_cnot)\n\n# Qadence CNOT unitary.\nqadence_cnot_matrix = block_to_tensor(CNOT(0,1))\n</code></pre> <pre><code>projector cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nqadence cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> <p>Another example is the canonical SWAP unitary that can be defined as \\(SWAP=|00\\rangle\\langle 00|+|01\\rangle\\langle 10|+|10\\rangle\\langle 01|+|11\\rangle\\langle 11|\\). Indeed, it can be shown that their matricial representations are again identical:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import SWAP\n\n# Define all projectors.\nprojector00 = Projector(ket=\"00\", bra=\"00\", qubit_support=(0, 1))\nprojector01 = Projector(ket=\"01\", bra=\"10\", qubit_support=(0, 1))\nprojector10 = Projector(ket=\"10\", bra=\"01\", qubit_support=(0, 1))\nprojector11 = Projector(ket=\"11\", bra=\"11\", qubit_support=(0, 1))\n\n# Construct the SWAP gate.\nprojector_swap = projector00 + projector10 + projector01 + projector11\n\n# Get the underlying unitary.\nprojector_swap_matrix = block_to_tensor(projector_swap)\n\n# Qadence SWAP unitary.\nqadence_swap_matrix = block_to_tensor(SWAP(0,1))\n</code></pre> <pre><code>projector swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]])\nqadence swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]], grad_fn=&lt;UnsafeViewBackward0&gt;)\n</code></pre> <p>Warning</p> <p>Projectors are non-unitary operators, only supported by the PyQTorch backend.</p> <p>To examplify this point, let's run some non-unitary computation involving projectors.</p> <pre><code>from qadence import chain, run\nfrom qadence.operations import H, CNOT\n\n# Define a projector for |1&gt; onto the qubit labelled 1.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=1)\n\n# Some non-unitary computation.\nnon_unitary_block = chain(H(0), CNOT(0,1), projector_block)\n\n# Projected wavefunction becomes unnormalized\nprojected_wf = run(non_unitary_block)  # Run on PyQTorch.\n</code></pre> <pre><code>projected_wf = tensor([[0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>supports_adjoint</code> <p>Does the backend support native adjoint differentation.</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p> <code>native_endianness</code> <p>The native endianness of the backend</p> <p> TYPE: <code>Endianness</code> </p> <code>engine</code> <p>The underlying (native) automatic differentiation engine of the backend.</p> <p> TYPE: <code>Engine</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: ArrayLike | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, InteractionBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine TORCH.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.TORCH, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine JAX.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.JAX, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = self.backend.expectation(circuit, observable, param_values, state)\n    else:\n        expectation = DifferentiableExpectation(\n            backend=self.backend,\n            circuit=circuit,\n            observable=observable,\n            param_values=param_values,\n            state=state,\n            measurement=measurement,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        ).psr()\n    return expectation\n</code></pre>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Qadence offers both a PyTorch and Jax differentiation engine.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are applied by implementing a custom <code>torch.autograd.Function</code> class for PyTorch and the <code>custom_vjp</code> in the Jax Engine, respectively.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> under <code>qadence.engines.torch.differentiable_expectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 a00d46440d5a4618a65eec8b76010f41 0 09acb688862e4243899cef325d666eed X a00d46440d5a4618a65eec8b76010f41--09acb688862e4243899cef325d666eed acff06ea0abb4b0987b3884aea52503c 1 3d43413a22664715906000e70f9424e1 09acb688862e4243899cef325d666eed--3d43413a22664715906000e70f9424e1 b81a211225f14e16be62dbd1deea642a 359c8e817e9b4b7a8fc5b34d8bfbe7f3 Y acff06ea0abb4b0987b3884aea52503c--359c8e817e9b4b7a8fc5b34d8bfbe7f3 359c8e817e9b4b7a8fc5b34d8bfbe7f3--b81a211225f14e16be62dbd1deea642a <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 121bc7651c8d45ae8e6c85bdbea0e073 0 9a5073e700dc4fbf8ba6622b59ec69e1 X 121bc7651c8d45ae8e6c85bdbea0e073--9a5073e700dc4fbf8ba6622b59ec69e1 417eb86ce1254c469e154251e836a8bb Y 9a5073e700dc4fbf8ba6622b59ec69e1--417eb86ce1254c469e154251e836a8bb 2f60cf6560ff4e429c830b6d8457ad38 417eb86ce1254c469e154251e836a8bb--2f60cf6560ff4e429c830b6d8457ad38 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 daee64427fe64742b6ffc0167a86a5af 0 d5490a34a7b04ddca0f87247a2ef18c2 X daee64427fe64742b6ffc0167a86a5af--d5490a34a7b04ddca0f87247a2ef18c2 77be95aa2afb411d997e51b90a2ace88 1 d8d372f9664b43bb8b1d19823dbb150d d5490a34a7b04ddca0f87247a2ef18c2--d8d372f9664b43bb8b1d19823dbb150d f4d25d58d71144768c876684f1844a7c d8d372f9664b43bb8b1d19823dbb150d--f4d25d58d71144768c876684f1844a7c 5d242bcd040b4a9e84629c6c48882b01 dd6e9339ced34e689e668826492c8793 77be95aa2afb411d997e51b90a2ace88--dd6e9339ced34e689e668826492c8793 fa25b69293c94c91948b0a9724b2dca0 Y dd6e9339ced34e689e668826492c8793--fa25b69293c94c91948b0a9724b2dca0 fa25b69293c94c91948b0a9724b2dca0--5d242bcd040b4a9e84629c6c48882b01 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_62f2753ce8e041e58c43bb0a070a3408 28f9ce3e367449639641c0b0f6e19665 0 e96e591a92ff42de88a06467737fa46c 28f9ce3e367449639641c0b0f6e19665--e96e591a92ff42de88a06467737fa46c 9ff01bf1d03c433399935a3529e8a58f 1 a29507d2f58d472fa479b8ebd971a21e e96e591a92ff42de88a06467737fa46c--a29507d2f58d472fa479b8ebd971a21e 8ec39d8156f442f794c88fa882afa04a 13b144483db8423b80060d4a56b96389 AddBlock 9ff01bf1d03c433399935a3529e8a58f--13b144483db8423b80060d4a56b96389 9875a7995548476c80cb471b741b3edc 2 13b144483db8423b80060d4a56b96389--8ec39d8156f442f794c88fa882afa04a c6a2aa77c9d6435483813ebb2567c883 8b7024e5cbdf49bf937a0e03b3a83584 9875a7995548476c80cb471b741b3edc--8b7024e5cbdf49bf937a0e03b3a83584 8b7024e5cbdf49bf937a0e03b3a83584--c6a2aa77c9d6435483813ebb2567c883 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_68c1ce1d550045a79fb2f79ce36a5064 cluster_29ce94d9d66e413e8a5729f17c450ae5 rx efe4e2e2e5064e369b0893c30e417028 0 dffcc76d03e445c28f768bd51922f622 X efe4e2e2e5064e369b0893c30e417028--dffcc76d03e445c28f768bd51922f622 5505fe506e0747c7b557d40fcac99698 1 2d72b9c114a0478bbfa22591b7894a5f dffcc76d03e445c28f768bd51922f622--2d72b9c114a0478bbfa22591b7894a5f 07a4ed02f49643329177a923dacf101c 2d72b9c114a0478bbfa22591b7894a5f--07a4ed02f49643329177a923dacf101c 3e74f8c7de5c4956822c58a8e03b5935 07a4ed02f49643329177a923dacf101c--3e74f8c7de5c4956822c58a8e03b5935 51f3bb05dede48e692e33485b504353b a8766c358012499ab8d3b640875d36fb Y 5505fe506e0747c7b557d40fcac99698--a8766c358012499ab8d3b640875d36fb 85952245ae4d45f183770cdc5a31ff18 2 0995d8ff23604284bec5aeb68175a9dc a8766c358012499ab8d3b640875d36fb--0995d8ff23604284bec5aeb68175a9dc de98f26c826c4a47a6a4c907527b4d36 HamEvo 0995d8ff23604284bec5aeb68175a9dc--de98f26c826c4a47a6a4c907527b4d36 de98f26c826c4a47a6a4c907527b4d36--51f3bb05dede48e692e33485b504353b ed42d7b45a7f4034ba7cdca7cc5aa462 9db8936fa512456faf75d83d1e53364e RX(x) 85952245ae4d45f183770cdc5a31ff18--9db8936fa512456faf75d83d1e53364e 70681761fc494aa0b03ec8adbcf5065d 3 3039236215ce494faae4d7b4548830ab 9db8936fa512456faf75d83d1e53364e--3039236215ce494faae4d7b4548830ab ea90a92038d4432f92799f6474d7cb43 t = 10 3039236215ce494faae4d7b4548830ab--ea90a92038d4432f92799f6474d7cb43 ea90a92038d4432f92799f6474d7cb43--ed42d7b45a7f4034ba7cdca7cc5aa462 499c195ceaa7480fa383fced47123219 3234f502ea6b4f8c848a759323bd37bc RX(0.5) 70681761fc494aa0b03ec8adbcf5065d--3234f502ea6b4f8c848a759323bd37bc 94b09d7e96d841b684a1ad919a0484a3 X 3234f502ea6b4f8c848a759323bd37bc--94b09d7e96d841b684a1ad919a0484a3 94b09d7e96d841b684a1ad919a0484a3--3039236215ce494faae4d7b4548830ab a8af6dda8b0e470297d29bd434a82621 94b09d7e96d841b684a1ad919a0484a3--a8af6dda8b0e470297d29bd434a82621 a8af6dda8b0e470297d29bd434a82621--499c195ceaa7480fa383fced47123219 <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_91530a6e1aea455baa66d80c63317cfe HEA cluster_b5dbdb9e031e452380340af850083f97 Tower Fourier FM d296e989b5284aa9adc385a1c2ab9cef 0 1deaed6aa851427aa7c0a8681a8ad6b3 RX(1.0*phi) d296e989b5284aa9adc385a1c2ab9cef--1deaed6aa851427aa7c0a8681a8ad6b3 ef05acee81514ee8acbedc78ed469426 1 f5d73f808fc14da2ba76cbcac35dcd1d RX(theta\u2080) 1deaed6aa851427aa7c0a8681a8ad6b3--f5d73f808fc14da2ba76cbcac35dcd1d 203b380164254ac08738bb652c46bddb RY(theta\u2084) f5d73f808fc14da2ba76cbcac35dcd1d--203b380164254ac08738bb652c46bddb 96388d7bf23c469dbd005fab4c90b531 RX(theta\u2088) 203b380164254ac08738bb652c46bddb--96388d7bf23c469dbd005fab4c90b531 0492a2c6c1314f84b15e21e5716175f7 96388d7bf23c469dbd005fab4c90b531--0492a2c6c1314f84b15e21e5716175f7 edfbc908a93d49a183e2a358072f0654 0492a2c6c1314f84b15e21e5716175f7--edfbc908a93d49a183e2a358072f0654 312f40f24f5748e3ac56d7403a587aba RX(theta\u2081\u2082) edfbc908a93d49a183e2a358072f0654--312f40f24f5748e3ac56d7403a587aba 105611e675304dc1956f2c73e4f47e33 RY(theta\u2081\u2086) 312f40f24f5748e3ac56d7403a587aba--105611e675304dc1956f2c73e4f47e33 6f47e4256dc441b1b8f688a90ffe8d32 RX(theta\u2082\u2080) 105611e675304dc1956f2c73e4f47e33--6f47e4256dc441b1b8f688a90ffe8d32 959b9d02a0fa4e83ac11bfc06d37a1d7 6f47e4256dc441b1b8f688a90ffe8d32--959b9d02a0fa4e83ac11bfc06d37a1d7 bbedfda7ccf049f0a939bfaa14facc90 959b9d02a0fa4e83ac11bfc06d37a1d7--bbedfda7ccf049f0a939bfaa14facc90 d5204a012914439eaf5b292d84c8346c bbedfda7ccf049f0a939bfaa14facc90--d5204a012914439eaf5b292d84c8346c e73a8f81b87d4975915b5947659d2051 bc77ce435f684794834899afeea77ba5 RX(2.0*phi) ef05acee81514ee8acbedc78ed469426--bc77ce435f684794834899afeea77ba5 185cc06e09c24021a48c712c59ec81fe 2 883ab2fef7374f69b45c114077430961 RX(theta\u2081) bc77ce435f684794834899afeea77ba5--883ab2fef7374f69b45c114077430961 1430fa0630584faaa7c45e1eb11578c2 RY(theta\u2085) 883ab2fef7374f69b45c114077430961--1430fa0630584faaa7c45e1eb11578c2 fefb41ad9b0d4bfab94f0bd4691c32ea RX(theta\u2089) 1430fa0630584faaa7c45e1eb11578c2--fefb41ad9b0d4bfab94f0bd4691c32ea da0d03a17a30441cb6422f963a56f840 X fefb41ad9b0d4bfab94f0bd4691c32ea--da0d03a17a30441cb6422f963a56f840 da0d03a17a30441cb6422f963a56f840--0492a2c6c1314f84b15e21e5716175f7 318131972f314dd982760e6cecdee648 da0d03a17a30441cb6422f963a56f840--318131972f314dd982760e6cecdee648 8d914ce911f54c17a05b9bb22d071522 RX(theta\u2081\u2083) 318131972f314dd982760e6cecdee648--8d914ce911f54c17a05b9bb22d071522 1cf76ebebcb848a58a0d5424015a5a3e RY(theta\u2081\u2087) 8d914ce911f54c17a05b9bb22d071522--1cf76ebebcb848a58a0d5424015a5a3e 1bd639d7821f473ab238bf2c7887acfc RX(theta\u2082\u2081) 1cf76ebebcb848a58a0d5424015a5a3e--1bd639d7821f473ab238bf2c7887acfc 1d35cb48ff7d45c78c8a634498b02262 X 1bd639d7821f473ab238bf2c7887acfc--1d35cb48ff7d45c78c8a634498b02262 1d35cb48ff7d45c78c8a634498b02262--959b9d02a0fa4e83ac11bfc06d37a1d7 3fb9a32ee0fc4db5a2abc53e27813f01 1d35cb48ff7d45c78c8a634498b02262--3fb9a32ee0fc4db5a2abc53e27813f01 3fb9a32ee0fc4db5a2abc53e27813f01--e73a8f81b87d4975915b5947659d2051 5e804212bfa048ccbf7733fe5f9f4f5c 9f5c6952ece54226b041bcb62a96bf95 RX(3.0*phi) 185cc06e09c24021a48c712c59ec81fe--9f5c6952ece54226b041bcb62a96bf95 6a70f057404c49b29fa49b62f0cc3109 3 f2b047aa370a434e9296a9d8f6fde316 RX(theta\u2082) 9f5c6952ece54226b041bcb62a96bf95--f2b047aa370a434e9296a9d8f6fde316 17f0efe8bde34620baeb02c20340f0a9 RY(theta\u2086) f2b047aa370a434e9296a9d8f6fde316--17f0efe8bde34620baeb02c20340f0a9 d6c0816dfd1646f6904f4346f1a49114 RX(theta\u2081\u2080) 17f0efe8bde34620baeb02c20340f0a9--d6c0816dfd1646f6904f4346f1a49114 91bb516f49c044d6b950f843533c2bef d6c0816dfd1646f6904f4346f1a49114--91bb516f49c044d6b950f843533c2bef 7a19588206a44b58b1453158d78ed827 X 91bb516f49c044d6b950f843533c2bef--7a19588206a44b58b1453158d78ed827 7a19588206a44b58b1453158d78ed827--318131972f314dd982760e6cecdee648 67dd3941e4df4dcf95bbd4ecabaad124 RX(theta\u2081\u2084) 7a19588206a44b58b1453158d78ed827--67dd3941e4df4dcf95bbd4ecabaad124 d605f5974c9b4be68380ee0047c42596 RY(theta\u2081\u2088) 67dd3941e4df4dcf95bbd4ecabaad124--d605f5974c9b4be68380ee0047c42596 7578f0c3f78f4fcd977c8050852ae0cc RX(theta\u2082\u2082) d605f5974c9b4be68380ee0047c42596--7578f0c3f78f4fcd977c8050852ae0cc fda3fc31887745ab9fc8dd6ac2a8de36 7578f0c3f78f4fcd977c8050852ae0cc--fda3fc31887745ab9fc8dd6ac2a8de36 c02f19f491844055a1c30c4739a84cf7 X fda3fc31887745ab9fc8dd6ac2a8de36--c02f19f491844055a1c30c4739a84cf7 c02f19f491844055a1c30c4739a84cf7--3fb9a32ee0fc4db5a2abc53e27813f01 c02f19f491844055a1c30c4739a84cf7--5e804212bfa048ccbf7733fe5f9f4f5c 68c3d8d9de644e89802fd95b6715e9ab ed689f2d8929413585ccea8fb16d0e9e RX(4.0*phi) 6a70f057404c49b29fa49b62f0cc3109--ed689f2d8929413585ccea8fb16d0e9e 1de75a7b85d04e39b579bfd96a09ca53 RX(theta\u2083) ed689f2d8929413585ccea8fb16d0e9e--1de75a7b85d04e39b579bfd96a09ca53 859b7c63f6cf44aaa009fcf828bfb523 RY(theta\u2087) 1de75a7b85d04e39b579bfd96a09ca53--859b7c63f6cf44aaa009fcf828bfb523 d65479c9457a4eb3b89c49298de75872 RX(theta\u2081\u2081) 859b7c63f6cf44aaa009fcf828bfb523--d65479c9457a4eb3b89c49298de75872 d1eee458e3bc445c931b484d21452e38 X d65479c9457a4eb3b89c49298de75872--d1eee458e3bc445c931b484d21452e38 d1eee458e3bc445c931b484d21452e38--91bb516f49c044d6b950f843533c2bef 0ddb4806e0e042a9a4e0db180191089e d1eee458e3bc445c931b484d21452e38--0ddb4806e0e042a9a4e0db180191089e 27d2a37f5d1348db950ccaaf29fa70de RX(theta\u2081\u2085) 0ddb4806e0e042a9a4e0db180191089e--27d2a37f5d1348db950ccaaf29fa70de 414b6848d40b4c1baea5196c675cfddb RY(theta\u2081\u2089) 27d2a37f5d1348db950ccaaf29fa70de--414b6848d40b4c1baea5196c675cfddb 53a4435ba68c48f1bc2653e820b83e51 RX(theta\u2082\u2083) 414b6848d40b4c1baea5196c675cfddb--53a4435ba68c48f1bc2653e820b83e51 1449daab257b4bc1981fca52bbe3885a X 53a4435ba68c48f1bc2653e820b83e51--1449daab257b4bc1981fca52bbe3885a 1449daab257b4bc1981fca52bbe3885a--fda3fc31887745ab9fc8dd6ac2a8de36 c2fb6ffaf8e243c197c8e6983dabd2b7 1449daab257b4bc1981fca52bbe3885a--c2fb6ffaf8e243c197c8e6983dabd2b7 c2fb6ffaf8e243c197c8e6983dabd2b7--68c3d8d9de644e89802fd95b6715e9ab <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_3ff90e4b80454c6fabf2869179773fb6 Obs. cluster_80c0fe5d948e44e0a9e6564cdc0de409 cluster_4d4b3267ab3e43a391c6632e87e1e170 HEA 37347b1b38014412b9ecd7e4312f075e 0 b4daab62927b4edf907b47adce9b925f RX(theta\u2080) 37347b1b38014412b9ecd7e4312f075e--b4daab62927b4edf907b47adce9b925f 6252fcc6f0ec4377a482fb8c7c104a17 1 452f68a3975a4097a6ee76b64e35b100 RY(theta\u2083) b4daab62927b4edf907b47adce9b925f--452f68a3975a4097a6ee76b64e35b100 ad1184fd36bf4b2ba3185d80bded28ce RX(theta\u2086) 452f68a3975a4097a6ee76b64e35b100--ad1184fd36bf4b2ba3185d80bded28ce af6ce40d5b8c4526bc5e0e307fd61a71 ad1184fd36bf4b2ba3185d80bded28ce--af6ce40d5b8c4526bc5e0e307fd61a71 0ae63b78a36b443eb862f77278360b68 af6ce40d5b8c4526bc5e0e307fd61a71--0ae63b78a36b443eb862f77278360b68 de7c44a987f141ca9abb047bcfeed0e4 RX(theta\u2089) 0ae63b78a36b443eb862f77278360b68--de7c44a987f141ca9abb047bcfeed0e4 01af042632e44d4db957a061820cf76c RY(theta\u2081\u2082) de7c44a987f141ca9abb047bcfeed0e4--01af042632e44d4db957a061820cf76c 899948b94d9940a680fe1febb7b1b8a5 RX(theta\u2081\u2085) 01af042632e44d4db957a061820cf76c--899948b94d9940a680fe1febb7b1b8a5 685de9bb68da4874a80c00ed671ee363 899948b94d9940a680fe1febb7b1b8a5--685de9bb68da4874a80c00ed671ee363 0a9727db6f584ff2bb266b1020df9705 685de9bb68da4874a80c00ed671ee363--0a9727db6f584ff2bb266b1020df9705 b210cb10a6a748bfb1058fe8b99b67a1 0a9727db6f584ff2bb266b1020df9705--b210cb10a6a748bfb1058fe8b99b67a1 a49e4e9365284b0d8339077cb08a329a b210cb10a6a748bfb1058fe8b99b67a1--a49e4e9365284b0d8339077cb08a329a 8aec05941a794f6bbb5e0dec581dd61e 08e96e99697245ddab209d1f9d2d2d3d RX(theta\u2081) 6252fcc6f0ec4377a482fb8c7c104a17--08e96e99697245ddab209d1f9d2d2d3d 4b0ac100794a4166aa3c100a5a68f86c 2 65c4173163c14bbdb222ddf004147c08 RY(theta\u2084) 08e96e99697245ddab209d1f9d2d2d3d--65c4173163c14bbdb222ddf004147c08 622fa6af4a2d4b5694c0ce0d18d054da RX(theta\u2087) 65c4173163c14bbdb222ddf004147c08--622fa6af4a2d4b5694c0ce0d18d054da 790841d86aa74829bc1f56a4df0dd654 X 622fa6af4a2d4b5694c0ce0d18d054da--790841d86aa74829bc1f56a4df0dd654 790841d86aa74829bc1f56a4df0dd654--af6ce40d5b8c4526bc5e0e307fd61a71 012b99a1fe054f35933ac6096effd44f 790841d86aa74829bc1f56a4df0dd654--012b99a1fe054f35933ac6096effd44f aae7c9bb1b7f475aa33e26baa99fc2f4 RX(theta\u2081\u2080) 012b99a1fe054f35933ac6096effd44f--aae7c9bb1b7f475aa33e26baa99fc2f4 d44fc6b026d8432380ab9585b0a60a7f RY(theta\u2081\u2083) aae7c9bb1b7f475aa33e26baa99fc2f4--d44fc6b026d8432380ab9585b0a60a7f 26960d2abba34bbe9d2f8606bbe6f273 RX(theta\u2081\u2086) d44fc6b026d8432380ab9585b0a60a7f--26960d2abba34bbe9d2f8606bbe6f273 5b7b5b3e18114713a8e3573e51cc4630 X 26960d2abba34bbe9d2f8606bbe6f273--5b7b5b3e18114713a8e3573e51cc4630 5b7b5b3e18114713a8e3573e51cc4630--685de9bb68da4874a80c00ed671ee363 d607382632a749d5bd92c693323ef94e 5b7b5b3e18114713a8e3573e51cc4630--d607382632a749d5bd92c693323ef94e 47244fcf35514322aa6defb519529240 AddBlock d607382632a749d5bd92c693323ef94e--47244fcf35514322aa6defb519529240 47244fcf35514322aa6defb519529240--8aec05941a794f6bbb5e0dec581dd61e e2c07102001e40a690b382094a2c7f4f 643a0920e212459385abd2d91b098af8 RX(theta\u2082) 4b0ac100794a4166aa3c100a5a68f86c--643a0920e212459385abd2d91b098af8 e8cd00321f354814b2d980387afad4a1 RY(theta\u2085) 643a0920e212459385abd2d91b098af8--e8cd00321f354814b2d980387afad4a1 f10c49bd5d8c4a29bd663782691f0ba9 RX(theta\u2088) e8cd00321f354814b2d980387afad4a1--f10c49bd5d8c4a29bd663782691f0ba9 7201f8e7138549269f2da9013010e567 f10c49bd5d8c4a29bd663782691f0ba9--7201f8e7138549269f2da9013010e567 36a9fd3d1e1b47e18c9de8416b321351 X 7201f8e7138549269f2da9013010e567--36a9fd3d1e1b47e18c9de8416b321351 36a9fd3d1e1b47e18c9de8416b321351--012b99a1fe054f35933ac6096effd44f a88a4e8796b1456db3ff664ac12e7f75 RX(theta\u2081\u2081) 36a9fd3d1e1b47e18c9de8416b321351--a88a4e8796b1456db3ff664ac12e7f75 bb0b6c1b2bc3446897ee68d37828f8ab RY(theta\u2081\u2084) a88a4e8796b1456db3ff664ac12e7f75--bb0b6c1b2bc3446897ee68d37828f8ab 0ffb3d2a57e24e66b2c52689ad178316 RX(theta\u2081\u2087) bb0b6c1b2bc3446897ee68d37828f8ab--0ffb3d2a57e24e66b2c52689ad178316 c2271c3d114f450cb1088b3079f6551e 0ffb3d2a57e24e66b2c52689ad178316--c2271c3d114f450cb1088b3079f6551e f1b68527fc6849ebb326a609d9302503 X c2271c3d114f450cb1088b3079f6551e--f1b68527fc6849ebb326a609d9302503 f1b68527fc6849ebb326a609d9302503--d607382632a749d5bd92c693323ef94e dc038862eab64f12a6a70b2265f8b395 f1b68527fc6849ebb326a609d9302503--dc038862eab64f12a6a70b2265f8b395 dc038862eab64f12a6a70b2265f8b395--e2c07102001e40a690b382094a2c7f4f <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 06e4e8e7c1064934a7ef3a56057e9313 0 f084e2a5b1ba4f1cb8a254277db3a5ef 06e4e8e7c1064934a7ef3a56057e9313--f084e2a5b1ba4f1cb8a254277db3a5ef 0455dd314c464b84b02989d907ad5e62 1 20e7f8bf5a214949bf438d7a2deb106a ec331c50f2f0488e8d355556c65f5e81 f084e2a5b1ba4f1cb8a254277db3a5ef--ec331c50f2f0488e8d355556c65f5e81 809adcde008a47dd8a13f89635c78ae3 20e7f8bf5a214949bf438d7a2deb106a--809adcde008a47dd8a13f89635c78ae3 e7f150a6643741069bbffcf9a80ca125 1cb96cfc6490477d92a26f6c53d7fea6 809adcde008a47dd8a13f89635c78ae3--1cb96cfc6490477d92a26f6c53d7fea6 406afee553d94010b9ca3812c7c72a05 e7f150a6643741069bbffcf9a80ca125--406afee553d94010b9ca3812c7c72a05 e05ff08829164fe1a2dbab13766a741e d77ff2e200244b9795982e6d51d52156 0455dd314c464b84b02989d907ad5e62--d77ff2e200244b9795982e6d51d52156 61e2b5f00e65487d957c9f151e944215 2 d77ff2e200244b9795982e6d51d52156--20e7f8bf5a214949bf438d7a2deb106a 5535f8404bae4097bfb3059587430375 ec331c50f2f0488e8d355556c65f5e81--5535f8404bae4097bfb3059587430375 ab0f89e5d6324a5cae43ecf902c14e2f 5535f8404bae4097bfb3059587430375--ab0f89e5d6324a5cae43ecf902c14e2f ab0f89e5d6324a5cae43ecf902c14e2f--e05ff08829164fe1a2dbab13766a741e 5bc4249dd07e469c80c41c314ca3453a fcca21a0adce489cb9d96f609ce1cd47 61e2b5f00e65487d957c9f151e944215--fcca21a0adce489cb9d96f609ce1cd47 c8b16280618e41cd905f6498b43e9b06 3 1736ee48597d40edb888b2fb3b5472be fcca21a0adce489cb9d96f609ce1cd47--1736ee48597d40edb888b2fb3b5472be 936c034bc8474f5a98cf495726792b90 1736ee48597d40edb888b2fb3b5472be--936c034bc8474f5a98cf495726792b90 d965e908706f43b8b8de461070d14a18 936c034bc8474f5a98cf495726792b90--d965e908706f43b8b8de461070d14a18 d965e908706f43b8b8de461070d14a18--5bc4249dd07e469c80c41c314ca3453a 90d5dfd2dd004fd59fb531a4d3ef9498 688ddcff6ef24372939a60cca2a5af34 c8b16280618e41cd905f6498b43e9b06--688ddcff6ef24372939a60cca2a5af34 5ca5777847eb421ead8409fde0ec8904 688ddcff6ef24372939a60cca2a5af34--5ca5777847eb421ead8409fde0ec8904 f620170f2eb04cb588362db8085ac390 5ca5777847eb421ead8409fde0ec8904--f620170f2eb04cb588362db8085ac390 f620170f2eb04cb588362db8085ac390--e7f150a6643741069bbffcf9a80ca125 1cb96cfc6490477d92a26f6c53d7fea6--90d5dfd2dd004fd59fb531a4d3ef9498 <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 53b08cb3e9d44b8aaede0788d28bb91f 0 923f87943c1e42c49845a5f948f1183a 53b08cb3e9d44b8aaede0788d28bb91f--923f87943c1e42c49845a5f948f1183a b17e28cf57a24b489cc372757b0b041d 1 c43e4a87a799404486e16c6eebb5a3e9 923f87943c1e42c49845a5f948f1183a--c43e4a87a799404486e16c6eebb5a3e9 dd03e80f74d642ef8c495a32e04dd2f8 c43e4a87a799404486e16c6eebb5a3e9--dd03e80f74d642ef8c495a32e04dd2f8 5880642aa2e149339bd0e51bef89734d dd03e80f74d642ef8c495a32e04dd2f8--5880642aa2e149339bd0e51bef89734d 66663fdb83714f029f8c20def3c2eb7d 1141b2be54d146a891ef5e688dea5d0b PHASE(0.5) b17e28cf57a24b489cc372757b0b041d--1141b2be54d146a891ef5e688dea5d0b 427005a6ccd74f01be147464cf428471 2 1141b2be54d146a891ef5e688dea5d0b--923f87943c1e42c49845a5f948f1183a 178dba51d8ac4166a09014dee16f2448 1141b2be54d146a891ef5e688dea5d0b--178dba51d8ac4166a09014dee16f2448 8aa9f64040d34a05baeaa028844e2d51 178dba51d8ac4166a09014dee16f2448--8aa9f64040d34a05baeaa028844e2d51 8aa9f64040d34a05baeaa028844e2d51--66663fdb83714f029f8c20def3c2eb7d 2c56bf1052e346b38389376aa651c860 cd66582fceb6432681d434c63f7cde00 427005a6ccd74f01be147464cf428471--cd66582fceb6432681d434c63f7cde00 25057b8f78c94be8b83005da7dc20a2a 3 b6e078c7d04749b787fa59975cc45329 PHASE(0.5) cd66582fceb6432681d434c63f7cde00--b6e078c7d04749b787fa59975cc45329 b6e078c7d04749b787fa59975cc45329--c43e4a87a799404486e16c6eebb5a3e9 f0092f1d8a8b424faaf4d8025cbe156c b6e078c7d04749b787fa59975cc45329--f0092f1d8a8b424faaf4d8025cbe156c f0092f1d8a8b424faaf4d8025cbe156c--2c56bf1052e346b38389376aa651c860 494a2c857d244e6981928710c1c49e22 427f7bcf108142b49df6f77f0dd8d037 25057b8f78c94be8b83005da7dc20a2a--427f7bcf108142b49df6f77f0dd8d037 bad7c08ddd9443508555efce7929fa8a 427f7bcf108142b49df6f77f0dd8d037--bad7c08ddd9443508555efce7929fa8a df3f2aae981b454fa0c266f2c0da513b PHASE(0.5) bad7c08ddd9443508555efce7929fa8a--df3f2aae981b454fa0c266f2c0da513b df3f2aae981b454fa0c266f2c0da513b--dd03e80f74d642ef8c495a32e04dd2f8 df3f2aae981b454fa0c266f2c0da513b--494a2c857d244e6981928710c1c49e22"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from qadence import AnalogRot, PI\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = PI, # [rad/\u03bcs]\n    delta = PI, # [rad/\u03bcs]\n    phase = PI, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run, PI\nfrom qadence.analog.constants import C6_DICT\nfrom math import cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = PI\ndelta = PI\nphase = PI\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run, PI\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = PI\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>AnalogInteraction</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, AnalogInteraction, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = AnalogInteraction(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction, PI\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * PI * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * PI * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice, PI\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = PI)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>AnalogInteraction</code> operation initializes an <code>InteractionBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = QubitSupportType.GLOBAL</code>. However, composing blocks using <code>kron</code> with local qubit supports and different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, AnalogInteraction\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    AnalogInteraction(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    AnalogInteraction(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    AnalogInteraction(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2024-02-01T18:45:11.787166 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook, we solve a quadratic unconstrained binary optimization (QUBO) problem with Qadence. QUBOs are very popular combinatorial optimization problems with a wide range of applications. Here, we solve the problem using the QAOA <sup>1</sup> variational algorithm by embedding the QUBO problem weights onto a register as standard for neutral atom quantum devices.</p> <p>Additional background information on QUBOs can be found here, directly solved using the pulse-level interface Pulser.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: optimal register coordinates for embedding the QUBO problem <p>A basic ingredient for solving a QUBO problem with a neutral atom device is to embed the problem onto the atomic register. In short, embedding algorithms cast the problem onto a graph mapped onto the register by optimally finding atomic coordinates. A discussion on the embedding algorithms is beyond the scope of this tutorial and a simplified version taken from here is added below.</p> <p><pre><code>import numpy as np\nimport numpy.typing as npt\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom qadence import RydbergDevice\n\ndef qubo_register_coords(Q: np.ndarray, device: RydbergDevice) -&gt; list:\n    \"\"\"Compute coordinates for register.\"\"\"\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        interaction_coeff = device.rydberg_level\n        new_Q = squareform(interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <p>With the embedding routine under our belt, let's start by adding the required imports and ensure the reproducibility of this tutorial.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRX, AnalogRZ, chain\nfrom qadence.ml_tools import train_gradient_free, TrainConfig, num_parameters\nimport nevergrad as ng\nimport matplotlib.pyplot as plt\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted edges and a cost function to be optimized. The weighted edges are represented by a real-valued symmetric matrix <code>Q</code> which is used throughout the tutorial.</p> <pre><code># QUBO problem weights (real-value symmetric matrix)\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n\ndef loss(model: QuantumModel, *args) -&gt; tuple[float, dict]:\n    to_arr_fn = lambda bitstring: np.array(list(bitstring), dtype=int)\n    cost_fn = lambda arr: arr.T @ Q @ arr\n    samples = model.sample({}, n_shots=1000)[0]  # extract samples\n    cost_fn = sum(samples[key] * cost_fn(to_arr_fn(key)) for key in samples)\n    return cost_fn / sum(samples.values()), {}  # We return an optional metrics dict\n</code></pre> <p>The QAOA algorithm needs a variational quantum circuit with optimizable parameters. For that purpose, we use a fully analog circuit composed of two global rotations per layer on different axes of the Bloch sphere. The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian <sup>1</sup>. In this setting, the embedding is realized by the appropriate register coordinates and the resulting qubit interaction.</p> Rydberg level <p>The Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in the original tutorial, and set the device specifications with the updated Rydberg level.</p> <pre><code># Device specification and atomic register\ndevice = RydbergDevice(rydberg_level=70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q, device), device_specs=device\n)\n\n# Analog variational quantum circuit\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\ncircuit = QuantumCircuit(reg, block)\n</code></pre> <pre><code>\n</code></pre> <p>By feeding the circuit to a <code>QuantumModel</code> we can check the initial counts where no clear solution can be found:</p> <pre><code>model = QuantumModel(circuit)\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'01000': 197, '00001': 193, '00010': 189, '00100': 174, '10000': 169, '00000': 78})\n</code></pre> <p>Finally, we can proceed with the variational optimization. The cost function defined above is derived from bitstring computations and therefore non differentiable. We use Qadence ML facilities to run gradient-free optimizations using the <code>nevergrad</code> library.</p> <pre><code>config = TrainConfig(max_iter=100)\noptimizer = ng.optimizers.NGOpt(\n    budget=config.max_iter, parametrization=num_parameters(model)\n)\ntrain_gradient_free(model, None, optimizer, config, loss)\n\noptimal_counts = model.sample({}, n_shots=1000)[0]\n</code></pre>   optimal_count = Counter({'00100': 191, '10000': 190, '00001': 183, '01000': 181, '00010': 163, '00000': 92})    <p>Finally, let's plot the solution. The expected bitstrings are marked in red.</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings = [\"01011\", \"00111\"]\n\ndef plot_distribution(C, ax, title):\n    C = dict(sorted(C.items(), key=lambda item: item[1], reverse=True))\n    indexes = solution_bitstrings # QUBO solutions\n    color_dict = {key: \"r\" if key in indexes else \"g\" for key in C}\n    ax.set_xlabel(\"bitstrings\")\n    ax.set_ylabel(\"counts\")\n    ax.set_xticks([i for i in range(len(C.keys()))], C.keys(), rotation=90)\n    ax.bar(list(C.keys())[:20], list(C.values())[:20])\n    ax.set_title(title)\n\nfig, axs = plt.subplots(1, 2, figsize=(12, 4))\nplot_distribution(initial_counts, axs[0], \"Initial counts\")\nplot_distribution(optimal_counts, axs[1], \"Optimal counts\")\n</code></pre> 2024-02-01T18:45:13.550746 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/#references","title":"References","text":"<ol> <li> <p>Edward Farhi, Jeffrey Goldstone, Sam Gutmann, A Quantum Approximate Optimization Algorithm, arXiv:1411.4028 (2014) \u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo, PI\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = PI\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=PI,            # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_b497e439d944476893ea8db6f701566a cluster_e470c497eca14c359921cc1c54c521dd cluster_da15075112b84d9c95d34b5f60f18a62 cluster_3eb7af709f294c65af518d773073a6cd cluster_21343d5f0f4c4697a75b843b08679d50 cluster_6b099851d3f243bda16b332988be8deb cluster_7375e4292c60422391857c72ae161e0c 2762e40572e24ca197eaf866e07c526b 0 827386fc8f3f4f3591761ff218de2c25 HamEvo 2762e40572e24ca197eaf866e07c526b--827386fc8f3f4f3591761ff218de2c25 2c6ffd89a70e4406af0f9410e38af653 1 33863a4ec2a4420995036ef07c7ea8b5 HamEvo 827386fc8f3f4f3591761ff218de2c25--33863a4ec2a4420995036ef07c7ea8b5 288fd3e250af4a2a84f03044419bc7df HamEvo 33863a4ec2a4420995036ef07c7ea8b5--288fd3e250af4a2a84f03044419bc7df 7fbcbdb7eaba46db8c4034d09d82ffcf X 288fd3e250af4a2a84f03044419bc7df--7fbcbdb7eaba46db8c4034d09d82ffcf 23f9cd54180840bf854475bd3fe8356c HamEvo 7fbcbdb7eaba46db8c4034d09d82ffcf--23f9cd54180840bf854475bd3fe8356c a6a55093080944b3a32582f2487bdcb1 HamEvo 23f9cd54180840bf854475bd3fe8356c--a6a55093080944b3a32582f2487bdcb1 8b4650a4e0ee4d52b49a0d468c8e0d2a X a6a55093080944b3a32582f2487bdcb1--8b4650a4e0ee4d52b49a0d468c8e0d2a cb6503b18c7449278d8253f67270aba8 8b4650a4e0ee4d52b49a0d468c8e0d2a--cb6503b18c7449278d8253f67270aba8 a465b1c10ec648678b17af16c9af5a10 HamEvo cb6503b18c7449278d8253f67270aba8--a465b1c10ec648678b17af16c9af5a10 1fce0ae82f904164bf612365bcff87fd HamEvo a465b1c10ec648678b17af16c9af5a10--1fce0ae82f904164bf612365bcff87fd 9e3a7ea5d702458991170df8a413f4ac 1fce0ae82f904164bf612365bcff87fd--9e3a7ea5d702458991170df8a413f4ac 2c027b38da7249a7a712cb5a313ce6eb 9e3a7ea5d702458991170df8a413f4ac--2c027b38da7249a7a712cb5a313ce6eb 0d65f0a8dae347c3843949516ce0aa91 87528705aff5400f9b6829c3e54640bd t = -3.142 2c6ffd89a70e4406af0f9410e38af653--87528705aff5400f9b6829c3e54640bd a861fc6acfc148a58289acaf99dcb7c5 2 55d23a09fb434081a5e9d9df82c53e50 t = 3.142 87528705aff5400f9b6829c3e54640bd--55d23a09fb434081a5e9d9df82c53e50 12c9006a487c4a17bd0e2125a2d18737 t = -3.142 55d23a09fb434081a5e9d9df82c53e50--12c9006a487c4a17bd0e2125a2d18737 a20395709f1e406ebd3f07854859ee59 12c9006a487c4a17bd0e2125a2d18737--a20395709f1e406ebd3f07854859ee59 6069469624fc49dc8dbda05569ff7826 t = 1.571 a20395709f1e406ebd3f07854859ee59--6069469624fc49dc8dbda05569ff7826 b1e70e7077bf449581c82b87d4266065 t = 1.571 6069469624fc49dc8dbda05569ff7826--b1e70e7077bf449581c82b87d4266065 1a976ed317e34ae296f26a5c1e345ce3 b1e70e7077bf449581c82b87d4266065--1a976ed317e34ae296f26a5c1e345ce3 61f28e202abe42caaf66df234989b47f X 1a976ed317e34ae296f26a5c1e345ce3--61f28e202abe42caaf66df234989b47f bdab0546cd174fa1acf0206e2ed9e857 t = 1.571 61f28e202abe42caaf66df234989b47f--bdab0546cd174fa1acf0206e2ed9e857 d2a50960321f4d2ebf069de0d3bc262f t = 1.571 bdab0546cd174fa1acf0206e2ed9e857--d2a50960321f4d2ebf069de0d3bc262f ccd55af9c9a24507a629077d9f7a2c4e X d2a50960321f4d2ebf069de0d3bc262f--ccd55af9c9a24507a629077d9f7a2c4e ccd55af9c9a24507a629077d9f7a2c4e--0d65f0a8dae347c3843949516ce0aa91 c831ad03a1af47c0ac7f0203471ce50c f416f906d3bd419e8fa436c64a218be3 a861fc6acfc148a58289acaf99dcb7c5--f416f906d3bd419e8fa436c64a218be3 ece4e743d8aa4bdbbf014198248033fa f416f906d3bd419e8fa436c64a218be3--ece4e743d8aa4bdbbf014198248033fa b1f7505c81984811bed938fa4ca778a1 ece4e743d8aa4bdbbf014198248033fa--b1f7505c81984811bed938fa4ca778a1 54726d17efc94787bed059604c7fbd8e X b1f7505c81984811bed938fa4ca778a1--54726d17efc94787bed059604c7fbd8e 90c56d65d56d4f41a2de3af171235cbb 54726d17efc94787bed059604c7fbd8e--90c56d65d56d4f41a2de3af171235cbb a567e44282894e19a98f530b0538877a 90c56d65d56d4f41a2de3af171235cbb--a567e44282894e19a98f530b0538877a d76689bbc11849f38bcb62e8a5d8a2e3 X a567e44282894e19a98f530b0538877a--d76689bbc11849f38bcb62e8a5d8a2e3 cf949ecb965e4b32b6edc01b4b0adcd0 X d76689bbc11849f38bcb62e8a5d8a2e3--cf949ecb965e4b32b6edc01b4b0adcd0 5b62d56a673d4b589a8b0186bb838519 cf949ecb965e4b32b6edc01b4b0adcd0--5b62d56a673d4b589a8b0186bb838519 e36fc335e25b4118ba2106bbf222e9c7 5b62d56a673d4b589a8b0186bb838519--e36fc335e25b4118ba2106bbf222e9c7 125fe1f83e7141669b6e1338e664408c X e36fc335e25b4118ba2106bbf222e9c7--125fe1f83e7141669b6e1338e664408c 125fe1f83e7141669b6e1338e664408c--c831ad03a1af47c0ac7f0203471ce50c <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_1da82d7aaa9245ea8c6d73d248e3f79c cluster_fb58e4b3d98c44d8ba5e2f3a55bc36be eebd7af74d0f4c97bfc494f6460efda2 0 8437f0e9cbb44f51bc8c5bf67c06d83b X eebd7af74d0f4c97bfc494f6460efda2--8437f0e9cbb44f51bc8c5bf67c06d83b d6c400a324cd4fb7964f9d0318cf7512 1 17f334aa28dd41858fdbed8bceec00de HamEvo 8437f0e9cbb44f51bc8c5bf67c06d83b--17f334aa28dd41858fdbed8bceec00de 1b914631721646a8a9813a8bbdcf45d9 X 17f334aa28dd41858fdbed8bceec00de--1b914631721646a8a9813a8bbdcf45d9 358cb72909c84c959055442acf8d3ef7 1b914631721646a8a9813a8bbdcf45d9--358cb72909c84c959055442acf8d3ef7 d1d2271177a94fe690184efe2cc3c173 HamEvo 358cb72909c84c959055442acf8d3ef7--d1d2271177a94fe690184efe2cc3c173 e8708e0c8ae145daae861b51ee622e83 d1d2271177a94fe690184efe2cc3c173--e8708e0c8ae145daae861b51ee622e83 39343544672845d1a97f839782d8c749 e8708e0c8ae145daae861b51ee622e83--39343544672845d1a97f839782d8c749 e386423e60884ba4bac5cd997c9c34bd 6e86de60fd7b48cb8056ba0ab3911953 d6c400a324cd4fb7964f9d0318cf7512--6e86de60fd7b48cb8056ba0ab3911953 0435a89c25f547f49e0de8c14eb86470 2 66bb46d2a8694915831c9a24c5fd40b2 t = -0.500 6e86de60fd7b48cb8056ba0ab3911953--66bb46d2a8694915831c9a24c5fd40b2 94dbaf7d7c0040b8972cfcb15f87e60d 66bb46d2a8694915831c9a24c5fd40b2--94dbaf7d7c0040b8972cfcb15f87e60d 9d41b295d212462d8c2517b7a5024a3f X 94dbaf7d7c0040b8972cfcb15f87e60d--9d41b295d212462d8c2517b7a5024a3f 7d611f240eae4ca382dd8d6c4ddc36b4 t = -0.500 9d41b295d212462d8c2517b7a5024a3f--7d611f240eae4ca382dd8d6c4ddc36b4 357400158b6e4b99900d769ff784fabc X 7d611f240eae4ca382dd8d6c4ddc36b4--357400158b6e4b99900d769ff784fabc 357400158b6e4b99900d769ff784fabc--e386423e60884ba4bac5cd997c9c34bd 3e7de165536d4aa89691054d35059a82 3db2ef9595234995af59d737e9533740 X 0435a89c25f547f49e0de8c14eb86470--3db2ef9595234995af59d737e9533740 b7f1a94c6621476c9ae4d17d5ceeaa70 3db2ef9595234995af59d737e9533740--b7f1a94c6621476c9ae4d17d5ceeaa70 f05a53959a084ccf8742e92abb5c1037 X b7f1a94c6621476c9ae4d17d5ceeaa70--f05a53959a084ccf8742e92abb5c1037 c56ad4270cc04699b7486453b613b60c X f05a53959a084ccf8742e92abb5c1037--c56ad4270cc04699b7486453b613b60c a99d1773ccf04572b8e67e415318f1f9 c56ad4270cc04699b7486453b613b60c--a99d1773ccf04572b8e67e415318f1f9 ff905dfcf9524803a79c3a0642c3e13b X a99d1773ccf04572b8e67e415318f1f9--ff905dfcf9524803a79c3a0642c3e13b ff905dfcf9524803a79c3a0642c3e13b--3e7de165536d4aa89691054d35059a82 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_4e6a7ddab1584328ac815c64cd296c88 cluster_1c35f51ac43d4806acdff54023505b05 c767eb64ee4b4446b84a76d609bbb89a 0 760fcff4aeac444db472984723411629 X c767eb64ee4b4446b84a76d609bbb89a--760fcff4aeac444db472984723411629 29487c8b73a040a69790026cb86d88af 1 cabcd0a53b2d481081ee0baa3758cc2a HamEvo 760fcff4aeac444db472984723411629--cabcd0a53b2d481081ee0baa3758cc2a 887794410cc24ea6a246671bb820b9df X cabcd0a53b2d481081ee0baa3758cc2a--887794410cc24ea6a246671bb820b9df b2b6a2e991664001868b9250342bf3af 887794410cc24ea6a246671bb820b9df--b2b6a2e991664001868b9250342bf3af 3e3ee55c0fe54758a1c74b3740244b26 HamEvo b2b6a2e991664001868b9250342bf3af--3e3ee55c0fe54758a1c74b3740244b26 3b15ddb508394bdab891319acd2d3a0b 3e3ee55c0fe54758a1c74b3740244b26--3b15ddb508394bdab891319acd2d3a0b 644d46fabcf440668f1b78f0dbf73ba7 3b15ddb508394bdab891319acd2d3a0b--644d46fabcf440668f1b78f0dbf73ba7 7080167959414eeb9bf740b9c2ad8e5e 9c127fec29b14d539842471e1eedd24d 29487c8b73a040a69790026cb86d88af--9c127fec29b14d539842471e1eedd24d 06e1e9274f7f4e0f824f3553b1840c57 2 041bbb87457b4c2794a41e96250ab6c0 t = -500.000000000000 9c127fec29b14d539842471e1eedd24d--041bbb87457b4c2794a41e96250ab6c0 d22b28e3645742b38d2bd1814ab7d916 041bbb87457b4c2794a41e96250ab6c0--d22b28e3645742b38d2bd1814ab7d916 e91e69f3cdd848359b73834503f6c33d X d22b28e3645742b38d2bd1814ab7d916--e91e69f3cdd848359b73834503f6c33d 6b85a1e9f3cc4d529afab3eedb8216d6 t = -500.000000000000 e91e69f3cdd848359b73834503f6c33d--6b85a1e9f3cc4d529afab3eedb8216d6 69bfdcfa76074ba48064784d84708162 X 6b85a1e9f3cc4d529afab3eedb8216d6--69bfdcfa76074ba48064784d84708162 69bfdcfa76074ba48064784d84708162--7080167959414eeb9bf740b9c2ad8e5e 0e3e71ad2f8e40c98079d1195a031922 4e1c54023d444c179b55ff1b45d07858 X 06e1e9274f7f4e0f824f3553b1840c57--4e1c54023d444c179b55ff1b45d07858 bb47256a2ed94fab9b405b42b475e4fe 4e1c54023d444c179b55ff1b45d07858--bb47256a2ed94fab9b405b42b475e4fe 729e47f17559498990a0719acc32e1c4 X bb47256a2ed94fab9b405b42b475e4fe--729e47f17559498990a0719acc32e1c4 b401135e99f649809c4a6fc1b6ccea6e X 729e47f17559498990a0719acc32e1c4--b401135e99f649809c4a6fc1b6ccea6e c2bf1c5d9bf14cc7bc00b8886dbcc2d4 b401135e99f649809c4a6fc1b6ccea6e--c2bf1c5d9bf14cc7bc00b8886dbcc2d4 b50d3f42d0f04f32846b8f255efe6865 X c2bf1c5d9bf14cc7bc00b8886dbcc2d4--b50d3f42d0f04f32846b8f255efe6865 b50d3f42d0f04f32846b8f255efe6865--0e3e71ad2f8e40c98079d1195a031922 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>AnalogInteraction</code> An idle block to to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.19153186677421175, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel, PI\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 30, '11': 20})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2024-02-01T18:45:14.324850 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2024-02-01T18:45:14.450403 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 21, '10': 2})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>AnalogInteraction</code> and <code>AnalogRY</code> blocks together with appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, AnalogInteraction\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-PI / 2),\n        AnalogInteraction(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([PI / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2024-02-01T18:45:14.934758 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(PI/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2024-02-01T18:45:15.093525 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n    PI\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.0100])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.0106])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(PI)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.6974]) The trained function value:  tensor([[0.6974]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>InteractionBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, AnalogInteraction\n\nb = chain(AnalogInteraction(200), AnalogInteraction(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), AnalogInteraction(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `InteractionBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, AnalogInteraction\n\n    b = chain(AnalogInteraction(200), AnalogInteraction(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), AnalogInteraction(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.InteractionBlock","title":"<code>InteractionBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Free-evolution for the Hamiltonian interaction term of a register of qubits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct, use the <code>AnalogInteraction</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.1205+0.2779j, -0.4028-0.5196j, -0.6412+0.0323j, -0.2348-0.0933j],\n         [-0.1532-0.2579j,  0.3364+0.4789j, -0.6311-0.0889j, -0.3710+0.1539j],\n         [-0.2295-0.6436j, -0.0058-0.3170j,  0.1553+0.2692j, -0.3819-0.4360j],\n         [-0.0921-0.5856j, -0.2621-0.2365j, -0.1598-0.2440j,  0.4385+0.4966j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * PI),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None, param_prefix=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | Callable | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data provided comes from. Used to map input data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI). Used to map data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <code>param_prefix</code> <p>string prefix to create trainable parameters multiplying the feature parameter inside the feature-encoding function. Note that currently this does not take into account the domain of the feature-encoding function.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | Callable | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n    param_prefix: str | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data provided comes from. Used to map input data\n            to the correct domain of the feature-encoding function.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI).\n            Used to map data to the correct domain of the feature-encoding function.\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n        param_prefix: string prefix to create trainable parameters multiplying the feature parameter\n            inside the feature-encoding function. Note that currently this does not take into\n            account the domain of the feature-encoding function.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    # Backwards compatibility\n    fm_type, reupload_scaling = backwards_compatibility(fm_type, reupload_scaling)\n\n    scaled_fparam = fm_parameter_scaling(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    transform_func = fm_parameter_func(fm_type)\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    fparam = scaled_fparam\n    for i, qubit in enumerate(support):\n        if param_prefix is not None:\n            train_param = VariationalParameter(param_prefix + f\"_{i}\")\n            fparam = train_param * scaled_fparam\n        op_list.append(op(qubit, multiplier * rs_func(i) * transform_func(fparam)))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | Callable | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | Callable | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        if callable(interaction):\n            int_fn = interaction\n            try:\n                if not block_is_qubit_hamiltonian(interaction(0, 1)):\n                    raise ValueError(\"Custom interactions must be composed of Pauli operators.\")\n            except TypeError:\n                raise TypeError(\n                    \"Please use a custom interaction function signed with two integer parameters.\"\n                )\n        else:\n            int_fn = INTERACTION_DICT.get(interaction, None)  # type: ignore [arg-type]\n            if int_fn is None:\n                raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * PI / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f62f3c11480&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f62f38a3400&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, None)\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    data = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.3026, 0.2765]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n[tensor([0.6595, 0.0538, 0.8660, 0.8650, 0.0394]), tensor([0.2900, 0.3294, 0.6735, 0.3359, 0.2816]), tensor([0.4227, 0.3033, 0.5571, 0.8693, 0.4491])]\n[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run, PI\nimport torch\nhevo = HamEvo(generator=RX(0, PI), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.1384-3.6270e-17j, -0.5441+1.7335e-17j],\n        [ 1.2545-5.3697e-17j, -0.7574+3.2421e-17j]])\ntensor([[1.5091-0.7780j, 0.5771-0.9542j],\n        [1.4106-0.5384j, 0.5040-0.6605j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * PI / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * PI / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-PI / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = PI\n    omega = 0\n    duration = alpha / delta * 1000\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=0.0, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n\n    if omega == 0 and delta == 0:\n        raise ValueError(\"Parameters omega and delta cannot both be 0.\")\n\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    alpha = duration * h_norm / 1000\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogInteraction","title":"<code>AnalogInteraction(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Evolution of the interaction term for a register of qubits.</p> <p>Constructs a <code>InteractionBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to evolve the interaction for in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>InteractionBlock</code> is applied to. Can be either <code>\"global\"</code> to evolve the interaction block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>InteractionBlock</code> <p>a <code>InteractionBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogInteraction(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; InteractionBlock:\n    \"\"\"Evolution of the interaction term for a register of qubits.\n\n    Constructs a [`InteractionBlock`][qadence.blocks.analog.InteractionBlock].\n\n    Arguments:\n        duration: Time to evolve the interaction for in nanoseconds.\n        qubit_support: Qubits the `InteractionBlock` is applied to. Can be either\n            `\"global\"` to evolve the interaction block to all qubits or a tuple of integers.\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        a `InteractionBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return InteractionBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['3335324e-a292-4b03-9dd1-e3219b81bf88', 'd04b2610-e470-4a10-aaf8-219b4bebed4f'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.9859993654159114\ntheta: trainable=True value=2.0\nexpr=x*y : {x, y}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.6903893734503416\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = make_differentiable(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False, engine=Engine.TORCH)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level.</p> <p>parameters or gate-level parameters. The constructed embedding function has the signature:</p> <pre><code> embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False, engine: Engine = Engine.TORCH\n) -&gt; tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType],]:\n    \"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*.\n\n    parameters or *gate-level* parameters. The constructed embedding function has the signature:\n\n         embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n    concretize_parameter = _concretize_parameter(engine)\n    if engine == Engine.TORCH:\n        cast_dtype = tensor\n    else:\n        from jax.numpy import array\n\n        cast_dtype = array\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, DifferentiableExpression] = {\n        expr: make_differentiable(expr=expr, engine=engine)\n        for expr in unique_expressions\n        if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n        embedded_params: dict[sympy.Expr, ArrayLike] = {}\n        for expr, fn in embeddings.items():\n            angle: ArrayLike\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: ParamDictType = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: ParamDictType\n    params = {\n        p.name: concretize_parameter(value=p.value, trainable=True) for p in trainable_symbols\n    }\n    params.update(\n        {\n            stringify(expr): concretize_parameter(value=evaluate(expr), trainable=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): cast_dtype(nparray(expr.tolist(), dtype=npcdouble))\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('3324ceec-fe39-4c35-a164-71e86527bc72', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.6398639069137206'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('3397ed40-ad55-45e4-aec8-48b7a6f9ba1a', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.4276945815961849'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('0a578a4c-2192-4c0b-90e3-4d9f55b30434', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.8742892845567309'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('1035fa9f-dca2-43f9-aa46-b93d00766b5e', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.41919975377010965'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('799a4ad4-811c-42bd-8aa5-f5fe359f38cd', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6109177287180888'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('9e48e27e-1a9e-48ff-813c-fe6adbbd5da8', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.37421788716051174'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('ed403932-724e-4144-a54d-ff23496e6d10', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9806087614373826'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('462b8d5c-f55e-4ff8-b2ed-46f6e0ab5993', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.1191298453974663'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5233ec4b-2a43-4d65-b991-0ea0088f6718', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.2908857259376022'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('781bc353-7c8b-431b-a330-5b938a3346d4', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.43496561975352277'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('4fcd812a-c992-4c8c-943d-2faa27be8135', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.13952221070351867'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('d7382a53-53c9-4b42-acad-0905135fcf99', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.230873635340905'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>10100101\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.3881-0.1329j,  0.2745-0.3881j, -0.2080+0.2140j,  0.6633-0.2767j]])\ntensor([[0.9225-0.3859j, 0.0000+0.0000j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGINTERACTION","title":"<code>ANALOGINTERACTION = 'AnalogInteraction'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog interaction operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANGLE","title":"<code>ENTANGLE = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 78, '1000': 8, '0010': 5, '0100': 4, '0001': 1, '0101': 1, '1010': 1, '1101': 1, '1110': 1})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[-0.0018],\n        [-0.0004],\n        [ 0.0510],\n        [ 0.0049],\n        [ 0.0771],\n        [ 0.0133],\n        [-0.0328],\n        [-0.0192],\n        [ 0.0395],\n        [-0.0323]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4053],\n        [0.9018],\n        [0.9084],\n        [0.2606],\n        [0.9428]]), tensor([[0.3943],\n        [0.7844],\n        [0.7885],\n        [0.2577],\n        [0.8092]])], 'y2': [tensor([[0.4695],\n        [0.1881],\n        [0.6359],\n        [0.7454],\n        [0.2043]]), tensor([[0.4524],\n        [0.1870],\n        [0.5939],\n        [0.6783],\n        [0.2029]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2024-02-01T18:45:38.024162 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2024-02-01T18:45:38.591277 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_ad2a27c854484e149ac24eb369022a92 mixing cluster_3030993b88b449a0b3c79241e9a32c89 cost cluster_814e791dc3bb49db8d61f3659f10fe90 mixing cluster_21bf50d7727e4fd788f490913e6565cd cost c2ade4eaa13d4118b42305c025ff36dd 0 717cefc1858841cda625eab7bc771bdd c2ade4eaa13d4118b42305c025ff36dd--717cefc1858841cda625eab7bc771bdd 43e3169bfb67454eb9dbadbfb35aa7b6 1 88304de41d5041658032840910083ad5 717cefc1858841cda625eab7bc771bdd--88304de41d5041658032840910083ad5 f5642817df3d48a5b1af199821d2cc8a 88304de41d5041658032840910083ad5--f5642817df3d48a5b1af199821d2cc8a 5d5afe6c11d64c7aa57f43ead6b8cb55 f5642817df3d48a5b1af199821d2cc8a--5d5afe6c11d64c7aa57f43ead6b8cb55 a096985ff04340938f9888e3cc072907 5d5afe6c11d64c7aa57f43ead6b8cb55--a096985ff04340938f9888e3cc072907 a5c515a4c86a4f509536884650f56191 a096985ff04340938f9888e3cc072907--a5c515a4c86a4f509536884650f56191 f387239efacf45eb8d7c9ae521483fe2 a5c515a4c86a4f509536884650f56191--f387239efacf45eb8d7c9ae521483fe2 de13a9ff32cc47b8a189008b5a17f37f f387239efacf45eb8d7c9ae521483fe2--de13a9ff32cc47b8a189008b5a17f37f af69e3eaad234a4f9140affb79c2f4d4 de13a9ff32cc47b8a189008b5a17f37f--af69e3eaad234a4f9140affb79c2f4d4 3078ad2f68b441bfa1438207248b0251 af69e3eaad234a4f9140affb79c2f4d4--3078ad2f68b441bfa1438207248b0251 483693c300064ce0baf0d2401d994e1a 3078ad2f68b441bfa1438207248b0251--483693c300064ce0baf0d2401d994e1a 29069b8708e841708292f9b061af4962 483693c300064ce0baf0d2401d994e1a--29069b8708e841708292f9b061af4962 26fdd623310341598ccaa2e1e8fadd70 29069b8708e841708292f9b061af4962--26fdd623310341598ccaa2e1e8fadd70 012efa5e276f455cbb0a5d066ed30a71 26fdd623310341598ccaa2e1e8fadd70--012efa5e276f455cbb0a5d066ed30a71 ffd9097c191a4275b5ffa41bb78e902c 012efa5e276f455cbb0a5d066ed30a71--ffd9097c191a4275b5ffa41bb78e902c 7b515c55cef944edab45e742fc652160 ffd9097c191a4275b5ffa41bb78e902c--7b515c55cef944edab45e742fc652160 6688483d8f6a47f09bbd9f11c44d62fe 7b515c55cef944edab45e742fc652160--6688483d8f6a47f09bbd9f11c44d62fe bf3a9ffdd03a49999598fd1fbd106cd5 6688483d8f6a47f09bbd9f11c44d62fe--bf3a9ffdd03a49999598fd1fbd106cd5 26f0f4c1e3ac49589e3c70e89df31ec8 bf3a9ffdd03a49999598fd1fbd106cd5--26f0f4c1e3ac49589e3c70e89df31ec8 04abc538ab9b4b859e9f7a7d0180f499 26f0f4c1e3ac49589e3c70e89df31ec8--04abc538ab9b4b859e9f7a7d0180f499 3f501caea62c497e8930f01523bf75fe 04abc538ab9b4b859e9f7a7d0180f499--3f501caea62c497e8930f01523bf75fe 2d2cf4dffd3f406d8bbd5b61003afe54 3f501caea62c497e8930f01523bf75fe--2d2cf4dffd3f406d8bbd5b61003afe54 df1cdce4e61947fab648423786ec6a23 2d2cf4dffd3f406d8bbd5b61003afe54--df1cdce4e61947fab648423786ec6a23 d5a841f2b837461b8d0f12a648d3e2df df1cdce4e61947fab648423786ec6a23--d5a841f2b837461b8d0f12a648d3e2df 5fbc88f7ebf448ce80c37577c05a6c29 d5a841f2b837461b8d0f12a648d3e2df--5fbc88f7ebf448ce80c37577c05a6c29 078ea9948cf546da95c411edf13bd886 5fbc88f7ebf448ce80c37577c05a6c29--078ea9948cf546da95c411edf13bd886 3ced0e248a83487a9948d63e28f72868 078ea9948cf546da95c411edf13bd886--3ced0e248a83487a9948d63e28f72868 74f4c4d2385241a08dc5c3b23adedb76 3ced0e248a83487a9948d63e28f72868--74f4c4d2385241a08dc5c3b23adedb76 97a8bcdc934a4ba69e3eff2d160c08f7 74f4c4d2385241a08dc5c3b23adedb76--97a8bcdc934a4ba69e3eff2d160c08f7 4d6df46129714bd7a0eb37eda8f14f60 97a8bcdc934a4ba69e3eff2d160c08f7--4d6df46129714bd7a0eb37eda8f14f60 e55ac08e04c44fac8c5f0cbb0eb86046 4d6df46129714bd7a0eb37eda8f14f60--e55ac08e04c44fac8c5f0cbb0eb86046 c0ccc903f6014ae6b9b74691c62f32a2 e55ac08e04c44fac8c5f0cbb0eb86046--c0ccc903f6014ae6b9b74691c62f32a2 b0d4725ad054406e8053f7706c2d7e58 c0ccc903f6014ae6b9b74691c62f32a2--b0d4725ad054406e8053f7706c2d7e58 c982058f4b7b497bab5bde2ca26c7eef b0d4725ad054406e8053f7706c2d7e58--c982058f4b7b497bab5bde2ca26c7eef 0f4a228c08fb47d39efd5060fcffacec c982058f4b7b497bab5bde2ca26c7eef--0f4a228c08fb47d39efd5060fcffacec 677385ec7e3c486183713771034af6cb 0f4a228c08fb47d39efd5060fcffacec--677385ec7e3c486183713771034af6cb 43470d08a6de42a1b715d8f9d317a7c1 677385ec7e3c486183713771034af6cb--43470d08a6de42a1b715d8f9d317a7c1 80cbe12299304e22ba9c9643b64732e7 43470d08a6de42a1b715d8f9d317a7c1--80cbe12299304e22ba9c9643b64732e7 d28fed6ba64f4c8d81e62ca761d35b0a 80cbe12299304e22ba9c9643b64732e7--d28fed6ba64f4c8d81e62ca761d35b0a c4d3dd8b749347619e551e14d6240be2 d28fed6ba64f4c8d81e62ca761d35b0a--c4d3dd8b749347619e551e14d6240be2 ec0448aaca404e299aea338d767457e2 c4d3dd8b749347619e551e14d6240be2--ec0448aaca404e299aea338d767457e2 0b76acd019d44c26a836eb34471a4b65 ec0448aaca404e299aea338d767457e2--0b76acd019d44c26a836eb34471a4b65 c36c0d93520a478eac9d7bcf36d81090 0b76acd019d44c26a836eb34471a4b65--c36c0d93520a478eac9d7bcf36d81090 72bc6e096e8147679e3cea719f62e7e0 c36c0d93520a478eac9d7bcf36d81090--72bc6e096e8147679e3cea719f62e7e0 fdd9a95957aa4d2983213b6b5b46901f 72bc6e096e8147679e3cea719f62e7e0--fdd9a95957aa4d2983213b6b5b46901f 0052ccf80ee24c2d9cae6c4e938fc37c fdd9a95957aa4d2983213b6b5b46901f--0052ccf80ee24c2d9cae6c4e938fc37c aa8810cf10234c56ad202f10af128b99 0052ccf80ee24c2d9cae6c4e938fc37c--aa8810cf10234c56ad202f10af128b99 47a3a290cc44401393ba41c4573d74f8 aa8810cf10234c56ad202f10af128b99--47a3a290cc44401393ba41c4573d74f8 e53732b27ae1404d8d20f29983c5675b 47a3a290cc44401393ba41c4573d74f8--e53732b27ae1404d8d20f29983c5675b 44bcd2868fb04715857a0e53a2cedc7a e53732b27ae1404d8d20f29983c5675b--44bcd2868fb04715857a0e53a2cedc7a 565abe6b57014de9a5ac7c669f546efe 44bcd2868fb04715857a0e53a2cedc7a--565abe6b57014de9a5ac7c669f546efe 012aae7c7ef641ea9b5e0e0aa432854d 565abe6b57014de9a5ac7c669f546efe--012aae7c7ef641ea9b5e0e0aa432854d 0229ba814e1549d29a699366fe332147 012aae7c7ef641ea9b5e0e0aa432854d--0229ba814e1549d29a699366fe332147 0af073bd3d6b42df8f051b2debd7369c 0229ba814e1549d29a699366fe332147--0af073bd3d6b42df8f051b2debd7369c f37147b46c00488a9b7a4856f535efa7 0af073bd3d6b42df8f051b2debd7369c--f37147b46c00488a9b7a4856f535efa7 df9e2f45bda54ca8b1251015c391d85b f37147b46c00488a9b7a4856f535efa7--df9e2f45bda54ca8b1251015c391d85b 689090f941504950b7497305d5d83110 df9e2f45bda54ca8b1251015c391d85b--689090f941504950b7497305d5d83110 ef5224af3233404dbe888d13f2c06625 689090f941504950b7497305d5d83110--ef5224af3233404dbe888d13f2c06625 069f8ebdf1f84eb8b8370ec0c97f590c ef5224af3233404dbe888d13f2c06625--069f8ebdf1f84eb8b8370ec0c97f590c a700d1ba176c4156baabe46cf0e6ee65 069f8ebdf1f84eb8b8370ec0c97f590c--a700d1ba176c4156baabe46cf0e6ee65 102c8bdb6089496a95fd659ffad508f0 a700d1ba176c4156baabe46cf0e6ee65--102c8bdb6089496a95fd659ffad508f0 c4dbef744e0d454cbaf16e948d73a950 102c8bdb6089496a95fd659ffad508f0--c4dbef744e0d454cbaf16e948d73a950 60d76d4b640340048d4aa7af19e7821c c4dbef744e0d454cbaf16e948d73a950--60d76d4b640340048d4aa7af19e7821c 953788291aff486c932afa2e2fa647ba 60d76d4b640340048d4aa7af19e7821c--953788291aff486c932afa2e2fa647ba be2c2ac5075d402da7f0eaa56c3c183d 953788291aff486c932afa2e2fa647ba--be2c2ac5075d402da7f0eaa56c3c183d 0f79c50023784b91af74aa23e5efbe02 be2c2ac5075d402da7f0eaa56c3c183d--0f79c50023784b91af74aa23e5efbe02 cab6529f54124e04927b2690c4ba49f2 0f79c50023784b91af74aa23e5efbe02--cab6529f54124e04927b2690c4ba49f2 94443a85ec49471f9933977920398e3f cab6529f54124e04927b2690c4ba49f2--94443a85ec49471f9933977920398e3f 75a9cd10db13474b810e2fef2fe23acc 94443a85ec49471f9933977920398e3f--75a9cd10db13474b810e2fef2fe23acc 9859b0b2c8ed448895a61afbaf855c7c 75a9cd10db13474b810e2fef2fe23acc--9859b0b2c8ed448895a61afbaf855c7c 4c76a9c763864e08befe322ca9a5c32c 9859b0b2c8ed448895a61afbaf855c7c--4c76a9c763864e08befe322ca9a5c32c 1ee14726504a4358aa4c3533411298f2 4c76a9c763864e08befe322ca9a5c32c--1ee14726504a4358aa4c3533411298f2 f3a955fd7e6d4190bab9d5a13f5d3d49 1ee14726504a4358aa4c3533411298f2--f3a955fd7e6d4190bab9d5a13f5d3d49 07616f446a5e4de19df50954cf856bf2 f3a955fd7e6d4190bab9d5a13f5d3d49--07616f446a5e4de19df50954cf856bf2 47c78881ef14414695af0eb73ee9d0be 07616f446a5e4de19df50954cf856bf2--47c78881ef14414695af0eb73ee9d0be 92d7dbf8edc341b3900f7a05e3fae691 47c78881ef14414695af0eb73ee9d0be--92d7dbf8edc341b3900f7a05e3fae691 9b0e283b15914141866d0a846ae32908 92d7dbf8edc341b3900f7a05e3fae691--9b0e283b15914141866d0a846ae32908 bf7df32854e94f28900a2b8e652d4ee0 9b0e283b15914141866d0a846ae32908--bf7df32854e94f28900a2b8e652d4ee0 ff050a364980480ea5dd6755fe97aa24 bf7df32854e94f28900a2b8e652d4ee0--ff050a364980480ea5dd6755fe97aa24 0c181dbc58ca47deb978894549cba506 ff050a364980480ea5dd6755fe97aa24--0c181dbc58ca47deb978894549cba506 967af6e9a5c7414c8e6be3e854f99789 0c181dbc58ca47deb978894549cba506--967af6e9a5c7414c8e6be3e854f99789 0c2302a5d28f48ba8a8c325d87fc3ac7 967af6e9a5c7414c8e6be3e854f99789--0c2302a5d28f48ba8a8c325d87fc3ac7 90b3474a6b0242599e5b1aa7ab786738 0c2302a5d28f48ba8a8c325d87fc3ac7--90b3474a6b0242599e5b1aa7ab786738 8fdcc0e27d3945e591c285d0c7e5873f 90b3474a6b0242599e5b1aa7ab786738--8fdcc0e27d3945e591c285d0c7e5873f f5173ac90cc54c7ab4cb01cc09d95b4e 8fdcc0e27d3945e591c285d0c7e5873f--f5173ac90cc54c7ab4cb01cc09d95b4e 2070f8c2f95546b3b3784333827fcbdb f5173ac90cc54c7ab4cb01cc09d95b4e--2070f8c2f95546b3b3784333827fcbdb b8171589e4ed4af49e6711f7c3b4fb95 2070f8c2f95546b3b3784333827fcbdb--b8171589e4ed4af49e6711f7c3b4fb95 23531bf1db974eb086f70052fa6a3d97 b8171589e4ed4af49e6711f7c3b4fb95--23531bf1db974eb086f70052fa6a3d97 36c56fa1982c442aaa0282ffc92dc506 23531bf1db974eb086f70052fa6a3d97--36c56fa1982c442aaa0282ffc92dc506 8060c38d560242f68c97fba7d736e825 36c56fa1982c442aaa0282ffc92dc506--8060c38d560242f68c97fba7d736e825 dad4e1573d3e4da9b946ee075b376e72 8060c38d560242f68c97fba7d736e825--dad4e1573d3e4da9b946ee075b376e72 cece50858caa4c1785b246dc6bfd8ddc dad4e1573d3e4da9b946ee075b376e72--cece50858caa4c1785b246dc6bfd8ddc 2ceae41ff202415793f986657436e63f cece50858caa4c1785b246dc6bfd8ddc--2ceae41ff202415793f986657436e63f 74d7c7407c9b48b8946da8266286e2df 2ceae41ff202415793f986657436e63f--74d7c7407c9b48b8946da8266286e2df ce99992598db4fd8ae15c0d39d0778e8 74d7c7407c9b48b8946da8266286e2df--ce99992598db4fd8ae15c0d39d0778e8 22b70575c7114dc588429f348a62f4d7 ce99992598db4fd8ae15c0d39d0778e8--22b70575c7114dc588429f348a62f4d7 a107f398b6d24e7eb6e718b6cc358840 22b70575c7114dc588429f348a62f4d7--a107f398b6d24e7eb6e718b6cc358840 49a2143908fd430ca61e9255ccca7eb1 a107f398b6d24e7eb6e718b6cc358840--49a2143908fd430ca61e9255ccca7eb1 5b3b4eb5fbab4ac3a652eda2678c536d 49a2143908fd430ca61e9255ccca7eb1--5b3b4eb5fbab4ac3a652eda2678c536d b83bb07b7e63432ba291e253a49adcad 5b3b4eb5fbab4ac3a652eda2678c536d--b83bb07b7e63432ba291e253a49adcad fe86d50704254441bb22b8bb9a2bb5ef b83bb07b7e63432ba291e253a49adcad--fe86d50704254441bb22b8bb9a2bb5ef 05ac25f05fe749b69ca5511d9416f47d fe86d50704254441bb22b8bb9a2bb5ef--05ac25f05fe749b69ca5511d9416f47d be90bf5a71bd46d2a240b2e49b9bc1f8 05ac25f05fe749b69ca5511d9416f47d--be90bf5a71bd46d2a240b2e49b9bc1f8 7cdd326ae2ca4b1083ae0e72e9093c37 be90bf5a71bd46d2a240b2e49b9bc1f8--7cdd326ae2ca4b1083ae0e72e9093c37 7769bedc1da546f9926d358483850dfc 7cdd326ae2ca4b1083ae0e72e9093c37--7769bedc1da546f9926d358483850dfc 7d0a24081a4640ab8a2226c768dc4582 7769bedc1da546f9926d358483850dfc--7d0a24081a4640ab8a2226c768dc4582 40ef48dbe0b34707a00753486355a24a 7d0a24081a4640ab8a2226c768dc4582--40ef48dbe0b34707a00753486355a24a 4d638106116548d0acdfccfe3b1c3080 40ef48dbe0b34707a00753486355a24a--4d638106116548d0acdfccfe3b1c3080 08e950d2a30f4097a5d54427cb7150ba 4d638106116548d0acdfccfe3b1c3080--08e950d2a30f4097a5d54427cb7150ba 5681c059a1f947848c1dadc5d204b673 08e950d2a30f4097a5d54427cb7150ba--5681c059a1f947848c1dadc5d204b673 c010699dcc4e468fa6304e7bafcd2495 5681c059a1f947848c1dadc5d204b673--c010699dcc4e468fa6304e7bafcd2495 0b3459e77ccd4b8caac0ba09448ecc6e c010699dcc4e468fa6304e7bafcd2495--0b3459e77ccd4b8caac0ba09448ecc6e 54b0d1d1606344dcb5f43964f463557a 0b3459e77ccd4b8caac0ba09448ecc6e--54b0d1d1606344dcb5f43964f463557a 9bbeefedf38446158e6e3b15d8020be5 54b0d1d1606344dcb5f43964f463557a--9bbeefedf38446158e6e3b15d8020be5 7954480bb845447891831b3b3ca1a95c 9bbeefedf38446158e6e3b15d8020be5--7954480bb845447891831b3b3ca1a95c 788db713da674e93b59d763746b649f4 7954480bb845447891831b3b3ca1a95c--788db713da674e93b59d763746b649f4 b5005ec804bb4d71adf7c099d6dfa2ed 788db713da674e93b59d763746b649f4--b5005ec804bb4d71adf7c099d6dfa2ed e20bb0f924254635aaccaf1692d4b6cb b5005ec804bb4d71adf7c099d6dfa2ed--e20bb0f924254635aaccaf1692d4b6cb 9e53bee1256a4dea9e7e3c90730d7872 e20bb0f924254635aaccaf1692d4b6cb--9e53bee1256a4dea9e7e3c90730d7872 c24b96a2cb2048edac4240975223e9d1 9e53bee1256a4dea9e7e3c90730d7872--c24b96a2cb2048edac4240975223e9d1 7007058b6d1a4fccaea8d8464174d4c3 c24b96a2cb2048edac4240975223e9d1--7007058b6d1a4fccaea8d8464174d4c3 3c4c761b833848c795f5444bc99a4875 7007058b6d1a4fccaea8d8464174d4c3--3c4c761b833848c795f5444bc99a4875 c0f277d820aa454e86fe48e82287f2e2 3c4c761b833848c795f5444bc99a4875--c0f277d820aa454e86fe48e82287f2e2 677a7af815df4f9a949701a944b8a0e1 c0f277d820aa454e86fe48e82287f2e2--677a7af815df4f9a949701a944b8a0e1 a0cb65256e0844ecbc4e6f446f3b7450 677a7af815df4f9a949701a944b8a0e1--a0cb65256e0844ecbc4e6f446f3b7450 cca1c34af054422e8ee77c55b53340f0 a0cb65256e0844ecbc4e6f446f3b7450--cca1c34af054422e8ee77c55b53340f0 64d4b8b158614fdf8caf29f0aaf9ccee cca1c34af054422e8ee77c55b53340f0--64d4b8b158614fdf8caf29f0aaf9ccee 0b952fb05e5646a4a55b13edf35ee308 64d4b8b158614fdf8caf29f0aaf9ccee--0b952fb05e5646a4a55b13edf35ee308 0a8f4be7d1dc49119df96db7765f2882 0b952fb05e5646a4a55b13edf35ee308--0a8f4be7d1dc49119df96db7765f2882 0d822c0f2dc2436f8745523cb9bbda20 RX(b00) 0a8f4be7d1dc49119df96db7765f2882--0d822c0f2dc2436f8745523cb9bbda20 d9d8888a48a44afe861cacc784dce352 0d822c0f2dc2436f8745523cb9bbda20--d9d8888a48a44afe861cacc784dce352 832f1230b23a4da9aa37134f199af558 d9d8888a48a44afe861cacc784dce352--832f1230b23a4da9aa37134f199af558 456e946e4e97444597730c3c82818486 832f1230b23a4da9aa37134f199af558--456e946e4e97444597730c3c82818486 a5349a80eaf94dd4b77841d9b461821a 456e946e4e97444597730c3c82818486--a5349a80eaf94dd4b77841d9b461821a 65c79b5c211542d78af3b42afc670676 a5349a80eaf94dd4b77841d9b461821a--65c79b5c211542d78af3b42afc670676 d5c39f7b4d42424c8ce3330c7e906706 65c79b5c211542d78af3b42afc670676--d5c39f7b4d42424c8ce3330c7e906706 134e6bca1f3c419e92aae20150d07693 d5c39f7b4d42424c8ce3330c7e906706--134e6bca1f3c419e92aae20150d07693 7898d04af9a74ad0be822533ddcacd5f 134e6bca1f3c419e92aae20150d07693--7898d04af9a74ad0be822533ddcacd5f 77bc662aa8694167be31485064967fc5 7898d04af9a74ad0be822533ddcacd5f--77bc662aa8694167be31485064967fc5 ceb40e1ac1a64b6ba0f9c585ddc3a791 77bc662aa8694167be31485064967fc5--ceb40e1ac1a64b6ba0f9c585ddc3a791 be212372953447d0a89158dbe4a0abc6 ceb40e1ac1a64b6ba0f9c585ddc3a791--be212372953447d0a89158dbe4a0abc6 12ffbe9e0fd84f78a699a15d7398e825 be212372953447d0a89158dbe4a0abc6--12ffbe9e0fd84f78a699a15d7398e825 d375b989610c4382b2cb5af558a042aa 12ffbe9e0fd84f78a699a15d7398e825--d375b989610c4382b2cb5af558a042aa 66d5f74db64d45eeb0073c4b04de05a6 d375b989610c4382b2cb5af558a042aa--66d5f74db64d45eeb0073c4b04de05a6 3c33e963216c4e24a885f7ff5d0ff478 66d5f74db64d45eeb0073c4b04de05a6--3c33e963216c4e24a885f7ff5d0ff478 7d392da68ade4780a7616f93c78539c8 3c33e963216c4e24a885f7ff5d0ff478--7d392da68ade4780a7616f93c78539c8 80fdb1d9d05e4aafae69a5984b22f98d 7d392da68ade4780a7616f93c78539c8--80fdb1d9d05e4aafae69a5984b22f98d fac94cdaf4e844378fcee1f8aa1f6d93 80fdb1d9d05e4aafae69a5984b22f98d--fac94cdaf4e844378fcee1f8aa1f6d93 8c51f5f21cc4431aa68ef3e688e56b19 fac94cdaf4e844378fcee1f8aa1f6d93--8c51f5f21cc4431aa68ef3e688e56b19 daa9b794ada9454ea599de946b489079 8c51f5f21cc4431aa68ef3e688e56b19--daa9b794ada9454ea599de946b489079 3f6d4eb0c8f247588847c98ab29b36ca daa9b794ada9454ea599de946b489079--3f6d4eb0c8f247588847c98ab29b36ca 8c27807f7db44bb4ba1dc518decbcea7 3f6d4eb0c8f247588847c98ab29b36ca--8c27807f7db44bb4ba1dc518decbcea7 d8fbab0f69ae4e1ebcdfe9ccf3dc12b4 8c27807f7db44bb4ba1dc518decbcea7--d8fbab0f69ae4e1ebcdfe9ccf3dc12b4 d925c9e14827423a81e3206f81ab047e d8fbab0f69ae4e1ebcdfe9ccf3dc12b4--d925c9e14827423a81e3206f81ab047e e40fbe4e716b4dcdbb9dcc3afb5c2515 d925c9e14827423a81e3206f81ab047e--e40fbe4e716b4dcdbb9dcc3afb5c2515 9d6735d632bc45f3b62a3741b854f3df e40fbe4e716b4dcdbb9dcc3afb5c2515--9d6735d632bc45f3b62a3741b854f3df 124ff58a2f9f4539b8488e7f3b4a98eb 9d6735d632bc45f3b62a3741b854f3df--124ff58a2f9f4539b8488e7f3b4a98eb a29e77bfc77b48eebe71f5d0497a991c 124ff58a2f9f4539b8488e7f3b4a98eb--a29e77bfc77b48eebe71f5d0497a991c 0575bd123b2946a5bcc269ec0376d3c7 a29e77bfc77b48eebe71f5d0497a991c--0575bd123b2946a5bcc269ec0376d3c7 e8a1eeca6ced40869f7e746dfb2ce7cd 0575bd123b2946a5bcc269ec0376d3c7--e8a1eeca6ced40869f7e746dfb2ce7cd 14afc6fe327d429e85f90d1246cc842a e8a1eeca6ced40869f7e746dfb2ce7cd--14afc6fe327d429e85f90d1246cc842a 48686bb9b8f44ffea721ba7dfbb828ff 14afc6fe327d429e85f90d1246cc842a--48686bb9b8f44ffea721ba7dfbb828ff 43482a206a1f478cac9f85b27bb0b1d9 48686bb9b8f44ffea721ba7dfbb828ff--43482a206a1f478cac9f85b27bb0b1d9 d0f21d2c5c57426fbbe45ed32459349f 43482a206a1f478cac9f85b27bb0b1d9--d0f21d2c5c57426fbbe45ed32459349f 32c5c375e6634f9abb5f7a5f113d7ac0 d0f21d2c5c57426fbbe45ed32459349f--32c5c375e6634f9abb5f7a5f113d7ac0 55d40dee149f43e8890b284e6b44df4e 32c5c375e6634f9abb5f7a5f113d7ac0--55d40dee149f43e8890b284e6b44df4e 17c7d771a96f467e9e65496933b0c506 55d40dee149f43e8890b284e6b44df4e--17c7d771a96f467e9e65496933b0c506 db061fea547c45498738d20997e1723b 17c7d771a96f467e9e65496933b0c506--db061fea547c45498738d20997e1723b b6369da33eb743fd9ab7897980175d03 db061fea547c45498738d20997e1723b--b6369da33eb743fd9ab7897980175d03 35533487c3084463ac9238fe0299d854 b6369da33eb743fd9ab7897980175d03--35533487c3084463ac9238fe0299d854 4d5ef8897b074e4b925c9116173e617d 35533487c3084463ac9238fe0299d854--4d5ef8897b074e4b925c9116173e617d 3a472208f4b04b1aba72dede1b71eb33 4d5ef8897b074e4b925c9116173e617d--3a472208f4b04b1aba72dede1b71eb33 25f67c00ffda47d9b2ec8e4751b8b0ee 3a472208f4b04b1aba72dede1b71eb33--25f67c00ffda47d9b2ec8e4751b8b0ee 028bcb84892541fa947f7c1224d9c207 25f67c00ffda47d9b2ec8e4751b8b0ee--028bcb84892541fa947f7c1224d9c207 82495ba336534f4c90be589054123400 028bcb84892541fa947f7c1224d9c207--82495ba336534f4c90be589054123400 2608a3ef82f34a8a97692192db33c0e0 82495ba336534f4c90be589054123400--2608a3ef82f34a8a97692192db33c0e0 722007cf737f4d2596ac9e105fd95a9a 2608a3ef82f34a8a97692192db33c0e0--722007cf737f4d2596ac9e105fd95a9a 4c09ecceba604706afde4239b814942b 722007cf737f4d2596ac9e105fd95a9a--4c09ecceba604706afde4239b814942b 29a544c921f945499b28ce48d9d38b7d 4c09ecceba604706afde4239b814942b--29a544c921f945499b28ce48d9d38b7d 1f933270a434465bbd553581c98dab0e 29a544c921f945499b28ce48d9d38b7d--1f933270a434465bbd553581c98dab0e 19529e1a39394b18aa3ebae198a4dba7 1f933270a434465bbd553581c98dab0e--19529e1a39394b18aa3ebae198a4dba7 7de7193e9b494ac98fd01aeb70b809b0 19529e1a39394b18aa3ebae198a4dba7--7de7193e9b494ac98fd01aeb70b809b0 20c4bfb592db406a810ad955e6c8d4fc 7de7193e9b494ac98fd01aeb70b809b0--20c4bfb592db406a810ad955e6c8d4fc a93a98251f594f22ae7e6c24a3aa54f9 20c4bfb592db406a810ad955e6c8d4fc--a93a98251f594f22ae7e6c24a3aa54f9 1df750b6db7445fe81e85654d2ae5462 a93a98251f594f22ae7e6c24a3aa54f9--1df750b6db7445fe81e85654d2ae5462 f152267bf97f47f88c8e1e10a1f0786b 1df750b6db7445fe81e85654d2ae5462--f152267bf97f47f88c8e1e10a1f0786b 01416e54e5094f22bfe900019064b4b3 f152267bf97f47f88c8e1e10a1f0786b--01416e54e5094f22bfe900019064b4b3 4ae98f6904bc44748be07589c9c70720 01416e54e5094f22bfe900019064b4b3--4ae98f6904bc44748be07589c9c70720 de1d5e5d5f2b4af284db81f415877279 4ae98f6904bc44748be07589c9c70720--de1d5e5d5f2b4af284db81f415877279 81e33bffea78422189ef8a1831837b98 de1d5e5d5f2b4af284db81f415877279--81e33bffea78422189ef8a1831837b98 d6ea096bb3554d0ab8f81ad27ba200e6 81e33bffea78422189ef8a1831837b98--d6ea096bb3554d0ab8f81ad27ba200e6 a21ce1c3b0f04834a4be320585215ac8 d6ea096bb3554d0ab8f81ad27ba200e6--a21ce1c3b0f04834a4be320585215ac8 8d712a8837224a769bc498de5d955d9b a21ce1c3b0f04834a4be320585215ac8--8d712a8837224a769bc498de5d955d9b e6c77ddcde8249e3b0fb0c0f25476bd1 8d712a8837224a769bc498de5d955d9b--e6c77ddcde8249e3b0fb0c0f25476bd1 90d5471fa54b4260aea39b3ffdd75373 e6c77ddcde8249e3b0fb0c0f25476bd1--90d5471fa54b4260aea39b3ffdd75373 fceda912f56a4320933e23bb7ccf5fe3 90d5471fa54b4260aea39b3ffdd75373--fceda912f56a4320933e23bb7ccf5fe3 e77994a18e2f4729a2d97adbe82d9474 fceda912f56a4320933e23bb7ccf5fe3--e77994a18e2f4729a2d97adbe82d9474 7f4432058371478c93dc7f7aa1151449 e77994a18e2f4729a2d97adbe82d9474--7f4432058371478c93dc7f7aa1151449 d18e2794ca614ee4819534fcdfc4bb5b 7f4432058371478c93dc7f7aa1151449--d18e2794ca614ee4819534fcdfc4bb5b 84ce9d90c1c6415fa2872e17365cd578 d18e2794ca614ee4819534fcdfc4bb5b--84ce9d90c1c6415fa2872e17365cd578 5bcfe9e72a2a472fad44c5646d1edf71 84ce9d90c1c6415fa2872e17365cd578--5bcfe9e72a2a472fad44c5646d1edf71 e1f3edfa74394c319afbae20b46245db 5bcfe9e72a2a472fad44c5646d1edf71--e1f3edfa74394c319afbae20b46245db 0be7af6ab8d14f319c5d7a10882fb0d9 e1f3edfa74394c319afbae20b46245db--0be7af6ab8d14f319c5d7a10882fb0d9 27aa33e9877f42d68fe772aaf0c405cb 0be7af6ab8d14f319c5d7a10882fb0d9--27aa33e9877f42d68fe772aaf0c405cb 2975e2b5b7204dc986dc9db62bc555fd 27aa33e9877f42d68fe772aaf0c405cb--2975e2b5b7204dc986dc9db62bc555fd ecc288d48705455f974e0c5d1def9e8c 2975e2b5b7204dc986dc9db62bc555fd--ecc288d48705455f974e0c5d1def9e8c 6a02f42c91064cb19180afcd2e96a9e1 ecc288d48705455f974e0c5d1def9e8c--6a02f42c91064cb19180afcd2e96a9e1 5d0769fb2c714aaeb3d086da10278cb0 6a02f42c91064cb19180afcd2e96a9e1--5d0769fb2c714aaeb3d086da10278cb0 cbced9b1ece343c48bfdb00f2f7d68f7 5d0769fb2c714aaeb3d086da10278cb0--cbced9b1ece343c48bfdb00f2f7d68f7 922e72bccd9a400d87cbe27934c8afeb cbced9b1ece343c48bfdb00f2f7d68f7--922e72bccd9a400d87cbe27934c8afeb 8245c3afab1840a3a3c6455357aa96ea 922e72bccd9a400d87cbe27934c8afeb--8245c3afab1840a3a3c6455357aa96ea 98e3b48ab51c45cb97a150a10603bb6f 8245c3afab1840a3a3c6455357aa96ea--98e3b48ab51c45cb97a150a10603bb6f 7da10ff204bb4f05bffc7f0047488354 98e3b48ab51c45cb97a150a10603bb6f--7da10ff204bb4f05bffc7f0047488354 bc396f4093074bcb9b2fc6bb706170ad 7da10ff204bb4f05bffc7f0047488354--bc396f4093074bcb9b2fc6bb706170ad 7834229316674a4dbef3ec7156a32bde bc396f4093074bcb9b2fc6bb706170ad--7834229316674a4dbef3ec7156a32bde af4c679158044bd19f5c336c5911dd5f 7834229316674a4dbef3ec7156a32bde--af4c679158044bd19f5c336c5911dd5f b14161d320a7428c8886726d164414f9 af4c679158044bd19f5c336c5911dd5f--b14161d320a7428c8886726d164414f9 0873c4de5fe345c49f60cc9ab337b263 b14161d320a7428c8886726d164414f9--0873c4de5fe345c49f60cc9ab337b263 37498eb61ea7447391d2f653e12c15c3 0873c4de5fe345c49f60cc9ab337b263--37498eb61ea7447391d2f653e12c15c3 e415297e7fb24d12acadf505d3b4d38e 37498eb61ea7447391d2f653e12c15c3--e415297e7fb24d12acadf505d3b4d38e 1e70b4a78f3a40eda9992275e98c5df9 e415297e7fb24d12acadf505d3b4d38e--1e70b4a78f3a40eda9992275e98c5df9 bc7c74b68265442d87641b0667a1d1cd 1e70b4a78f3a40eda9992275e98c5df9--bc7c74b68265442d87641b0667a1d1cd 0258b1f736c142de8080ad30662aa91a bc7c74b68265442d87641b0667a1d1cd--0258b1f736c142de8080ad30662aa91a ee07b021e79f42dba1cdc8d1d5040310 0258b1f736c142de8080ad30662aa91a--ee07b021e79f42dba1cdc8d1d5040310 df3b4e07bfb94bb49235f5fabc17f244 ee07b021e79f42dba1cdc8d1d5040310--df3b4e07bfb94bb49235f5fabc17f244 b6e2fb94aa1d4505b40ea0724d788db4 df3b4e07bfb94bb49235f5fabc17f244--b6e2fb94aa1d4505b40ea0724d788db4 efda73aa56ad40678cdd237cb9e263c3 b6e2fb94aa1d4505b40ea0724d788db4--efda73aa56ad40678cdd237cb9e263c3 205f5c40ee814426924cff5431d7e66c efda73aa56ad40678cdd237cb9e263c3--205f5c40ee814426924cff5431d7e66c 883f34135a5d4904900f0c4050315f0f 205f5c40ee814426924cff5431d7e66c--883f34135a5d4904900f0c4050315f0f f897348292ac455ebdc870940fcdc082 883f34135a5d4904900f0c4050315f0f--f897348292ac455ebdc870940fcdc082 bdc7e781ff30463fb4dc786d636937a5 f897348292ac455ebdc870940fcdc082--bdc7e781ff30463fb4dc786d636937a5 08e9e8305dc6408384374e4b7b774857 bdc7e781ff30463fb4dc786d636937a5--08e9e8305dc6408384374e4b7b774857 a4c3ddd8cdc846aa8e03a9aca71bde4d 08e9e8305dc6408384374e4b7b774857--a4c3ddd8cdc846aa8e03a9aca71bde4d 4794b419eb1f4c80a43d92ade8fb99c7 a4c3ddd8cdc846aa8e03a9aca71bde4d--4794b419eb1f4c80a43d92ade8fb99c7 43f345675d604d10a9b9c61005a76aa4 4794b419eb1f4c80a43d92ade8fb99c7--43f345675d604d10a9b9c61005a76aa4 6e664fe9f03b4d028fab3b38a09713df 43f345675d604d10a9b9c61005a76aa4--6e664fe9f03b4d028fab3b38a09713df 1709224ef0eb4f74a6e616037f8aae38 6e664fe9f03b4d028fab3b38a09713df--1709224ef0eb4f74a6e616037f8aae38 69cd45af64c04b7a863133ca13e4ba70 1709224ef0eb4f74a6e616037f8aae38--69cd45af64c04b7a863133ca13e4ba70 9394682d313e464298d89854a579c9f4 69cd45af64c04b7a863133ca13e4ba70--9394682d313e464298d89854a579c9f4 26d35b61a71049c6b93f521982e42d84 9394682d313e464298d89854a579c9f4--26d35b61a71049c6b93f521982e42d84 4019485cef274b02b85c9b8f6362ac42 26d35b61a71049c6b93f521982e42d84--4019485cef274b02b85c9b8f6362ac42 15abce20b2cc4e1080eeaf985527a90a 4019485cef274b02b85c9b8f6362ac42--15abce20b2cc4e1080eeaf985527a90a 5879f8b6d3c34b00b84c8ae0977354e3 15abce20b2cc4e1080eeaf985527a90a--5879f8b6d3c34b00b84c8ae0977354e3 75440e1c662d4cfb8bbe4c16b4c39cf9 5879f8b6d3c34b00b84c8ae0977354e3--75440e1c662d4cfb8bbe4c16b4c39cf9 5cd68957161f40be8befad7b152d9785 75440e1c662d4cfb8bbe4c16b4c39cf9--5cd68957161f40be8befad7b152d9785 bab15c129d624b7ba4d3768c81a50f20 5cd68957161f40be8befad7b152d9785--bab15c129d624b7ba4d3768c81a50f20 762aad9775754ea09e6d63c9871cddc4 bab15c129d624b7ba4d3768c81a50f20--762aad9775754ea09e6d63c9871cddc4 2b97ddb38fe444038ac58547e19ed5d3 762aad9775754ea09e6d63c9871cddc4--2b97ddb38fe444038ac58547e19ed5d3 b58c509ac1cc48c187c7765eccfcdac7 2b97ddb38fe444038ac58547e19ed5d3--b58c509ac1cc48c187c7765eccfcdac7 d15760a1782e425a8def175f7c64e538 b58c509ac1cc48c187c7765eccfcdac7--d15760a1782e425a8def175f7c64e538 4f93bc0602814314a324ccb57c84c5d1 d15760a1782e425a8def175f7c64e538--4f93bc0602814314a324ccb57c84c5d1 8221b7ba6ece4a66bef6e3f20a6c4f05 4f93bc0602814314a324ccb57c84c5d1--8221b7ba6ece4a66bef6e3f20a6c4f05 b4154e53b7b74d0aacac99fd7859a902 8221b7ba6ece4a66bef6e3f20a6c4f05--b4154e53b7b74d0aacac99fd7859a902 2bdba8f5ef5a46da9d3f586cf6cf9285 b4154e53b7b74d0aacac99fd7859a902--2bdba8f5ef5a46da9d3f586cf6cf9285 0608ee05ae0344c8868e2c6a381c0c99 2bdba8f5ef5a46da9d3f586cf6cf9285--0608ee05ae0344c8868e2c6a381c0c99 037a242b469649b2b11e1aa9bae33a15 0608ee05ae0344c8868e2c6a381c0c99--037a242b469649b2b11e1aa9bae33a15 d78c422088324ca2b8f9d0072e692b17 037a242b469649b2b11e1aa9bae33a15--d78c422088324ca2b8f9d0072e692b17 4409279585f6407198aa73caf179c999 d78c422088324ca2b8f9d0072e692b17--4409279585f6407198aa73caf179c999 acd772b9d1f24da29312f03493f7827e 4409279585f6407198aa73caf179c999--acd772b9d1f24da29312f03493f7827e 03c3ae4ac8224608bd535eaadb45b520 RX(b10) acd772b9d1f24da29312f03493f7827e--03c3ae4ac8224608bd535eaadb45b520 9ca0701b41f645cb97fa372a3e333682 03c3ae4ac8224608bd535eaadb45b520--9ca0701b41f645cb97fa372a3e333682 4be1682335144bf989ee5d4002e6da5a 863234b680cd42188434a70261bace50 X 43e3169bfb67454eb9dbadbfb35aa7b6--863234b680cd42188434a70261bace50 f9254232c8124e08a848e096c5554702 2 863234b680cd42188434a70261bace50--717cefc1858841cda625eab7bc771bdd 04716e0bd2dd444b93cd2a3b3f3d3f77 863234b680cd42188434a70261bace50--04716e0bd2dd444b93cd2a3b3f3d3f77 99519e65389a4e1b80defecfcb57e372 04716e0bd2dd444b93cd2a3b3f3d3f77--99519e65389a4e1b80defecfcb57e372 d0d1d0d1061549bab21caa85dd58e3e0 99519e65389a4e1b80defecfcb57e372--d0d1d0d1061549bab21caa85dd58e3e0 9904f001d97c4df59822c7bf1d1f98f1 d0d1d0d1061549bab21caa85dd58e3e0--9904f001d97c4df59822c7bf1d1f98f1 a313e161162745c6976d0210ade95eab 9904f001d97c4df59822c7bf1d1f98f1--a313e161162745c6976d0210ade95eab cc6902a0033145d881103914e9029360 a313e161162745c6976d0210ade95eab--cc6902a0033145d881103914e9029360 0c342fb471c54331a1e0b7bd3b6682fc cc6902a0033145d881103914e9029360--0c342fb471c54331a1e0b7bd3b6682fc 79922f068d26451eb5006c7fee6e599e 0c342fb471c54331a1e0b7bd3b6682fc--79922f068d26451eb5006c7fee6e599e cc749405ab4a4f779c429c72fea5a50d 79922f068d26451eb5006c7fee6e599e--cc749405ab4a4f779c429c72fea5a50d 0fdd5f4a8835430da5f3f2c3d154193d cc749405ab4a4f779c429c72fea5a50d--0fdd5f4a8835430da5f3f2c3d154193d bc681c7688cd4b70aa8ddf67e4c50f63 0fdd5f4a8835430da5f3f2c3d154193d--bc681c7688cd4b70aa8ddf67e4c50f63 25ce2dd85c2e4edabe64ed89dfa324b5 bc681c7688cd4b70aa8ddf67e4c50f63--25ce2dd85c2e4edabe64ed89dfa324b5 71fc9065039144869072314445cde523 25ce2dd85c2e4edabe64ed89dfa324b5--71fc9065039144869072314445cde523 31de7b94001d4f9290266a95b468d466 X 71fc9065039144869072314445cde523--31de7b94001d4f9290266a95b468d466 31de7b94001d4f9290266a95b468d466--ffd9097c191a4275b5ffa41bb78e902c 970a8f97adb741fc806a4b665d7a6759 X 31de7b94001d4f9290266a95b468d466--970a8f97adb741fc806a4b665d7a6759 970a8f97adb741fc806a4b665d7a6759--7b515c55cef944edab45e742fc652160 e1d2fd61936f43938be02d7b6d0e1d18 RZ(-1.0*g0) 970a8f97adb741fc806a4b665d7a6759--e1d2fd61936f43938be02d7b6d0e1d18 e7f45b5ca67a42c3ab1a1d90b27b5f84 X e1d2fd61936f43938be02d7b6d0e1d18--e7f45b5ca67a42c3ab1a1d90b27b5f84 e7f45b5ca67a42c3ab1a1d90b27b5f84--bf3a9ffdd03a49999598fd1fbd106cd5 1b9d00bfb881454d84e9f834262da0f0 X e7f45b5ca67a42c3ab1a1d90b27b5f84--1b9d00bfb881454d84e9f834262da0f0 1b9d00bfb881454d84e9f834262da0f0--26f0f4c1e3ac49589e3c70e89df31ec8 800c2eaa63c3482cada1511f1bc3eb01 1b9d00bfb881454d84e9f834262da0f0--800c2eaa63c3482cada1511f1bc3eb01 5162e367f1104e80a295f90dbb82f180 800c2eaa63c3482cada1511f1bc3eb01--5162e367f1104e80a295f90dbb82f180 62d1e4933ab14acca5c2bd54295e096a 5162e367f1104e80a295f90dbb82f180--62d1e4933ab14acca5c2bd54295e096a 140d355e343241e589c13a5eda7c1b70 62d1e4933ab14acca5c2bd54295e096a--140d355e343241e589c13a5eda7c1b70 37617dcee03246cbbf7d5ce4e367c1e3 140d355e343241e589c13a5eda7c1b70--37617dcee03246cbbf7d5ce4e367c1e3 16fb8b23d5704d548c4895ea8349d990 X 37617dcee03246cbbf7d5ce4e367c1e3--16fb8b23d5704d548c4895ea8349d990 16fb8b23d5704d548c4895ea8349d990--5fbc88f7ebf448ce80c37577c05a6c29 3d83a2d4d1054fb1ac0810cefbb34005 X 16fb8b23d5704d548c4895ea8349d990--3d83a2d4d1054fb1ac0810cefbb34005 3d83a2d4d1054fb1ac0810cefbb34005--078ea9948cf546da95c411edf13bd886 044044484c784bebb53827342f093390 3d83a2d4d1054fb1ac0810cefbb34005--044044484c784bebb53827342f093390 a3634eae2ee24e9aa0d04f1a9c902d05 044044484c784bebb53827342f093390--a3634eae2ee24e9aa0d04f1a9c902d05 c58e12bb6aa447e4931421394da28d7c a3634eae2ee24e9aa0d04f1a9c902d05--c58e12bb6aa447e4931421394da28d7c 25e601afa64840a89fee0ac914ade83b c58e12bb6aa447e4931421394da28d7c--25e601afa64840a89fee0ac914ade83b 3f244e2bb18e402480a76e2767a2972d 25e601afa64840a89fee0ac914ade83b--3f244e2bb18e402480a76e2767a2972d 60cc151b7b664d26b924cc689f145367 3f244e2bb18e402480a76e2767a2972d--60cc151b7b664d26b924cc689f145367 8461554ed014499bbcd3f94542e32930 60cc151b7b664d26b924cc689f145367--8461554ed014499bbcd3f94542e32930 b2b51d22691d4208a461dc80235c9ba3 X 8461554ed014499bbcd3f94542e32930--b2b51d22691d4208a461dc80235c9ba3 b2b51d22691d4208a461dc80235c9ba3--c982058f4b7b497bab5bde2ca26c7eef 3592edc7773a4839868b1d87f895ba8c X b2b51d22691d4208a461dc80235c9ba3--3592edc7773a4839868b1d87f895ba8c 3592edc7773a4839868b1d87f895ba8c--0f4a228c08fb47d39efd5060fcffacec b21d4e02d67b442380ae29966efb39d4 3592edc7773a4839868b1d87f895ba8c--b21d4e02d67b442380ae29966efb39d4 c0a631deda4d458da1535b1ddf359770 b21d4e02d67b442380ae29966efb39d4--c0a631deda4d458da1535b1ddf359770 0f7acc3d67764eb299338d780db7289c c0a631deda4d458da1535b1ddf359770--0f7acc3d67764eb299338d780db7289c b88c8e9aca044015ba16d861c8fd14eb 0f7acc3d67764eb299338d780db7289c--b88c8e9aca044015ba16d861c8fd14eb a2047ec48d794582b48fe3dac3db4cca b88c8e9aca044015ba16d861c8fd14eb--a2047ec48d794582b48fe3dac3db4cca 7b1173ce00de4dbc9a9a0b7993e3d30e a2047ec48d794582b48fe3dac3db4cca--7b1173ce00de4dbc9a9a0b7993e3d30e 1963732b0b2e465c852c557b5098ee7e 7b1173ce00de4dbc9a9a0b7993e3d30e--1963732b0b2e465c852c557b5098ee7e 0e2336341e7140a2b15e46e709306a3b 1963732b0b2e465c852c557b5098ee7e--0e2336341e7140a2b15e46e709306a3b 48fc8c44d2f44720ab9154d58b7248de 0e2336341e7140a2b15e46e709306a3b--48fc8c44d2f44720ab9154d58b7248de b32310d4ddd64680bf2a68cd73f9ee34 48fc8c44d2f44720ab9154d58b7248de--b32310d4ddd64680bf2a68cd73f9ee34 40624eb81ddd4572911c08634350be01 b32310d4ddd64680bf2a68cd73f9ee34--40624eb81ddd4572911c08634350be01 3a0028d221bc4992992990b95d28f88f X 40624eb81ddd4572911c08634350be01--3a0028d221bc4992992990b95d28f88f 3a0028d221bc4992992990b95d28f88f--aa8810cf10234c56ad202f10af128b99 9fd185415a2845ed954cff5474a1890a X 3a0028d221bc4992992990b95d28f88f--9fd185415a2845ed954cff5474a1890a 9fd185415a2845ed954cff5474a1890a--47a3a290cc44401393ba41c4573d74f8 4b3c4c62ba2d47afa6cfe695c6e24306 9fd185415a2845ed954cff5474a1890a--4b3c4c62ba2d47afa6cfe695c6e24306 a4b0173df87149d38dfb0f382d9ed161 4b3c4c62ba2d47afa6cfe695c6e24306--a4b0173df87149d38dfb0f382d9ed161 88ff0b63cd5b46fcabcc7bae0e1be300 a4b0173df87149d38dfb0f382d9ed161--88ff0b63cd5b46fcabcc7bae0e1be300 dcc7a3a015714924acb2c34ec7cea591 88ff0b63cd5b46fcabcc7bae0e1be300--dcc7a3a015714924acb2c34ec7cea591 93c5e00635a349fa95d9da06981fe95d dcc7a3a015714924acb2c34ec7cea591--93c5e00635a349fa95d9da06981fe95d 86fc452f857c47f09e8f06a293932b40 93c5e00635a349fa95d9da06981fe95d--86fc452f857c47f09e8f06a293932b40 1154eb3910e0453789e0dcb950019e23 86fc452f857c47f09e8f06a293932b40--1154eb3910e0453789e0dcb950019e23 e983473333344c7bafa90dda3d89aee7 1154eb3910e0453789e0dcb950019e23--e983473333344c7bafa90dda3d89aee7 2b491b6ff13542099cf7307210747870 e983473333344c7bafa90dda3d89aee7--2b491b6ff13542099cf7307210747870 5b8d1da142494d40b44d46d057e1472f 2b491b6ff13542099cf7307210747870--5b8d1da142494d40b44d46d057e1472f 870d85d557d142ea993542247a456bf5 5b8d1da142494d40b44d46d057e1472f--870d85d557d142ea993542247a456bf5 814fd99611444a9d8a36eb07ab118162 870d85d557d142ea993542247a456bf5--814fd99611444a9d8a36eb07ab118162 559f0cddeb94409595b899d3a20644be 814fd99611444a9d8a36eb07ab118162--559f0cddeb94409595b899d3a20644be f0cb9bc3f50d42578826a994b71a8c75 X 559f0cddeb94409595b899d3a20644be--f0cb9bc3f50d42578826a994b71a8c75 f0cb9bc3f50d42578826a994b71a8c75--c4dbef744e0d454cbaf16e948d73a950 4304121c76cf41fd9fffeeb14762e8c5 f0cb9bc3f50d42578826a994b71a8c75--4304121c76cf41fd9fffeeb14762e8c5 8d6b5055b2fa4d3d8f1b18002e63f8a5 4304121c76cf41fd9fffeeb14762e8c5--8d6b5055b2fa4d3d8f1b18002e63f8a5 897de562bf694eb4bd6226463bfd587f 8d6b5055b2fa4d3d8f1b18002e63f8a5--897de562bf694eb4bd6226463bfd587f ddd6401f2d20498f8faf72b8fb044025 897de562bf694eb4bd6226463bfd587f--ddd6401f2d20498f8faf72b8fb044025 685199fa3e834650800b3ccc0608e543 ddd6401f2d20498f8faf72b8fb044025--685199fa3e834650800b3ccc0608e543 cdd0efce694c49149a13ad0fe8e1f138 685199fa3e834650800b3ccc0608e543--cdd0efce694c49149a13ad0fe8e1f138 704a01de172c4c67a8c94c8598309c22 cdd0efce694c49149a13ad0fe8e1f138--704a01de172c4c67a8c94c8598309c22 7f1c3cbce36941638e774d51e04e444f 704a01de172c4c67a8c94c8598309c22--7f1c3cbce36941638e774d51e04e444f 2b6b851a091b456dab355a8acf60b383 7f1c3cbce36941638e774d51e04e444f--2b6b851a091b456dab355a8acf60b383 079ae1e2d8774acdaaf3ea212c91808c 2b6b851a091b456dab355a8acf60b383--079ae1e2d8774acdaaf3ea212c91808c 25fc203ff56441809289a76b1fe1293f 079ae1e2d8774acdaaf3ea212c91808c--25fc203ff56441809289a76b1fe1293f 53e7053c625b43c591a92767a944d372 25fc203ff56441809289a76b1fe1293f--53e7053c625b43c591a92767a944d372 f65237d4c27d4e9c900dd55fef88a08c 53e7053c625b43c591a92767a944d372--f65237d4c27d4e9c900dd55fef88a08c bf01cdbebaaa48ab97306fc546075e69 f65237d4c27d4e9c900dd55fef88a08c--bf01cdbebaaa48ab97306fc546075e69 cbb1f31f72c9418bb2e2e87e83f3d756 bf01cdbebaaa48ab97306fc546075e69--cbb1f31f72c9418bb2e2e87e83f3d756 f6503fe776c34e71a5596e8e0a8e679d cbb1f31f72c9418bb2e2e87e83f3d756--f6503fe776c34e71a5596e8e0a8e679d 8a108aba77de4fb7b004f2bde44331b8 f6503fe776c34e71a5596e8e0a8e679d--8a108aba77de4fb7b004f2bde44331b8 c07a9a97692b484fa030001ea4d8d131 8a108aba77de4fb7b004f2bde44331b8--c07a9a97692b484fa030001ea4d8d131 fe284811b243404da20e082a896b5d95 c07a9a97692b484fa030001ea4d8d131--fe284811b243404da20e082a896b5d95 f4043adbad7d47079fcae73e2146f9cc fe284811b243404da20e082a896b5d95--f4043adbad7d47079fcae73e2146f9cc 60afc13b17054249b0d45134e02147f7 f4043adbad7d47079fcae73e2146f9cc--60afc13b17054249b0d45134e02147f7 4495315211754224b569b0912f4dc2f8 60afc13b17054249b0d45134e02147f7--4495315211754224b569b0912f4dc2f8 b6d02f9aabe44db4bdeeeccd7c9f585b 4495315211754224b569b0912f4dc2f8--b6d02f9aabe44db4bdeeeccd7c9f585b 7b67e07a0dab4043970c7c0bcf368c5b b6d02f9aabe44db4bdeeeccd7c9f585b--7b67e07a0dab4043970c7c0bcf368c5b 375cb9d1f93a43cf8a94dd5318cda40c 7b67e07a0dab4043970c7c0bcf368c5b--375cb9d1f93a43cf8a94dd5318cda40c 58ce5f874b914364a6d1a9439fe6d9e9 375cb9d1f93a43cf8a94dd5318cda40c--58ce5f874b914364a6d1a9439fe6d9e9 3171fe02448e4daf8117de5486095445 58ce5f874b914364a6d1a9439fe6d9e9--3171fe02448e4daf8117de5486095445 64f858760f2a4d6d9ab69d96ecfeefdb 3171fe02448e4daf8117de5486095445--64f858760f2a4d6d9ab69d96ecfeefdb a55d3591c1e04497a3fd99721f4e1f20 64f858760f2a4d6d9ab69d96ecfeefdb--a55d3591c1e04497a3fd99721f4e1f20 310e2e3cf21543bb839324053a8c270e a55d3591c1e04497a3fd99721f4e1f20--310e2e3cf21543bb839324053a8c270e a0d956e8572445fcb17a4984bf4c0e84 310e2e3cf21543bb839324053a8c270e--a0d956e8572445fcb17a4984bf4c0e84 091040cb74c8405581edab951ecf9dbd a0d956e8572445fcb17a4984bf4c0e84--091040cb74c8405581edab951ecf9dbd e56e3056faec42debd1576275d84e567 091040cb74c8405581edab951ecf9dbd--e56e3056faec42debd1576275d84e567 da1b20cf52db464398e39cf219b03f3b e56e3056faec42debd1576275d84e567--da1b20cf52db464398e39cf219b03f3b 6dc95fae84904900ba037fec94f91595 da1b20cf52db464398e39cf219b03f3b--6dc95fae84904900ba037fec94f91595 e522e843e2fb4f6c9298f0fe199ab196 6dc95fae84904900ba037fec94f91595--e522e843e2fb4f6c9298f0fe199ab196 83fa7cb641f44127b9a08b05e42d223f e522e843e2fb4f6c9298f0fe199ab196--83fa7cb641f44127b9a08b05e42d223f 5ac6bb62255347e2bc6f7100b69f1d78 83fa7cb641f44127b9a08b05e42d223f--5ac6bb62255347e2bc6f7100b69f1d78 5506897708fe4870b6fbcdf8aec74e7b 5ac6bb62255347e2bc6f7100b69f1d78--5506897708fe4870b6fbcdf8aec74e7b f9ac9de4d6ae4f2cbd519058e82f3dc0 5506897708fe4870b6fbcdf8aec74e7b--f9ac9de4d6ae4f2cbd519058e82f3dc0 a626f74da2be41c7b87c28c944aa0af6 f9ac9de4d6ae4f2cbd519058e82f3dc0--a626f74da2be41c7b87c28c944aa0af6 56e0afef54d6448f94a22e17ce1cbf2d a626f74da2be41c7b87c28c944aa0af6--56e0afef54d6448f94a22e17ce1cbf2d de5c4995a303420080d85140f2777133 56e0afef54d6448f94a22e17ce1cbf2d--de5c4995a303420080d85140f2777133 392c7147059840fba36e59683fa3f1af de5c4995a303420080d85140f2777133--392c7147059840fba36e59683fa3f1af 3c5a40b5879148e5bf90083a6ce91347 392c7147059840fba36e59683fa3f1af--3c5a40b5879148e5bf90083a6ce91347 1594fed0d417400eb58cb7c67140d7cd 3c5a40b5879148e5bf90083a6ce91347--1594fed0d417400eb58cb7c67140d7cd 2227a022e06d49ea80da3bd2f04264d5 1594fed0d417400eb58cb7c67140d7cd--2227a022e06d49ea80da3bd2f04264d5 96baa1a358fa401d953a9d325704b9d8 2227a022e06d49ea80da3bd2f04264d5--96baa1a358fa401d953a9d325704b9d8 cebcb64fa9734333bb1f4bfbbde2352d 96baa1a358fa401d953a9d325704b9d8--cebcb64fa9734333bb1f4bfbbde2352d fb4828bd189740dea52475789ff2e4eb cebcb64fa9734333bb1f4bfbbde2352d--fb4828bd189740dea52475789ff2e4eb 0bd5df788bfb474ab1c0b821f0ee95c2 fb4828bd189740dea52475789ff2e4eb--0bd5df788bfb474ab1c0b821f0ee95c2 dd4fae2b009b4961bfd73f154531c5fd 0bd5df788bfb474ab1c0b821f0ee95c2--dd4fae2b009b4961bfd73f154531c5fd a0bc40a6af7f4a31988dffb97e4596b3 dd4fae2b009b4961bfd73f154531c5fd--a0bc40a6af7f4a31988dffb97e4596b3 f07f4c2347804a15a145ef299c99f0f1 a0bc40a6af7f4a31988dffb97e4596b3--f07f4c2347804a15a145ef299c99f0f1 cad25190c8874974b5095d1f56b04b5d f07f4c2347804a15a145ef299c99f0f1--cad25190c8874974b5095d1f56b04b5d eab4859ccc4e437281a4b763473d0329 cad25190c8874974b5095d1f56b04b5d--eab4859ccc4e437281a4b763473d0329 9fed5de0728f4a82968376f6dfc9507f eab4859ccc4e437281a4b763473d0329--9fed5de0728f4a82968376f6dfc9507f 83aa2fcbf58647f1bd9e9130c31c6c98 9fed5de0728f4a82968376f6dfc9507f--83aa2fcbf58647f1bd9e9130c31c6c98 7269f2eeb4994624ae31761b2ade5475 83aa2fcbf58647f1bd9e9130c31c6c98--7269f2eeb4994624ae31761b2ade5475 e096ede505bc4cf18dfe2d41a1319c0e 7269f2eeb4994624ae31761b2ade5475--e096ede505bc4cf18dfe2d41a1319c0e 5aa363f39ee343459ded479461d5cee3 e096ede505bc4cf18dfe2d41a1319c0e--5aa363f39ee343459ded479461d5cee3 432c932bc24744ccafb19f2a679bbcb7 5aa363f39ee343459ded479461d5cee3--432c932bc24744ccafb19f2a679bbcb7 a325871ce83e429a880ec72f28f9205f 432c932bc24744ccafb19f2a679bbcb7--a325871ce83e429a880ec72f28f9205f d4b300b6f50a4c8cbee77b110a241194 a325871ce83e429a880ec72f28f9205f--d4b300b6f50a4c8cbee77b110a241194 b57d24eff10c44d7a8569257a05c883a d4b300b6f50a4c8cbee77b110a241194--b57d24eff10c44d7a8569257a05c883a 63d71dbfb20c4452a63c9921d4a8c84f b57d24eff10c44d7a8569257a05c883a--63d71dbfb20c4452a63c9921d4a8c84f ccbfa9de957846cdbe39b36b748fc659 63d71dbfb20c4452a63c9921d4a8c84f--ccbfa9de957846cdbe39b36b748fc659 d7570f605421425c8fef7954360cb49d RX(b01) ccbfa9de957846cdbe39b36b748fc659--d7570f605421425c8fef7954360cb49d 65bd8088cf65461d946fa5678a7177f0 X d7570f605421425c8fef7954360cb49d--65bd8088cf65461d946fa5678a7177f0 65bd8088cf65461d946fa5678a7177f0--d9d8888a48a44afe861cacc784dce352 c8437ce1b06942b291d78e99128f620b 65bd8088cf65461d946fa5678a7177f0--c8437ce1b06942b291d78e99128f620b 8c1281a015bd423b9662e921dffcf819 c8437ce1b06942b291d78e99128f620b--8c1281a015bd423b9662e921dffcf819 25127340eb834221b74701090025590f 8c1281a015bd423b9662e921dffcf819--25127340eb834221b74701090025590f a348a45b75d94cb98faa76eb80ac42e5 25127340eb834221b74701090025590f--a348a45b75d94cb98faa76eb80ac42e5 206b1f818bd448aebd353a73616ca6b9 a348a45b75d94cb98faa76eb80ac42e5--206b1f818bd448aebd353a73616ca6b9 56a2a7e6fe4e40ab946f39e84588850b 206b1f818bd448aebd353a73616ca6b9--56a2a7e6fe4e40ab946f39e84588850b 0c8dbab49172483b87d2f20b5eaa9723 56a2a7e6fe4e40ab946f39e84588850b--0c8dbab49172483b87d2f20b5eaa9723 86897291473740f0a191d9a84716286f 0c8dbab49172483b87d2f20b5eaa9723--86897291473740f0a191d9a84716286f bc05f336877e4ba6861f73149b193d4e 86897291473740f0a191d9a84716286f--bc05f336877e4ba6861f73149b193d4e e661135d04484ed6923f0d7c9d7f321e bc05f336877e4ba6861f73149b193d4e--e661135d04484ed6923f0d7c9d7f321e 1d66acbee2ae41178199f3f421b40981 e661135d04484ed6923f0d7c9d7f321e--1d66acbee2ae41178199f3f421b40981 43a974aeae834e59aa3d0d2b65029d98 1d66acbee2ae41178199f3f421b40981--43a974aeae834e59aa3d0d2b65029d98 dddc43e7e63d47c198f10ee9776cbc32 43a974aeae834e59aa3d0d2b65029d98--dddc43e7e63d47c198f10ee9776cbc32 e920a144888a4812b4aafedf44b7ee68 X dddc43e7e63d47c198f10ee9776cbc32--e920a144888a4812b4aafedf44b7ee68 e920a144888a4812b4aafedf44b7ee68--3c33e963216c4e24a885f7ff5d0ff478 bd91618a5acf459b86672db336fc35b9 X e920a144888a4812b4aafedf44b7ee68--bd91618a5acf459b86672db336fc35b9 bd91618a5acf459b86672db336fc35b9--7d392da68ade4780a7616f93c78539c8 643f6e1350544929804e5abc6075596a RZ(-1.0*g1) bd91618a5acf459b86672db336fc35b9--643f6e1350544929804e5abc6075596a 3bf6b7e7ec314a16a792f8175a118025 X 643f6e1350544929804e5abc6075596a--3bf6b7e7ec314a16a792f8175a118025 3bf6b7e7ec314a16a792f8175a118025--fac94cdaf4e844378fcee1f8aa1f6d93 4ea5e3c1a4e2420a824dfed07314ddce X 3bf6b7e7ec314a16a792f8175a118025--4ea5e3c1a4e2420a824dfed07314ddce 4ea5e3c1a4e2420a824dfed07314ddce--8c51f5f21cc4431aa68ef3e688e56b19 dee7a6583bcf4a21b8b6f6b797092280 4ea5e3c1a4e2420a824dfed07314ddce--dee7a6583bcf4a21b8b6f6b797092280 605aa59e1b964931b9693c5544f784f8 dee7a6583bcf4a21b8b6f6b797092280--605aa59e1b964931b9693c5544f784f8 cc1fcd14bb9c4069965f58386cb83134 605aa59e1b964931b9693c5544f784f8--cc1fcd14bb9c4069965f58386cb83134 ecb2c83a9d7f45be80955d0e56f7231a cc1fcd14bb9c4069965f58386cb83134--ecb2c83a9d7f45be80955d0e56f7231a 248611c940254b06a81d8d2488187359 ecb2c83a9d7f45be80955d0e56f7231a--248611c940254b06a81d8d2488187359 b7d2318cd6974d739549414ef8156da9 X 248611c940254b06a81d8d2488187359--b7d2318cd6974d739549414ef8156da9 b7d2318cd6974d739549414ef8156da9--e40fbe4e716b4dcdbb9dcc3afb5c2515 d36df35abf4a483290b2a5438cf44053 X b7d2318cd6974d739549414ef8156da9--d36df35abf4a483290b2a5438cf44053 d36df35abf4a483290b2a5438cf44053--9d6735d632bc45f3b62a3741b854f3df ce51f6e1703c482e9260994cedb1db1c d36df35abf4a483290b2a5438cf44053--ce51f6e1703c482e9260994cedb1db1c 6d2794c5b3d44b3fbedaa73111756f71 ce51f6e1703c482e9260994cedb1db1c--6d2794c5b3d44b3fbedaa73111756f71 6316299759c145b38dff1dbf493f4979 6d2794c5b3d44b3fbedaa73111756f71--6316299759c145b38dff1dbf493f4979 bdece5de87664310917658b5a20411b0 6316299759c145b38dff1dbf493f4979--bdece5de87664310917658b5a20411b0 9ef84e3ebe774b7c831c78200d0a6523 bdece5de87664310917658b5a20411b0--9ef84e3ebe774b7c831c78200d0a6523 0d73b0e365cc4ec2abb7cc4d99d6458a 9ef84e3ebe774b7c831c78200d0a6523--0d73b0e365cc4ec2abb7cc4d99d6458a 42ef82a6aa8d40a593d1c2d1484a83b0 0d73b0e365cc4ec2abb7cc4d99d6458a--42ef82a6aa8d40a593d1c2d1484a83b0 27f096b039524188b5a5423c44ffc34d X 42ef82a6aa8d40a593d1c2d1484a83b0--27f096b039524188b5a5423c44ffc34d 27f096b039524188b5a5423c44ffc34d--d0f21d2c5c57426fbbe45ed32459349f 3e1ec0e57bc84b4da14f2f9cf4876e34 X 27f096b039524188b5a5423c44ffc34d--3e1ec0e57bc84b4da14f2f9cf4876e34 3e1ec0e57bc84b4da14f2f9cf4876e34--32c5c375e6634f9abb5f7a5f113d7ac0 08ae84f008d14c9e88d41bb2a5c8ff4b 3e1ec0e57bc84b4da14f2f9cf4876e34--08ae84f008d14c9e88d41bb2a5c8ff4b 304593ac6a4b4c429a19bce8d5d28712 08ae84f008d14c9e88d41bb2a5c8ff4b--304593ac6a4b4c429a19bce8d5d28712 24364f72464446138e2f5ff74a845e45 304593ac6a4b4c429a19bce8d5d28712--24364f72464446138e2f5ff74a845e45 e14139524033445a97f31b51116b5fd7 24364f72464446138e2f5ff74a845e45--e14139524033445a97f31b51116b5fd7 895422eb7d3642b78af1c50b6190e3ab e14139524033445a97f31b51116b5fd7--895422eb7d3642b78af1c50b6190e3ab f5b6a48433154f0a94ce5de01069c96b 895422eb7d3642b78af1c50b6190e3ab--f5b6a48433154f0a94ce5de01069c96b 91cd42e116b84d7e96ce4b3498bcf24a f5b6a48433154f0a94ce5de01069c96b--91cd42e116b84d7e96ce4b3498bcf24a cb6fcd103f0b42538d548765c4e59cdb 91cd42e116b84d7e96ce4b3498bcf24a--cb6fcd103f0b42538d548765c4e59cdb 41d4b9d0b286481ea2ec8eccc04b68ae cb6fcd103f0b42538d548765c4e59cdb--41d4b9d0b286481ea2ec8eccc04b68ae 21dca2a574914e05bd7f9c10a750f3b1 41d4b9d0b286481ea2ec8eccc04b68ae--21dca2a574914e05bd7f9c10a750f3b1 64681807e70c45f99c8523dcd51eb50d 21dca2a574914e05bd7f9c10a750f3b1--64681807e70c45f99c8523dcd51eb50d f014dd551d0941fdb459a2703e748848 X 64681807e70c45f99c8523dcd51eb50d--f014dd551d0941fdb459a2703e748848 f014dd551d0941fdb459a2703e748848--722007cf737f4d2596ac9e105fd95a9a ed145bb7069b473c96f9fad74a0159d0 X f014dd551d0941fdb459a2703e748848--ed145bb7069b473c96f9fad74a0159d0 ed145bb7069b473c96f9fad74a0159d0--4c09ecceba604706afde4239b814942b d823cca906aa45f3b3dcfcd0d4fbb9b7 ed145bb7069b473c96f9fad74a0159d0--d823cca906aa45f3b3dcfcd0d4fbb9b7 b5cfb67d9ab242b0a4e4fd7c9bdb7630 d823cca906aa45f3b3dcfcd0d4fbb9b7--b5cfb67d9ab242b0a4e4fd7c9bdb7630 2613adcffa5542a288e0cffc6887fcc2 b5cfb67d9ab242b0a4e4fd7c9bdb7630--2613adcffa5542a288e0cffc6887fcc2 eca31c3b47e145a19427341fc5c3a840 2613adcffa5542a288e0cffc6887fcc2--eca31c3b47e145a19427341fc5c3a840 5c62c8d675fe4990aa87060ab06545b7 eca31c3b47e145a19427341fc5c3a840--5c62c8d675fe4990aa87060ab06545b7 ca7e069628ca4d14b1c7f6bebb5fb7fa 5c62c8d675fe4990aa87060ab06545b7--ca7e069628ca4d14b1c7f6bebb5fb7fa aa5b54e7a04142dd8aa4d5fa554ddde7 ca7e069628ca4d14b1c7f6bebb5fb7fa--aa5b54e7a04142dd8aa4d5fa554ddde7 e0686b2b17f749b1ba4b0548183a9288 aa5b54e7a04142dd8aa4d5fa554ddde7--e0686b2b17f749b1ba4b0548183a9288 c540705aff3b4bfcb0781050a91b29ce e0686b2b17f749b1ba4b0548183a9288--c540705aff3b4bfcb0781050a91b29ce 4e38018f915d49b3b3ba343baccbc1ac c540705aff3b4bfcb0781050a91b29ce--4e38018f915d49b3b3ba343baccbc1ac 22da6006a46c402ca8423665b779afa8 4e38018f915d49b3b3ba343baccbc1ac--22da6006a46c402ca8423665b779afa8 2fdc8f4a888e4fe280a567364ee92534 22da6006a46c402ca8423665b779afa8--2fdc8f4a888e4fe280a567364ee92534 3f32fc6438d84b63b43c782afad8a569 2fdc8f4a888e4fe280a567364ee92534--3f32fc6438d84b63b43c782afad8a569 188253ee281941efa821b72a982d7098 X 3f32fc6438d84b63b43c782afad8a569--188253ee281941efa821b72a982d7098 188253ee281941efa821b72a982d7098--a21ce1c3b0f04834a4be320585215ac8 f16ca48bc9c2457c9a3d374555084dfd 188253ee281941efa821b72a982d7098--f16ca48bc9c2457c9a3d374555084dfd fa94b2b3aabf4253abc6f51a4fd13d24 f16ca48bc9c2457c9a3d374555084dfd--fa94b2b3aabf4253abc6f51a4fd13d24 d10594ca31904a1186c90c83e40facc3 fa94b2b3aabf4253abc6f51a4fd13d24--d10594ca31904a1186c90c83e40facc3 b8f56ee3bc914283a6a206b85d72d19d d10594ca31904a1186c90c83e40facc3--b8f56ee3bc914283a6a206b85d72d19d 6868d1b79a644b1fb2b69e8d017b522a b8f56ee3bc914283a6a206b85d72d19d--6868d1b79a644b1fb2b69e8d017b522a a78b6b8204a744e28e84d769b6840f70 6868d1b79a644b1fb2b69e8d017b522a--a78b6b8204a744e28e84d769b6840f70 155e3ddab9764219a8e98623b6960ff4 a78b6b8204a744e28e84d769b6840f70--155e3ddab9764219a8e98623b6960ff4 f4eda35708bc4d25ab1e334cd7a99c9d 155e3ddab9764219a8e98623b6960ff4--f4eda35708bc4d25ab1e334cd7a99c9d a4a6864f705e405d999236ca63d373af f4eda35708bc4d25ab1e334cd7a99c9d--a4a6864f705e405d999236ca63d373af f3e781f98cc84aee8a7d74fad475b05e a4a6864f705e405d999236ca63d373af--f3e781f98cc84aee8a7d74fad475b05e 260ce81262a74b49acbc67ab6b71bda6 f3e781f98cc84aee8a7d74fad475b05e--260ce81262a74b49acbc67ab6b71bda6 2d2838bc5c7047cdac9d82e174dfbd19 260ce81262a74b49acbc67ab6b71bda6--2d2838bc5c7047cdac9d82e174dfbd19 c2f820df591645db8a3036b7315d4428 2d2838bc5c7047cdac9d82e174dfbd19--c2f820df591645db8a3036b7315d4428 f31daa5cbb494eafaa86e3fae336c433 c2f820df591645db8a3036b7315d4428--f31daa5cbb494eafaa86e3fae336c433 10c0520f66d04298a3cf3506d1a8fb78 f31daa5cbb494eafaa86e3fae336c433--10c0520f66d04298a3cf3506d1a8fb78 2faf8a0d319640cea7ab4f0c198db169 10c0520f66d04298a3cf3506d1a8fb78--2faf8a0d319640cea7ab4f0c198db169 e8f21e22322c4f3c8aaa591a322ef88a 2faf8a0d319640cea7ab4f0c198db169--e8f21e22322c4f3c8aaa591a322ef88a feaa69c72b9b45019a950eb057ad6aae e8f21e22322c4f3c8aaa591a322ef88a--feaa69c72b9b45019a950eb057ad6aae f5005c433c2a4e26892ade94c779d86f feaa69c72b9b45019a950eb057ad6aae--f5005c433c2a4e26892ade94c779d86f 43aea06271cf4fbfae6045eb69ba84dc f5005c433c2a4e26892ade94c779d86f--43aea06271cf4fbfae6045eb69ba84dc d792bc023a1d4e06a7d7f3dc0a74dccd 43aea06271cf4fbfae6045eb69ba84dc--d792bc023a1d4e06a7d7f3dc0a74dccd 7352f75d1bf34c209e071d2b11fa50db d792bc023a1d4e06a7d7f3dc0a74dccd--7352f75d1bf34c209e071d2b11fa50db 4beb08763df84f0a859d56dbedef7577 7352f75d1bf34c209e071d2b11fa50db--4beb08763df84f0a859d56dbedef7577 b62cafa947f64ad9a0336b26ffd3afb3 4beb08763df84f0a859d56dbedef7577--b62cafa947f64ad9a0336b26ffd3afb3 8cef0e5d9c974d7b8e1c998f4e519c8e b62cafa947f64ad9a0336b26ffd3afb3--8cef0e5d9c974d7b8e1c998f4e519c8e f4176cc9aa95494b8ac0b58bb96a4500 8cef0e5d9c974d7b8e1c998f4e519c8e--f4176cc9aa95494b8ac0b58bb96a4500 83c6da33555d48459a840d21d60b44e4 f4176cc9aa95494b8ac0b58bb96a4500--83c6da33555d48459a840d21d60b44e4 543b33a702b6492499899df0c857b4a1 83c6da33555d48459a840d21d60b44e4--543b33a702b6492499899df0c857b4a1 ab371f5a23334d7299d09e749cbd4e21 543b33a702b6492499899df0c857b4a1--ab371f5a23334d7299d09e749cbd4e21 6229f007c98f44f586ba50a96365e263 ab371f5a23334d7299d09e749cbd4e21--6229f007c98f44f586ba50a96365e263 bd7683f06eda41b6b226976fc9ac75b9 6229f007c98f44f586ba50a96365e263--bd7683f06eda41b6b226976fc9ac75b9 bf0939e907ff4b9fbaf8eea2b1402b8a bd7683f06eda41b6b226976fc9ac75b9--bf0939e907ff4b9fbaf8eea2b1402b8a 5f6f8bb19f7a4d45b2e9e2f4f103837c bf0939e907ff4b9fbaf8eea2b1402b8a--5f6f8bb19f7a4d45b2e9e2f4f103837c 39db1811251248f6836b0b3740095589 5f6f8bb19f7a4d45b2e9e2f4f103837c--39db1811251248f6836b0b3740095589 52e0867e02a24ba3b908bc205e8c798a 39db1811251248f6836b0b3740095589--52e0867e02a24ba3b908bc205e8c798a e28861e329a64b3c920779054a83577f 52e0867e02a24ba3b908bc205e8c798a--e28861e329a64b3c920779054a83577f 64535c4f9bb04a9caaf0831db1112789 e28861e329a64b3c920779054a83577f--64535c4f9bb04a9caaf0831db1112789 12a9404b25204a3f9da4766a4efc0420 64535c4f9bb04a9caaf0831db1112789--12a9404b25204a3f9da4766a4efc0420 f5b3a3f651614970b96718d0a03cb3e0 12a9404b25204a3f9da4766a4efc0420--f5b3a3f651614970b96718d0a03cb3e0 4506f5ef8d4f4f8fb019190dc32e53a2 f5b3a3f651614970b96718d0a03cb3e0--4506f5ef8d4f4f8fb019190dc32e53a2 7f4ab715cbe1481a98431d060204336f 4506f5ef8d4f4f8fb019190dc32e53a2--7f4ab715cbe1481a98431d060204336f 72ef521bec5b43658d4f9c3f6ffcae2b 7f4ab715cbe1481a98431d060204336f--72ef521bec5b43658d4f9c3f6ffcae2b 1e3eed22422a49349b3bdf0a4a36502c 72ef521bec5b43658d4f9c3f6ffcae2b--1e3eed22422a49349b3bdf0a4a36502c c9e053c561b840a9b15bcf4d2847c682 1e3eed22422a49349b3bdf0a4a36502c--c9e053c561b840a9b15bcf4d2847c682 4e619a82999841ac89a840b70e669715 c9e053c561b840a9b15bcf4d2847c682--4e619a82999841ac89a840b70e669715 df3e0908d2124a29ba6ca5c99c9a5165 4e619a82999841ac89a840b70e669715--df3e0908d2124a29ba6ca5c99c9a5165 105296511c39450799e7f8b0b19a5302 df3e0908d2124a29ba6ca5c99c9a5165--105296511c39450799e7f8b0b19a5302 3d41686469c5436eb5c9b045d721011f 105296511c39450799e7f8b0b19a5302--3d41686469c5436eb5c9b045d721011f b444ccad849144738f3ddffe98dc63cc 3d41686469c5436eb5c9b045d721011f--b444ccad849144738f3ddffe98dc63cc e9838bf470244f99a02aa6b2866e3377 b444ccad849144738f3ddffe98dc63cc--e9838bf470244f99a02aa6b2866e3377 221e5a18632a40d8987c948ced94861c e9838bf470244f99a02aa6b2866e3377--221e5a18632a40d8987c948ced94861c 0df71b9d54694701b6dd871f3b1ec173 221e5a18632a40d8987c948ced94861c--0df71b9d54694701b6dd871f3b1ec173 5e7cc17c17ff4961b1430b00e96c81e6 0df71b9d54694701b6dd871f3b1ec173--5e7cc17c17ff4961b1430b00e96c81e6 d17db9958b324db792894aa3133e57db 5e7cc17c17ff4961b1430b00e96c81e6--d17db9958b324db792894aa3133e57db 24501a82833341a4925a9f64c569ca2b d17db9958b324db792894aa3133e57db--24501a82833341a4925a9f64c569ca2b 2e0eed5716ac498db79afcb485f2b9f5 24501a82833341a4925a9f64c569ca2b--2e0eed5716ac498db79afcb485f2b9f5 c338790907044b478d0f9947df637d41 2e0eed5716ac498db79afcb485f2b9f5--c338790907044b478d0f9947df637d41 c56f849308da42179fd9bc5ef84be221 c338790907044b478d0f9947df637d41--c56f849308da42179fd9bc5ef84be221 026209f68d4447fbbdf6c41d69a2610d c56f849308da42179fd9bc5ef84be221--026209f68d4447fbbdf6c41d69a2610d 91b7ad4c1aad48f18af1544bac09e69e 026209f68d4447fbbdf6c41d69a2610d--91b7ad4c1aad48f18af1544bac09e69e df5fb2c7683c4163b765461fdd28ad00 91b7ad4c1aad48f18af1544bac09e69e--df5fb2c7683c4163b765461fdd28ad00 818f338f75fe4092a5f1a19fd79755af df5fb2c7683c4163b765461fdd28ad00--818f338f75fe4092a5f1a19fd79755af 7ab56696a49e46d1aacbdee52af2d11e 818f338f75fe4092a5f1a19fd79755af--7ab56696a49e46d1aacbdee52af2d11e 4073bbe8a8bb4732a2ac980249faa470 7ab56696a49e46d1aacbdee52af2d11e--4073bbe8a8bb4732a2ac980249faa470 173b2e62471740f1aa02beaf044c3069 4073bbe8a8bb4732a2ac980249faa470--173b2e62471740f1aa02beaf044c3069 d8192690cf894006a297698f58773e63 173b2e62471740f1aa02beaf044c3069--d8192690cf894006a297698f58773e63 e994895a20fb45c09c037901497b6c19 d8192690cf894006a297698f58773e63--e994895a20fb45c09c037901497b6c19 04a3bc6e855b4d9bab7023209890d1f2 RX(b11) e994895a20fb45c09c037901497b6c19--04a3bc6e855b4d9bab7023209890d1f2 04a3bc6e855b4d9bab7023209890d1f2--4be1682335144bf989ee5d4002e6da5a d57b4ad2f86b41979d8f0f2467b00c75 0742cea9bdef44e89ef984c897759d89 f9254232c8124e08a848e096c5554702--0742cea9bdef44e89ef984c897759d89 52a9762a778b40ed908b5367d4093cc2 3 b58be986edf24ab7a72836b6633e8e62 X 0742cea9bdef44e89ef984c897759d89--b58be986edf24ab7a72836b6633e8e62 b58be986edf24ab7a72836b6633e8e62--04716e0bd2dd444b93cd2a3b3f3d3f77 aa13b92a449a4d0899144f2a8cb0a9a5 b58be986edf24ab7a72836b6633e8e62--aa13b92a449a4d0899144f2a8cb0a9a5 a127cd05f84b44679cfd992fc0d13127 aa13b92a449a4d0899144f2a8cb0a9a5--a127cd05f84b44679cfd992fc0d13127 fe8a17a98b3645998832f569dba712de a127cd05f84b44679cfd992fc0d13127--fe8a17a98b3645998832f569dba712de bb17a9211e1046569f19a6a281198708 fe8a17a98b3645998832f569dba712de--bb17a9211e1046569f19a6a281198708 96cd29cdda4a42e38fdb8e2cc891abf9 bb17a9211e1046569f19a6a281198708--96cd29cdda4a42e38fdb8e2cc891abf9 e459093b93574c998b729ddbdb41c1a4 96cd29cdda4a42e38fdb8e2cc891abf9--e459093b93574c998b729ddbdb41c1a4 b53cf5427af04e7cab39107b7ef57814 e459093b93574c998b729ddbdb41c1a4--b53cf5427af04e7cab39107b7ef57814 a89d689479824039bea4c8022e628171 b53cf5427af04e7cab39107b7ef57814--a89d689479824039bea4c8022e628171 5fd48dcc80994af0ad8dcbca59bb25dc a89d689479824039bea4c8022e628171--5fd48dcc80994af0ad8dcbca59bb25dc 9cf7cf549bb9412ca4e730dfcc68dcfd 5fd48dcc80994af0ad8dcbca59bb25dc--9cf7cf549bb9412ca4e730dfcc68dcfd 9b1abff2580848d089ea8c5945dd1d4c 9cf7cf549bb9412ca4e730dfcc68dcfd--9b1abff2580848d089ea8c5945dd1d4c fb1444f53c31419e85e91bb5456212d8 X 9b1abff2580848d089ea8c5945dd1d4c--fb1444f53c31419e85e91bb5456212d8 fb1444f53c31419e85e91bb5456212d8--71fc9065039144869072314445cde523 58ce307ade3c4367a1a1b24637efa363 fb1444f53c31419e85e91bb5456212d8--58ce307ade3c4367a1a1b24637efa363 75239d2b216a450d9d0afab780a2bc51 58ce307ade3c4367a1a1b24637efa363--75239d2b216a450d9d0afab780a2bc51 5c0ae867a4454ac59f6f98cd0044ec65 75239d2b216a450d9d0afab780a2bc51--5c0ae867a4454ac59f6f98cd0044ec65 5059c49fd1714a67841f0cbd837940a1 5c0ae867a4454ac59f6f98cd0044ec65--5059c49fd1714a67841f0cbd837940a1 47222764193846f5af9b2cbf5e2f937f 5059c49fd1714a67841f0cbd837940a1--47222764193846f5af9b2cbf5e2f937f 564cca3037d2425cb0ffa66a38b7e94b X 47222764193846f5af9b2cbf5e2f937f--564cca3037d2425cb0ffa66a38b7e94b 564cca3037d2425cb0ffa66a38b7e94b--800c2eaa63c3482cada1511f1bc3eb01 261212aecbfd4d2db7cb03a250f9f76e 564cca3037d2425cb0ffa66a38b7e94b--261212aecbfd4d2db7cb03a250f9f76e 18e831fae29749e3b7a2d4be5a373986 261212aecbfd4d2db7cb03a250f9f76e--18e831fae29749e3b7a2d4be5a373986 6f5e15db4a844f5ebea02079fc5989d6 18e831fae29749e3b7a2d4be5a373986--6f5e15db4a844f5ebea02079fc5989d6 cb058447655a47319aee3c8829a3c9a2 X 6f5e15db4a844f5ebea02079fc5989d6--cb058447655a47319aee3c8829a3c9a2 cb058447655a47319aee3c8829a3c9a2--37617dcee03246cbbf7d5ce4e367c1e3 671c2dfc7b40454784f271242caa602c cb058447655a47319aee3c8829a3c9a2--671c2dfc7b40454784f271242caa602c be07d1b134e441fda5de55e4e33116ae 671c2dfc7b40454784f271242caa602c--be07d1b134e441fda5de55e4e33116ae fe438124c48b4a36a060310eaa0d75bb X be07d1b134e441fda5de55e4e33116ae--fe438124c48b4a36a060310eaa0d75bb fe438124c48b4a36a060310eaa0d75bb--044044484c784bebb53827342f093390 e5e0a5ffeded4b0b81e327b799d2c3f6 fe438124c48b4a36a060310eaa0d75bb--e5e0a5ffeded4b0b81e327b799d2c3f6 b8344e1e19af4765b0a49664f98e902e e5e0a5ffeded4b0b81e327b799d2c3f6--b8344e1e19af4765b0a49664f98e902e dae366f6ef8046c5b1a81afef372ff83 b8344e1e19af4765b0a49664f98e902e--dae366f6ef8046c5b1a81afef372ff83 9fbc6cd40452483fa53a8bc697098283 dae366f6ef8046c5b1a81afef372ff83--9fbc6cd40452483fa53a8bc697098283 acacb2126f63497f98c81fd39ebbc2b0 9fbc6cd40452483fa53a8bc697098283--acacb2126f63497f98c81fd39ebbc2b0 90513f4a00834744aca101e707e25e17 X acacb2126f63497f98c81fd39ebbc2b0--90513f4a00834744aca101e707e25e17 90513f4a00834744aca101e707e25e17--8461554ed014499bbcd3f94542e32930 f769d1d271b4423fafc02150610ee6a1 90513f4a00834744aca101e707e25e17--f769d1d271b4423fafc02150610ee6a1 6a84e009af6a45f49080559f2cc0fe33 f769d1d271b4423fafc02150610ee6a1--6a84e009af6a45f49080559f2cc0fe33 bb04db88081a4db1b65881500e84ea88 X 6a84e009af6a45f49080559f2cc0fe33--bb04db88081a4db1b65881500e84ea88 bb04db88081a4db1b65881500e84ea88--b21d4e02d67b442380ae29966efb39d4 e9308e92d45b44fbb1a49c8cfb7fb31a bb04db88081a4db1b65881500e84ea88--e9308e92d45b44fbb1a49c8cfb7fb31a 6b8100dc212244b1915b0a02738228da e9308e92d45b44fbb1a49c8cfb7fb31a--6b8100dc212244b1915b0a02738228da f57284bacfc74e7cbfe06b0558504f06 6b8100dc212244b1915b0a02738228da--f57284bacfc74e7cbfe06b0558504f06 7b4f8ec131324f30b0d44f0f5c088c33 f57284bacfc74e7cbfe06b0558504f06--7b4f8ec131324f30b0d44f0f5c088c33 e0ac4af74cab41a8b999ffeb80cc8faf 7b4f8ec131324f30b0d44f0f5c088c33--e0ac4af74cab41a8b999ffeb80cc8faf 96a875513b46496c921642221da4df7c e0ac4af74cab41a8b999ffeb80cc8faf--96a875513b46496c921642221da4df7c 4a95f07181f74ef2acf98074ec25793f 96a875513b46496c921642221da4df7c--4a95f07181f74ef2acf98074ec25793f c18cadaf68d44193a3579f54b4717e50 4a95f07181f74ef2acf98074ec25793f--c18cadaf68d44193a3579f54b4717e50 91895b2373ae422f902f1144b7c57e8f c18cadaf68d44193a3579f54b4717e50--91895b2373ae422f902f1144b7c57e8f 903dd56fbd1944a2bd8ce2d9b0e1cd92 X 91895b2373ae422f902f1144b7c57e8f--903dd56fbd1944a2bd8ce2d9b0e1cd92 903dd56fbd1944a2bd8ce2d9b0e1cd92--40624eb81ddd4572911c08634350be01 ed1df85022fb4f3d98718445c3123528 903dd56fbd1944a2bd8ce2d9b0e1cd92--ed1df85022fb4f3d98718445c3123528 b89e67a64b554591b5f10afd3a01a41b ed1df85022fb4f3d98718445c3123528--b89e67a64b554591b5f10afd3a01a41b ef6279ae519b4265bd5ece258761c0f1 X b89e67a64b554591b5f10afd3a01a41b--ef6279ae519b4265bd5ece258761c0f1 ef6279ae519b4265bd5ece258761c0f1--4b3c4c62ba2d47afa6cfe695c6e24306 9c7233fcc0134f698b5dcb94bf46d1f1 ef6279ae519b4265bd5ece258761c0f1--9c7233fcc0134f698b5dcb94bf46d1f1 1997f25eb14b47cda5370da186bbf87f 9c7233fcc0134f698b5dcb94bf46d1f1--1997f25eb14b47cda5370da186bbf87f 721ff0983ec24cf49aab2b903c1e55a8 1997f25eb14b47cda5370da186bbf87f--721ff0983ec24cf49aab2b903c1e55a8 e1b685ee5b5d47979820c82d3fe9248e 721ff0983ec24cf49aab2b903c1e55a8--e1b685ee5b5d47979820c82d3fe9248e 0b41d41ce7614b7fbae3a393b6eb75c6 e1b685ee5b5d47979820c82d3fe9248e--0b41d41ce7614b7fbae3a393b6eb75c6 33b7c5446a9140f4b2f6fa15e5cd271d 0b41d41ce7614b7fbae3a393b6eb75c6--33b7c5446a9140f4b2f6fa15e5cd271d ad8c3953c71448ec872cb24d326c678a 33b7c5446a9140f4b2f6fa15e5cd271d--ad8c3953c71448ec872cb24d326c678a 61bcc4c4cff4493e888af445ed979b70 ad8c3953c71448ec872cb24d326c678a--61bcc4c4cff4493e888af445ed979b70 b9fde029568542b1b502d090118da197 61bcc4c4cff4493e888af445ed979b70--b9fde029568542b1b502d090118da197 b1d94e3f67554a54845f8d64d8c6c51a b9fde029568542b1b502d090118da197--b1d94e3f67554a54845f8d64d8c6c51a 10c95a6c905f4531aed977a5aa69296a b1d94e3f67554a54845f8d64d8c6c51a--10c95a6c905f4531aed977a5aa69296a f5dce1b211034f1b926522781a32dc28 X 10c95a6c905f4531aed977a5aa69296a--f5dce1b211034f1b926522781a32dc28 f5dce1b211034f1b926522781a32dc28--559f0cddeb94409595b899d3a20644be f0cc4ad555e94ec3b813b41318232c0e f5dce1b211034f1b926522781a32dc28--f0cc4ad555e94ec3b813b41318232c0e 042a0cdca7114783b39059e1bef00a11 X f0cc4ad555e94ec3b813b41318232c0e--042a0cdca7114783b39059e1bef00a11 042a0cdca7114783b39059e1bef00a11--4304121c76cf41fd9fffeeb14762e8c5 f571fdf2e49347478997d4ebf1c6566a RZ(-1.0*g0) 042a0cdca7114783b39059e1bef00a11--f571fdf2e49347478997d4ebf1c6566a b253586d71be4a8ca2bb2ce823282435 X f571fdf2e49347478997d4ebf1c6566a--b253586d71be4a8ca2bb2ce823282435 b253586d71be4a8ca2bb2ce823282435--897de562bf694eb4bd6226463bfd587f 3003dd54e1c7402f864a630f3b63041b X b253586d71be4a8ca2bb2ce823282435--3003dd54e1c7402f864a630f3b63041b 3003dd54e1c7402f864a630f3b63041b--ddd6401f2d20498f8faf72b8fb044025 ee147a43677448a89a6dfd835bfce3db 3003dd54e1c7402f864a630f3b63041b--ee147a43677448a89a6dfd835bfce3db 461c8693fc424d02b2a7905cf5166c45 ee147a43677448a89a6dfd835bfce3db--461c8693fc424d02b2a7905cf5166c45 cff7725d847b4467806ffc18cca97856 461c8693fc424d02b2a7905cf5166c45--cff7725d847b4467806ffc18cca97856 ee719006dd8b493483afb77dd6b34d3d cff7725d847b4467806ffc18cca97856--ee719006dd8b493483afb77dd6b34d3d 6909b9ce700441e99f3e8473b8e7d86b ee719006dd8b493483afb77dd6b34d3d--6909b9ce700441e99f3e8473b8e7d86b d3c9d6b511c645a19fab0b0231aa4c06 6909b9ce700441e99f3e8473b8e7d86b--d3c9d6b511c645a19fab0b0231aa4c06 8d7dc129910d4b46ba013cb002de797e d3c9d6b511c645a19fab0b0231aa4c06--8d7dc129910d4b46ba013cb002de797e 7678748d9497458ba7f3fc6e445690e1 X 8d7dc129910d4b46ba013cb002de797e--7678748d9497458ba7f3fc6e445690e1 7678748d9497458ba7f3fc6e445690e1--53e7053c625b43c591a92767a944d372 9d345798ff2d43f08dfcd65d00722a85 7678748d9497458ba7f3fc6e445690e1--9d345798ff2d43f08dfcd65d00722a85 83205fd3ec0145a492d5cfdee4d828e2 9d345798ff2d43f08dfcd65d00722a85--83205fd3ec0145a492d5cfdee4d828e2 704e33053d2440caa2ca681c8d5ca2ae 83205fd3ec0145a492d5cfdee4d828e2--704e33053d2440caa2ca681c8d5ca2ae a8e2c1cdabb04edc8f1283cdfc0d3bf3 704e33053d2440caa2ca681c8d5ca2ae--a8e2c1cdabb04edc8f1283cdfc0d3bf3 f74fb5f323714745ae67bfb648b927ca a8e2c1cdabb04edc8f1283cdfc0d3bf3--f74fb5f323714745ae67bfb648b927ca 7601a602829a41c79ba25692dd30de97 f74fb5f323714745ae67bfb648b927ca--7601a602829a41c79ba25692dd30de97 2bbe74f1ded9463ea8a1331c6495cbd4 7601a602829a41c79ba25692dd30de97--2bbe74f1ded9463ea8a1331c6495cbd4 9ceca6d4a7bf4236aacd0fea562ca2fc 2bbe74f1ded9463ea8a1331c6495cbd4--9ceca6d4a7bf4236aacd0fea562ca2fc f40394241fd042aba6d86652b46f8ac4 9ceca6d4a7bf4236aacd0fea562ca2fc--f40394241fd042aba6d86652b46f8ac4 a622ad5d916e40c2a1ed903b0184f6c1 f40394241fd042aba6d86652b46f8ac4--a622ad5d916e40c2a1ed903b0184f6c1 bfd7bdd900e545989708b30008fc60cf a622ad5d916e40c2a1ed903b0184f6c1--bfd7bdd900e545989708b30008fc60cf a32bf39208ab4af383f569a5a9ece42a bfd7bdd900e545989708b30008fc60cf--a32bf39208ab4af383f569a5a9ece42a add760df1bcf4db8956e16957d301c7d a32bf39208ab4af383f569a5a9ece42a--add760df1bcf4db8956e16957d301c7d be2b4302bc2447878414279ac231e628 add760df1bcf4db8956e16957d301c7d--be2b4302bc2447878414279ac231e628 e4947b57902a47829cec40d1fd91b84a be2b4302bc2447878414279ac231e628--e4947b57902a47829cec40d1fd91b84a f78b509c74ff46aea49c0dcc75993938 e4947b57902a47829cec40d1fd91b84a--f78b509c74ff46aea49c0dcc75993938 6327ce1986594cfaa882af192bd876f5 f78b509c74ff46aea49c0dcc75993938--6327ce1986594cfaa882af192bd876f5 ac3fb6ce36b64b23963f0f3dda4495bc 6327ce1986594cfaa882af192bd876f5--ac3fb6ce36b64b23963f0f3dda4495bc b927f881d96b41c1b6c8128e2c40737d ac3fb6ce36b64b23963f0f3dda4495bc--b927f881d96b41c1b6c8128e2c40737d b71104b5fadb4b3e9f6fe51acef69a64 b927f881d96b41c1b6c8128e2c40737d--b71104b5fadb4b3e9f6fe51acef69a64 0aa8959142584f97a0a65155d8131c4d b71104b5fadb4b3e9f6fe51acef69a64--0aa8959142584f97a0a65155d8131c4d e14b8ef737b44d01a91288520dd90e78 0aa8959142584f97a0a65155d8131c4d--e14b8ef737b44d01a91288520dd90e78 ffa2201c02d843a5b7a51ae5399128a4 e14b8ef737b44d01a91288520dd90e78--ffa2201c02d843a5b7a51ae5399128a4 f5b55a1134714d34b97b65afde063eba ffa2201c02d843a5b7a51ae5399128a4--f5b55a1134714d34b97b65afde063eba 175ab93c9d1040299f5e6308862ce125 f5b55a1134714d34b97b65afde063eba--175ab93c9d1040299f5e6308862ce125 a098fa0cd05140babc56d8a77f3d056b 175ab93c9d1040299f5e6308862ce125--a098fa0cd05140babc56d8a77f3d056b 5486906abdbb4590b170533f3f10b2db a098fa0cd05140babc56d8a77f3d056b--5486906abdbb4590b170533f3f10b2db dfc8aceedec74f499b99f5c077746da6 5486906abdbb4590b170533f3f10b2db--dfc8aceedec74f499b99f5c077746da6 fb9d3c1f6ad349d6b0e998ee9a3dd1d7 dfc8aceedec74f499b99f5c077746da6--fb9d3c1f6ad349d6b0e998ee9a3dd1d7 1ac9e9662335460888dbdda452318504 fb9d3c1f6ad349d6b0e998ee9a3dd1d7--1ac9e9662335460888dbdda452318504 ef42ad4392d645939e6d7851af3b1f7c 1ac9e9662335460888dbdda452318504--ef42ad4392d645939e6d7851af3b1f7c 5daf4362780f447687775a331159d5ae ef42ad4392d645939e6d7851af3b1f7c--5daf4362780f447687775a331159d5ae e2f5db72758d45bb882c4c0f34296976 5daf4362780f447687775a331159d5ae--e2f5db72758d45bb882c4c0f34296976 4c7141bbccc244c1b1436e4a196bc60a e2f5db72758d45bb882c4c0f34296976--4c7141bbccc244c1b1436e4a196bc60a 1a7b6e6cfaf0416794986243c1481720 4c7141bbccc244c1b1436e4a196bc60a--1a7b6e6cfaf0416794986243c1481720 3b8c22860334441482e6e71233b3dcb0 1a7b6e6cfaf0416794986243c1481720--3b8c22860334441482e6e71233b3dcb0 f47813afe8324c91a43196323e356872 3b8c22860334441482e6e71233b3dcb0--f47813afe8324c91a43196323e356872 1dea5b14979544839f9c007dedc49a6c f47813afe8324c91a43196323e356872--1dea5b14979544839f9c007dedc49a6c 00f3d6a906354befbc4b79fc4235704f 1dea5b14979544839f9c007dedc49a6c--00f3d6a906354befbc4b79fc4235704f 45e6e3a8f5394d10b9969aea70e113f4 00f3d6a906354befbc4b79fc4235704f--45e6e3a8f5394d10b9969aea70e113f4 25f2f12e94b54247a97d0f7d74b3bfeb 45e6e3a8f5394d10b9969aea70e113f4--25f2f12e94b54247a97d0f7d74b3bfeb b5b1ca077acf4e509259624f3f82bf2d 25f2f12e94b54247a97d0f7d74b3bfeb--b5b1ca077acf4e509259624f3f82bf2d 67c86b97a0d848149732ef261e5119d4 b5b1ca077acf4e509259624f3f82bf2d--67c86b97a0d848149732ef261e5119d4 22e62bdec88842c78af0d0c7cc68f4f5 67c86b97a0d848149732ef261e5119d4--22e62bdec88842c78af0d0c7cc68f4f5 d26006244fa64ddb9465d98a87f76387 22e62bdec88842c78af0d0c7cc68f4f5--d26006244fa64ddb9465d98a87f76387 843f3d8983d74547b1cee83f342fd5a4 d26006244fa64ddb9465d98a87f76387--843f3d8983d74547b1cee83f342fd5a4 df48a57d8b7241d19b6abc9e89d925a3 843f3d8983d74547b1cee83f342fd5a4--df48a57d8b7241d19b6abc9e89d925a3 92239426b13a41eda7ddebb4c42df790 df48a57d8b7241d19b6abc9e89d925a3--92239426b13a41eda7ddebb4c42df790 f885f37bde03441d8f6355b584b3c08b 92239426b13a41eda7ddebb4c42df790--f885f37bde03441d8f6355b584b3c08b 63fbca57334e4e65bbb003ad2bfaed46 f885f37bde03441d8f6355b584b3c08b--63fbca57334e4e65bbb003ad2bfaed46 77923dd08eb44c55b3cac3bc907b7c45 63fbca57334e4e65bbb003ad2bfaed46--77923dd08eb44c55b3cac3bc907b7c45 b191cfe3f2884426b2824f2f958337ea 77923dd08eb44c55b3cac3bc907b7c45--b191cfe3f2884426b2824f2f958337ea 6114dc0324c74e24aab449725c94da04 b191cfe3f2884426b2824f2f958337ea--6114dc0324c74e24aab449725c94da04 4aa5e221082743508ebea9cd0d2e8206 6114dc0324c74e24aab449725c94da04--4aa5e221082743508ebea9cd0d2e8206 4ac638d442eb4285bfcb1dad4b0fc91a 4aa5e221082743508ebea9cd0d2e8206--4ac638d442eb4285bfcb1dad4b0fc91a d8b6db53abcf419f95459b8c822273b2 RX(b02) 4ac638d442eb4285bfcb1dad4b0fc91a--d8b6db53abcf419f95459b8c822273b2 b2c69406df834c0a9dbb207e08d28d33 d8b6db53abcf419f95459b8c822273b2--b2c69406df834c0a9dbb207e08d28d33 0c23aa96b90b4b7ea4eac104b2b63c45 X b2c69406df834c0a9dbb207e08d28d33--0c23aa96b90b4b7ea4eac104b2b63c45 0c23aa96b90b4b7ea4eac104b2b63c45--c8437ce1b06942b291d78e99128f620b 9e9dde8793f7465abf6bd97a2bb03952 0c23aa96b90b4b7ea4eac104b2b63c45--9e9dde8793f7465abf6bd97a2bb03952 849fce05420b45ef90e7888998371ba4 9e9dde8793f7465abf6bd97a2bb03952--849fce05420b45ef90e7888998371ba4 667acba630134bae8a2ea2af7c5f3c50 849fce05420b45ef90e7888998371ba4--667acba630134bae8a2ea2af7c5f3c50 423e28dfab6c43e29775390b43f30695 667acba630134bae8a2ea2af7c5f3c50--423e28dfab6c43e29775390b43f30695 83e98a13dc5d4f69866f7322b42180bb 423e28dfab6c43e29775390b43f30695--83e98a13dc5d4f69866f7322b42180bb 5f8eb0f4964149aab76697f6b341a899 83e98a13dc5d4f69866f7322b42180bb--5f8eb0f4964149aab76697f6b341a899 81e3bb77659d448da9c7da7fa4624180 5f8eb0f4964149aab76697f6b341a899--81e3bb77659d448da9c7da7fa4624180 f229aa6ff3e344c0aec13f02de919dd3 81e3bb77659d448da9c7da7fa4624180--f229aa6ff3e344c0aec13f02de919dd3 34ffe44109f849e09bb2b7f4d66dccbe f229aa6ff3e344c0aec13f02de919dd3--34ffe44109f849e09bb2b7f4d66dccbe a8694b7fd14c4b99ab41d8c0517e5ebb 34ffe44109f849e09bb2b7f4d66dccbe--a8694b7fd14c4b99ab41d8c0517e5ebb dbd674b2ee504b99aa34cb5328725071 a8694b7fd14c4b99ab41d8c0517e5ebb--dbd674b2ee504b99aa34cb5328725071 84bd1afcb7b94a9e8e729acdc671680b X dbd674b2ee504b99aa34cb5328725071--84bd1afcb7b94a9e8e729acdc671680b 84bd1afcb7b94a9e8e729acdc671680b--dddc43e7e63d47c198f10ee9776cbc32 0c6d571f4afb4c39aa8225009fd744a5 84bd1afcb7b94a9e8e729acdc671680b--0c6d571f4afb4c39aa8225009fd744a5 43be0bd790264490a7ab600d935e93bd 0c6d571f4afb4c39aa8225009fd744a5--43be0bd790264490a7ab600d935e93bd a056dea756064a388b49edacaea90900 43be0bd790264490a7ab600d935e93bd--a056dea756064a388b49edacaea90900 97c6f0a5c1f54475a4aa1748944a146c a056dea756064a388b49edacaea90900--97c6f0a5c1f54475a4aa1748944a146c ae425f40bb6f4025b38f49fe28ec764b 97c6f0a5c1f54475a4aa1748944a146c--ae425f40bb6f4025b38f49fe28ec764b 3ca6d200b89245f2b8db398aefa2c4fc X ae425f40bb6f4025b38f49fe28ec764b--3ca6d200b89245f2b8db398aefa2c4fc 3ca6d200b89245f2b8db398aefa2c4fc--dee7a6583bcf4a21b8b6f6b797092280 8f4d71ad7c664702a51318a14e698ec5 3ca6d200b89245f2b8db398aefa2c4fc--8f4d71ad7c664702a51318a14e698ec5 886b7d84c619468e833b937e37527672 8f4d71ad7c664702a51318a14e698ec5--886b7d84c619468e833b937e37527672 af334f25aca744ce9629f7e4d1ba8d6c 886b7d84c619468e833b937e37527672--af334f25aca744ce9629f7e4d1ba8d6c 2d4442bcda8a445fa7d2f24258765307 X af334f25aca744ce9629f7e4d1ba8d6c--2d4442bcda8a445fa7d2f24258765307 2d4442bcda8a445fa7d2f24258765307--248611c940254b06a81d8d2488187359 61f315f7c5474ccd8f0ca2e78952cc25 2d4442bcda8a445fa7d2f24258765307--61f315f7c5474ccd8f0ca2e78952cc25 4aab6c84fa654c80a0a9a2208a48e30e 61f315f7c5474ccd8f0ca2e78952cc25--4aab6c84fa654c80a0a9a2208a48e30e 625d82c21c294b82ab2482efb549426d X 4aab6c84fa654c80a0a9a2208a48e30e--625d82c21c294b82ab2482efb549426d 625d82c21c294b82ab2482efb549426d--ce51f6e1703c482e9260994cedb1db1c 292ac8eb96954388875126bf3c68a0cb 625d82c21c294b82ab2482efb549426d--292ac8eb96954388875126bf3c68a0cb 86bb84e3459b4d20ace1b627983c975d 292ac8eb96954388875126bf3c68a0cb--86bb84e3459b4d20ace1b627983c975d 2fab6f25b2644801bba81cb1f4a93ac2 86bb84e3459b4d20ace1b627983c975d--2fab6f25b2644801bba81cb1f4a93ac2 38c7b57a7b0c49b4aa4ec4fbde396b20 2fab6f25b2644801bba81cb1f4a93ac2--38c7b57a7b0c49b4aa4ec4fbde396b20 efb26ec7b69b42c89d97db39bf44428b 38c7b57a7b0c49b4aa4ec4fbde396b20--efb26ec7b69b42c89d97db39bf44428b 4572bfff5bfd47c5a97f08d83f9455e3 X efb26ec7b69b42c89d97db39bf44428b--4572bfff5bfd47c5a97f08d83f9455e3 4572bfff5bfd47c5a97f08d83f9455e3--42ef82a6aa8d40a593d1c2d1484a83b0 d07707bc685040d1a3beb9fe0d7fb5bc 4572bfff5bfd47c5a97f08d83f9455e3--d07707bc685040d1a3beb9fe0d7fb5bc 1aa1be983be045e4b328291bd200d8ce d07707bc685040d1a3beb9fe0d7fb5bc--1aa1be983be045e4b328291bd200d8ce 204b3b063243408f962f71ba2599f61a X 1aa1be983be045e4b328291bd200d8ce--204b3b063243408f962f71ba2599f61a 204b3b063243408f962f71ba2599f61a--08ae84f008d14c9e88d41bb2a5c8ff4b dd80545e2e99493cb88984d2f16169b2 204b3b063243408f962f71ba2599f61a--dd80545e2e99493cb88984d2f16169b2 6fd1141abd1f4c058915821c5ecd6f3f dd80545e2e99493cb88984d2f16169b2--6fd1141abd1f4c058915821c5ecd6f3f bf11e8b0a1f54996b61325364eeb8967 6fd1141abd1f4c058915821c5ecd6f3f--bf11e8b0a1f54996b61325364eeb8967 b51e55abd43e477db4ff6e763116f027 bf11e8b0a1f54996b61325364eeb8967--b51e55abd43e477db4ff6e763116f027 f1ee96aa72ed403cbc5853c4066992ac b51e55abd43e477db4ff6e763116f027--f1ee96aa72ed403cbc5853c4066992ac 29d7c318c5f34bc2947bf321b823ed48 f1ee96aa72ed403cbc5853c4066992ac--29d7c318c5f34bc2947bf321b823ed48 b5422c544fb3477da28803b52f410716 29d7c318c5f34bc2947bf321b823ed48--b5422c544fb3477da28803b52f410716 19e8ddcaaa584b6993f2a56f9bfaf1a2 b5422c544fb3477da28803b52f410716--19e8ddcaaa584b6993f2a56f9bfaf1a2 43e0d61bd2cd4e8a8c9c94fb1027adb4 19e8ddcaaa584b6993f2a56f9bfaf1a2--43e0d61bd2cd4e8a8c9c94fb1027adb4 1e4f85eec559454687db3619256851e8 X 43e0d61bd2cd4e8a8c9c94fb1027adb4--1e4f85eec559454687db3619256851e8 1e4f85eec559454687db3619256851e8--64681807e70c45f99c8523dcd51eb50d 3ada4609b37b41ee9c9995e820210f7f 1e4f85eec559454687db3619256851e8--3ada4609b37b41ee9c9995e820210f7f 0bedfed1d71e4add9a8974927f11a5c9 3ada4609b37b41ee9c9995e820210f7f--0bedfed1d71e4add9a8974927f11a5c9 ee9322393ea44938ab0778ddda97002e X 0bedfed1d71e4add9a8974927f11a5c9--ee9322393ea44938ab0778ddda97002e ee9322393ea44938ab0778ddda97002e--d823cca906aa45f3b3dcfcd0d4fbb9b7 ea2ac0b07bdc47cc9319cd4b4f748447 ee9322393ea44938ab0778ddda97002e--ea2ac0b07bdc47cc9319cd4b4f748447 48ecadd464034910861b89add8817100 ea2ac0b07bdc47cc9319cd4b4f748447--48ecadd464034910861b89add8817100 69146feb6ff24fa38860c980be1ce578 48ecadd464034910861b89add8817100--69146feb6ff24fa38860c980be1ce578 86f79024b12b4a5496660382a11889d4 69146feb6ff24fa38860c980be1ce578--86f79024b12b4a5496660382a11889d4 b5459fbe31794c0e82a225a411889d26 86f79024b12b4a5496660382a11889d4--b5459fbe31794c0e82a225a411889d26 a4ac07dc3a82429383b8cd050e1bf154 b5459fbe31794c0e82a225a411889d26--a4ac07dc3a82429383b8cd050e1bf154 71c2fe33bbf94e8cb62e61a43e3096ce a4ac07dc3a82429383b8cd050e1bf154--71c2fe33bbf94e8cb62e61a43e3096ce 570f4becea464ab589fc603fb9e2da1c 71c2fe33bbf94e8cb62e61a43e3096ce--570f4becea464ab589fc603fb9e2da1c 34913e9bc8e24bd5adf81aaf4cba8abe 570f4becea464ab589fc603fb9e2da1c--34913e9bc8e24bd5adf81aaf4cba8abe df05be156cd24b99a867999d02d153d7 34913e9bc8e24bd5adf81aaf4cba8abe--df05be156cd24b99a867999d02d153d7 54d047a2acaa4e9da4f246e4394b9d25 df05be156cd24b99a867999d02d153d7--54d047a2acaa4e9da4f246e4394b9d25 79b0dcfae4a448a89c4b67669f850a4b X 54d047a2acaa4e9da4f246e4394b9d25--79b0dcfae4a448a89c4b67669f850a4b 79b0dcfae4a448a89c4b67669f850a4b--3f32fc6438d84b63b43c782afad8a569 f8ca9ff341db40f48b27167becb7cf7e 79b0dcfae4a448a89c4b67669f850a4b--f8ca9ff341db40f48b27167becb7cf7e 704c1c4aae5e492cbb4822962320a6e7 X f8ca9ff341db40f48b27167becb7cf7e--704c1c4aae5e492cbb4822962320a6e7 704c1c4aae5e492cbb4822962320a6e7--f16ca48bc9c2457c9a3d374555084dfd 4f3e2d43b4da45bfa4978f7343a607de RZ(-1.0*g1) 704c1c4aae5e492cbb4822962320a6e7--4f3e2d43b4da45bfa4978f7343a607de 26529fd9dd574830a72b4c69f3f00864 X 4f3e2d43b4da45bfa4978f7343a607de--26529fd9dd574830a72b4c69f3f00864 26529fd9dd574830a72b4c69f3f00864--d10594ca31904a1186c90c83e40facc3 e7ff4bcc40974a0694ce8c39e95903cb X 26529fd9dd574830a72b4c69f3f00864--e7ff4bcc40974a0694ce8c39e95903cb e7ff4bcc40974a0694ce8c39e95903cb--b8f56ee3bc914283a6a206b85d72d19d ce91de0851e34ff588c89c39cf3e6f23 e7ff4bcc40974a0694ce8c39e95903cb--ce91de0851e34ff588c89c39cf3e6f23 d7754e2fefd24fc78c31905fdb75a4b2 ce91de0851e34ff588c89c39cf3e6f23--d7754e2fefd24fc78c31905fdb75a4b2 c335fd6def3048dd98f16310685bbf3d d7754e2fefd24fc78c31905fdb75a4b2--c335fd6def3048dd98f16310685bbf3d 44c954c47ff0410e930b1fa98f0a6af6 c335fd6def3048dd98f16310685bbf3d--44c954c47ff0410e930b1fa98f0a6af6 35e28e9d20564f668ffc088861d07e7e 44c954c47ff0410e930b1fa98f0a6af6--35e28e9d20564f668ffc088861d07e7e 085002656d62499c989f13f1e9182ba4 35e28e9d20564f668ffc088861d07e7e--085002656d62499c989f13f1e9182ba4 8d71f7b82b1d46a8bb24f517c3f3f3fb 085002656d62499c989f13f1e9182ba4--8d71f7b82b1d46a8bb24f517c3f3f3fb 0f628962bab6421696a2b283434d794f X 8d71f7b82b1d46a8bb24f517c3f3f3fb--0f628962bab6421696a2b283434d794f 0f628962bab6421696a2b283434d794f--2d2838bc5c7047cdac9d82e174dfbd19 bbef18314bc24d44b85a973f3b4aa8cd 0f628962bab6421696a2b283434d794f--bbef18314bc24d44b85a973f3b4aa8cd ed268f1179144d40be0a64f3764f6e8d bbef18314bc24d44b85a973f3b4aa8cd--ed268f1179144d40be0a64f3764f6e8d 14ed031e99e6492d94b538d67d7dcc09 ed268f1179144d40be0a64f3764f6e8d--14ed031e99e6492d94b538d67d7dcc09 8045478d478b4b8d9974178f3f6f3ffd 14ed031e99e6492d94b538d67d7dcc09--8045478d478b4b8d9974178f3f6f3ffd 7132d3892cd4433996e31eeea9ad184c 8045478d478b4b8d9974178f3f6f3ffd--7132d3892cd4433996e31eeea9ad184c 0ed0f75f425d4b768e2f93432a421931 7132d3892cd4433996e31eeea9ad184c--0ed0f75f425d4b768e2f93432a421931 40ca6eda86fe4ce5bf116e4ef2085e28 0ed0f75f425d4b768e2f93432a421931--40ca6eda86fe4ce5bf116e4ef2085e28 5e1c85654d9449a3add07fe202ba3bb7 40ca6eda86fe4ce5bf116e4ef2085e28--5e1c85654d9449a3add07fe202ba3bb7 da51c30119884c90b0de4c9afc910a9c 5e1c85654d9449a3add07fe202ba3bb7--da51c30119884c90b0de4c9afc910a9c 7df81f100d714d198fb0c71235fbb553 da51c30119884c90b0de4c9afc910a9c--7df81f100d714d198fb0c71235fbb553 8a56e8b6a0d24905a972b9febf4a2c24 7df81f100d714d198fb0c71235fbb553--8a56e8b6a0d24905a972b9febf4a2c24 4a592a5053c94ea892138066e39e666d 8a56e8b6a0d24905a972b9febf4a2c24--4a592a5053c94ea892138066e39e666d 28aead53cce540f7902210b69e62c330 4a592a5053c94ea892138066e39e666d--28aead53cce540f7902210b69e62c330 2b10f3af034e411690f998a5d37516a2 28aead53cce540f7902210b69e62c330--2b10f3af034e411690f998a5d37516a2 8167f6c1ae404c9881427414fab32a68 2b10f3af034e411690f998a5d37516a2--8167f6c1ae404c9881427414fab32a68 ff5b2b12595346db967caf9b8ebf4e0c 8167f6c1ae404c9881427414fab32a68--ff5b2b12595346db967caf9b8ebf4e0c 34d949afb23c42be883f977b4df3e2a3 ff5b2b12595346db967caf9b8ebf4e0c--34d949afb23c42be883f977b4df3e2a3 60f2a9ac10334ff0b54cb622fbbd11ba 34d949afb23c42be883f977b4df3e2a3--60f2a9ac10334ff0b54cb622fbbd11ba 330215c2bdd74b8c88b37c1bb496b9d2 60f2a9ac10334ff0b54cb622fbbd11ba--330215c2bdd74b8c88b37c1bb496b9d2 631117da19044c7a8591fa9f021c72e2 330215c2bdd74b8c88b37c1bb496b9d2--631117da19044c7a8591fa9f021c72e2 e25c696fb37f4092beb8635f2a7fe1a2 631117da19044c7a8591fa9f021c72e2--e25c696fb37f4092beb8635f2a7fe1a2 fc90093a1d7948c4a530f1acbde12f2a e25c696fb37f4092beb8635f2a7fe1a2--fc90093a1d7948c4a530f1acbde12f2a f8b1950353c24e3493b59d824b5b215c fc90093a1d7948c4a530f1acbde12f2a--f8b1950353c24e3493b59d824b5b215c 2d9185fe42ae4edc8c619dbda0cccaf3 f8b1950353c24e3493b59d824b5b215c--2d9185fe42ae4edc8c619dbda0cccaf3 0886657320c543f9b4da2b585d73e4a9 2d9185fe42ae4edc8c619dbda0cccaf3--0886657320c543f9b4da2b585d73e4a9 14ff48e74ea4422786f1810ab385426d 0886657320c543f9b4da2b585d73e4a9--14ff48e74ea4422786f1810ab385426d dfe84906ff864903a72d044c984794a7 14ff48e74ea4422786f1810ab385426d--dfe84906ff864903a72d044c984794a7 3a9d609221a44766aeb182a8f69edfda dfe84906ff864903a72d044c984794a7--3a9d609221a44766aeb182a8f69edfda d6f28eca7e684cba97ad0e2826a7fb06 3a9d609221a44766aeb182a8f69edfda--d6f28eca7e684cba97ad0e2826a7fb06 1926d40a826646f596238ab4a5f3e0fa d6f28eca7e684cba97ad0e2826a7fb06--1926d40a826646f596238ab4a5f3e0fa 979f31b103144439aa5dc9e77e9a6d27 1926d40a826646f596238ab4a5f3e0fa--979f31b103144439aa5dc9e77e9a6d27 c6416f708d5e4a6a8c65551f26d5d001 979f31b103144439aa5dc9e77e9a6d27--c6416f708d5e4a6a8c65551f26d5d001 f90fe114b1704c46b06c28e8562c39d5 c6416f708d5e4a6a8c65551f26d5d001--f90fe114b1704c46b06c28e8562c39d5 f525c8476415482f8c298bcf6797970b f90fe114b1704c46b06c28e8562c39d5--f525c8476415482f8c298bcf6797970b 67499095dbff4f5fbdb6ab419ef249e1 f525c8476415482f8c298bcf6797970b--67499095dbff4f5fbdb6ab419ef249e1 71a8cde9d9ae43cd8f9fc15aa31c4ef3 67499095dbff4f5fbdb6ab419ef249e1--71a8cde9d9ae43cd8f9fc15aa31c4ef3 19796d1e901348f8a150b72b9798d240 71a8cde9d9ae43cd8f9fc15aa31c4ef3--19796d1e901348f8a150b72b9798d240 bf42f60c79974393a8e3f04d49c0f06f 19796d1e901348f8a150b72b9798d240--bf42f60c79974393a8e3f04d49c0f06f 3f27582c7fe047f4b457fbcfde0e6865 bf42f60c79974393a8e3f04d49c0f06f--3f27582c7fe047f4b457fbcfde0e6865 74824168339c403299f166c3c148c628 3f27582c7fe047f4b457fbcfde0e6865--74824168339c403299f166c3c148c628 a485b8dd72ff4aae8ccbd70da3f8f91b 74824168339c403299f166c3c148c628--a485b8dd72ff4aae8ccbd70da3f8f91b 0ec9862e47e341b48325a889086e5cf2 a485b8dd72ff4aae8ccbd70da3f8f91b--0ec9862e47e341b48325a889086e5cf2 588091dcc32a40b4beef0b4e94f15adf 0ec9862e47e341b48325a889086e5cf2--588091dcc32a40b4beef0b4e94f15adf 10b1abbd81074523b3b22da3e68fbe00 588091dcc32a40b4beef0b4e94f15adf--10b1abbd81074523b3b22da3e68fbe00 97bf9de387104ee9adec3261e12319a4 10b1abbd81074523b3b22da3e68fbe00--97bf9de387104ee9adec3261e12319a4 021f6ea3b55242fe92410a6904453d46 97bf9de387104ee9adec3261e12319a4--021f6ea3b55242fe92410a6904453d46 f4b7ac52f66a44248ec90289930da488 021f6ea3b55242fe92410a6904453d46--f4b7ac52f66a44248ec90289930da488 203118c3541c41a7b684129a9026fbdc f4b7ac52f66a44248ec90289930da488--203118c3541c41a7b684129a9026fbdc 1ce105621af44702814d80e03434e051 203118c3541c41a7b684129a9026fbdc--1ce105621af44702814d80e03434e051 3785c03e0d684997af932c7ad5325604 1ce105621af44702814d80e03434e051--3785c03e0d684997af932c7ad5325604 02fd9afad4a04a079094aca9c38fa10c 3785c03e0d684997af932c7ad5325604--02fd9afad4a04a079094aca9c38fa10c ab2e7424eb4743568550516a1897e976 02fd9afad4a04a079094aca9c38fa10c--ab2e7424eb4743568550516a1897e976 00877f819af9464e98662007a4c012e1 ab2e7424eb4743568550516a1897e976--00877f819af9464e98662007a4c012e1 42537d78ddcb4e15bcc664fe259effb2 00877f819af9464e98662007a4c012e1--42537d78ddcb4e15bcc664fe259effb2 2c6a1984d3cb47449eb32532ec5e000b 42537d78ddcb4e15bcc664fe259effb2--2c6a1984d3cb47449eb32532ec5e000b 8bca5678f510411d829484bacb06bc5f RX(b12) 2c6a1984d3cb47449eb32532ec5e000b--8bca5678f510411d829484bacb06bc5f 8bca5678f510411d829484bacb06bc5f--d57b4ad2f86b41979d8f0f2467b00c75 a9fa90eaf353478293ca8c529185f5de ea7357a886414e31b78882b01b13bad3 52a9762a778b40ed908b5367d4093cc2--ea7357a886414e31b78882b01b13bad3 f25216d033c046938fc0ba3c74a9dcd4 4 8cd6f36a0e3f447c89845754af59789b ea7357a886414e31b78882b01b13bad3--8cd6f36a0e3f447c89845754af59789b 6311415d2a7b448c88fb29fb32160996 X 8cd6f36a0e3f447c89845754af59789b--6311415d2a7b448c88fb29fb32160996 6311415d2a7b448c88fb29fb32160996--aa13b92a449a4d0899144f2a8cb0a9a5 914b603adcb84b18bfdbd23a9b9592f2 6311415d2a7b448c88fb29fb32160996--914b603adcb84b18bfdbd23a9b9592f2 7c87998db46c4eff887b3844a28223a8 914b603adcb84b18bfdbd23a9b9592f2--7c87998db46c4eff887b3844a28223a8 9d20d44c39f14c539d0337a9a9ac1117 7c87998db46c4eff887b3844a28223a8--9d20d44c39f14c539d0337a9a9ac1117 e30853de06124ece84d8563bf4d079ba 9d20d44c39f14c539d0337a9a9ac1117--e30853de06124ece84d8563bf4d079ba b672b120a5e64da1b0b0448bccdf0f02 e30853de06124ece84d8563bf4d079ba--b672b120a5e64da1b0b0448bccdf0f02 09687b8c510c4f508a586657a9799608 b672b120a5e64da1b0b0448bccdf0f02--09687b8c510c4f508a586657a9799608 7cce16d71281428697687a45d3e693ed 09687b8c510c4f508a586657a9799608--7cce16d71281428697687a45d3e693ed cfbca5a47aed4812945edc7a55c4ccaa 7cce16d71281428697687a45d3e693ed--cfbca5a47aed4812945edc7a55c4ccaa 2a5aecaad6d64a049405ce9d448ec495 cfbca5a47aed4812945edc7a55c4ccaa--2a5aecaad6d64a049405ce9d448ec495 24142460cf994d489ee8efb02d863991 X 2a5aecaad6d64a049405ce9d448ec495--24142460cf994d489ee8efb02d863991 24142460cf994d489ee8efb02d863991--9b1abff2580848d089ea8c5945dd1d4c e0689d949f194600af19073eb853624d 24142460cf994d489ee8efb02d863991--e0689d949f194600af19073eb853624d 3a761d6550a44ea49ec41fbe738a11ab e0689d949f194600af19073eb853624d--3a761d6550a44ea49ec41fbe738a11ab 60f2a7a9d2e6405ba7b621a43b57da12 3a761d6550a44ea49ec41fbe738a11ab--60f2a7a9d2e6405ba7b621a43b57da12 9c0fb783faa44d658d2d9fcbf036ced4 60f2a7a9d2e6405ba7b621a43b57da12--9c0fb783faa44d658d2d9fcbf036ced4 d01467ac86b144f4988ea68bd10f5bb8 9c0fb783faa44d658d2d9fcbf036ced4--d01467ac86b144f4988ea68bd10f5bb8 4346357af6cd41389e569a1877b51411 d01467ac86b144f4988ea68bd10f5bb8--4346357af6cd41389e569a1877b51411 443f6ba23820456ea0e84277a6e4273d 4346357af6cd41389e569a1877b51411--443f6ba23820456ea0e84277a6e4273d 379ebf41b92c4935bb15871823d791ec X 443f6ba23820456ea0e84277a6e4273d--379ebf41b92c4935bb15871823d791ec 379ebf41b92c4935bb15871823d791ec--261212aecbfd4d2db7cb03a250f9f76e c00919b7691045d798ea1536dcfa8f85 RZ(-1.0*g0) 379ebf41b92c4935bb15871823d791ec--c00919b7691045d798ea1536dcfa8f85 e657676ec7ad48e993835cbe8f0e51b0 X c00919b7691045d798ea1536dcfa8f85--e657676ec7ad48e993835cbe8f0e51b0 e657676ec7ad48e993835cbe8f0e51b0--6f5e15db4a844f5ebea02079fc5989d6 b72735d9f6a44d169c84b6332bdecfbc e657676ec7ad48e993835cbe8f0e51b0--b72735d9f6a44d169c84b6332bdecfbc 8b1ab53bac8442758ce31301dacacbcb b72735d9f6a44d169c84b6332bdecfbc--8b1ab53bac8442758ce31301dacacbcb a45c431774fb47298f5d36c932637786 8b1ab53bac8442758ce31301dacacbcb--a45c431774fb47298f5d36c932637786 981252a845a746259be28f62954b9789 a45c431774fb47298f5d36c932637786--981252a845a746259be28f62954b9789 4ccf84877a894c058fc00ed8c2776ee7 X 981252a845a746259be28f62954b9789--4ccf84877a894c058fc00ed8c2776ee7 4ccf84877a894c058fc00ed8c2776ee7--e5e0a5ffeded4b0b81e327b799d2c3f6 fd1c27c97daf4f98bb67d62e4cf42f12 4ccf84877a894c058fc00ed8c2776ee7--fd1c27c97daf4f98bb67d62e4cf42f12 82919b34fe9f4022abae45df483b585b fd1c27c97daf4f98bb67d62e4cf42f12--82919b34fe9f4022abae45df483b585b 3eee7037512847409cbc7c1024bb6556 82919b34fe9f4022abae45df483b585b--3eee7037512847409cbc7c1024bb6556 53da86192bd84141a679cb073132ee8d X 3eee7037512847409cbc7c1024bb6556--53da86192bd84141a679cb073132ee8d 53da86192bd84141a679cb073132ee8d--acacb2126f63497f98c81fd39ebbc2b0 b1bb72d5a6834d90a38af5aac0160aee 53da86192bd84141a679cb073132ee8d--b1bb72d5a6834d90a38af5aac0160aee c65e8bd5d1a54dc4be5454ed17ee990f b1bb72d5a6834d90a38af5aac0160aee--c65e8bd5d1a54dc4be5454ed17ee990f 28214ee1c987435aa57293a279180516 c65e8bd5d1a54dc4be5454ed17ee990f--28214ee1c987435aa57293a279180516 84492c5f126d40adb254f7cb507785ad 28214ee1c987435aa57293a279180516--84492c5f126d40adb254f7cb507785ad c6b5ee7cdebb4e138bef440604968efa X 84492c5f126d40adb254f7cb507785ad--c6b5ee7cdebb4e138bef440604968efa c6b5ee7cdebb4e138bef440604968efa--e9308e92d45b44fbb1a49c8cfb7fb31a 1305e8c489044b1b87b2f6d8afa2dd7a c6b5ee7cdebb4e138bef440604968efa--1305e8c489044b1b87b2f6d8afa2dd7a cb88784f0a154612ad76122be6e039a5 1305e8c489044b1b87b2f6d8afa2dd7a--cb88784f0a154612ad76122be6e039a5 7f33760030a5492788ff0cbc5c73fb7a cb88784f0a154612ad76122be6e039a5--7f33760030a5492788ff0cbc5c73fb7a 3c36b6ff2f264f78943c9c034a08f7c2 7f33760030a5492788ff0cbc5c73fb7a--3c36b6ff2f264f78943c9c034a08f7c2 c4b49337b9c740fbb3f1ae9014ee429d 3c36b6ff2f264f78943c9c034a08f7c2--c4b49337b9c740fbb3f1ae9014ee429d ef16062122e842d8a074d3109d148b40 c4b49337b9c740fbb3f1ae9014ee429d--ef16062122e842d8a074d3109d148b40 46fa4a8d7ffc430a9c4e07fd05d2a35a ef16062122e842d8a074d3109d148b40--46fa4a8d7ffc430a9c4e07fd05d2a35a a6d1bda3d32542b09a3d8a1c3f66a3eb X 46fa4a8d7ffc430a9c4e07fd05d2a35a--a6d1bda3d32542b09a3d8a1c3f66a3eb a6d1bda3d32542b09a3d8a1c3f66a3eb--91895b2373ae422f902f1144b7c57e8f cba133db05f04dfb93762f0b752deece a6d1bda3d32542b09a3d8a1c3f66a3eb--cba133db05f04dfb93762f0b752deece 169b5c0c74754a1f9c819d27f0fb7df6 cba133db05f04dfb93762f0b752deece--169b5c0c74754a1f9c819d27f0fb7df6 4083e99f8ad848829c098309ae5d1403 169b5c0c74754a1f9c819d27f0fb7df6--4083e99f8ad848829c098309ae5d1403 db40528a78294fe49a14269f90dc02fe 4083e99f8ad848829c098309ae5d1403--db40528a78294fe49a14269f90dc02fe dea99123387246ab82b608b3051721e6 X db40528a78294fe49a14269f90dc02fe--dea99123387246ab82b608b3051721e6 dea99123387246ab82b608b3051721e6--9c7233fcc0134f698b5dcb94bf46d1f1 e0cf3a5f7c7a45df9e319e996d2469c8 dea99123387246ab82b608b3051721e6--e0cf3a5f7c7a45df9e319e996d2469c8 d8fa2889957644229e089c17af14822c e0cf3a5f7c7a45df9e319e996d2469c8--d8fa2889957644229e089c17af14822c 952e470b7259406f9edd0365663bfb8c d8fa2889957644229e089c17af14822c--952e470b7259406f9edd0365663bfb8c a051a16e7e2e47c2b271e5181e9ff10d 952e470b7259406f9edd0365663bfb8c--a051a16e7e2e47c2b271e5181e9ff10d 93759d51cc4047bbbded397f402749d7 a051a16e7e2e47c2b271e5181e9ff10d--93759d51cc4047bbbded397f402749d7 377f39c1a80e4ef6919dda66c1985e7f 93759d51cc4047bbbded397f402749d7--377f39c1a80e4ef6919dda66c1985e7f 704351022e7e4f47bb58eca56d07448b 377f39c1a80e4ef6919dda66c1985e7f--704351022e7e4f47bb58eca56d07448b 149d07a3132947e8be1d43e0f536b749 704351022e7e4f47bb58eca56d07448b--149d07a3132947e8be1d43e0f536b749 ceab67d01da34fd5aba723cd87f1b979 149d07a3132947e8be1d43e0f536b749--ceab67d01da34fd5aba723cd87f1b979 95b7ff2f7d244147b97b607f4b5d0f26 X ceab67d01da34fd5aba723cd87f1b979--95b7ff2f7d244147b97b607f4b5d0f26 95b7ff2f7d244147b97b607f4b5d0f26--10c95a6c905f4531aed977a5aa69296a c26f53acc1834b1cb50c2bcf500cd192 95b7ff2f7d244147b97b607f4b5d0f26--c26f53acc1834b1cb50c2bcf500cd192 a0ab2cd0bd734b0a9b41854c12328900 c26f53acc1834b1cb50c2bcf500cd192--a0ab2cd0bd734b0a9b41854c12328900 0eab10fe0baa4da9b7e7c272dcaf19ca a0ab2cd0bd734b0a9b41854c12328900--0eab10fe0baa4da9b7e7c272dcaf19ca fc9dedd0899d41c5a3c800a25859baad 0eab10fe0baa4da9b7e7c272dcaf19ca--fc9dedd0899d41c5a3c800a25859baad 177d7a003db442dd8e322e1428274026 fc9dedd0899d41c5a3c800a25859baad--177d7a003db442dd8e322e1428274026 36ecd5267fd744e89f196a17d86d7a65 177d7a003db442dd8e322e1428274026--36ecd5267fd744e89f196a17d86d7a65 32a53e7b70064b13a11f1af33b338b44 X 36ecd5267fd744e89f196a17d86d7a65--32a53e7b70064b13a11f1af33b338b44 32a53e7b70064b13a11f1af33b338b44--ee147a43677448a89a6dfd835bfce3db 7a8d35d045d048cd96d7413b82239049 32a53e7b70064b13a11f1af33b338b44--7a8d35d045d048cd96d7413b82239049 7a5573bd70fa4e68ac150667b9ba50c5 7a8d35d045d048cd96d7413b82239049--7a5573bd70fa4e68ac150667b9ba50c5 cca0f68eaf1f43d8bff2dae6ba68c7f0 7a5573bd70fa4e68ac150667b9ba50c5--cca0f68eaf1f43d8bff2dae6ba68c7f0 3e9654c28b6348e1a906ff1cd68ff154 cca0f68eaf1f43d8bff2dae6ba68c7f0--3e9654c28b6348e1a906ff1cd68ff154 8b7497e9d5074c73ac6854e15d9586f6 3e9654c28b6348e1a906ff1cd68ff154--8b7497e9d5074c73ac6854e15d9586f6 05a91a1f02e045499e57088274d9b50a X 8b7497e9d5074c73ac6854e15d9586f6--05a91a1f02e045499e57088274d9b50a 05a91a1f02e045499e57088274d9b50a--8d7dc129910d4b46ba013cb002de797e f9c0c53d630a41769d5a08f1ec61123c 05a91a1f02e045499e57088274d9b50a--f9c0c53d630a41769d5a08f1ec61123c 0a1de8943cc34f32b007c29ca85b5b6e X f9c0c53d630a41769d5a08f1ec61123c--0a1de8943cc34f32b007c29ca85b5b6e 0a1de8943cc34f32b007c29ca85b5b6e--9d345798ff2d43f08dfcd65d00722a85 1b9056514cb44f5cb26db5f04ad7ee3b 0a1de8943cc34f32b007c29ca85b5b6e--1b9056514cb44f5cb26db5f04ad7ee3b e3deeb940cf04741b7db2132a7b5510f 1b9056514cb44f5cb26db5f04ad7ee3b--e3deeb940cf04741b7db2132a7b5510f 464db5d1ba4f462299c937d2dd911a31 e3deeb940cf04741b7db2132a7b5510f--464db5d1ba4f462299c937d2dd911a31 ecb6401423a54d38b4177654ff1cb7e3 X 464db5d1ba4f462299c937d2dd911a31--ecb6401423a54d38b4177654ff1cb7e3 ecb6401423a54d38b4177654ff1cb7e3--f74fb5f323714745ae67bfb648b927ca e05926222ac546449bcf4ac8eb2befc4 X ecb6401423a54d38b4177654ff1cb7e3--e05926222ac546449bcf4ac8eb2befc4 e05926222ac546449bcf4ac8eb2befc4--7601a602829a41c79ba25692dd30de97 6bfc88a27b054a09852cec72cefc7ace e05926222ac546449bcf4ac8eb2befc4--6bfc88a27b054a09852cec72cefc7ace 9d70bebb741f4e93a8d15df844b1a7d7 6bfc88a27b054a09852cec72cefc7ace--9d70bebb741f4e93a8d15df844b1a7d7 894269dc1ebf41fe8f979ecd21d1debe 9d70bebb741f4e93a8d15df844b1a7d7--894269dc1ebf41fe8f979ecd21d1debe bb3d4ebae1064000bab9cd6522a0d62f 894269dc1ebf41fe8f979ecd21d1debe--bb3d4ebae1064000bab9cd6522a0d62f c7da0e4851274ddcae61a727ed24364a bb3d4ebae1064000bab9cd6522a0d62f--c7da0e4851274ddcae61a727ed24364a 7debd43e995a4334892f0a5d6033e776 X c7da0e4851274ddcae61a727ed24364a--7debd43e995a4334892f0a5d6033e776 7debd43e995a4334892f0a5d6033e776--a32bf39208ab4af383f569a5a9ece42a 6665ae6c03a244f090170270f4305956 X 7debd43e995a4334892f0a5d6033e776--6665ae6c03a244f090170270f4305956 6665ae6c03a244f090170270f4305956--add760df1bcf4db8956e16957d301c7d 56f962d844d54ba3a3c555592db291f4 6665ae6c03a244f090170270f4305956--56f962d844d54ba3a3c555592db291f4 d002e3692f304554a8c0a528150949c9 56f962d844d54ba3a3c555592db291f4--d002e3692f304554a8c0a528150949c9 bf1929f320ee416ca328f51af007d4e6 d002e3692f304554a8c0a528150949c9--bf1929f320ee416ca328f51af007d4e6 cf3d42d6700147ea8a388cbe7c5969f2 bf1929f320ee416ca328f51af007d4e6--cf3d42d6700147ea8a388cbe7c5969f2 63e5f9db04fe4afd9c15a6ab7075998b cf3d42d6700147ea8a388cbe7c5969f2--63e5f9db04fe4afd9c15a6ab7075998b 08a6b71ac6fa492ea7078d376b434de5 63e5f9db04fe4afd9c15a6ab7075998b--08a6b71ac6fa492ea7078d376b434de5 16e07ba75e614847930838822764bd68 08a6b71ac6fa492ea7078d376b434de5--16e07ba75e614847930838822764bd68 2eb8ebea54294911a4f1b706ffb98eb5 X 16e07ba75e614847930838822764bd68--2eb8ebea54294911a4f1b706ffb98eb5 2eb8ebea54294911a4f1b706ffb98eb5--0aa8959142584f97a0a65155d8131c4d 919e250858d0480597693e15c3496cb4 X 2eb8ebea54294911a4f1b706ffb98eb5--919e250858d0480597693e15c3496cb4 919e250858d0480597693e15c3496cb4--e14b8ef737b44d01a91288520dd90e78 943803f06aba4a7783ba1ef8d44ccd75 919e250858d0480597693e15c3496cb4--943803f06aba4a7783ba1ef8d44ccd75 b2a3a3b477084aaabada1b1de5659cae 943803f06aba4a7783ba1ef8d44ccd75--b2a3a3b477084aaabada1b1de5659cae ea41d130d64d48b18d28cd8f6e381621 b2a3a3b477084aaabada1b1de5659cae--ea41d130d64d48b18d28cd8f6e381621 8b69e09d49b4438ab5cede67886df404 ea41d130d64d48b18d28cd8f6e381621--8b69e09d49b4438ab5cede67886df404 8e96dd276c3c4b6c802ebd976d51984c 8b69e09d49b4438ab5cede67886df404--8e96dd276c3c4b6c802ebd976d51984c 2ee8180c3a3849a8b45734624c06a938 8e96dd276c3c4b6c802ebd976d51984c--2ee8180c3a3849a8b45734624c06a938 e5dd85e48b8346a894f7229c3ed29998 2ee8180c3a3849a8b45734624c06a938--e5dd85e48b8346a894f7229c3ed29998 9fa881d0ec7d4246b02b55c07d23774a e5dd85e48b8346a894f7229c3ed29998--9fa881d0ec7d4246b02b55c07d23774a bf660651b451401fba91bc82d114862e 9fa881d0ec7d4246b02b55c07d23774a--bf660651b451401fba91bc82d114862e 198c420072634e169bbb30351871e27a X bf660651b451401fba91bc82d114862e--198c420072634e169bbb30351871e27a 198c420072634e169bbb30351871e27a--5daf4362780f447687775a331159d5ae 299ed5c92b2a49c29826d27ce635d47e 198c420072634e169bbb30351871e27a--299ed5c92b2a49c29826d27ce635d47e e2b1fe4b69b345ea9385f4051de56852 299ed5c92b2a49c29826d27ce635d47e--e2b1fe4b69b345ea9385f4051de56852 ee4d9f83d3cd4c50bcfddd1a4f8fac40 e2b1fe4b69b345ea9385f4051de56852--ee4d9f83d3cd4c50bcfddd1a4f8fac40 2e2b8cc01b464d66a319a961cf235c37 ee4d9f83d3cd4c50bcfddd1a4f8fac40--2e2b8cc01b464d66a319a961cf235c37 67c6b6091d5947a0b27b3e98916b4524 2e2b8cc01b464d66a319a961cf235c37--67c6b6091d5947a0b27b3e98916b4524 93ba43ced39b4c7ab20ba4679e2a50f3 67c6b6091d5947a0b27b3e98916b4524--93ba43ced39b4c7ab20ba4679e2a50f3 cdead02bb3c143e2a89b35014d2e7aa9 93ba43ced39b4c7ab20ba4679e2a50f3--cdead02bb3c143e2a89b35014d2e7aa9 7efa7a6efeba4f5e9f49c80e203d7da8 cdead02bb3c143e2a89b35014d2e7aa9--7efa7a6efeba4f5e9f49c80e203d7da8 a1768b478121454b81aeb05a26e5ada3 7efa7a6efeba4f5e9f49c80e203d7da8--a1768b478121454b81aeb05a26e5ada3 e7f546b9a3df403aa991237e9fd3a742 a1768b478121454b81aeb05a26e5ada3--e7f546b9a3df403aa991237e9fd3a742 813940cf708d4f16bcb603e4b0d8b271 e7f546b9a3df403aa991237e9fd3a742--813940cf708d4f16bcb603e4b0d8b271 c9059d9b412343d08dec9b261c6a07f7 813940cf708d4f16bcb603e4b0d8b271--c9059d9b412343d08dec9b261c6a07f7 9402a5f786dc4d90abcacf1fdf5e673e c9059d9b412343d08dec9b261c6a07f7--9402a5f786dc4d90abcacf1fdf5e673e 841f005eeaaa41ccbc83fe816c5a1ab1 9402a5f786dc4d90abcacf1fdf5e673e--841f005eeaaa41ccbc83fe816c5a1ab1 a0ee8798e3b04a49b76f376da3965c37 841f005eeaaa41ccbc83fe816c5a1ab1--a0ee8798e3b04a49b76f376da3965c37 1b65fbbe6f6e474f8e13df3d227881ee a0ee8798e3b04a49b76f376da3965c37--1b65fbbe6f6e474f8e13df3d227881ee a40c7a5dde5343b98d131ff8cd29f330 1b65fbbe6f6e474f8e13df3d227881ee--a40c7a5dde5343b98d131ff8cd29f330 cc4357b2fad5487b93a8419eeda1c6f9 a40c7a5dde5343b98d131ff8cd29f330--cc4357b2fad5487b93a8419eeda1c6f9 7c93149b824f4550be18df2b320bec3c cc4357b2fad5487b93a8419eeda1c6f9--7c93149b824f4550be18df2b320bec3c 1bd9bf7521ee49a1990e0ac590ef68bc 7c93149b824f4550be18df2b320bec3c--1bd9bf7521ee49a1990e0ac590ef68bc 47107e4cdb684916bf24e06e444e94d6 1bd9bf7521ee49a1990e0ac590ef68bc--47107e4cdb684916bf24e06e444e94d6 6a2e267434bd4724b888eaea285fc836 47107e4cdb684916bf24e06e444e94d6--6a2e267434bd4724b888eaea285fc836 b6fcd09fe0504e48a43919cdc3c69144 6a2e267434bd4724b888eaea285fc836--b6fcd09fe0504e48a43919cdc3c69144 70bff111220b42f2a361139d70603e7a RX(b03) b6fcd09fe0504e48a43919cdc3c69144--70bff111220b42f2a361139d70603e7a d88d9341aee246f48780fc57f54bc0a2 70bff111220b42f2a361139d70603e7a--d88d9341aee246f48780fc57f54bc0a2 df9d19e0f256469eb59b1fc23f626820 d88d9341aee246f48780fc57f54bc0a2--df9d19e0f256469eb59b1fc23f626820 82066e257b8b4030a89384eeb2bafe1d X df9d19e0f256469eb59b1fc23f626820--82066e257b8b4030a89384eeb2bafe1d 82066e257b8b4030a89384eeb2bafe1d--9e9dde8793f7465abf6bd97a2bb03952 033177d21d6c459ea613ecdcd1d01164 82066e257b8b4030a89384eeb2bafe1d--033177d21d6c459ea613ecdcd1d01164 1ea11c9e86cc4b2bb30a61c3473de7c7 033177d21d6c459ea613ecdcd1d01164--1ea11c9e86cc4b2bb30a61c3473de7c7 e792eb7ae11f407e8e6209a6fb4ae677 1ea11c9e86cc4b2bb30a61c3473de7c7--e792eb7ae11f407e8e6209a6fb4ae677 089f84d78c654697a30b99cd262b8dab e792eb7ae11f407e8e6209a6fb4ae677--089f84d78c654697a30b99cd262b8dab a237f5ee6f004b61b02b9fad470ef25b 089f84d78c654697a30b99cd262b8dab--a237f5ee6f004b61b02b9fad470ef25b ed08c99d62bd4feabf2b9f35dc36cf40 a237f5ee6f004b61b02b9fad470ef25b--ed08c99d62bd4feabf2b9f35dc36cf40 a2474cd7d449467e88a9126bc9b28cbd ed08c99d62bd4feabf2b9f35dc36cf40--a2474cd7d449467e88a9126bc9b28cbd 57f4c82ada1b40a3a30e8b78bb9a6a29 a2474cd7d449467e88a9126bc9b28cbd--57f4c82ada1b40a3a30e8b78bb9a6a29 ecb772a6c78846e082d66c9f8be54afb 57f4c82ada1b40a3a30e8b78bb9a6a29--ecb772a6c78846e082d66c9f8be54afb d0c3ea7fc63040d484dda717963e04d3 X ecb772a6c78846e082d66c9f8be54afb--d0c3ea7fc63040d484dda717963e04d3 d0c3ea7fc63040d484dda717963e04d3--dbd674b2ee504b99aa34cb5328725071 d8d0c58cef5e431c9bc7606e1e624766 d0c3ea7fc63040d484dda717963e04d3--d8d0c58cef5e431c9bc7606e1e624766 dcfeaa5e6d6644b0bf7258c7db2cb6fe d8d0c58cef5e431c9bc7606e1e624766--dcfeaa5e6d6644b0bf7258c7db2cb6fe 5a53d90871df4357aa75960d481310fb dcfeaa5e6d6644b0bf7258c7db2cb6fe--5a53d90871df4357aa75960d481310fb be4531383fe24c7bb7db8fbc7390c9ec 5a53d90871df4357aa75960d481310fb--be4531383fe24c7bb7db8fbc7390c9ec 02ef8eafb681459499eb1b950dcb6250 be4531383fe24c7bb7db8fbc7390c9ec--02ef8eafb681459499eb1b950dcb6250 acf3a7a2e92949a9afae9e7b4ced3af3 02ef8eafb681459499eb1b950dcb6250--acf3a7a2e92949a9afae9e7b4ced3af3 3e07605e47524e25a17b715904649d9a acf3a7a2e92949a9afae9e7b4ced3af3--3e07605e47524e25a17b715904649d9a bfb64128970c41ecb083d4891c2d5db2 X 3e07605e47524e25a17b715904649d9a--bfb64128970c41ecb083d4891c2d5db2 bfb64128970c41ecb083d4891c2d5db2--8f4d71ad7c664702a51318a14e698ec5 22d2c9ac6700413aab625a94a9786a93 RZ(-1.0*g1) bfb64128970c41ecb083d4891c2d5db2--22d2c9ac6700413aab625a94a9786a93 bdf0038ee6b84622b4b66baa8090c825 X 22d2c9ac6700413aab625a94a9786a93--bdf0038ee6b84622b4b66baa8090c825 bdf0038ee6b84622b4b66baa8090c825--af334f25aca744ce9629f7e4d1ba8d6c 80b014573d4e46aca53bbda98684aa87 bdf0038ee6b84622b4b66baa8090c825--80b014573d4e46aca53bbda98684aa87 501f34668d7e41138236a8fa7bb4cfe8 80b014573d4e46aca53bbda98684aa87--501f34668d7e41138236a8fa7bb4cfe8 023199ae33834f76aecd90c5c72f6d1c 501f34668d7e41138236a8fa7bb4cfe8--023199ae33834f76aecd90c5c72f6d1c e5b644dc6be94150a3f4709a9c524b85 023199ae33834f76aecd90c5c72f6d1c--e5b644dc6be94150a3f4709a9c524b85 8677f07ca88e4492bd41d56185161df6 X e5b644dc6be94150a3f4709a9c524b85--8677f07ca88e4492bd41d56185161df6 8677f07ca88e4492bd41d56185161df6--292ac8eb96954388875126bf3c68a0cb e354e773a1464599bddfc42cd95ff654 8677f07ca88e4492bd41d56185161df6--e354e773a1464599bddfc42cd95ff654 34df4147a65341da81752f6985a90b10 e354e773a1464599bddfc42cd95ff654--34df4147a65341da81752f6985a90b10 5b2985f15c3d4f349a9b3dce9ea570dc 34df4147a65341da81752f6985a90b10--5b2985f15c3d4f349a9b3dce9ea570dc 5e20da76c8214f538b43ad5b4ff9e5e7 X 5b2985f15c3d4f349a9b3dce9ea570dc--5e20da76c8214f538b43ad5b4ff9e5e7 5e20da76c8214f538b43ad5b4ff9e5e7--efb26ec7b69b42c89d97db39bf44428b 14c20e8f573a401588af89c19bdb417c 5e20da76c8214f538b43ad5b4ff9e5e7--14c20e8f573a401588af89c19bdb417c d98bd717667f4280b2a2d64ba226bd5a 14c20e8f573a401588af89c19bdb417c--d98bd717667f4280b2a2d64ba226bd5a 62ea2e22478f40cbac2b16e5119cdf94 d98bd717667f4280b2a2d64ba226bd5a--62ea2e22478f40cbac2b16e5119cdf94 d80531e722a540f7b29b6ff9993b7e14 62ea2e22478f40cbac2b16e5119cdf94--d80531e722a540f7b29b6ff9993b7e14 1c9fda19c3f34d6faf09d5d8a3fc9f46 X d80531e722a540f7b29b6ff9993b7e14--1c9fda19c3f34d6faf09d5d8a3fc9f46 1c9fda19c3f34d6faf09d5d8a3fc9f46--dd80545e2e99493cb88984d2f16169b2 349e6283891549bb992e84e94c8c8883 1c9fda19c3f34d6faf09d5d8a3fc9f46--349e6283891549bb992e84e94c8c8883 326a8a650fcb424cb82eef49bba7ffc4 349e6283891549bb992e84e94c8c8883--326a8a650fcb424cb82eef49bba7ffc4 ed05107334d8441eb512166350b2a7e0 326a8a650fcb424cb82eef49bba7ffc4--ed05107334d8441eb512166350b2a7e0 5061ab55420f4ce3953e9829eec71d99 ed05107334d8441eb512166350b2a7e0--5061ab55420f4ce3953e9829eec71d99 7a494594944f414ba3351c6ac2a618b4 5061ab55420f4ce3953e9829eec71d99--7a494594944f414ba3351c6ac2a618b4 c574fdc222c549e18bdf6f5da878441f 7a494594944f414ba3351c6ac2a618b4--c574fdc222c549e18bdf6f5da878441f a093bfefb9e1456c9f1d2773ac05dd1a c574fdc222c549e18bdf6f5da878441f--a093bfefb9e1456c9f1d2773ac05dd1a 9722b7b1602b490ab4594d5456885915 X a093bfefb9e1456c9f1d2773ac05dd1a--9722b7b1602b490ab4594d5456885915 9722b7b1602b490ab4594d5456885915--43e0d61bd2cd4e8a8c9c94fb1027adb4 6658ffd3b4344d98ae33c512c316a260 9722b7b1602b490ab4594d5456885915--6658ffd3b4344d98ae33c512c316a260 4b37e46b0ff64f1c8a3a3e8c2de68722 6658ffd3b4344d98ae33c512c316a260--4b37e46b0ff64f1c8a3a3e8c2de68722 4701e6be2999413587d2d4c63f4aa7f7 4b37e46b0ff64f1c8a3a3e8c2de68722--4701e6be2999413587d2d4c63f4aa7f7 56a02268a0434aa2904c9d521c7057e4 4701e6be2999413587d2d4c63f4aa7f7--56a02268a0434aa2904c9d521c7057e4 639153adb0a84ec282b66047260b0f9f X 56a02268a0434aa2904c9d521c7057e4--639153adb0a84ec282b66047260b0f9f 639153adb0a84ec282b66047260b0f9f--ea2ac0b07bdc47cc9319cd4b4f748447 0f4eca3a955646e4b10d8449e4612825 639153adb0a84ec282b66047260b0f9f--0f4eca3a955646e4b10d8449e4612825 b8ce608792f44bcf986c5a035091c627 0f4eca3a955646e4b10d8449e4612825--b8ce608792f44bcf986c5a035091c627 8367a96ee7714a779f6f5ec0d79570db b8ce608792f44bcf986c5a035091c627--8367a96ee7714a779f6f5ec0d79570db b4e06557f6aa461ab4f8f184ee93893a 8367a96ee7714a779f6f5ec0d79570db--b4e06557f6aa461ab4f8f184ee93893a 6017470523f8428695aeefbf16cf9ba2 b4e06557f6aa461ab4f8f184ee93893a--6017470523f8428695aeefbf16cf9ba2 713da618450b4d4d85ac823971981e0a 6017470523f8428695aeefbf16cf9ba2--713da618450b4d4d85ac823971981e0a 68bb94994fdb44e095a349e6ce30a81a 713da618450b4d4d85ac823971981e0a--68bb94994fdb44e095a349e6ce30a81a 496926411a534a1793c36aaf5baee858 68bb94994fdb44e095a349e6ce30a81a--496926411a534a1793c36aaf5baee858 405c02bfa575416d9b9c3fbb91a35dcb 496926411a534a1793c36aaf5baee858--405c02bfa575416d9b9c3fbb91a35dcb b41a745c8e2746faa4954e5f27ba95ba X 405c02bfa575416d9b9c3fbb91a35dcb--b41a745c8e2746faa4954e5f27ba95ba b41a745c8e2746faa4954e5f27ba95ba--54d047a2acaa4e9da4f246e4394b9d25 4b57679977494c3f8c7187af47522fa2 b41a745c8e2746faa4954e5f27ba95ba--4b57679977494c3f8c7187af47522fa2 f2327d8df368491785f7ca4f122ee7c6 4b57679977494c3f8c7187af47522fa2--f2327d8df368491785f7ca4f122ee7c6 1bc1456b49854fda84f6d854f8972dcd f2327d8df368491785f7ca4f122ee7c6--1bc1456b49854fda84f6d854f8972dcd a0618ecfb973449fa8898fa7bc1ae87d 1bc1456b49854fda84f6d854f8972dcd--a0618ecfb973449fa8898fa7bc1ae87d a1c4c9f41a8e42d281d96ff20d7ccb0f a0618ecfb973449fa8898fa7bc1ae87d--a1c4c9f41a8e42d281d96ff20d7ccb0f 1b1a2e84707c4a8db1b2b3676be80702 a1c4c9f41a8e42d281d96ff20d7ccb0f--1b1a2e84707c4a8db1b2b3676be80702 66eeb7fe061644f6b199d149a0e24fd0 X 1b1a2e84707c4a8db1b2b3676be80702--66eeb7fe061644f6b199d149a0e24fd0 66eeb7fe061644f6b199d149a0e24fd0--ce91de0851e34ff588c89c39cf3e6f23 29a87b7ceb46412685f94c017ba31943 66eeb7fe061644f6b199d149a0e24fd0--29a87b7ceb46412685f94c017ba31943 705a622881a34caab69fcd22c0053916 29a87b7ceb46412685f94c017ba31943--705a622881a34caab69fcd22c0053916 22850c2e8240459085f7be42b8d4a184 705a622881a34caab69fcd22c0053916--22850c2e8240459085f7be42b8d4a184 4ccbfd8f32124afda51c9b75688e9791 22850c2e8240459085f7be42b8d4a184--4ccbfd8f32124afda51c9b75688e9791 31a94ea64189499a8d125bdf862ee498 4ccbfd8f32124afda51c9b75688e9791--31a94ea64189499a8d125bdf862ee498 49a6f238f3ec464f9f477cb2dd5de7f9 X 31a94ea64189499a8d125bdf862ee498--49a6f238f3ec464f9f477cb2dd5de7f9 49a6f238f3ec464f9f477cb2dd5de7f9--8d71f7b82b1d46a8bb24f517c3f3f3fb 8373c3a11e5a4d02aee5bcad1b6c45e8 49a6f238f3ec464f9f477cb2dd5de7f9--8373c3a11e5a4d02aee5bcad1b6c45e8 24c9c1b1637943a593891c2306a7ce50 X 8373c3a11e5a4d02aee5bcad1b6c45e8--24c9c1b1637943a593891c2306a7ce50 24c9c1b1637943a593891c2306a7ce50--bbef18314bc24d44b85a973f3b4aa8cd e4a61d5438ae4cdfb74c263feb606ac1 24c9c1b1637943a593891c2306a7ce50--e4a61d5438ae4cdfb74c263feb606ac1 3be375a300f8473daebb8ab40a54e5aa e4a61d5438ae4cdfb74c263feb606ac1--3be375a300f8473daebb8ab40a54e5aa a945269b99004ea4a28200f84d97e411 3be375a300f8473daebb8ab40a54e5aa--a945269b99004ea4a28200f84d97e411 8d0842f26d384232a15c36078bc73c4f X a945269b99004ea4a28200f84d97e411--8d0842f26d384232a15c36078bc73c4f 8d0842f26d384232a15c36078bc73c4f--7132d3892cd4433996e31eeea9ad184c 08b2112b04274175b6770cdf07dd5f82 X 8d0842f26d384232a15c36078bc73c4f--08b2112b04274175b6770cdf07dd5f82 08b2112b04274175b6770cdf07dd5f82--0ed0f75f425d4b768e2f93432a421931 b51e43b1ef404ceeae01ed158b51caa8 08b2112b04274175b6770cdf07dd5f82--b51e43b1ef404ceeae01ed158b51caa8 29216e4f469d40878b31f21a87b74f52 b51e43b1ef404ceeae01ed158b51caa8--29216e4f469d40878b31f21a87b74f52 d06955fcbb4f47b09a55c25756d6aac4 29216e4f469d40878b31f21a87b74f52--d06955fcbb4f47b09a55c25756d6aac4 cf070dedc3af4dee84c7cf3b74498c0c d06955fcbb4f47b09a55c25756d6aac4--cf070dedc3af4dee84c7cf3b74498c0c a94572211b0342bbb31b100724d153a1 cf070dedc3af4dee84c7cf3b74498c0c--a94572211b0342bbb31b100724d153a1 764c99db38a74c73a92566aaa2c73b14 X a94572211b0342bbb31b100724d153a1--764c99db38a74c73a92566aaa2c73b14 764c99db38a74c73a92566aaa2c73b14--4a592a5053c94ea892138066e39e666d 3d262000580f4240a8071631ccd59cbc X 764c99db38a74c73a92566aaa2c73b14--3d262000580f4240a8071631ccd59cbc 3d262000580f4240a8071631ccd59cbc--28aead53cce540f7902210b69e62c330 d28bf6f94d8544058309ce33182f09dc 3d262000580f4240a8071631ccd59cbc--d28bf6f94d8544058309ce33182f09dc a694e82423ec41df9160cabaa09e9f5a d28bf6f94d8544058309ce33182f09dc--a694e82423ec41df9160cabaa09e9f5a 58ebb92957cd40b887f39b801aa57e29 a694e82423ec41df9160cabaa09e9f5a--58ebb92957cd40b887f39b801aa57e29 fd154cd4332b4924a9147285e8a654ed 58ebb92957cd40b887f39b801aa57e29--fd154cd4332b4924a9147285e8a654ed f7ea8d0af838460c88bc3356226668cd fd154cd4332b4924a9147285e8a654ed--f7ea8d0af838460c88bc3356226668cd 37715886beb048daa9211ff2ef896f79 f7ea8d0af838460c88bc3356226668cd--37715886beb048daa9211ff2ef896f79 a31b1d7aeed04255ad4e76f556d77802 37715886beb048daa9211ff2ef896f79--a31b1d7aeed04255ad4e76f556d77802 85998c660e87482fb79d1aadc193ac60 X a31b1d7aeed04255ad4e76f556d77802--85998c660e87482fb79d1aadc193ac60 85998c660e87482fb79d1aadc193ac60--e25c696fb37f4092beb8635f2a7fe1a2 d2fab6310cb3409eaa7f09f59e6e0d11 X 85998c660e87482fb79d1aadc193ac60--d2fab6310cb3409eaa7f09f59e6e0d11 d2fab6310cb3409eaa7f09f59e6e0d11--fc90093a1d7948c4a530f1acbde12f2a af1f1f8fa18a493b870a01a021b302d8 d2fab6310cb3409eaa7f09f59e6e0d11--af1f1f8fa18a493b870a01a021b302d8 8ff73c9079d44c78bb65dc78206c9015 af1f1f8fa18a493b870a01a021b302d8--8ff73c9079d44c78bb65dc78206c9015 8819b7fc2bab40ae8a0ae9c840eade37 8ff73c9079d44c78bb65dc78206c9015--8819b7fc2bab40ae8a0ae9c840eade37 c18024a8b14844faa339ed380492672b 8819b7fc2bab40ae8a0ae9c840eade37--c18024a8b14844faa339ed380492672b 3f721e79ba2f4ee8b3f03c9d6493a728 c18024a8b14844faa339ed380492672b--3f721e79ba2f4ee8b3f03c9d6493a728 3646aa6d47f2413997f1e59665324d87 3f721e79ba2f4ee8b3f03c9d6493a728--3646aa6d47f2413997f1e59665324d87 73092ec7f32a462493483fc9974aa8ec 3646aa6d47f2413997f1e59665324d87--73092ec7f32a462493483fc9974aa8ec bc61bd7ec136470c9cf2ccd67c80d0ae 73092ec7f32a462493483fc9974aa8ec--bc61bd7ec136470c9cf2ccd67c80d0ae d351f600be0b4bc5805b8258f44c269a bc61bd7ec136470c9cf2ccd67c80d0ae--d351f600be0b4bc5805b8258f44c269a 509687e6cccb460080743daed5c8862e X d351f600be0b4bc5805b8258f44c269a--509687e6cccb460080743daed5c8862e 509687e6cccb460080743daed5c8862e--c6416f708d5e4a6a8c65551f26d5d001 7f389025448d49f1b690a8a338b079cb 509687e6cccb460080743daed5c8862e--7f389025448d49f1b690a8a338b079cb f5c6227fd19a4fd1a7f3888982f0090f 7f389025448d49f1b690a8a338b079cb--f5c6227fd19a4fd1a7f3888982f0090f 9f16c695b7054322aaa4f1cfbcef026c f5c6227fd19a4fd1a7f3888982f0090f--9f16c695b7054322aaa4f1cfbcef026c 1501ec6e7e7748e594845f237d3d101d 9f16c695b7054322aaa4f1cfbcef026c--1501ec6e7e7748e594845f237d3d101d 5f64b64f8d0d46cb883c476f80795c0d 1501ec6e7e7748e594845f237d3d101d--5f64b64f8d0d46cb883c476f80795c0d 197c48c97ea941bd8c67be0cd9d4d82c 5f64b64f8d0d46cb883c476f80795c0d--197c48c97ea941bd8c67be0cd9d4d82c 5f1f2fac1ef64dcc93bbdc15c4295b03 197c48c97ea941bd8c67be0cd9d4d82c--5f1f2fac1ef64dcc93bbdc15c4295b03 c6763c5d357340c19c49bcc7e3fe6f89 5f1f2fac1ef64dcc93bbdc15c4295b03--c6763c5d357340c19c49bcc7e3fe6f89 20efee53bba3490d93345a15671fdcad c6763c5d357340c19c49bcc7e3fe6f89--20efee53bba3490d93345a15671fdcad 729a057aaa844bf4840b06a7f014b7df 20efee53bba3490d93345a15671fdcad--729a057aaa844bf4840b06a7f014b7df fff906b344444055a2fd8519c55cd5ec 729a057aaa844bf4840b06a7f014b7df--fff906b344444055a2fd8519c55cd5ec 823f95e4462f4726a30d6039abdea6e3 fff906b344444055a2fd8519c55cd5ec--823f95e4462f4726a30d6039abdea6e3 88bcaefed60741e7b93fef3edf979059 823f95e4462f4726a30d6039abdea6e3--88bcaefed60741e7b93fef3edf979059 dd6e643c32d04a1d8276fcc5e4591e81 88bcaefed60741e7b93fef3edf979059--dd6e643c32d04a1d8276fcc5e4591e81 2c41a5cb542d485d99aa15e45032bc0d dd6e643c32d04a1d8276fcc5e4591e81--2c41a5cb542d485d99aa15e45032bc0d 0462792c1edf491baaefdac76da075cf 2c41a5cb542d485d99aa15e45032bc0d--0462792c1edf491baaefdac76da075cf 5949561a309d496b8d6b65033b81319a 0462792c1edf491baaefdac76da075cf--5949561a309d496b8d6b65033b81319a 76859e2e5c8745ebadcc2244746eca65 5949561a309d496b8d6b65033b81319a--76859e2e5c8745ebadcc2244746eca65 d9db9f076aac422eb736dedd3d0bf8ce 76859e2e5c8745ebadcc2244746eca65--d9db9f076aac422eb736dedd3d0bf8ce fb531b796a7e42148ea69e91f4ff48c4 d9db9f076aac422eb736dedd3d0bf8ce--fb531b796a7e42148ea69e91f4ff48c4 c8f566896174494b918bf44e464d216a fb531b796a7e42148ea69e91f4ff48c4--c8f566896174494b918bf44e464d216a ea7254b13e404ee49406d3d70047b7e3 c8f566896174494b918bf44e464d216a--ea7254b13e404ee49406d3d70047b7e3 463875a08f054817a4f58f201bc28831 ea7254b13e404ee49406d3d70047b7e3--463875a08f054817a4f58f201bc28831 5baffc8be11d44fca47f4f0826175f5a RX(b13) 463875a08f054817a4f58f201bc28831--5baffc8be11d44fca47f4f0826175f5a 5baffc8be11d44fca47f4f0826175f5a--a9fa90eaf353478293ca8c529185f5de b4c3971850894ed0a50074d4f3fe5061 9c0ad8562b8b41259754636646173c10 f25216d033c046938fc0ba3c74a9dcd4--9c0ad8562b8b41259754636646173c10 9573b1bef66a44179b7b808cbcd313a9 5 2370d9bd9c994be89eb48cd4655bf17b 9c0ad8562b8b41259754636646173c10--2370d9bd9c994be89eb48cd4655bf17b a16ba8805f2442c78b4d2826b84863ab 2370d9bd9c994be89eb48cd4655bf17b--a16ba8805f2442c78b4d2826b84863ab fcc6e123fdce47788b75d3e69bedcba2 X a16ba8805f2442c78b4d2826b84863ab--fcc6e123fdce47788b75d3e69bedcba2 fcc6e123fdce47788b75d3e69bedcba2--914b603adcb84b18bfdbd23a9b9592f2 017b42b59d2b4148a8187fde6d63cbec fcc6e123fdce47788b75d3e69bedcba2--017b42b59d2b4148a8187fde6d63cbec 488588f0d15f43659f75dab2848ed93f 017b42b59d2b4148a8187fde6d63cbec--488588f0d15f43659f75dab2848ed93f bd719618e18643e9b47a8c3323182c70 488588f0d15f43659f75dab2848ed93f--bd719618e18643e9b47a8c3323182c70 b984b0435e1e4b8487366a1904cd67a6 bd719618e18643e9b47a8c3323182c70--b984b0435e1e4b8487366a1904cd67a6 384f4d7fabb3458fa2b53c6c80f1078e b984b0435e1e4b8487366a1904cd67a6--384f4d7fabb3458fa2b53c6c80f1078e e25f8ae5eea64a14970068d67bfbfa69 384f4d7fabb3458fa2b53c6c80f1078e--e25f8ae5eea64a14970068d67bfbfa69 4230ba663e6e42a2ad20151f5b5e1d08 e25f8ae5eea64a14970068d67bfbfa69--4230ba663e6e42a2ad20151f5b5e1d08 90b3ae43430a434f8fc6b4bde2419045 X 4230ba663e6e42a2ad20151f5b5e1d08--90b3ae43430a434f8fc6b4bde2419045 90b3ae43430a434f8fc6b4bde2419045--2a5aecaad6d64a049405ce9d448ec495 00a69fddae2a4d2cbaef32386fd8ef36 90b3ae43430a434f8fc6b4bde2419045--00a69fddae2a4d2cbaef32386fd8ef36 86bffbc9f88f431988cafe97c14a4699 00a69fddae2a4d2cbaef32386fd8ef36--86bffbc9f88f431988cafe97c14a4699 7c5f463d74ae4762b2b74f1dda11a624 86bffbc9f88f431988cafe97c14a4699--7c5f463d74ae4762b2b74f1dda11a624 df56f75c7b3d4a8483ff2a89e4fc0ccc 7c5f463d74ae4762b2b74f1dda11a624--df56f75c7b3d4a8483ff2a89e4fc0ccc bc3e3a4b1d1541e1a6c351484a4cef16 df56f75c7b3d4a8483ff2a89e4fc0ccc--bc3e3a4b1d1541e1a6c351484a4cef16 17c27ab7c86142a7bf748f5c3539e4e3 bc3e3a4b1d1541e1a6c351484a4cef16--17c27ab7c86142a7bf748f5c3539e4e3 43e2cf4eb4a044e689446462db3d3610 17c27ab7c86142a7bf748f5c3539e4e3--43e2cf4eb4a044e689446462db3d3610 0e7c4dfa6ab74e3ea2a5b9774f2fd513 43e2cf4eb4a044e689446462db3d3610--0e7c4dfa6ab74e3ea2a5b9774f2fd513 c58d17953ec2452a9f719c53dc40dca3 0e7c4dfa6ab74e3ea2a5b9774f2fd513--c58d17953ec2452a9f719c53dc40dca3 6b6553fae7bb444f83fe24e398373558 c58d17953ec2452a9f719c53dc40dca3--6b6553fae7bb444f83fe24e398373558 cc236f802d034498b3f3fdd5beab4c05 6b6553fae7bb444f83fe24e398373558--cc236f802d034498b3f3fdd5beab4c05 c317be40f9974a408c6adb44c4554263 cc236f802d034498b3f3fdd5beab4c05--c317be40f9974a408c6adb44c4554263 49bcd5e0fa804a12941294feaacb712e c317be40f9974a408c6adb44c4554263--49bcd5e0fa804a12941294feaacb712e 468a1a26c19740d68668303e3682140b 49bcd5e0fa804a12941294feaacb712e--468a1a26c19740d68668303e3682140b 895426bcaf30426c9f33a0da8290dc73 468a1a26c19740d68668303e3682140b--895426bcaf30426c9f33a0da8290dc73 5936eb9c46664307adbf506a3eb267c6 895426bcaf30426c9f33a0da8290dc73--5936eb9c46664307adbf506a3eb267c6 9cc5d4d074bb4bfb9982bf4de77c8e94 X 5936eb9c46664307adbf506a3eb267c6--9cc5d4d074bb4bfb9982bf4de77c8e94 9cc5d4d074bb4bfb9982bf4de77c8e94--fd1c27c97daf4f98bb67d62e4cf42f12 09fcfe97ba904c27864ff209e5bea753 RZ(-1.0*g0) 9cc5d4d074bb4bfb9982bf4de77c8e94--09fcfe97ba904c27864ff209e5bea753 a48b2f8662d640ac854fec423e3d1f57 X 09fcfe97ba904c27864ff209e5bea753--a48b2f8662d640ac854fec423e3d1f57 a48b2f8662d640ac854fec423e3d1f57--3eee7037512847409cbc7c1024bb6556 5cb94d596fdd43229dd7e7b58ecdf6e0 a48b2f8662d640ac854fec423e3d1f57--5cb94d596fdd43229dd7e7b58ecdf6e0 41320340a6954f6ebe336007368f5a8d 5cb94d596fdd43229dd7e7b58ecdf6e0--41320340a6954f6ebe336007368f5a8d f5f3f1ef5480401092671a7991abb37f 41320340a6954f6ebe336007368f5a8d--f5f3f1ef5480401092671a7991abb37f 4eac0d895eca44509965243d6728d454 f5f3f1ef5480401092671a7991abb37f--4eac0d895eca44509965243d6728d454 9fa476a0c7d1475db0d53b7eba624503 4eac0d895eca44509965243d6728d454--9fa476a0c7d1475db0d53b7eba624503 c10a3842ac3049af8a2357d0f6d6e5d9 9fa476a0c7d1475db0d53b7eba624503--c10a3842ac3049af8a2357d0f6d6e5d9 ae04705d2cc14a0092f1ab44385d1f24 X c10a3842ac3049af8a2357d0f6d6e5d9--ae04705d2cc14a0092f1ab44385d1f24 ae04705d2cc14a0092f1ab44385d1f24--1305e8c489044b1b87b2f6d8afa2dd7a 6255d3e120b34bd8963d445ce4e44dc1 ae04705d2cc14a0092f1ab44385d1f24--6255d3e120b34bd8963d445ce4e44dc1 8afb63c18e7f4655a4820496213c7b34 6255d3e120b34bd8963d445ce4e44dc1--8afb63c18e7f4655a4820496213c7b34 e38bd3b0a27e4e2185898bdacc2d480d 8afb63c18e7f4655a4820496213c7b34--e38bd3b0a27e4e2185898bdacc2d480d 1dfab4879bd74eec8322f5745a727439 e38bd3b0a27e4e2185898bdacc2d480d--1dfab4879bd74eec8322f5745a727439 7d580fe039524ae392520f73f4cab5da 1dfab4879bd74eec8322f5745a727439--7d580fe039524ae392520f73f4cab5da 676096bce4fd4eeb9ca8bbd8fd779e73 X 7d580fe039524ae392520f73f4cab5da--676096bce4fd4eeb9ca8bbd8fd779e73 676096bce4fd4eeb9ca8bbd8fd779e73--46fa4a8d7ffc430a9c4e07fd05d2a35a 21da4a76cbef4713bf39f430fab1365d 676096bce4fd4eeb9ca8bbd8fd779e73--21da4a76cbef4713bf39f430fab1365d 7bf35a5a2e194eaebaaa27cb13db165d 21da4a76cbef4713bf39f430fab1365d--7bf35a5a2e194eaebaaa27cb13db165d 4d89c913480f489f85f9d9a669dc1d96 7bf35a5a2e194eaebaaa27cb13db165d--4d89c913480f489f85f9d9a669dc1d96 d0b55b9d241344e5a08fd9143754606e 4d89c913480f489f85f9d9a669dc1d96--d0b55b9d241344e5a08fd9143754606e bc57e4dc78b540ba854f83ed98898bfc d0b55b9d241344e5a08fd9143754606e--bc57e4dc78b540ba854f83ed98898bfc d1dab2fcf03c41f6bf9c4efab35c83c6 bc57e4dc78b540ba854f83ed98898bfc--d1dab2fcf03c41f6bf9c4efab35c83c6 e6735529afba40bc8aacf77a0619374f X d1dab2fcf03c41f6bf9c4efab35c83c6--e6735529afba40bc8aacf77a0619374f e6735529afba40bc8aacf77a0619374f--e0cf3a5f7c7a45df9e319e996d2469c8 e86a46dd41a14eddb293301b84a611d1 e6735529afba40bc8aacf77a0619374f--e86a46dd41a14eddb293301b84a611d1 650a6a3eeb1340dda4aa1232947d2415 e86a46dd41a14eddb293301b84a611d1--650a6a3eeb1340dda4aa1232947d2415 66f62e36b15448d6b39594ef823c34b0 650a6a3eeb1340dda4aa1232947d2415--66f62e36b15448d6b39594ef823c34b0 0d6bbf09f7ce4494b3f3a220bac8a76b 66f62e36b15448d6b39594ef823c34b0--0d6bbf09f7ce4494b3f3a220bac8a76b 320dab1d0f1a4fa4858f263f4fdd58c0 0d6bbf09f7ce4494b3f3a220bac8a76b--320dab1d0f1a4fa4858f263f4fdd58c0 b94f143a5c4d40d7b506d9b6d36b7b6d 320dab1d0f1a4fa4858f263f4fdd58c0--b94f143a5c4d40d7b506d9b6d36b7b6d 569ea9f491114222a4ba7e7a7b75e647 b94f143a5c4d40d7b506d9b6d36b7b6d--569ea9f491114222a4ba7e7a7b75e647 8b50e86b571448059692067007091fbe X 569ea9f491114222a4ba7e7a7b75e647--8b50e86b571448059692067007091fbe 8b50e86b571448059692067007091fbe--ceab67d01da34fd5aba723cd87f1b979 56eb814e46ba4c1cad81d66afe0d5728 8b50e86b571448059692067007091fbe--56eb814e46ba4c1cad81d66afe0d5728 e4e88463761a4692b6a44103210fa386 56eb814e46ba4c1cad81d66afe0d5728--e4e88463761a4692b6a44103210fa386 60151bebc0a642a496256bc518cab59c e4e88463761a4692b6a44103210fa386--60151bebc0a642a496256bc518cab59c 73d07ddaa0cf486191766ad472d028f2 60151bebc0a642a496256bc518cab59c--73d07ddaa0cf486191766ad472d028f2 548576e67053483d959cc32a31567d34 73d07ddaa0cf486191766ad472d028f2--548576e67053483d959cc32a31567d34 d74c277fa41c4b5eaa701cf54ccf6ff3 548576e67053483d959cc32a31567d34--d74c277fa41c4b5eaa701cf54ccf6ff3 97af46f7a0b448cfad087fd13bb81c8d d74c277fa41c4b5eaa701cf54ccf6ff3--97af46f7a0b448cfad087fd13bb81c8d 505e2070b4d84f16a907affd5e129718 97af46f7a0b448cfad087fd13bb81c8d--505e2070b4d84f16a907affd5e129718 f5cab3348c184175bb90323a4eacb0c1 X 505e2070b4d84f16a907affd5e129718--f5cab3348c184175bb90323a4eacb0c1 f5cab3348c184175bb90323a4eacb0c1--7a8d35d045d048cd96d7413b82239049 e2064007f65f40df942745aca99af475 f5cab3348c184175bb90323a4eacb0c1--e2064007f65f40df942745aca99af475 000a5e1d983a45619321069b610f05c3 e2064007f65f40df942745aca99af475--000a5e1d983a45619321069b610f05c3 111429ebc36e47a6a6b4eb0329caf3e9 000a5e1d983a45619321069b610f05c3--111429ebc36e47a6a6b4eb0329caf3e9 ae13f2089add4e3ca7ca173df9482ff3 X 111429ebc36e47a6a6b4eb0329caf3e9--ae13f2089add4e3ca7ca173df9482ff3 ae13f2089add4e3ca7ca173df9482ff3--8b7497e9d5074c73ac6854e15d9586f6 5fa0e07b51ab46f9b092739b451c07e5 ae13f2089add4e3ca7ca173df9482ff3--5fa0e07b51ab46f9b092739b451c07e5 5b5bcbb9bf2a4fe7943decf6bc5095d2 5fa0e07b51ab46f9b092739b451c07e5--5b5bcbb9bf2a4fe7943decf6bc5095d2 d84d3fbd9f36497f9ba251fd98b8ddcc 5b5bcbb9bf2a4fe7943decf6bc5095d2--d84d3fbd9f36497f9ba251fd98b8ddcc 9d221ec023bc49c39596c2968ba00ac0 X d84d3fbd9f36497f9ba251fd98b8ddcc--9d221ec023bc49c39596c2968ba00ac0 9d221ec023bc49c39596c2968ba00ac0--1b9056514cb44f5cb26db5f04ad7ee3b 9865fc40994241c48cf70f6fc3ab00eb RZ(-1.0*g0) 9d221ec023bc49c39596c2968ba00ac0--9865fc40994241c48cf70f6fc3ab00eb bf7ada9270024f9ca7c76d79e6ec8d27 X 9865fc40994241c48cf70f6fc3ab00eb--bf7ada9270024f9ca7c76d79e6ec8d27 bf7ada9270024f9ca7c76d79e6ec8d27--464db5d1ba4f462299c937d2dd911a31 ce8a00620a9c4ed8a78ec26a6be9082a bf7ada9270024f9ca7c76d79e6ec8d27--ce8a00620a9c4ed8a78ec26a6be9082a d50e35e5ce2e448da9bfe5f9ea674d96 ce8a00620a9c4ed8a78ec26a6be9082a--d50e35e5ce2e448da9bfe5f9ea674d96 f362ce168d2b4d90b1ab8cf42b8515f4 X d50e35e5ce2e448da9bfe5f9ea674d96--f362ce168d2b4d90b1ab8cf42b8515f4 f362ce168d2b4d90b1ab8cf42b8515f4--6bfc88a27b054a09852cec72cefc7ace a1f4ca5462764b9a9ee2deba6d21e5a2 f362ce168d2b4d90b1ab8cf42b8515f4--a1f4ca5462764b9a9ee2deba6d21e5a2 80d7d8b0db9447e6a8dba325e634d312 a1f4ca5462764b9a9ee2deba6d21e5a2--80d7d8b0db9447e6a8dba325e634d312 f608561128324a879a0cb2fb144a3c04 80d7d8b0db9447e6a8dba325e634d312--f608561128324a879a0cb2fb144a3c04 51e9d7f620be40c0ae6b0dc6823d6da6 X f608561128324a879a0cb2fb144a3c04--51e9d7f620be40c0ae6b0dc6823d6da6 51e9d7f620be40c0ae6b0dc6823d6da6--c7da0e4851274ddcae61a727ed24364a 744f67b85c3d42b19b114ab9df43189e 51e9d7f620be40c0ae6b0dc6823d6da6--744f67b85c3d42b19b114ab9df43189e c5acbf65e2f942a2ab0ff83902be5c1c 744f67b85c3d42b19b114ab9df43189e--c5acbf65e2f942a2ab0ff83902be5c1c 46448434c4924e999be454c7cf56ffcd X c5acbf65e2f942a2ab0ff83902be5c1c--46448434c4924e999be454c7cf56ffcd 46448434c4924e999be454c7cf56ffcd--56f962d844d54ba3a3c555592db291f4 75db85bc4d8e44e2b4bdbe15b39732ff 46448434c4924e999be454c7cf56ffcd--75db85bc4d8e44e2b4bdbe15b39732ff 242ba51b04d04b65b8c5ec59978b9f6d 75db85bc4d8e44e2b4bdbe15b39732ff--242ba51b04d04b65b8c5ec59978b9f6d 21e1b48f5ebf4cd3894c3fda1c766f8b 242ba51b04d04b65b8c5ec59978b9f6d--21e1b48f5ebf4cd3894c3fda1c766f8b 33ad1d0fd7854924a25e83688d6a3d90 21e1b48f5ebf4cd3894c3fda1c766f8b--33ad1d0fd7854924a25e83688d6a3d90 2c8d37a94217420ab40873a9d29a3018 33ad1d0fd7854924a25e83688d6a3d90--2c8d37a94217420ab40873a9d29a3018 6afbf1d09081483ca3d7b588a08f899d X 2c8d37a94217420ab40873a9d29a3018--6afbf1d09081483ca3d7b588a08f899d 6afbf1d09081483ca3d7b588a08f899d--16e07ba75e614847930838822764bd68 cdf90284a6884fe581d59735e538e9af 6afbf1d09081483ca3d7b588a08f899d--cdf90284a6884fe581d59735e538e9af ea151203199144a6a27557d5e2862861 cdf90284a6884fe581d59735e538e9af--ea151203199144a6a27557d5e2862861 8206aa9553a446be9231453a66eb595f X ea151203199144a6a27557d5e2862861--8206aa9553a446be9231453a66eb595f 8206aa9553a446be9231453a66eb595f--943803f06aba4a7783ba1ef8d44ccd75 1a569bdd56be49ca8bebc3f7cd6bf6b7 8206aa9553a446be9231453a66eb595f--1a569bdd56be49ca8bebc3f7cd6bf6b7 fc3f3c1f27dc484fb20cff4b6dd51c89 1a569bdd56be49ca8bebc3f7cd6bf6b7--fc3f3c1f27dc484fb20cff4b6dd51c89 f76fb008f5dc4cd98ccb29989d8d7e2f fc3f3c1f27dc484fb20cff4b6dd51c89--f76fb008f5dc4cd98ccb29989d8d7e2f 8d3b2be0bfb0439e941385311b67451b f76fb008f5dc4cd98ccb29989d8d7e2f--8d3b2be0bfb0439e941385311b67451b 55625656e1794d2fb52e3d7410a5c554 8d3b2be0bfb0439e941385311b67451b--55625656e1794d2fb52e3d7410a5c554 785b3ccb705e452286dd94e4025b2915 55625656e1794d2fb52e3d7410a5c554--785b3ccb705e452286dd94e4025b2915 902c96b572ee4a39b665ba5b936f5a5a 785b3ccb705e452286dd94e4025b2915--902c96b572ee4a39b665ba5b936f5a5a e0bb5203aefd4560af8830859324923f X 902c96b572ee4a39b665ba5b936f5a5a--e0bb5203aefd4560af8830859324923f e0bb5203aefd4560af8830859324923f--bf660651b451401fba91bc82d114862e 48e2d4a66c474d5e803798b90822f53d e0bb5203aefd4560af8830859324923f--48e2d4a66c474d5e803798b90822f53d 9365b69b60174e28b954d12ea0234bd1 X 48e2d4a66c474d5e803798b90822f53d--9365b69b60174e28b954d12ea0234bd1 9365b69b60174e28b954d12ea0234bd1--299ed5c92b2a49c29826d27ce635d47e 38a660eac6bc41a690359b2b3913e062 RZ(-1.0*g0) 9365b69b60174e28b954d12ea0234bd1--38a660eac6bc41a690359b2b3913e062 ee61f37cfb9542cc8fbee76382edbac2 X 38a660eac6bc41a690359b2b3913e062--ee61f37cfb9542cc8fbee76382edbac2 ee61f37cfb9542cc8fbee76382edbac2--ee4d9f83d3cd4c50bcfddd1a4f8fac40 90512806e6a544149dfadd62904a2a82 X ee61f37cfb9542cc8fbee76382edbac2--90512806e6a544149dfadd62904a2a82 90512806e6a544149dfadd62904a2a82--2e2b8cc01b464d66a319a961cf235c37 8ce9289e2c0746b594b58d7761132e8c 90512806e6a544149dfadd62904a2a82--8ce9289e2c0746b594b58d7761132e8c 312ad9cd8c0c4dbb930b397f924ffc7e 8ce9289e2c0746b594b58d7761132e8c--312ad9cd8c0c4dbb930b397f924ffc7e 3b3d5380f3aa46d49916c139114fcae2 312ad9cd8c0c4dbb930b397f924ffc7e--3b3d5380f3aa46d49916c139114fcae2 2a085b4f073e4ecfbb6ba6e7268cc9f3 X 3b3d5380f3aa46d49916c139114fcae2--2a085b4f073e4ecfbb6ba6e7268cc9f3 2a085b4f073e4ecfbb6ba6e7268cc9f3--7efa7a6efeba4f5e9f49c80e203d7da8 b44a51917d0d430e9089d0d4fdb7e10a X 2a085b4f073e4ecfbb6ba6e7268cc9f3--b44a51917d0d430e9089d0d4fdb7e10a b44a51917d0d430e9089d0d4fdb7e10a--a1768b478121454b81aeb05a26e5ada3 97e03a8ad69149709701881d79c05ccb b44a51917d0d430e9089d0d4fdb7e10a--97e03a8ad69149709701881d79c05ccb 0fb43c76920946eda8dc66c56ffc9d96 97e03a8ad69149709701881d79c05ccb--0fb43c76920946eda8dc66c56ffc9d96 179ea649da754b86a8cb4054767acd88 0fb43c76920946eda8dc66c56ffc9d96--179ea649da754b86a8cb4054767acd88 0e5171e281154adeab13feedf7d67268 179ea649da754b86a8cb4054767acd88--0e5171e281154adeab13feedf7d67268 4d2e151212e043bc8728c2d2b87d28c3 0e5171e281154adeab13feedf7d67268--4d2e151212e043bc8728c2d2b87d28c3 187e64b5d7b74dca8e44e2e438ae9b31 X 4d2e151212e043bc8728c2d2b87d28c3--187e64b5d7b74dca8e44e2e438ae9b31 187e64b5d7b74dca8e44e2e438ae9b31--a0ee8798e3b04a49b76f376da3965c37 3ff689c89f3c424794434bd8b74ac4c5 187e64b5d7b74dca8e44e2e438ae9b31--3ff689c89f3c424794434bd8b74ac4c5 6e13be4a78444726bb0bf64955377c22 3ff689c89f3c424794434bd8b74ac4c5--6e13be4a78444726bb0bf64955377c22 3c89fc078d2c48689a6a983b6946a98b 6e13be4a78444726bb0bf64955377c22--3c89fc078d2c48689a6a983b6946a98b 6d53ffe25ef34c8787e7198cceb3191f 3c89fc078d2c48689a6a983b6946a98b--6d53ffe25ef34c8787e7198cceb3191f fd30168fc19442ff84bf8d78209643e4 6d53ffe25ef34c8787e7198cceb3191f--fd30168fc19442ff84bf8d78209643e4 021c91e72aff4d189201ef68a18898f4 fd30168fc19442ff84bf8d78209643e4--021c91e72aff4d189201ef68a18898f4 a2e0aeb53cf74f47ad30a2be169f008f 021c91e72aff4d189201ef68a18898f4--a2e0aeb53cf74f47ad30a2be169f008f 2bb451bc6c2b4a4999ab83d7bfedaba1 a2e0aeb53cf74f47ad30a2be169f008f--2bb451bc6c2b4a4999ab83d7bfedaba1 cfb6234b6bb24bb88ae144488a3f4f92 RX(b04) 2bb451bc6c2b4a4999ab83d7bfedaba1--cfb6234b6bb24bb88ae144488a3f4f92 5ad6309ade414656bc00cb6f1eeb7011 cfb6234b6bb24bb88ae144488a3f4f92--5ad6309ade414656bc00cb6f1eeb7011 c55f843178104cd981b08a78127517f7 5ad6309ade414656bc00cb6f1eeb7011--c55f843178104cd981b08a78127517f7 8caaa2fad5ea45f787e83edd6db998c2 c55f843178104cd981b08a78127517f7--8caaa2fad5ea45f787e83edd6db998c2 59193633b07643469c0165cd6d2a47b5 X 8caaa2fad5ea45f787e83edd6db998c2--59193633b07643469c0165cd6d2a47b5 59193633b07643469c0165cd6d2a47b5--033177d21d6c459ea613ecdcd1d01164 0d12364f2bb94f638db64ac9ea312862 59193633b07643469c0165cd6d2a47b5--0d12364f2bb94f638db64ac9ea312862 6c02b6333ef44591a5a98c2b581f50f9 0d12364f2bb94f638db64ac9ea312862--6c02b6333ef44591a5a98c2b581f50f9 d82750cb11804dd8a3d9e6202b4f350e 6c02b6333ef44591a5a98c2b581f50f9--d82750cb11804dd8a3d9e6202b4f350e 14889d1aeb8c41a2afe53de5d289e290 d82750cb11804dd8a3d9e6202b4f350e--14889d1aeb8c41a2afe53de5d289e290 44bcee0b2e524b0d82dd7e4aec5b5cc8 14889d1aeb8c41a2afe53de5d289e290--44bcee0b2e524b0d82dd7e4aec5b5cc8 d9c00342cc7d469fb8fc3e80c813dc3c 44bcee0b2e524b0d82dd7e4aec5b5cc8--d9c00342cc7d469fb8fc3e80c813dc3c 3dee9a576be54201b65eda8d503fbfd8 d9c00342cc7d469fb8fc3e80c813dc3c--3dee9a576be54201b65eda8d503fbfd8 845ecd6880ea4e479cc587d3abeb6fa3 X 3dee9a576be54201b65eda8d503fbfd8--845ecd6880ea4e479cc587d3abeb6fa3 845ecd6880ea4e479cc587d3abeb6fa3--ecb772a6c78846e082d66c9f8be54afb 2b498b80f9b84f3eac6c1a6742fad184 845ecd6880ea4e479cc587d3abeb6fa3--2b498b80f9b84f3eac6c1a6742fad184 38ac49eca86c4affb45acb40b9fdde85 2b498b80f9b84f3eac6c1a6742fad184--38ac49eca86c4affb45acb40b9fdde85 d90b924f3ffd4604b9c96eb00f82bf07 38ac49eca86c4affb45acb40b9fdde85--d90b924f3ffd4604b9c96eb00f82bf07 a749d36d69d249a7964316dbfd662d99 d90b924f3ffd4604b9c96eb00f82bf07--a749d36d69d249a7964316dbfd662d99 64210e532ec64f57a7f6a26e00628c55 a749d36d69d249a7964316dbfd662d99--64210e532ec64f57a7f6a26e00628c55 ca569c371cf34be88d2027344556d2c4 64210e532ec64f57a7f6a26e00628c55--ca569c371cf34be88d2027344556d2c4 107ee31141494927bee4a0d5b215f58a ca569c371cf34be88d2027344556d2c4--107ee31141494927bee4a0d5b215f58a 69985c2b0c3240f3bc9f2a6bd9fef977 107ee31141494927bee4a0d5b215f58a--69985c2b0c3240f3bc9f2a6bd9fef977 947646a48d0545c18962367ca23baeab 69985c2b0c3240f3bc9f2a6bd9fef977--947646a48d0545c18962367ca23baeab b833ba98c2a645a3addb0dafc6f7d409 947646a48d0545c18962367ca23baeab--b833ba98c2a645a3addb0dafc6f7d409 0cbcf473df5342d1a3739d8ffb648d77 b833ba98c2a645a3addb0dafc6f7d409--0cbcf473df5342d1a3739d8ffb648d77 63930e2e0b094d3b96e5b8a6dc61b734 0cbcf473df5342d1a3739d8ffb648d77--63930e2e0b094d3b96e5b8a6dc61b734 5d45d9e26c2c405cb61f86edf67ddcc3 63930e2e0b094d3b96e5b8a6dc61b734--5d45d9e26c2c405cb61f86edf67ddcc3 a8b2329a636f43a7b146036602841a42 5d45d9e26c2c405cb61f86edf67ddcc3--a8b2329a636f43a7b146036602841a42 f7754132d6ea46cab0f83bef3c1dae11 a8b2329a636f43a7b146036602841a42--f7754132d6ea46cab0f83bef3c1dae11 f6803807f9ef483498279ecd402cf626 f7754132d6ea46cab0f83bef3c1dae11--f6803807f9ef483498279ecd402cf626 a1b8af203f3f40488ff6d727d9d34fc5 X f6803807f9ef483498279ecd402cf626--a1b8af203f3f40488ff6d727d9d34fc5 a1b8af203f3f40488ff6d727d9d34fc5--e354e773a1464599bddfc42cd95ff654 1e4be587f8f94f7a8110dc4a2de681fa RZ(-1.0*g1) a1b8af203f3f40488ff6d727d9d34fc5--1e4be587f8f94f7a8110dc4a2de681fa 6d84057c3c01426690e31374b0b5b388 X 1e4be587f8f94f7a8110dc4a2de681fa--6d84057c3c01426690e31374b0b5b388 6d84057c3c01426690e31374b0b5b388--5b2985f15c3d4f349a9b3dce9ea570dc 961666c05c854d3482df00b867e28ba7 6d84057c3c01426690e31374b0b5b388--961666c05c854d3482df00b867e28ba7 6eeb1253166b4231b38dd775c330db19 961666c05c854d3482df00b867e28ba7--6eeb1253166b4231b38dd775c330db19 9edeb149817d41709a56b3f04624c5d1 6eeb1253166b4231b38dd775c330db19--9edeb149817d41709a56b3f04624c5d1 72cc625ce5364384997c5700e8080fa3 9edeb149817d41709a56b3f04624c5d1--72cc625ce5364384997c5700e8080fa3 f11340ea54fb4956a1b3b2382d5a9007 72cc625ce5364384997c5700e8080fa3--f11340ea54fb4956a1b3b2382d5a9007 c1240862fde44e6bbb2fd8915bbf9035 f11340ea54fb4956a1b3b2382d5a9007--c1240862fde44e6bbb2fd8915bbf9035 0ccbade5da5340358423177fff24d729 X c1240862fde44e6bbb2fd8915bbf9035--0ccbade5da5340358423177fff24d729 0ccbade5da5340358423177fff24d729--349e6283891549bb992e84e94c8c8883 89fe63f3e0724e9fb36e78fffaddf558 0ccbade5da5340358423177fff24d729--89fe63f3e0724e9fb36e78fffaddf558 50ead2bf2e98496eb3c350579308d04f 89fe63f3e0724e9fb36e78fffaddf558--50ead2bf2e98496eb3c350579308d04f c54e849d523a40778bb7a1cbb510a66c 50ead2bf2e98496eb3c350579308d04f--c54e849d523a40778bb7a1cbb510a66c 35eff813d85b4511ba46d84cac4c93ea c54e849d523a40778bb7a1cbb510a66c--35eff813d85b4511ba46d84cac4c93ea 747136843dc3449f8e2455fbb561cdf8 35eff813d85b4511ba46d84cac4c93ea--747136843dc3449f8e2455fbb561cdf8 bc2089c7bead48f9aafb230688ea4e08 X 747136843dc3449f8e2455fbb561cdf8--bc2089c7bead48f9aafb230688ea4e08 bc2089c7bead48f9aafb230688ea4e08--a093bfefb9e1456c9f1d2773ac05dd1a 3061efa338404bed9c30d2a6d404602f bc2089c7bead48f9aafb230688ea4e08--3061efa338404bed9c30d2a6d404602f 799249d9a6564682a9f980bdebc25d37 3061efa338404bed9c30d2a6d404602f--799249d9a6564682a9f980bdebc25d37 96b745d9859c4caca232a07665b50d27 799249d9a6564682a9f980bdebc25d37--96b745d9859c4caca232a07665b50d27 5d69015c6de645b3ba78e54e682bae63 96b745d9859c4caca232a07665b50d27--5d69015c6de645b3ba78e54e682bae63 c54b5456814c411d95d0c02bc3dd8139 5d69015c6de645b3ba78e54e682bae63--c54b5456814c411d95d0c02bc3dd8139 6bdaf0e77e424fa085042a9e40298297 c54b5456814c411d95d0c02bc3dd8139--6bdaf0e77e424fa085042a9e40298297 ac698adf0df84af4ae570633d2b281f5 X 6bdaf0e77e424fa085042a9e40298297--ac698adf0df84af4ae570633d2b281f5 ac698adf0df84af4ae570633d2b281f5--0f4eca3a955646e4b10d8449e4612825 8564320c350240d1924ea15fbc25eb2c ac698adf0df84af4ae570633d2b281f5--8564320c350240d1924ea15fbc25eb2c 2d592520c6f8440a94cd5ef1a4294ef8 8564320c350240d1924ea15fbc25eb2c--2d592520c6f8440a94cd5ef1a4294ef8 118c117bfac84ce097d1de15f4a289da 2d592520c6f8440a94cd5ef1a4294ef8--118c117bfac84ce097d1de15f4a289da f99a7da9f19e4748a83b36f5efda1d24 118c117bfac84ce097d1de15f4a289da--f99a7da9f19e4748a83b36f5efda1d24 ea5ba2e2085843f18da49b8448d3093d f99a7da9f19e4748a83b36f5efda1d24--ea5ba2e2085843f18da49b8448d3093d d776913feb824ca18b70795864c73243 ea5ba2e2085843f18da49b8448d3093d--d776913feb824ca18b70795864c73243 fc07cd9a77bc4b2ea8d139628ce1889d d776913feb824ca18b70795864c73243--fc07cd9a77bc4b2ea8d139628ce1889d fc1b955b5bcc44ad82a0fda36c749ff5 X fc07cd9a77bc4b2ea8d139628ce1889d--fc1b955b5bcc44ad82a0fda36c749ff5 fc1b955b5bcc44ad82a0fda36c749ff5--405c02bfa575416d9b9c3fbb91a35dcb c91d525b950343d396eff7383aec33bc fc1b955b5bcc44ad82a0fda36c749ff5--c91d525b950343d396eff7383aec33bc 30dabbc5d6c742ef9e631d665faad179 c91d525b950343d396eff7383aec33bc--30dabbc5d6c742ef9e631d665faad179 d15f0daf8b0f4597bfc4b57b5d2a0a9b 30dabbc5d6c742ef9e631d665faad179--d15f0daf8b0f4597bfc4b57b5d2a0a9b c2f0fcf19bd3414bb1e871ce69b90873 d15f0daf8b0f4597bfc4b57b5d2a0a9b--c2f0fcf19bd3414bb1e871ce69b90873 29346de21b2c49689a33260b90519b89 c2f0fcf19bd3414bb1e871ce69b90873--29346de21b2c49689a33260b90519b89 f8871073d1484127b0302a6079294c11 29346de21b2c49689a33260b90519b89--f8871073d1484127b0302a6079294c11 30d1a2c3da7a4582a4a4e18ea3d68076 f8871073d1484127b0302a6079294c11--30d1a2c3da7a4582a4a4e18ea3d68076 be95a1f60e5644ab91318911f7088c58 30d1a2c3da7a4582a4a4e18ea3d68076--be95a1f60e5644ab91318911f7088c58 5ead0e2501ab4d65a15e2cb59d8dd58d X be95a1f60e5644ab91318911f7088c58--5ead0e2501ab4d65a15e2cb59d8dd58d 5ead0e2501ab4d65a15e2cb59d8dd58d--29a87b7ceb46412685f94c017ba31943 3d51b4fb617d490fa419f10ecfc47600 5ead0e2501ab4d65a15e2cb59d8dd58d--3d51b4fb617d490fa419f10ecfc47600 9961da0e9c1d4564a5bf70d15468e8e4 3d51b4fb617d490fa419f10ecfc47600--9961da0e9c1d4564a5bf70d15468e8e4 5a3c263f177242c79e977ab04e6eccfa 9961da0e9c1d4564a5bf70d15468e8e4--5a3c263f177242c79e977ab04e6eccfa 02003795e69d4b54a704a1fdd1914de0 X 5a3c263f177242c79e977ab04e6eccfa--02003795e69d4b54a704a1fdd1914de0 02003795e69d4b54a704a1fdd1914de0--31a94ea64189499a8d125bdf862ee498 8b0fb500ddf44bcaa56b879871e1d25a 02003795e69d4b54a704a1fdd1914de0--8b0fb500ddf44bcaa56b879871e1d25a 0d8af3189f5f495394ef29499232fd5b 8b0fb500ddf44bcaa56b879871e1d25a--0d8af3189f5f495394ef29499232fd5b f0a6b57be71948bab11af862e7057478 0d8af3189f5f495394ef29499232fd5b--f0a6b57be71948bab11af862e7057478 4c68fbf924b7444080bfd5b61c1569bc X f0a6b57be71948bab11af862e7057478--4c68fbf924b7444080bfd5b61c1569bc 4c68fbf924b7444080bfd5b61c1569bc--e4a61d5438ae4cdfb74c263feb606ac1 af4fcf6f550d4b57b08c8ec718f7916c RZ(-1.0*g1) 4c68fbf924b7444080bfd5b61c1569bc--af4fcf6f550d4b57b08c8ec718f7916c 90220982f6e144ddaf2b2606c1d95f8c X af4fcf6f550d4b57b08c8ec718f7916c--90220982f6e144ddaf2b2606c1d95f8c 90220982f6e144ddaf2b2606c1d95f8c--a945269b99004ea4a28200f84d97e411 d59e9477c86546808032b85869949cf0 90220982f6e144ddaf2b2606c1d95f8c--d59e9477c86546808032b85869949cf0 1ffabe48a7bd4bb48156d89987b32873 d59e9477c86546808032b85869949cf0--1ffabe48a7bd4bb48156d89987b32873 2d91f81ae99b453cb60094e9bf71cb7a X 1ffabe48a7bd4bb48156d89987b32873--2d91f81ae99b453cb60094e9bf71cb7a 2d91f81ae99b453cb60094e9bf71cb7a--b51e43b1ef404ceeae01ed158b51caa8 073323a9d484462abf9ec2303707446c 2d91f81ae99b453cb60094e9bf71cb7a--073323a9d484462abf9ec2303707446c f21aff734d6744fc91608704145db470 073323a9d484462abf9ec2303707446c--f21aff734d6744fc91608704145db470 aea667cb7c2d4381a261738ec4edfa6b f21aff734d6744fc91608704145db470--aea667cb7c2d4381a261738ec4edfa6b 6cf2f2706ec240b18070da5db00dd5d5 X aea667cb7c2d4381a261738ec4edfa6b--6cf2f2706ec240b18070da5db00dd5d5 6cf2f2706ec240b18070da5db00dd5d5--a94572211b0342bbb31b100724d153a1 5ea4229be9c040c28a7c47ed1c377b42 6cf2f2706ec240b18070da5db00dd5d5--5ea4229be9c040c28a7c47ed1c377b42 c286f46651f54a1ba8dc687165854afc 5ea4229be9c040c28a7c47ed1c377b42--c286f46651f54a1ba8dc687165854afc b7617ceda4884637b2dedc1728598a68 X c286f46651f54a1ba8dc687165854afc--b7617ceda4884637b2dedc1728598a68 b7617ceda4884637b2dedc1728598a68--d28bf6f94d8544058309ce33182f09dc c3eb8a6ed4f14012a6b773ec7f48fef7 b7617ceda4884637b2dedc1728598a68--c3eb8a6ed4f14012a6b773ec7f48fef7 51dced8a82b74f53aef8158c5518371e c3eb8a6ed4f14012a6b773ec7f48fef7--51dced8a82b74f53aef8158c5518371e 7d7f50d51e8141f5898db5e18b06a6e0 51dced8a82b74f53aef8158c5518371e--7d7f50d51e8141f5898db5e18b06a6e0 e4ddde683e3d4e71b6568d94c3f43a71 7d7f50d51e8141f5898db5e18b06a6e0--e4ddde683e3d4e71b6568d94c3f43a71 f33675b37fb549f2b6d984fb9a2d3dee e4ddde683e3d4e71b6568d94c3f43a71--f33675b37fb549f2b6d984fb9a2d3dee 40d34f37dc1d45108cb4a033dab3919f X f33675b37fb549f2b6d984fb9a2d3dee--40d34f37dc1d45108cb4a033dab3919f 40d34f37dc1d45108cb4a033dab3919f--a31b1d7aeed04255ad4e76f556d77802 17d79c8415fb4c949f928bb5a9d8c36b 40d34f37dc1d45108cb4a033dab3919f--17d79c8415fb4c949f928bb5a9d8c36b eb7143e1a9b241f59fe1ac154d0089d3 17d79c8415fb4c949f928bb5a9d8c36b--eb7143e1a9b241f59fe1ac154d0089d3 1960fb673b1d41b387dff17912b17398 X eb7143e1a9b241f59fe1ac154d0089d3--1960fb673b1d41b387dff17912b17398 1960fb673b1d41b387dff17912b17398--af1f1f8fa18a493b870a01a021b302d8 d75eff34607843f88b0d3c94cbce0bc3 1960fb673b1d41b387dff17912b17398--d75eff34607843f88b0d3c94cbce0bc3 18b18ecad6234ebeb326b9c05ecc85da d75eff34607843f88b0d3c94cbce0bc3--18b18ecad6234ebeb326b9c05ecc85da 588c2d717ac54b6c8f5295989973c93c 18b18ecad6234ebeb326b9c05ecc85da--588c2d717ac54b6c8f5295989973c93c f2c1c73095eb49aca555123898393687 588c2d717ac54b6c8f5295989973c93c--f2c1c73095eb49aca555123898393687 949f4e32a684432386057b3331cadb56 f2c1c73095eb49aca555123898393687--949f4e32a684432386057b3331cadb56 267dcd50e88a439bb8ba2078842d069c 949f4e32a684432386057b3331cadb56--267dcd50e88a439bb8ba2078842d069c ecdae3366db9450e8243e12a1998e39d 267dcd50e88a439bb8ba2078842d069c--ecdae3366db9450e8243e12a1998e39d 5eb34ffa9d6f4bb98555d84b30c7ec15 X ecdae3366db9450e8243e12a1998e39d--5eb34ffa9d6f4bb98555d84b30c7ec15 5eb34ffa9d6f4bb98555d84b30c7ec15--d351f600be0b4bc5805b8258f44c269a d353c1e863a3448189f5cf80392d5182 5eb34ffa9d6f4bb98555d84b30c7ec15--d353c1e863a3448189f5cf80392d5182 c60567d9326a4ff585f02c631e785173 X d353c1e863a3448189f5cf80392d5182--c60567d9326a4ff585f02c631e785173 c60567d9326a4ff585f02c631e785173--7f389025448d49f1b690a8a338b079cb 7d41324ee3a448a49b675921203144e5 RZ(-1.0*g1) c60567d9326a4ff585f02c631e785173--7d41324ee3a448a49b675921203144e5 e9e11f32cbc04157b02348d40011c22a X 7d41324ee3a448a49b675921203144e5--e9e11f32cbc04157b02348d40011c22a e9e11f32cbc04157b02348d40011c22a--9f16c695b7054322aaa4f1cfbcef026c 35f22b6af1f84d36a9a240ceb6fc2565 X e9e11f32cbc04157b02348d40011c22a--35f22b6af1f84d36a9a240ceb6fc2565 35f22b6af1f84d36a9a240ceb6fc2565--1501ec6e7e7748e594845f237d3d101d c179328a9f2044b3bf781e16facabf0f 35f22b6af1f84d36a9a240ceb6fc2565--c179328a9f2044b3bf781e16facabf0f 206bf91002f54c299a6a38a79267d10e c179328a9f2044b3bf781e16facabf0f--206bf91002f54c299a6a38a79267d10e 42c452bbcb7f498abbeec8b64dd50e36 206bf91002f54c299a6a38a79267d10e--42c452bbcb7f498abbeec8b64dd50e36 afcdb215727d42f5a8e9749478b5a0dc X 42c452bbcb7f498abbeec8b64dd50e36--afcdb215727d42f5a8e9749478b5a0dc afcdb215727d42f5a8e9749478b5a0dc--c6763c5d357340c19c49bcc7e3fe6f89 f89050d013eb489da8d93c8c66da223e X afcdb215727d42f5a8e9749478b5a0dc--f89050d013eb489da8d93c8c66da223e f89050d013eb489da8d93c8c66da223e--20efee53bba3490d93345a15671fdcad 7cd7fa1f80ea4979afbab0b40e931053 f89050d013eb489da8d93c8c66da223e--7cd7fa1f80ea4979afbab0b40e931053 3d1834797e1d4e41927cd82106de12a5 7cd7fa1f80ea4979afbab0b40e931053--3d1834797e1d4e41927cd82106de12a5 24981fbc01d24fc69ff91fd78685710b 3d1834797e1d4e41927cd82106de12a5--24981fbc01d24fc69ff91fd78685710b d5252980a7754670b7a8a2f08da91902 24981fbc01d24fc69ff91fd78685710b--d5252980a7754670b7a8a2f08da91902 d6e1f5e9a8ad4ce8a4a32eb5f72743b6 d5252980a7754670b7a8a2f08da91902--d6e1f5e9a8ad4ce8a4a32eb5f72743b6 729cdb0b4f3043719a985b11ef9ed40a X d6e1f5e9a8ad4ce8a4a32eb5f72743b6--729cdb0b4f3043719a985b11ef9ed40a 729cdb0b4f3043719a985b11ef9ed40a--2c41a5cb542d485d99aa15e45032bc0d c16cde55106a4c58ad5c6d5982a526b7 729cdb0b4f3043719a985b11ef9ed40a--c16cde55106a4c58ad5c6d5982a526b7 9443f46eadb24332b755e50ca67fe667 c16cde55106a4c58ad5c6d5982a526b7--9443f46eadb24332b755e50ca67fe667 ffbff9043ee944aba230a6039a125fb6 9443f46eadb24332b755e50ca67fe667--ffbff9043ee944aba230a6039a125fb6 fe7e00c9f8744621a0b65918c6e2c784 ffbff9043ee944aba230a6039a125fb6--fe7e00c9f8744621a0b65918c6e2c784 753cbde5ecda4051bce7932865e8f28a fe7e00c9f8744621a0b65918c6e2c784--753cbde5ecda4051bce7932865e8f28a 0c3af4c495ad4ddfabfc78a94ef2b449 753cbde5ecda4051bce7932865e8f28a--0c3af4c495ad4ddfabfc78a94ef2b449 967e44d9951743639716818560fecaab 0c3af4c495ad4ddfabfc78a94ef2b449--967e44d9951743639716818560fecaab 08b14980b0f14a88bd8e85f56b48cfb9 967e44d9951743639716818560fecaab--08b14980b0f14a88bd8e85f56b48cfb9 da8ec150732647329cb03b566f7ddbcf RX(b14) 08b14980b0f14a88bd8e85f56b48cfb9--da8ec150732647329cb03b566f7ddbcf da8ec150732647329cb03b566f7ddbcf--b4c3971850894ed0a50074d4f3fe5061 49c19b161c6941e5842d953f3c82f619 a76f5ea6f9d7489fa1d66d739c92ef21 9573b1bef66a44179b7b808cbcd313a9--a76f5ea6f9d7489fa1d66d739c92ef21 892cf8d44d9e4c9188c0e8aa39cd94c1 6 464228debb4b4268b29b3e68fc64a2ca a76f5ea6f9d7489fa1d66d739c92ef21--464228debb4b4268b29b3e68fc64a2ca 50ebdbec329b4bd08f6ffdf11a3c3b30 464228debb4b4268b29b3e68fc64a2ca--50ebdbec329b4bd08f6ffdf11a3c3b30 04a996c2cea3494db891644fca38dc36 50ebdbec329b4bd08f6ffdf11a3c3b30--04a996c2cea3494db891644fca38dc36 bbfa5cc78f044025a45c768d82c10a55 X 04a996c2cea3494db891644fca38dc36--bbfa5cc78f044025a45c768d82c10a55 bbfa5cc78f044025a45c768d82c10a55--017b42b59d2b4148a8187fde6d63cbec f3bd658dd1ee488fb85ef4f0cf4ec11a bbfa5cc78f044025a45c768d82c10a55--f3bd658dd1ee488fb85ef4f0cf4ec11a 344d8d58e0d44ffc918a1200dc848e08 f3bd658dd1ee488fb85ef4f0cf4ec11a--344d8d58e0d44ffc918a1200dc848e08 c697f345f4714891bb69b853d8fa67bd 344d8d58e0d44ffc918a1200dc848e08--c697f345f4714891bb69b853d8fa67bd cc40741af2824a1ca528f43c961d1422 c697f345f4714891bb69b853d8fa67bd--cc40741af2824a1ca528f43c961d1422 c1d80f0b1e5c43408fe521315311b883 cc40741af2824a1ca528f43c961d1422--c1d80f0b1e5c43408fe521315311b883 6ae0d765260c4b7db9866288d0cbe4c9 X c1d80f0b1e5c43408fe521315311b883--6ae0d765260c4b7db9866288d0cbe4c9 6ae0d765260c4b7db9866288d0cbe4c9--4230ba663e6e42a2ad20151f5b5e1d08 7c0e70125338409dbc8648d960759d9e 6ae0d765260c4b7db9866288d0cbe4c9--7c0e70125338409dbc8648d960759d9e aa2f726ba5e34854a36589c1ad032ce9 7c0e70125338409dbc8648d960759d9e--aa2f726ba5e34854a36589c1ad032ce9 57fe6676d47444cc897608751302b8b2 aa2f726ba5e34854a36589c1ad032ce9--57fe6676d47444cc897608751302b8b2 29d10492c9d44a77b572296dda8f40e7 57fe6676d47444cc897608751302b8b2--29d10492c9d44a77b572296dda8f40e7 960bd0c3030f47f3a5b97bdfb83e4ba8 29d10492c9d44a77b572296dda8f40e7--960bd0c3030f47f3a5b97bdfb83e4ba8 9dd8b5841afa40f09b47f896e6da8ad5 960bd0c3030f47f3a5b97bdfb83e4ba8--9dd8b5841afa40f09b47f896e6da8ad5 b7a84bc07f58489fa58a636cb786a976 9dd8b5841afa40f09b47f896e6da8ad5--b7a84bc07f58489fa58a636cb786a976 7ff91ae498a94568a4f59643298b55cd b7a84bc07f58489fa58a636cb786a976--7ff91ae498a94568a4f59643298b55cd 6dfc57cda88e4f7098d8082578ef1879 7ff91ae498a94568a4f59643298b55cd--6dfc57cda88e4f7098d8082578ef1879 ac86a86ddee84dd5853152f52b45d4be 6dfc57cda88e4f7098d8082578ef1879--ac86a86ddee84dd5853152f52b45d4be 3c9c81fc39cc4a56a944b91307798303 ac86a86ddee84dd5853152f52b45d4be--3c9c81fc39cc4a56a944b91307798303 28de77ab30a04042943eba7ec73a8bd7 3c9c81fc39cc4a56a944b91307798303--28de77ab30a04042943eba7ec73a8bd7 ef4ff479afbe45ce860463cfd9105c3d 28de77ab30a04042943eba7ec73a8bd7--ef4ff479afbe45ce860463cfd9105c3d 1abc04ada2d1412384b035404913bd79 ef4ff479afbe45ce860463cfd9105c3d--1abc04ada2d1412384b035404913bd79 983d9b246dd94188acb5b4fcf561afb8 1abc04ada2d1412384b035404913bd79--983d9b246dd94188acb5b4fcf561afb8 8b44217514104f5da99b7e4706795507 983d9b246dd94188acb5b4fcf561afb8--8b44217514104f5da99b7e4706795507 8e8e20791da34c7f9a423f6d8e24c3cc 8b44217514104f5da99b7e4706795507--8e8e20791da34c7f9a423f6d8e24c3cc 8dde1d9796e647369bf6148675a1d96b 8e8e20791da34c7f9a423f6d8e24c3cc--8dde1d9796e647369bf6148675a1d96b 24dc918c69884a76ab396e34f82d8e30 8dde1d9796e647369bf6148675a1d96b--24dc918c69884a76ab396e34f82d8e30 3e6a6af5f9ad4940ad514ac0f5aa8215 24dc918c69884a76ab396e34f82d8e30--3e6a6af5f9ad4940ad514ac0f5aa8215 a148db446e864f249e1280a07a17893e 3e6a6af5f9ad4940ad514ac0f5aa8215--a148db446e864f249e1280a07a17893e fa04292e13fc49b2b0c322f1fd4d0a8f a148db446e864f249e1280a07a17893e--fa04292e13fc49b2b0c322f1fd4d0a8f 5d7b6efd3b9a44029400c55e99036af6 fa04292e13fc49b2b0c322f1fd4d0a8f--5d7b6efd3b9a44029400c55e99036af6 a96bc046741d4b8489da16bf6e34fd78 5d7b6efd3b9a44029400c55e99036af6--a96bc046741d4b8489da16bf6e34fd78 1ccb78f1286047f183a2d04e9c62e56c a96bc046741d4b8489da16bf6e34fd78--1ccb78f1286047f183a2d04e9c62e56c 12c4211e320f407fbf171076e565c6cc 1ccb78f1286047f183a2d04e9c62e56c--12c4211e320f407fbf171076e565c6cc 558ce5501ba14917a7735dc648f86e5a 12c4211e320f407fbf171076e565c6cc--558ce5501ba14917a7735dc648f86e5a 6afba7fbdd474758b730e79d2d6fc1fb X 558ce5501ba14917a7735dc648f86e5a--6afba7fbdd474758b730e79d2d6fc1fb 6afba7fbdd474758b730e79d2d6fc1fb--6255d3e120b34bd8963d445ce4e44dc1 dcab319370d0428585cf7ecd23e475bc 6afba7fbdd474758b730e79d2d6fc1fb--dcab319370d0428585cf7ecd23e475bc 9e3c837d379b4dd794f2f3417f654b47 dcab319370d0428585cf7ecd23e475bc--9e3c837d379b4dd794f2f3417f654b47 3254513075af433ab8c91999d7563274 9e3c837d379b4dd794f2f3417f654b47--3254513075af433ab8c91999d7563274 4bd1762b384d4a8ca67190bb62230b0e X 3254513075af433ab8c91999d7563274--4bd1762b384d4a8ca67190bb62230b0e 4bd1762b384d4a8ca67190bb62230b0e--7d580fe039524ae392520f73f4cab5da d0c0902a616b406daeba7317216cb8d2 4bd1762b384d4a8ca67190bb62230b0e--d0c0902a616b406daeba7317216cb8d2 94f090adc0424839ba8683267fa27558 d0c0902a616b406daeba7317216cb8d2--94f090adc0424839ba8683267fa27558 b6e9ef627c14459ab888ba56237b51ae 94f090adc0424839ba8683267fa27558--b6e9ef627c14459ab888ba56237b51ae 7dde8865464a4caf87695b3d1d73cd2a b6e9ef627c14459ab888ba56237b51ae--7dde8865464a4caf87695b3d1d73cd2a c43914e887084e7ea91096cfbcac2252 7dde8865464a4caf87695b3d1d73cd2a--c43914e887084e7ea91096cfbcac2252 27607344ee13490fbdd921020604cf7b c43914e887084e7ea91096cfbcac2252--27607344ee13490fbdd921020604cf7b 2191ba0853dd4202a1826f50c1ed94ec 27607344ee13490fbdd921020604cf7b--2191ba0853dd4202a1826f50c1ed94ec df9a1388b0bc44c889446c87bb6d7199 2191ba0853dd4202a1826f50c1ed94ec--df9a1388b0bc44c889446c87bb6d7199 8e76d4092d1445ea9aa2dc42e8e2315d X df9a1388b0bc44c889446c87bb6d7199--8e76d4092d1445ea9aa2dc42e8e2315d 8e76d4092d1445ea9aa2dc42e8e2315d--e86a46dd41a14eddb293301b84a611d1 255f33c6bffc453da16430a8203cda78 8e76d4092d1445ea9aa2dc42e8e2315d--255f33c6bffc453da16430a8203cda78 3f3a7935b5064411b53f18500c5fe0fd 255f33c6bffc453da16430a8203cda78--3f3a7935b5064411b53f18500c5fe0fd bf9ffa4fbc534e8f8f5ccb1a6692654b 3f3a7935b5064411b53f18500c5fe0fd--bf9ffa4fbc534e8f8f5ccb1a6692654b 6b909b29bb8448a5b5da840c41b78268 bf9ffa4fbc534e8f8f5ccb1a6692654b--6b909b29bb8448a5b5da840c41b78268 08332e3733394a6283038e7937b0a81d 6b909b29bb8448a5b5da840c41b78268--08332e3733394a6283038e7937b0a81d 63fba55f2f964ead9a95fc86b61842fd X 08332e3733394a6283038e7937b0a81d--63fba55f2f964ead9a95fc86b61842fd 63fba55f2f964ead9a95fc86b61842fd--569ea9f491114222a4ba7e7a7b75e647 1324617564364d938d20f7c862210e92 63fba55f2f964ead9a95fc86b61842fd--1324617564364d938d20f7c862210e92 9c392514b19f4f3ba1d47c6ddfdb58c8 1324617564364d938d20f7c862210e92--9c392514b19f4f3ba1d47c6ddfdb58c8 39219b88ed6e46b9bf8c4a365f813608 9c392514b19f4f3ba1d47c6ddfdb58c8--39219b88ed6e46b9bf8c4a365f813608 bee668a384994b8d9be6d1b72827dfe4 39219b88ed6e46b9bf8c4a365f813608--bee668a384994b8d9be6d1b72827dfe4 189dabd506814d2eac97613e65fddcf8 bee668a384994b8d9be6d1b72827dfe4--189dabd506814d2eac97613e65fddcf8 eda38bad25f94223817f621749319698 189dabd506814d2eac97613e65fddcf8--eda38bad25f94223817f621749319698 09138992061141cda842bdb9678a2b80 eda38bad25f94223817f621749319698--09138992061141cda842bdb9678a2b80 9ead8ed38996432bb1cb63d828eec676 09138992061141cda842bdb9678a2b80--9ead8ed38996432bb1cb63d828eec676 615428d067a94e99957bb9d66cc3c2d8 9ead8ed38996432bb1cb63d828eec676--615428d067a94e99957bb9d66cc3c2d8 e47d417a86384a278cb3389e261a0ed1 615428d067a94e99957bb9d66cc3c2d8--e47d417a86384a278cb3389e261a0ed1 bc79976fc9ea45f18409c5a54988ffcc X e47d417a86384a278cb3389e261a0ed1--bc79976fc9ea45f18409c5a54988ffcc bc79976fc9ea45f18409c5a54988ffcc--e2064007f65f40df942745aca99af475 b97c8120ba8b4687bd7f7281a6745990 RZ(-1.0*g0) bc79976fc9ea45f18409c5a54988ffcc--b97c8120ba8b4687bd7f7281a6745990 56c7d778e4ce4fa98f52c19c60711d1c X b97c8120ba8b4687bd7f7281a6745990--56c7d778e4ce4fa98f52c19c60711d1c 56c7d778e4ce4fa98f52c19c60711d1c--111429ebc36e47a6a6b4eb0329caf3e9 540eca55da0e4da6ac29332dfab40078 56c7d778e4ce4fa98f52c19c60711d1c--540eca55da0e4da6ac29332dfab40078 1febdc3544204c9a8fc33e615c479533 540eca55da0e4da6ac29332dfab40078--1febdc3544204c9a8fc33e615c479533 9cdb4b4958b74873b5b530cd281e877f 1febdc3544204c9a8fc33e615c479533--9cdb4b4958b74873b5b530cd281e877f a821f22ca29e4ee0bda99cc8fede85d1 9cdb4b4958b74873b5b530cd281e877f--a821f22ca29e4ee0bda99cc8fede85d1 d252be141b11485c95a296bc7995dd46 a821f22ca29e4ee0bda99cc8fede85d1--d252be141b11485c95a296bc7995dd46 f5261c1779ef463298cd80d042abb3ce d252be141b11485c95a296bc7995dd46--f5261c1779ef463298cd80d042abb3ce aa2acaa5680041009932a1c26cb8fe99 f5261c1779ef463298cd80d042abb3ce--aa2acaa5680041009932a1c26cb8fe99 a316cf03ef8b49978206c80e00355bb8 aa2acaa5680041009932a1c26cb8fe99--a316cf03ef8b49978206c80e00355bb8 15030e9b8cbe4651b6d10b725114a816 a316cf03ef8b49978206c80e00355bb8--15030e9b8cbe4651b6d10b725114a816 0477bf114c034a38898e4e36cec88fe2 15030e9b8cbe4651b6d10b725114a816--0477bf114c034a38898e4e36cec88fe2 68af5bc6753742ebb4ed4ee972153a4d X 0477bf114c034a38898e4e36cec88fe2--68af5bc6753742ebb4ed4ee972153a4d 68af5bc6753742ebb4ed4ee972153a4d--a1f4ca5462764b9a9ee2deba6d21e5a2 83a3e1ac97734e7191b05b2bd4dfe5f1 RZ(-1.0*g0) 68af5bc6753742ebb4ed4ee972153a4d--83a3e1ac97734e7191b05b2bd4dfe5f1 dfd3a54c2aaf40c69eb1a54127282528 X 83a3e1ac97734e7191b05b2bd4dfe5f1--dfd3a54c2aaf40c69eb1a54127282528 dfd3a54c2aaf40c69eb1a54127282528--f608561128324a879a0cb2fb144a3c04 8c24fe85f5614ebcb280d008f52ad960 dfd3a54c2aaf40c69eb1a54127282528--8c24fe85f5614ebcb280d008f52ad960 7ee477f0995644349def98fa401e4900 8c24fe85f5614ebcb280d008f52ad960--7ee477f0995644349def98fa401e4900 0d5802d9dda24cbd8800fb6dc26275df 7ee477f0995644349def98fa401e4900--0d5802d9dda24cbd8800fb6dc26275df e210a5c042934eabb141b890f23b9b33 0d5802d9dda24cbd8800fb6dc26275df--e210a5c042934eabb141b890f23b9b33 4f661e96b3804b8f9efd869f19039adb X e210a5c042934eabb141b890f23b9b33--4f661e96b3804b8f9efd869f19039adb 4f661e96b3804b8f9efd869f19039adb--75db85bc4d8e44e2b4bdbe15b39732ff ea8be5ef2b444144a016fe6685b90deb 4f661e96b3804b8f9efd869f19039adb--ea8be5ef2b444144a016fe6685b90deb ca9b99671d9749f5adf5bda4781ccc77 ea8be5ef2b444144a016fe6685b90deb--ca9b99671d9749f5adf5bda4781ccc77 6a13758dc5e649798dc3a805c0ddf974 ca9b99671d9749f5adf5bda4781ccc77--6a13758dc5e649798dc3a805c0ddf974 707e07a5792a45cca786031373416061 X 6a13758dc5e649798dc3a805c0ddf974--707e07a5792a45cca786031373416061 707e07a5792a45cca786031373416061--2c8d37a94217420ab40873a9d29a3018 e2c79f4830c54d4f8caf9ccae70214f0 707e07a5792a45cca786031373416061--e2c79f4830c54d4f8caf9ccae70214f0 7fcf3795cd3049718f686ff60136577e e2c79f4830c54d4f8caf9ccae70214f0--7fcf3795cd3049718f686ff60136577e dce9f61884ac42b3b2e917a72d7ee6ca 7fcf3795cd3049718f686ff60136577e--dce9f61884ac42b3b2e917a72d7ee6ca ad74fe0e0fd649769e70bcc5e2f7311d dce9f61884ac42b3b2e917a72d7ee6ca--ad74fe0e0fd649769e70bcc5e2f7311d 4f574b2492d740408e86bac50c68e569 X ad74fe0e0fd649769e70bcc5e2f7311d--4f574b2492d740408e86bac50c68e569 4f574b2492d740408e86bac50c68e569--1a569bdd56be49ca8bebc3f7cd6bf6b7 96096e3d7ca44bf2a97ecdce976357a6 4f574b2492d740408e86bac50c68e569--96096e3d7ca44bf2a97ecdce976357a6 e843bb17c98a4ae7a3a438bf427d34f9 96096e3d7ca44bf2a97ecdce976357a6--e843bb17c98a4ae7a3a438bf427d34f9 85fcc374914142d2a3a31a64120065f5 e843bb17c98a4ae7a3a438bf427d34f9--85fcc374914142d2a3a31a64120065f5 12d04fbc1281400ab88afdf865220869 85fcc374914142d2a3a31a64120065f5--12d04fbc1281400ab88afdf865220869 6e644495850841bc8cad93ee9fcf03c6 12d04fbc1281400ab88afdf865220869--6e644495850841bc8cad93ee9fcf03c6 8f9234bc1e3b48bc89d6d36718f9a629 X 6e644495850841bc8cad93ee9fcf03c6--8f9234bc1e3b48bc89d6d36718f9a629 8f9234bc1e3b48bc89d6d36718f9a629--902c96b572ee4a39b665ba5b936f5a5a 6915fac3e22047798f6078b20ccff3e9 8f9234bc1e3b48bc89d6d36718f9a629--6915fac3e22047798f6078b20ccff3e9 e9db4241a52644f081dff64081994eb0 6915fac3e22047798f6078b20ccff3e9--e9db4241a52644f081dff64081994eb0 2ca7f5e5b16b440fada46dab9457ffa6 e9db4241a52644f081dff64081994eb0--2ca7f5e5b16b440fada46dab9457ffa6 0a32a08a6d974f97b6d75cb819eed579 2ca7f5e5b16b440fada46dab9457ffa6--0a32a08a6d974f97b6d75cb819eed579 69e5e80595594fda8750a10bf4f84204 0a32a08a6d974f97b6d75cb819eed579--69e5e80595594fda8750a10bf4f84204 109df04c5e684083b0a56429d911e1c8 69e5e80595594fda8750a10bf4f84204--109df04c5e684083b0a56429d911e1c8 ca40915de201499a951242a104ec13df X 109df04c5e684083b0a56429d911e1c8--ca40915de201499a951242a104ec13df ca40915de201499a951242a104ec13df--8ce9289e2c0746b594b58d7761132e8c 559552a72a4d475a8aa3c4603785920b RZ(-1.0*g0) ca40915de201499a951242a104ec13df--559552a72a4d475a8aa3c4603785920b aa755efd82c4465882bd93259253ee10 X 559552a72a4d475a8aa3c4603785920b--aa755efd82c4465882bd93259253ee10 aa755efd82c4465882bd93259253ee10--3b3d5380f3aa46d49916c139114fcae2 d386d0c47bbc431ab4bcb44ced3ba83b aa755efd82c4465882bd93259253ee10--d386d0c47bbc431ab4bcb44ced3ba83b e415fcd8a38242bab36ccc966f202dbe d386d0c47bbc431ab4bcb44ced3ba83b--e415fcd8a38242bab36ccc966f202dbe b64156b475a848908f6ff7f86e723229 X e415fcd8a38242bab36ccc966f202dbe--b64156b475a848908f6ff7f86e723229 b64156b475a848908f6ff7f86e723229--97e03a8ad69149709701881d79c05ccb ee01d0dabdd242dfb7c49047e9bcf7c0 b64156b475a848908f6ff7f86e723229--ee01d0dabdd242dfb7c49047e9bcf7c0 48102a7cfff74abd9abeca72406f47b0 ee01d0dabdd242dfb7c49047e9bcf7c0--48102a7cfff74abd9abeca72406f47b0 5279e67925ac45aab69ca1fed7dbe26b 48102a7cfff74abd9abeca72406f47b0--5279e67925ac45aab69ca1fed7dbe26b 40a2489b47014ef2afc983cf73b1ed89 X 5279e67925ac45aab69ca1fed7dbe26b--40a2489b47014ef2afc983cf73b1ed89 40a2489b47014ef2afc983cf73b1ed89--4d2e151212e043bc8728c2d2b87d28c3 b92c40cb904146e2b8d1dae4d0601109 40a2489b47014ef2afc983cf73b1ed89--b92c40cb904146e2b8d1dae4d0601109 b121ac47009242929a7cedeabf163374 X b92c40cb904146e2b8d1dae4d0601109--b121ac47009242929a7cedeabf163374 b121ac47009242929a7cedeabf163374--3ff689c89f3c424794434bd8b74ac4c5 8682ba6f97294309bf55d1e8de131024 b121ac47009242929a7cedeabf163374--8682ba6f97294309bf55d1e8de131024 ae96392514cd44fa8d47460da23c8c44 8682ba6f97294309bf55d1e8de131024--ae96392514cd44fa8d47460da23c8c44 7e9c0c59866247a88daacb36e92b7e9d ae96392514cd44fa8d47460da23c8c44--7e9c0c59866247a88daacb36e92b7e9d dcd61cd3270f44bf867d3f7ba1bca334 X 7e9c0c59866247a88daacb36e92b7e9d--dcd61cd3270f44bf867d3f7ba1bca334 dcd61cd3270f44bf867d3f7ba1bca334--fd30168fc19442ff84bf8d78209643e4 7e14c442af854bc3829e9b96ef623824 dcd61cd3270f44bf867d3f7ba1bca334--7e14c442af854bc3829e9b96ef623824 f3d194edf65447d19ec6b6053bdbcb82 7e14c442af854bc3829e9b96ef623824--f3d194edf65447d19ec6b6053bdbcb82 210f317ac3044af0a32442540c9f36b2 f3d194edf65447d19ec6b6053bdbcb82--210f317ac3044af0a32442540c9f36b2 aac58b4b459a45c8b2583a74e5a9518f RX(b05) 210f317ac3044af0a32442540c9f36b2--aac58b4b459a45c8b2583a74e5a9518f f32c5932ccde43edb1f43353e7dba5fd aac58b4b459a45c8b2583a74e5a9518f--f32c5932ccde43edb1f43353e7dba5fd d68efe20809d43a69b96e29c402acd53 f32c5932ccde43edb1f43353e7dba5fd--d68efe20809d43a69b96e29c402acd53 4504ead29eb546c297dee72829d50a1e d68efe20809d43a69b96e29c402acd53--4504ead29eb546c297dee72829d50a1e a8959360861c4ec2975efea383d9359e 4504ead29eb546c297dee72829d50a1e--a8959360861c4ec2975efea383d9359e ad30ddc3f74845b7b36c642b3e5f437e X a8959360861c4ec2975efea383d9359e--ad30ddc3f74845b7b36c642b3e5f437e ad30ddc3f74845b7b36c642b3e5f437e--0d12364f2bb94f638db64ac9ea312862 f8cccf81961f4e7ba01e0cdae3408801 ad30ddc3f74845b7b36c642b3e5f437e--f8cccf81961f4e7ba01e0cdae3408801 fb34c3475710429084756b8b462ae4f3 f8cccf81961f4e7ba01e0cdae3408801--fb34c3475710429084756b8b462ae4f3 7d4c3448fb1845718c7371761a2fbd56 fb34c3475710429084756b8b462ae4f3--7d4c3448fb1845718c7371761a2fbd56 f70f13024a684497b5dcba5002ef7dbd 7d4c3448fb1845718c7371761a2fbd56--f70f13024a684497b5dcba5002ef7dbd 760cb12d3ad6437daa56894c1951897a f70f13024a684497b5dcba5002ef7dbd--760cb12d3ad6437daa56894c1951897a 760f8d5d51b54f92a96b279ae54ab405 X 760cb12d3ad6437daa56894c1951897a--760f8d5d51b54f92a96b279ae54ab405 760f8d5d51b54f92a96b279ae54ab405--3dee9a576be54201b65eda8d503fbfd8 6912d4170e454e588298f4121f5def47 760f8d5d51b54f92a96b279ae54ab405--6912d4170e454e588298f4121f5def47 d2b17679eac745f1a7bb06d0096c25b5 6912d4170e454e588298f4121f5def47--d2b17679eac745f1a7bb06d0096c25b5 c25a9bf7f872450ea4ef5509973baf09 d2b17679eac745f1a7bb06d0096c25b5--c25a9bf7f872450ea4ef5509973baf09 7f54bc594ad54f5090f1f21697036822 c25a9bf7f872450ea4ef5509973baf09--7f54bc594ad54f5090f1f21697036822 18475c387606465ab774487f17d82faa 7f54bc594ad54f5090f1f21697036822--18475c387606465ab774487f17d82faa 4afac9d10fdb4e259df321ae0c14aaab 18475c387606465ab774487f17d82faa--4afac9d10fdb4e259df321ae0c14aaab eacf4d0fb15b492bbc0fedfbf4a2be31 4afac9d10fdb4e259df321ae0c14aaab--eacf4d0fb15b492bbc0fedfbf4a2be31 41cd1eb1b8eb4dcebe1c06c1234e3e3c eacf4d0fb15b492bbc0fedfbf4a2be31--41cd1eb1b8eb4dcebe1c06c1234e3e3c 485412d1aa324723ba32e921f40a37e8 41cd1eb1b8eb4dcebe1c06c1234e3e3c--485412d1aa324723ba32e921f40a37e8 8c5dee763a1d4c19a408eea97df36343 485412d1aa324723ba32e921f40a37e8--8c5dee763a1d4c19a408eea97df36343 e6369fc457ef4f7aaacccabe165a1118 8c5dee763a1d4c19a408eea97df36343--e6369fc457ef4f7aaacccabe165a1118 95d66d460e3c4d12abfc1ee67382eaca e6369fc457ef4f7aaacccabe165a1118--95d66d460e3c4d12abfc1ee67382eaca a694496080f44bed9f9d164f34da5e45 95d66d460e3c4d12abfc1ee67382eaca--a694496080f44bed9f9d164f34da5e45 dc92dda19e484261ba155f914ed33d3d a694496080f44bed9f9d164f34da5e45--dc92dda19e484261ba155f914ed33d3d d68fd6c6d556431c8a13b761ce13ff18 dc92dda19e484261ba155f914ed33d3d--d68fd6c6d556431c8a13b761ce13ff18 b416bcf6213f4d52b0a6536646eac185 d68fd6c6d556431c8a13b761ce13ff18--b416bcf6213f4d52b0a6536646eac185 ca15b332a1714bf593ad60853bf82572 b416bcf6213f4d52b0a6536646eac185--ca15b332a1714bf593ad60853bf82572 53fef05782df4691ace1d3cf1dded792 ca15b332a1714bf593ad60853bf82572--53fef05782df4691ace1d3cf1dded792 ce3be7a669c34815b1ac3819a8496e1f 53fef05782df4691ace1d3cf1dded792--ce3be7a669c34815b1ac3819a8496e1f a0c98019d86244ca99c9bee84a61fca3 ce3be7a669c34815b1ac3819a8496e1f--a0c98019d86244ca99c9bee84a61fca3 42b8133891e24ce8b20c59aee5693089 a0c98019d86244ca99c9bee84a61fca3--42b8133891e24ce8b20c59aee5693089 f27ca1ba5b2c48a994d39709b7e58e4d 42b8133891e24ce8b20c59aee5693089--f27ca1ba5b2c48a994d39709b7e58e4d 4a057a7f63c64ca88b0369f9b1502fae f27ca1ba5b2c48a994d39709b7e58e4d--4a057a7f63c64ca88b0369f9b1502fae 019426c1fc214213b6c30b03dfd826d0 4a057a7f63c64ca88b0369f9b1502fae--019426c1fc214213b6c30b03dfd826d0 3d05675658244a16b2f3bbf2917136ee 019426c1fc214213b6c30b03dfd826d0--3d05675658244a16b2f3bbf2917136ee 2df7da0de1fe426ba54330653fdafb18 3d05675658244a16b2f3bbf2917136ee--2df7da0de1fe426ba54330653fdafb18 3a78b7bbf3a04f4d92cd1870ae0179e9 2df7da0de1fe426ba54330653fdafb18--3a78b7bbf3a04f4d92cd1870ae0179e9 f86e141fb4a44f7bbe0db262910ec6aa X 3a78b7bbf3a04f4d92cd1870ae0179e9--f86e141fb4a44f7bbe0db262910ec6aa f86e141fb4a44f7bbe0db262910ec6aa--89fe63f3e0724e9fb36e78fffaddf558 fc208863c6894b46b6342dd5218ccf66 f86e141fb4a44f7bbe0db262910ec6aa--fc208863c6894b46b6342dd5218ccf66 819489826d8d48739844b6b476052774 fc208863c6894b46b6342dd5218ccf66--819489826d8d48739844b6b476052774 f904472e215f4984a236b2392377fa56 819489826d8d48739844b6b476052774--f904472e215f4984a236b2392377fa56 da0543a810d84433938c5d9cd0205213 X f904472e215f4984a236b2392377fa56--da0543a810d84433938c5d9cd0205213 da0543a810d84433938c5d9cd0205213--747136843dc3449f8e2455fbb561cdf8 b87d32e193ab4ba69418847a45e7b238 da0543a810d84433938c5d9cd0205213--b87d32e193ab4ba69418847a45e7b238 0c59268e9bc24e09b491a5b915178531 b87d32e193ab4ba69418847a45e7b238--0c59268e9bc24e09b491a5b915178531 0b937adb1ef643009872fb00b5dd7bad 0c59268e9bc24e09b491a5b915178531--0b937adb1ef643009872fb00b5dd7bad f1b6d4fdb4c14d968798607d7c31bc92 0b937adb1ef643009872fb00b5dd7bad--f1b6d4fdb4c14d968798607d7c31bc92 7b67fa8a797a45869e367f97a32571bf f1b6d4fdb4c14d968798607d7c31bc92--7b67fa8a797a45869e367f97a32571bf 9c6e8dbfa9204849b768f627e203c02a 7b67fa8a797a45869e367f97a32571bf--9c6e8dbfa9204849b768f627e203c02a 85a54cdd5fca45118262afd1eddc4938 9c6e8dbfa9204849b768f627e203c02a--85a54cdd5fca45118262afd1eddc4938 e7f7ddfe73ee43c7b5e1ab08879e676e 85a54cdd5fca45118262afd1eddc4938--e7f7ddfe73ee43c7b5e1ab08879e676e 9a15144766e746d999a8b6c9f079c5d5 X e7f7ddfe73ee43c7b5e1ab08879e676e--9a15144766e746d999a8b6c9f079c5d5 9a15144766e746d999a8b6c9f079c5d5--8564320c350240d1924ea15fbc25eb2c 4522eda152114ea1bb48bbbe3c495c85 9a15144766e746d999a8b6c9f079c5d5--4522eda152114ea1bb48bbbe3c495c85 5ad94238f44b4c07a3e499fa578e0e3f 4522eda152114ea1bb48bbbe3c495c85--5ad94238f44b4c07a3e499fa578e0e3f bb3595cc3be24d9c9c61a0fa902a7a4c 5ad94238f44b4c07a3e499fa578e0e3f--bb3595cc3be24d9c9c61a0fa902a7a4c d289880cc1b6437185113b79c60e7ee7 bb3595cc3be24d9c9c61a0fa902a7a4c--d289880cc1b6437185113b79c60e7ee7 e175df7ffbcc4863a2c34a228d1ecd28 d289880cc1b6437185113b79c60e7ee7--e175df7ffbcc4863a2c34a228d1ecd28 ef9fc01bf6f342a6a172b42336876fab X e175df7ffbcc4863a2c34a228d1ecd28--ef9fc01bf6f342a6a172b42336876fab ef9fc01bf6f342a6a172b42336876fab--fc07cd9a77bc4b2ea8d139628ce1889d c3b66522f82642a7b5eb2c4b5be309d9 ef9fc01bf6f342a6a172b42336876fab--c3b66522f82642a7b5eb2c4b5be309d9 628a4f29998b47e0b4a471720b4f1607 c3b66522f82642a7b5eb2c4b5be309d9--628a4f29998b47e0b4a471720b4f1607 26c2dd6f73b94bda99efd5a820cc4e10 628a4f29998b47e0b4a471720b4f1607--26c2dd6f73b94bda99efd5a820cc4e10 8000ddacd5c247729f569f287cf0b4f4 26c2dd6f73b94bda99efd5a820cc4e10--8000ddacd5c247729f569f287cf0b4f4 25e3561d9b2c45a098e09bd40b0c4c82 8000ddacd5c247729f569f287cf0b4f4--25e3561d9b2c45a098e09bd40b0c4c82 ff963a423cf94798838380aa57b5a012 25e3561d9b2c45a098e09bd40b0c4c82--ff963a423cf94798838380aa57b5a012 4cf58d4d9bbe458aa23dd5c39f1075bf ff963a423cf94798838380aa57b5a012--4cf58d4d9bbe458aa23dd5c39f1075bf 36305b9e90a6467394242b029b5253d3 4cf58d4d9bbe458aa23dd5c39f1075bf--36305b9e90a6467394242b029b5253d3 96f59aa798cf4c9b85d738dc334a43f0 36305b9e90a6467394242b029b5253d3--96f59aa798cf4c9b85d738dc334a43f0 734668f00dbc4bc7a6f07eaa7990d4bc 96f59aa798cf4c9b85d738dc334a43f0--734668f00dbc4bc7a6f07eaa7990d4bc cd4a71c3244447c2b904bcebec6ab901 X 734668f00dbc4bc7a6f07eaa7990d4bc--cd4a71c3244447c2b904bcebec6ab901 cd4a71c3244447c2b904bcebec6ab901--3d51b4fb617d490fa419f10ecfc47600 93b6d2cc4e0e437abeb1e510fa9cad43 RZ(-1.0*g1) cd4a71c3244447c2b904bcebec6ab901--93b6d2cc4e0e437abeb1e510fa9cad43 1eeec955700b42fe8532aa88651e7758 X 93b6d2cc4e0e437abeb1e510fa9cad43--1eeec955700b42fe8532aa88651e7758 1eeec955700b42fe8532aa88651e7758--5a3c263f177242c79e977ab04e6eccfa f435766b57c1481e8ec97a50b1b8231d 1eeec955700b42fe8532aa88651e7758--f435766b57c1481e8ec97a50b1b8231d db9bfb69c6af442aabc7d42e99e7d809 f435766b57c1481e8ec97a50b1b8231d--db9bfb69c6af442aabc7d42e99e7d809 97316e1ff0e449208ff2b8675f92fb9a db9bfb69c6af442aabc7d42e99e7d809--97316e1ff0e449208ff2b8675f92fb9a aea5e74584b14a6daf0cfbe3c55ba4f3 97316e1ff0e449208ff2b8675f92fb9a--aea5e74584b14a6daf0cfbe3c55ba4f3 bdf1c5e3a06345bda2c5ecd98a15237f aea5e74584b14a6daf0cfbe3c55ba4f3--bdf1c5e3a06345bda2c5ecd98a15237f ebeeb92ac7aa4de189d8e147966fb7ab bdf1c5e3a06345bda2c5ecd98a15237f--ebeeb92ac7aa4de189d8e147966fb7ab 9f49bcc93fc44ea98c39ccc690c80866 ebeeb92ac7aa4de189d8e147966fb7ab--9f49bcc93fc44ea98c39ccc690c80866 ffe1c2f966ca4edbbb9902754f4c380d 9f49bcc93fc44ea98c39ccc690c80866--ffe1c2f966ca4edbbb9902754f4c380d 278702467e0b4dc8b1221933e5348ce5 ffe1c2f966ca4edbbb9902754f4c380d--278702467e0b4dc8b1221933e5348ce5 edd1bd5f0c434a6baee54f9d00c22e6b 278702467e0b4dc8b1221933e5348ce5--edd1bd5f0c434a6baee54f9d00c22e6b ee769c61c0f74f0d84ae7da5e28128c7 X edd1bd5f0c434a6baee54f9d00c22e6b--ee769c61c0f74f0d84ae7da5e28128c7 ee769c61c0f74f0d84ae7da5e28128c7--073323a9d484462abf9ec2303707446c 8562e39598bd452ca05c59d82b109a51 RZ(-1.0*g1) ee769c61c0f74f0d84ae7da5e28128c7--8562e39598bd452ca05c59d82b109a51 5ae7fc3b131943dc845af35030ab6676 X 8562e39598bd452ca05c59d82b109a51--5ae7fc3b131943dc845af35030ab6676 5ae7fc3b131943dc845af35030ab6676--aea667cb7c2d4381a261738ec4edfa6b a296c4681fb4468682cf271bb825a65a 5ae7fc3b131943dc845af35030ab6676--a296c4681fb4468682cf271bb825a65a 2b96ecb2a0a84c98945fec8645c17565 a296c4681fb4468682cf271bb825a65a--2b96ecb2a0a84c98945fec8645c17565 f3be4f861d894878ab8de829a51e9504 2b96ecb2a0a84c98945fec8645c17565--f3be4f861d894878ab8de829a51e9504 55976df5ea5c4e7fbaf9e7f2658759c9 f3be4f861d894878ab8de829a51e9504--55976df5ea5c4e7fbaf9e7f2658759c9 63ac0d224eea44e69ce4078b9daad11a X 55976df5ea5c4e7fbaf9e7f2658759c9--63ac0d224eea44e69ce4078b9daad11a 63ac0d224eea44e69ce4078b9daad11a--c3eb8a6ed4f14012a6b773ec7f48fef7 e38e958d45384854a9efb2ac2c9e1fc1 63ac0d224eea44e69ce4078b9daad11a--e38e958d45384854a9efb2ac2c9e1fc1 7d3acb04530749148843b23eb2b39953 e38e958d45384854a9efb2ac2c9e1fc1--7d3acb04530749148843b23eb2b39953 d8116b4f10794756a7770171e7c3bbde 7d3acb04530749148843b23eb2b39953--d8116b4f10794756a7770171e7c3bbde 908fdb2225ca463bb7cab866ffc51466 X d8116b4f10794756a7770171e7c3bbde--908fdb2225ca463bb7cab866ffc51466 908fdb2225ca463bb7cab866ffc51466--f33675b37fb549f2b6d984fb9a2d3dee ba1bb6c770514a8999dc8c4789f306fe 908fdb2225ca463bb7cab866ffc51466--ba1bb6c770514a8999dc8c4789f306fe d1ef8ca7dc1f42438a620aa25cd2e5a0 ba1bb6c770514a8999dc8c4789f306fe--d1ef8ca7dc1f42438a620aa25cd2e5a0 18df2a9ff30041538782930513444aad d1ef8ca7dc1f42438a620aa25cd2e5a0--18df2a9ff30041538782930513444aad 3635a078c7d84426a5bfecb7ed4e3fb5 18df2a9ff30041538782930513444aad--3635a078c7d84426a5bfecb7ed4e3fb5 fde2bd824be04a28b390f0e373938d03 X 3635a078c7d84426a5bfecb7ed4e3fb5--fde2bd824be04a28b390f0e373938d03 fde2bd824be04a28b390f0e373938d03--d75eff34607843f88b0d3c94cbce0bc3 f49389177ad44c71b20a2c84b112455f fde2bd824be04a28b390f0e373938d03--f49389177ad44c71b20a2c84b112455f 0cb7afc0b843494193912bd244548af5 f49389177ad44c71b20a2c84b112455f--0cb7afc0b843494193912bd244548af5 4054bab7db8847ecaf227631e78f9d99 0cb7afc0b843494193912bd244548af5--4054bab7db8847ecaf227631e78f9d99 6d3193c3bcb042cd8863d61de42467c5 4054bab7db8847ecaf227631e78f9d99--6d3193c3bcb042cd8863d61de42467c5 f2978dce84e74c1d9ed94cae3ede3ce5 6d3193c3bcb042cd8863d61de42467c5--f2978dce84e74c1d9ed94cae3ede3ce5 6ccf7b6360a74ca2a21235a385c47604 X f2978dce84e74c1d9ed94cae3ede3ce5--6ccf7b6360a74ca2a21235a385c47604 6ccf7b6360a74ca2a21235a385c47604--ecdae3366db9450e8243e12a1998e39d 372c61eace0f4c3392b42b0e66d2bb01 6ccf7b6360a74ca2a21235a385c47604--372c61eace0f4c3392b42b0e66d2bb01 9342d434bc8a41bc833f18438dc758f5 372c61eace0f4c3392b42b0e66d2bb01--9342d434bc8a41bc833f18438dc758f5 e38c416f5acb4b948ac363626f8fa6c8 9342d434bc8a41bc833f18438dc758f5--e38c416f5acb4b948ac363626f8fa6c8 85fedcd654e940da8a068e18192ab775 e38c416f5acb4b948ac363626f8fa6c8--85fedcd654e940da8a068e18192ab775 cea6115c6fef405a8076a69e7120b1d8 85fedcd654e940da8a068e18192ab775--cea6115c6fef405a8076a69e7120b1d8 e3e8ddd867fe4d8198eafae26437eaee cea6115c6fef405a8076a69e7120b1d8--e3e8ddd867fe4d8198eafae26437eaee 30a0d837fd1e48e7b28d627334321de6 X e3e8ddd867fe4d8198eafae26437eaee--30a0d837fd1e48e7b28d627334321de6 30a0d837fd1e48e7b28d627334321de6--c179328a9f2044b3bf781e16facabf0f 7a995ea1e0f443299d3d7e1f5032d3f0 RZ(-1.0*g1) 30a0d837fd1e48e7b28d627334321de6--7a995ea1e0f443299d3d7e1f5032d3f0 b529060d2426402685704e01b6b29a2b X 7a995ea1e0f443299d3d7e1f5032d3f0--b529060d2426402685704e01b6b29a2b b529060d2426402685704e01b6b29a2b--42c452bbcb7f498abbeec8b64dd50e36 5e81b94af749424cb5ced42c6c9d1af0 b529060d2426402685704e01b6b29a2b--5e81b94af749424cb5ced42c6c9d1af0 443de55b650643a898224e5b1081eeab 5e81b94af749424cb5ced42c6c9d1af0--443de55b650643a898224e5b1081eeab 4aa9826f37ac41839be7ed309f7d534f X 443de55b650643a898224e5b1081eeab--4aa9826f37ac41839be7ed309f7d534f 4aa9826f37ac41839be7ed309f7d534f--7cd7fa1f80ea4979afbab0b40e931053 0107245181f44505860fa6803ab14ef2 4aa9826f37ac41839be7ed309f7d534f--0107245181f44505860fa6803ab14ef2 c0128025bc7d48c9b4e514ebe487f6b5 0107245181f44505860fa6803ab14ef2--c0128025bc7d48c9b4e514ebe487f6b5 2c04cdc10b0b4746add9dbc4f8aff503 c0128025bc7d48c9b4e514ebe487f6b5--2c04cdc10b0b4746add9dbc4f8aff503 1948296634c749b989ff8bdafb06a368 X 2c04cdc10b0b4746add9dbc4f8aff503--1948296634c749b989ff8bdafb06a368 1948296634c749b989ff8bdafb06a368--d6e1f5e9a8ad4ce8a4a32eb5f72743b6 4b201d78987d43b2bad7dec60c26a0f3 1948296634c749b989ff8bdafb06a368--4b201d78987d43b2bad7dec60c26a0f3 f57260e7da5e448d840ba02b83ad8fc7 X 4b201d78987d43b2bad7dec60c26a0f3--f57260e7da5e448d840ba02b83ad8fc7 f57260e7da5e448d840ba02b83ad8fc7--c16cde55106a4c58ad5c6d5982a526b7 a88e1f464a9b4215928633822e0fa492 f57260e7da5e448d840ba02b83ad8fc7--a88e1f464a9b4215928633822e0fa492 82a7237dbdb54e0daece4d6b01a16e69 a88e1f464a9b4215928633822e0fa492--82a7237dbdb54e0daece4d6b01a16e69 81dd9d4b9be24ec39445af889f66c6c3 82a7237dbdb54e0daece4d6b01a16e69--81dd9d4b9be24ec39445af889f66c6c3 0d222f0fb2ba49f7a20016fd3e433050 X 81dd9d4b9be24ec39445af889f66c6c3--0d222f0fb2ba49f7a20016fd3e433050 0d222f0fb2ba49f7a20016fd3e433050--753cbde5ecda4051bce7932865e8f28a f0fe82b58ace47caa1cd485b40add0ad 0d222f0fb2ba49f7a20016fd3e433050--f0fe82b58ace47caa1cd485b40add0ad 0db9fadc2fae4ceca986d28562545611 f0fe82b58ace47caa1cd485b40add0ad--0db9fadc2fae4ceca986d28562545611 3d701455f3a74f5783a25e010007c5ee 0db9fadc2fae4ceca986d28562545611--3d701455f3a74f5783a25e010007c5ee 582ac663c9974448940ad334f0d2b051 RX(b15) 3d701455f3a74f5783a25e010007c5ee--582ac663c9974448940ad334f0d2b051 582ac663c9974448940ad334f0d2b051--49c19b161c6941e5842d953f3c82f619 8f4557fd1c6f472b85c3c15b9ca5054d e05f082df7bf4a37bb3494606d8c16c5 892cf8d44d9e4c9188c0e8aa39cd94c1--e05f082df7bf4a37bb3494606d8c16c5 43e60aa838e84d07ac139ce3d39d9b89 7 083862db91754232bf94d2b3a29f51cb e05f082df7bf4a37bb3494606d8c16c5--083862db91754232bf94d2b3a29f51cb 02f69f71c113418b8b4e6d0ad8294cef 083862db91754232bf94d2b3a29f51cb--02f69f71c113418b8b4e6d0ad8294cef d28eaa26d5a04cf087d215046c39e9e9 02f69f71c113418b8b4e6d0ad8294cef--d28eaa26d5a04cf087d215046c39e9e9 c5c1506ddf0e4e319460fbbcdae29ee3 d28eaa26d5a04cf087d215046c39e9e9--c5c1506ddf0e4e319460fbbcdae29ee3 22858ac2ec664e2d89586a2466f7b536 X c5c1506ddf0e4e319460fbbcdae29ee3--22858ac2ec664e2d89586a2466f7b536 22858ac2ec664e2d89586a2466f7b536--f3bd658dd1ee488fb85ef4f0cf4ec11a f61ef106b88b464da62fa1b0ae5f4da2 22858ac2ec664e2d89586a2466f7b536--f61ef106b88b464da62fa1b0ae5f4da2 42337a55ba87460ba79a4676c5c2fa05 f61ef106b88b464da62fa1b0ae5f4da2--42337a55ba87460ba79a4676c5c2fa05 8876eafb95ff485585c159ef20a59172 42337a55ba87460ba79a4676c5c2fa05--8876eafb95ff485585c159ef20a59172 6e7404ddc2044e959cb564d693080e04 X 8876eafb95ff485585c159ef20a59172--6e7404ddc2044e959cb564d693080e04 6e7404ddc2044e959cb564d693080e04--c1d80f0b1e5c43408fe521315311b883 1c9702ce350d4ddb8e6cb23a788826d5 6e7404ddc2044e959cb564d693080e04--1c9702ce350d4ddb8e6cb23a788826d5 08021d9bfd0749cba6e6491c1126258f 1c9702ce350d4ddb8e6cb23a788826d5--08021d9bfd0749cba6e6491c1126258f 7110c9d1e88d4893a95f74afdf674785 08021d9bfd0749cba6e6491c1126258f--7110c9d1e88d4893a95f74afdf674785 5cd15d8b0c774d32be09495bfab32be4 7110c9d1e88d4893a95f74afdf674785--5cd15d8b0c774d32be09495bfab32be4 8cdaa3f16b134040a4bdf77235aff651 5cd15d8b0c774d32be09495bfab32be4--8cdaa3f16b134040a4bdf77235aff651 091bdf74e51949518f901d0d21fb913b 8cdaa3f16b134040a4bdf77235aff651--091bdf74e51949518f901d0d21fb913b 3643330abec54f5b96d1c32fb16f53a1 091bdf74e51949518f901d0d21fb913b--3643330abec54f5b96d1c32fb16f53a1 fa93daa276cc4c7dabf3ec7c5d8cf446 3643330abec54f5b96d1c32fb16f53a1--fa93daa276cc4c7dabf3ec7c5d8cf446 648290becb0e44d6ba0dd922bd482ead fa93daa276cc4c7dabf3ec7c5d8cf446--648290becb0e44d6ba0dd922bd482ead af2ffdc1aa9a427f8c681efefca47930 648290becb0e44d6ba0dd922bd482ead--af2ffdc1aa9a427f8c681efefca47930 afa8da6212054e26a736243b5038788f af2ffdc1aa9a427f8c681efefca47930--afa8da6212054e26a736243b5038788f 7522b87f94dc4582b19c40dea221c42d afa8da6212054e26a736243b5038788f--7522b87f94dc4582b19c40dea221c42d a9cb699a6b5449ae8003af24aac00e4c 7522b87f94dc4582b19c40dea221c42d--a9cb699a6b5449ae8003af24aac00e4c 615b69bc2e2a413c8f898f2c39527cb9 a9cb699a6b5449ae8003af24aac00e4c--615b69bc2e2a413c8f898f2c39527cb9 6f31b39c591746fe82bba6dcca85af48 615b69bc2e2a413c8f898f2c39527cb9--6f31b39c591746fe82bba6dcca85af48 c2ba01c3daa14d23867f32218cacf390 6f31b39c591746fe82bba6dcca85af48--c2ba01c3daa14d23867f32218cacf390 58bfe1b1eb684b1d8c9fc10d7bfeec9a c2ba01c3daa14d23867f32218cacf390--58bfe1b1eb684b1d8c9fc10d7bfeec9a 09ba94b9effc45dfaa734507cd022126 58bfe1b1eb684b1d8c9fc10d7bfeec9a--09ba94b9effc45dfaa734507cd022126 545b9e26af15474299fddd01f6d5ecb5 09ba94b9effc45dfaa734507cd022126--545b9e26af15474299fddd01f6d5ecb5 f64556d6593c4a759cf4b824d05df76a 545b9e26af15474299fddd01f6d5ecb5--f64556d6593c4a759cf4b824d05df76a ec8a09f0752242519227fbbc1899908d f64556d6593c4a759cf4b824d05df76a--ec8a09f0752242519227fbbc1899908d b4441b79f93d434bb4a950ed9e3eab24 ec8a09f0752242519227fbbc1899908d--b4441b79f93d434bb4a950ed9e3eab24 17dcec3410f14e5cbaa3e901b2cfd0f9 b4441b79f93d434bb4a950ed9e3eab24--17dcec3410f14e5cbaa3e901b2cfd0f9 fcae6dcb693c476d8f0dfd78b3fe3b82 17dcec3410f14e5cbaa3e901b2cfd0f9--fcae6dcb693c476d8f0dfd78b3fe3b82 b4e1c50e38f247b38a45c040c7127579 fcae6dcb693c476d8f0dfd78b3fe3b82--b4e1c50e38f247b38a45c040c7127579 3de60c95339c49dca597dda3ce84b126 b4e1c50e38f247b38a45c040c7127579--3de60c95339c49dca597dda3ce84b126 c3e4557e7c884185a543cab691fccb1f 3de60c95339c49dca597dda3ce84b126--c3e4557e7c884185a543cab691fccb1f b4a2b3050bb94cdeacdd45cf0d133774 c3e4557e7c884185a543cab691fccb1f--b4a2b3050bb94cdeacdd45cf0d133774 877c233ceb8f498ba26b63781ef7528c b4a2b3050bb94cdeacdd45cf0d133774--877c233ceb8f498ba26b63781ef7528c ddde2f5665ca42f683118219602a115e X 877c233ceb8f498ba26b63781ef7528c--ddde2f5665ca42f683118219602a115e ddde2f5665ca42f683118219602a115e--dcab319370d0428585cf7ecd23e475bc 4c47919ee5a748c3a7895df56a24f621 RZ(-1.0*g0) ddde2f5665ca42f683118219602a115e--4c47919ee5a748c3a7895df56a24f621 5abd0fab62de476781f9f695750f8077 X 4c47919ee5a748c3a7895df56a24f621--5abd0fab62de476781f9f695750f8077 5abd0fab62de476781f9f695750f8077--3254513075af433ab8c91999d7563274 26e43b265f6e439987508a1c042e8856 5abd0fab62de476781f9f695750f8077--26e43b265f6e439987508a1c042e8856 6ed0349a609f40448c27fafac60f7234 26e43b265f6e439987508a1c042e8856--6ed0349a609f40448c27fafac60f7234 e54809df0efc4f91a05bf25c5436053b 6ed0349a609f40448c27fafac60f7234--e54809df0efc4f91a05bf25c5436053b eb5b69d646004d659f09a1191df3f524 e54809df0efc4f91a05bf25c5436053b--eb5b69d646004d659f09a1191df3f524 74040ba609474bffb7d895c6c8a32ab8 eb5b69d646004d659f09a1191df3f524--74040ba609474bffb7d895c6c8a32ab8 53e65dfd266946d09a1a42b443bd6f32 74040ba609474bffb7d895c6c8a32ab8--53e65dfd266946d09a1a42b443bd6f32 4108edde91d64a5abece992325031abe 53e65dfd266946d09a1a42b443bd6f32--4108edde91d64a5abece992325031abe 1549db85e2f249629521d9a890aa5cf7 4108edde91d64a5abece992325031abe--1549db85e2f249629521d9a890aa5cf7 30134ac9e3f042fa9f0af5d2a2267124 1549db85e2f249629521d9a890aa5cf7--30134ac9e3f042fa9f0af5d2a2267124 7ea871ec2bac43af84985bf54cf01589 30134ac9e3f042fa9f0af5d2a2267124--7ea871ec2bac43af84985bf54cf01589 bb24f69d4e0a412d8f29efefeed3b4a4 X 7ea871ec2bac43af84985bf54cf01589--bb24f69d4e0a412d8f29efefeed3b4a4 bb24f69d4e0a412d8f29efefeed3b4a4--255f33c6bffc453da16430a8203cda78 c7256c35c903497fb485681252e83d4e bb24f69d4e0a412d8f29efefeed3b4a4--c7256c35c903497fb485681252e83d4e 18d18c086d98443f92f8c3d8023bc497 c7256c35c903497fb485681252e83d4e--18d18c086d98443f92f8c3d8023bc497 affb4bdcfc1a4b63926c130dcb91cd52 18d18c086d98443f92f8c3d8023bc497--affb4bdcfc1a4b63926c130dcb91cd52 ef00d4c0753b4bda94ce2b87cc4146cc X affb4bdcfc1a4b63926c130dcb91cd52--ef00d4c0753b4bda94ce2b87cc4146cc ef00d4c0753b4bda94ce2b87cc4146cc--08332e3733394a6283038e7937b0a81d 38c41869dab64a4584729462ec47391c ef00d4c0753b4bda94ce2b87cc4146cc--38c41869dab64a4584729462ec47391c 82eea50881c24987afef24b316946c3b 38c41869dab64a4584729462ec47391c--82eea50881c24987afef24b316946c3b 8ccafaee117c4e33b7038c47e5633c3a 82eea50881c24987afef24b316946c3b--8ccafaee117c4e33b7038c47e5633c3a 6a8e5540133f424a892434433af59d46 8ccafaee117c4e33b7038c47e5633c3a--6a8e5540133f424a892434433af59d46 708c690f71a649e182cbf3863b91edee 6a8e5540133f424a892434433af59d46--708c690f71a649e182cbf3863b91edee d7a460d9523c4d0e88007ead5497f455 708c690f71a649e182cbf3863b91edee--d7a460d9523c4d0e88007ead5497f455 9869005014844e78a69e7963bfbe6c1d d7a460d9523c4d0e88007ead5497f455--9869005014844e78a69e7963bfbe6c1d 9e439a0bf9f54d93ad44f11679f449c6 9869005014844e78a69e7963bfbe6c1d--9e439a0bf9f54d93ad44f11679f449c6 e3ff7fe292aa475397656cf9d75d1c62 9e439a0bf9f54d93ad44f11679f449c6--e3ff7fe292aa475397656cf9d75d1c62 5f1f2e5bfe9f49e78f0ff691b8b98c66 e3ff7fe292aa475397656cf9d75d1c62--5f1f2e5bfe9f49e78f0ff691b8b98c66 da167fce0bcc4940ac1ba779b69c0dd8 5f1f2e5bfe9f49e78f0ff691b8b98c66--da167fce0bcc4940ac1ba779b69c0dd8 74246d4a41d64cbebf26a397f3a0b613 da167fce0bcc4940ac1ba779b69c0dd8--74246d4a41d64cbebf26a397f3a0b613 eff87d9567d243e3b26bd4cfa65ff699 74246d4a41d64cbebf26a397f3a0b613--eff87d9567d243e3b26bd4cfa65ff699 40161e29e5574996870e57995e200fd4 eff87d9567d243e3b26bd4cfa65ff699--40161e29e5574996870e57995e200fd4 68206bf24a7f4cbabef02b2124174ae5 40161e29e5574996870e57995e200fd4--68206bf24a7f4cbabef02b2124174ae5 962057c0ac5244fba84291b0e0ce885a 68206bf24a7f4cbabef02b2124174ae5--962057c0ac5244fba84291b0e0ce885a d2f6e47e3bad49d7a8e90f97c6588543 962057c0ac5244fba84291b0e0ce885a--d2f6e47e3bad49d7a8e90f97c6588543 65590b7c38d04ab48e355cdb84e64585 d2f6e47e3bad49d7a8e90f97c6588543--65590b7c38d04ab48e355cdb84e64585 e21838bb1c5f42298d38723bf4c2452e 65590b7c38d04ab48e355cdb84e64585--e21838bb1c5f42298d38723bf4c2452e 5486c54086f04914b5ebc12b8ce74b4f e21838bb1c5f42298d38723bf4c2452e--5486c54086f04914b5ebc12b8ce74b4f 729165ff194f4acd86393322fa79b213 5486c54086f04914b5ebc12b8ce74b4f--729165ff194f4acd86393322fa79b213 f13c5606416b44c4b13429a789917f94 729165ff194f4acd86393322fa79b213--f13c5606416b44c4b13429a789917f94 f8bd59e8d63d4f92b85868700e59f79f f13c5606416b44c4b13429a789917f94--f8bd59e8d63d4f92b85868700e59f79f 97f7492f9e424c57af8c535efe2145c5 f8bd59e8d63d4f92b85868700e59f79f--97f7492f9e424c57af8c535efe2145c5 71166eb357bd45c9b8017316fe8081df 97f7492f9e424c57af8c535efe2145c5--71166eb357bd45c9b8017316fe8081df 8d2dba4bdf4440e8be8ad10706cc4e1c 71166eb357bd45c9b8017316fe8081df--8d2dba4bdf4440e8be8ad10706cc4e1c e9675f7a33b64a5d803ee1f319d11315 8d2dba4bdf4440e8be8ad10706cc4e1c--e9675f7a33b64a5d803ee1f319d11315 4f34b8f8281f46d28db6237d4a50409b e9675f7a33b64a5d803ee1f319d11315--4f34b8f8281f46d28db6237d4a50409b b964433ab1cf489498561961164bbf0f 4f34b8f8281f46d28db6237d4a50409b--b964433ab1cf489498561961164bbf0f 0993ac0c1cb44eac94a0dabf6f438c0c b964433ab1cf489498561961164bbf0f--0993ac0c1cb44eac94a0dabf6f438c0c 23e81942ac3f4811917cf9101cbb1ba3 0993ac0c1cb44eac94a0dabf6f438c0c--23e81942ac3f4811917cf9101cbb1ba3 47e8b432edd04316b104224f7dba8951 23e81942ac3f4811917cf9101cbb1ba3--47e8b432edd04316b104224f7dba8951 2eff9661bf684892b66505a0d6871d1b X 47e8b432edd04316b104224f7dba8951--2eff9661bf684892b66505a0d6871d1b 2eff9661bf684892b66505a0d6871d1b--ea8be5ef2b444144a016fe6685b90deb e62385bafbf74a5984d8ae7555679b3d RZ(-1.0*g0) 2eff9661bf684892b66505a0d6871d1b--e62385bafbf74a5984d8ae7555679b3d e979dbcd1e854129966cdb7c8f025a2e X e62385bafbf74a5984d8ae7555679b3d--e979dbcd1e854129966cdb7c8f025a2e e979dbcd1e854129966cdb7c8f025a2e--6a13758dc5e649798dc3a805c0ddf974 ee50c838bba54a44ad1f2efefd714a0a e979dbcd1e854129966cdb7c8f025a2e--ee50c838bba54a44ad1f2efefd714a0a 645f8334b57e432483e27e7c1ed66966 ee50c838bba54a44ad1f2efefd714a0a--645f8334b57e432483e27e7c1ed66966 174bca7b2b8e45779de5fc997070da80 645f8334b57e432483e27e7c1ed66966--174bca7b2b8e45779de5fc997070da80 252341988b354cbe9131c64a5d6b891c 174bca7b2b8e45779de5fc997070da80--252341988b354cbe9131c64a5d6b891c 44be80ed61ab41e18e49821a2385163f 252341988b354cbe9131c64a5d6b891c--44be80ed61ab41e18e49821a2385163f a3d79b33a8874a859b5fc1d8768d611c 44be80ed61ab41e18e49821a2385163f--a3d79b33a8874a859b5fc1d8768d611c 57919d62d6e7406580c005b45a29764c X a3d79b33a8874a859b5fc1d8768d611c--57919d62d6e7406580c005b45a29764c 57919d62d6e7406580c005b45a29764c--96096e3d7ca44bf2a97ecdce976357a6 4d04b6a0b5564648bff5d353a3f065e8 57919d62d6e7406580c005b45a29764c--4d04b6a0b5564648bff5d353a3f065e8 aca1e5398f1744e4a0623948778e911f 4d04b6a0b5564648bff5d353a3f065e8--aca1e5398f1744e4a0623948778e911f acc7a93c6ba94827a5ef01fbdf79cd1c aca1e5398f1744e4a0623948778e911f--acc7a93c6ba94827a5ef01fbdf79cd1c 0f166b26bedf462abd18d886a2d688c6 X acc7a93c6ba94827a5ef01fbdf79cd1c--0f166b26bedf462abd18d886a2d688c6 0f166b26bedf462abd18d886a2d688c6--6e644495850841bc8cad93ee9fcf03c6 71552d0657554168930e73a82860f705 0f166b26bedf462abd18d886a2d688c6--71552d0657554168930e73a82860f705 28347f3b566542f7b79f3d39dc75a114 71552d0657554168930e73a82860f705--28347f3b566542f7b79f3d39dc75a114 459c3ed3e2a04158b1f1a943dd54d957 28347f3b566542f7b79f3d39dc75a114--459c3ed3e2a04158b1f1a943dd54d957 51bca83171bd4ef5b189b56d077cfbbf 459c3ed3e2a04158b1f1a943dd54d957--51bca83171bd4ef5b189b56d077cfbbf 0af2d737c85a4144afb9bc54430f4482 51bca83171bd4ef5b189b56d077cfbbf--0af2d737c85a4144afb9bc54430f4482 91de142999cb4b30814d7f0afeadffc4 0af2d737c85a4144afb9bc54430f4482--91de142999cb4b30814d7f0afeadffc4 0f13185dec154396b40d31bdb242fbd5 91de142999cb4b30814d7f0afeadffc4--0f13185dec154396b40d31bdb242fbd5 0e0f61ace2fa474e98a4186ab45c152f 0f13185dec154396b40d31bdb242fbd5--0e0f61ace2fa474e98a4186ab45c152f 5961f04e4691496bb92a96352b379c7d 0e0f61ace2fa474e98a4186ab45c152f--5961f04e4691496bb92a96352b379c7d bdc64d710036415fb3a0fb8710ba7a7f 5961f04e4691496bb92a96352b379c7d--bdc64d710036415fb3a0fb8710ba7a7f 301627ad482e43029dcd6402b4f3127d bdc64d710036415fb3a0fb8710ba7a7f--301627ad482e43029dcd6402b4f3127d 5dbdeea215d04ff5ab244b11c44effd2 301627ad482e43029dcd6402b4f3127d--5dbdeea215d04ff5ab244b11c44effd2 6692e0606dee4ede919433e7ec679367 5dbdeea215d04ff5ab244b11c44effd2--6692e0606dee4ede919433e7ec679367 4748aba5fb94442a9daa1266ea5b2c92 X 6692e0606dee4ede919433e7ec679367--4748aba5fb94442a9daa1266ea5b2c92 4748aba5fb94442a9daa1266ea5b2c92--ee01d0dabdd242dfb7c49047e9bcf7c0 52129c599915423684e8198d42b02b94 RZ(-1.0*g0) 4748aba5fb94442a9daa1266ea5b2c92--52129c599915423684e8198d42b02b94 f72c9ea10b2e45b3a527618aa4cadd4d X 52129c599915423684e8198d42b02b94--f72c9ea10b2e45b3a527618aa4cadd4d f72c9ea10b2e45b3a527618aa4cadd4d--5279e67925ac45aab69ca1fed7dbe26b 941292a07f2e4c628a4d0e05bdf7e3b2 f72c9ea10b2e45b3a527618aa4cadd4d--941292a07f2e4c628a4d0e05bdf7e3b2 01b175f662ba4c5f8ba575a5dd132128 941292a07f2e4c628a4d0e05bdf7e3b2--01b175f662ba4c5f8ba575a5dd132128 6ebc7d451f1f441c84fdeb85f7f7e926 01b175f662ba4c5f8ba575a5dd132128--6ebc7d451f1f441c84fdeb85f7f7e926 cedf8a97ab38421d92a71947b84d17e0 X 6ebc7d451f1f441c84fdeb85f7f7e926--cedf8a97ab38421d92a71947b84d17e0 cedf8a97ab38421d92a71947b84d17e0--8682ba6f97294309bf55d1e8de131024 78c42fb02b3245b099a03c4d612970eb RZ(-1.0*g0) cedf8a97ab38421d92a71947b84d17e0--78c42fb02b3245b099a03c4d612970eb f8492760baa34a3393ef253eba32acb2 X 78c42fb02b3245b099a03c4d612970eb--f8492760baa34a3393ef253eba32acb2 f8492760baa34a3393ef253eba32acb2--7e9c0c59866247a88daacb36e92b7e9d b85fa17d43aa4e108456e2ae0661573e f8492760baa34a3393ef253eba32acb2--b85fa17d43aa4e108456e2ae0661573e ccb1f2938d504cbb962f9a7df273399c X b85fa17d43aa4e108456e2ae0661573e--ccb1f2938d504cbb962f9a7df273399c ccb1f2938d504cbb962f9a7df273399c--7e14c442af854bc3829e9b96ef623824 dde6564c96764f3eb78c944b713cbe52 RZ(-1.0*g0) ccb1f2938d504cbb962f9a7df273399c--dde6564c96764f3eb78c944b713cbe52 fdc89f6fc1ff4bf0a6aa9dd40fb6d435 X dde6564c96764f3eb78c944b713cbe52--fdc89f6fc1ff4bf0a6aa9dd40fb6d435 fdc89f6fc1ff4bf0a6aa9dd40fb6d435--210f317ac3044af0a32442540c9f36b2 2eb65fbf8d15473d9e67df069f73f397 RX(b06) fdc89f6fc1ff4bf0a6aa9dd40fb6d435--2eb65fbf8d15473d9e67df069f73f397 028029cb08684e7c8b3099f9a55331bd 2eb65fbf8d15473d9e67df069f73f397--028029cb08684e7c8b3099f9a55331bd 7bdc9127db1c4e7fbfa3a34c6bc1d82b 028029cb08684e7c8b3099f9a55331bd--7bdc9127db1c4e7fbfa3a34c6bc1d82b f88ca10a8e5e4b268807a9c006120679 7bdc9127db1c4e7fbfa3a34c6bc1d82b--f88ca10a8e5e4b268807a9c006120679 88d073959b39471e8cc022677a09d6cd f88ca10a8e5e4b268807a9c006120679--88d073959b39471e8cc022677a09d6cd 64939077283e444686a45ddee10950af 88d073959b39471e8cc022677a09d6cd--64939077283e444686a45ddee10950af 65d394db32dc4442b26b6f9e89bb8404 X 64939077283e444686a45ddee10950af--65d394db32dc4442b26b6f9e89bb8404 65d394db32dc4442b26b6f9e89bb8404--f8cccf81961f4e7ba01e0cdae3408801 5e1fade828f24e8394a4b4070bff8e23 65d394db32dc4442b26b6f9e89bb8404--5e1fade828f24e8394a4b4070bff8e23 d601e717320f438fb845777dd77a9c46 5e1fade828f24e8394a4b4070bff8e23--d601e717320f438fb845777dd77a9c46 73651646d0684ec799579c2dd784fcd5 d601e717320f438fb845777dd77a9c46--73651646d0684ec799579c2dd784fcd5 137bbdebc7a44288a4f9d002e13e1a34 X 73651646d0684ec799579c2dd784fcd5--137bbdebc7a44288a4f9d002e13e1a34 137bbdebc7a44288a4f9d002e13e1a34--760cb12d3ad6437daa56894c1951897a 534434e441ca46ca9f1e67dee3fa5c2f 137bbdebc7a44288a4f9d002e13e1a34--534434e441ca46ca9f1e67dee3fa5c2f 255c3db453bf4797b5326e12d2d9a4ff 534434e441ca46ca9f1e67dee3fa5c2f--255c3db453bf4797b5326e12d2d9a4ff d6ae8d36661843b3982ced267d151b15 255c3db453bf4797b5326e12d2d9a4ff--d6ae8d36661843b3982ced267d151b15 073ba9db88da44f1a1601d1cb3eb14ae d6ae8d36661843b3982ced267d151b15--073ba9db88da44f1a1601d1cb3eb14ae 398f8c8f278b496e887aa37e86989a3d 073ba9db88da44f1a1601d1cb3eb14ae--398f8c8f278b496e887aa37e86989a3d e8e49cab4ebf48c3bf1aed32f271cbb9 398f8c8f278b496e887aa37e86989a3d--e8e49cab4ebf48c3bf1aed32f271cbb9 e4a82a57fe9b45ea9c3ba093b1396379 e8e49cab4ebf48c3bf1aed32f271cbb9--e4a82a57fe9b45ea9c3ba093b1396379 0d67b8a0bd0d46b780d0c6e0b622745b e4a82a57fe9b45ea9c3ba093b1396379--0d67b8a0bd0d46b780d0c6e0b622745b a28544e8ace247e7b8aa8bae640257f6 0d67b8a0bd0d46b780d0c6e0b622745b--a28544e8ace247e7b8aa8bae640257f6 83036d042b6a4ce2b9d9e716cd5fc5dd a28544e8ace247e7b8aa8bae640257f6--83036d042b6a4ce2b9d9e716cd5fc5dd f2869763d22c4d1d9d2bea54dbf9ce23 83036d042b6a4ce2b9d9e716cd5fc5dd--f2869763d22c4d1d9d2bea54dbf9ce23 44f3aea24dbd42a8960a4edd00e217b0 f2869763d22c4d1d9d2bea54dbf9ce23--44f3aea24dbd42a8960a4edd00e217b0 9035dbec81964a2092b0fae2e6a0a454 44f3aea24dbd42a8960a4edd00e217b0--9035dbec81964a2092b0fae2e6a0a454 be10488206a54286bec25a9001da0ea7 9035dbec81964a2092b0fae2e6a0a454--be10488206a54286bec25a9001da0ea7 2b3d3b63640142ce86255cf819d840b1 be10488206a54286bec25a9001da0ea7--2b3d3b63640142ce86255cf819d840b1 317bfb025f7b48e5a6d2740cdb87d9bd 2b3d3b63640142ce86255cf819d840b1--317bfb025f7b48e5a6d2740cdb87d9bd bb762c92934045319cb8f55a705668ec 317bfb025f7b48e5a6d2740cdb87d9bd--bb762c92934045319cb8f55a705668ec c894cce42ab34984b3237baa6c87541f bb762c92934045319cb8f55a705668ec--c894cce42ab34984b3237baa6c87541f 6f8d6bb7ea97475cba9322cbfc1568dc c894cce42ab34984b3237baa6c87541f--6f8d6bb7ea97475cba9322cbfc1568dc 7b7a48422d7b406fa47f0f79a370b268 6f8d6bb7ea97475cba9322cbfc1568dc--7b7a48422d7b406fa47f0f79a370b268 764933564c084f8789989e3ce56f4aa1 7b7a48422d7b406fa47f0f79a370b268--764933564c084f8789989e3ce56f4aa1 571ce5382e06437a9b182a92a8792c21 764933564c084f8789989e3ce56f4aa1--571ce5382e06437a9b182a92a8792c21 adaf365a751246ab91b6c8ed2fc3c5a4 571ce5382e06437a9b182a92a8792c21--adaf365a751246ab91b6c8ed2fc3c5a4 f637cb554b504a5daf183f7fc7545752 adaf365a751246ab91b6c8ed2fc3c5a4--f637cb554b504a5daf183f7fc7545752 14603b29c40d469e858eada4c312e8df f637cb554b504a5daf183f7fc7545752--14603b29c40d469e858eada4c312e8df fc1cfae3bd5645febdf9b2670f5e260f 14603b29c40d469e858eada4c312e8df--fc1cfae3bd5645febdf9b2670f5e260f b9bfb1c1c67e4b24ae1a3d7a89579c0a fc1cfae3bd5645febdf9b2670f5e260f--b9bfb1c1c67e4b24ae1a3d7a89579c0a b9bc8ae8693343d28462a0ebf55c91d0 b9bfb1c1c67e4b24ae1a3d7a89579c0a--b9bc8ae8693343d28462a0ebf55c91d0 8d926c7d7361484a81928fce5e8cb84b b9bc8ae8693343d28462a0ebf55c91d0--8d926c7d7361484a81928fce5e8cb84b a6bfda35543b4d0c9af3f68fdc54423c X 8d926c7d7361484a81928fce5e8cb84b--a6bfda35543b4d0c9af3f68fdc54423c a6bfda35543b4d0c9af3f68fdc54423c--fc208863c6894b46b6342dd5218ccf66 806f881340c842c6a656e3ef80379a1e RZ(-1.0*g1) a6bfda35543b4d0c9af3f68fdc54423c--806f881340c842c6a656e3ef80379a1e 0af0e78752a343b6bef3d088311de842 X 806f881340c842c6a656e3ef80379a1e--0af0e78752a343b6bef3d088311de842 0af0e78752a343b6bef3d088311de842--f904472e215f4984a236b2392377fa56 27b0ceccd73f49dbbbc8b342984f46f9 0af0e78752a343b6bef3d088311de842--27b0ceccd73f49dbbbc8b342984f46f9 c506ce1bfde541acb4595282f5c9b2cb 27b0ceccd73f49dbbbc8b342984f46f9--c506ce1bfde541acb4595282f5c9b2cb fa0d2ad287c34f938f1145bd54537faf c506ce1bfde541acb4595282f5c9b2cb--fa0d2ad287c34f938f1145bd54537faf 004c7cdce9d942178c918cb62d27d32d fa0d2ad287c34f938f1145bd54537faf--004c7cdce9d942178c918cb62d27d32d a446b12744c341faa6bbe597208bb408 004c7cdce9d942178c918cb62d27d32d--a446b12744c341faa6bbe597208bb408 a8133b3d6dcf4042970ca98e610f10d9 a446b12744c341faa6bbe597208bb408--a8133b3d6dcf4042970ca98e610f10d9 ef90de562455409fa7d2a08e651275b6 a8133b3d6dcf4042970ca98e610f10d9--ef90de562455409fa7d2a08e651275b6 84d425968a9f46ad8ed1a8eb2039062e ef90de562455409fa7d2a08e651275b6--84d425968a9f46ad8ed1a8eb2039062e e2e9dd574fed4bc1b63e8c3624a13b11 84d425968a9f46ad8ed1a8eb2039062e--e2e9dd574fed4bc1b63e8c3624a13b11 38eefabdbdc94074ad5a55ec839d45cc e2e9dd574fed4bc1b63e8c3624a13b11--38eefabdbdc94074ad5a55ec839d45cc c7e5f50932de46f6973bc43b08dc11bb X 38eefabdbdc94074ad5a55ec839d45cc--c7e5f50932de46f6973bc43b08dc11bb c7e5f50932de46f6973bc43b08dc11bb--4522eda152114ea1bb48bbbe3c495c85 aee57169c6c24066931ddce805f797d7 c7e5f50932de46f6973bc43b08dc11bb--aee57169c6c24066931ddce805f797d7 1dcbb1a539f5492ab50a20a61f41555b aee57169c6c24066931ddce805f797d7--1dcbb1a539f5492ab50a20a61f41555b 15f207e1250e4937bbd32ddd6bb6ed06 1dcbb1a539f5492ab50a20a61f41555b--15f207e1250e4937bbd32ddd6bb6ed06 aa4984769c2143e989f052122091a5fd X 15f207e1250e4937bbd32ddd6bb6ed06--aa4984769c2143e989f052122091a5fd aa4984769c2143e989f052122091a5fd--e175df7ffbcc4863a2c34a228d1ecd28 677d0fcaa26f4c61917c1fe46c352f00 aa4984769c2143e989f052122091a5fd--677d0fcaa26f4c61917c1fe46c352f00 bb40040856de4d388b2df27887a55540 677d0fcaa26f4c61917c1fe46c352f00--bb40040856de4d388b2df27887a55540 e0036d1672a941b2a109e6bb10201fb0 bb40040856de4d388b2df27887a55540--e0036d1672a941b2a109e6bb10201fb0 81017ed0bc254ea4b5ae7d6b6c612297 e0036d1672a941b2a109e6bb10201fb0--81017ed0bc254ea4b5ae7d6b6c612297 fc1727c95490458b9c0fe914ad1db92f 81017ed0bc254ea4b5ae7d6b6c612297--fc1727c95490458b9c0fe914ad1db92f 1af2dc2f2ae54fce99af6068059e3f0f fc1727c95490458b9c0fe914ad1db92f--1af2dc2f2ae54fce99af6068059e3f0f e63d94568a7048f089490294a63167ef 1af2dc2f2ae54fce99af6068059e3f0f--e63d94568a7048f089490294a63167ef bd262d7ac7e54dd49f30736a8c834908 e63d94568a7048f089490294a63167ef--bd262d7ac7e54dd49f30736a8c834908 d84da2a971dd43f78ae63f71b8d8a204 bd262d7ac7e54dd49f30736a8c834908--d84da2a971dd43f78ae63f71b8d8a204 e852537193e74f0e8a23bcef5e18b1f2 d84da2a971dd43f78ae63f71b8d8a204--e852537193e74f0e8a23bcef5e18b1f2 475402c904fc40b3aaa12449507704c0 e852537193e74f0e8a23bcef5e18b1f2--475402c904fc40b3aaa12449507704c0 28d36252275744a2be1ac02cd782c9dc 475402c904fc40b3aaa12449507704c0--28d36252275744a2be1ac02cd782c9dc 81a48c2e20b8444aa0b6bd9137e036e4 28d36252275744a2be1ac02cd782c9dc--81a48c2e20b8444aa0b6bd9137e036e4 cb763aca95334f39974f079cddc8cfea 81a48c2e20b8444aa0b6bd9137e036e4--cb763aca95334f39974f079cddc8cfea d81e1127a920485fb27ad6c5e846d3d8 cb763aca95334f39974f079cddc8cfea--d81e1127a920485fb27ad6c5e846d3d8 1dcb7dfc186c4db29b02d4f9f1eec2e0 d81e1127a920485fb27ad6c5e846d3d8--1dcb7dfc186c4db29b02d4f9f1eec2e0 48ab8e44dc2a4c0d8e6466f6e37786c6 1dcb7dfc186c4db29b02d4f9f1eec2e0--48ab8e44dc2a4c0d8e6466f6e37786c6 864d9edbf3694171a7b49bbc64460761 48ab8e44dc2a4c0d8e6466f6e37786c6--864d9edbf3694171a7b49bbc64460761 f2faf7db21434e6e9650952a562f265b 864d9edbf3694171a7b49bbc64460761--f2faf7db21434e6e9650952a562f265b 502078aad3b547aca4ef61e8feef766d f2faf7db21434e6e9650952a562f265b--502078aad3b547aca4ef61e8feef766d bcbde1756f1649b9a0669a91cb851205 502078aad3b547aca4ef61e8feef766d--bcbde1756f1649b9a0669a91cb851205 ecf234f39547487d80cccbba7c118406 bcbde1756f1649b9a0669a91cb851205--ecf234f39547487d80cccbba7c118406 dfb62e50e88f4365a56f2beeee2a3d03 ecf234f39547487d80cccbba7c118406--dfb62e50e88f4365a56f2beeee2a3d03 cac67525554c4c798c326d0a8ca222a3 dfb62e50e88f4365a56f2beeee2a3d03--cac67525554c4c798c326d0a8ca222a3 1bb75c2525034facaa0c8b8d334ee8b3 cac67525554c4c798c326d0a8ca222a3--1bb75c2525034facaa0c8b8d334ee8b3 fff8e3aa8b4e45dea3bfe7cd1914e1d6 1bb75c2525034facaa0c8b8d334ee8b3--fff8e3aa8b4e45dea3bfe7cd1914e1d6 ca72949603a947c0bf1d377426cf6181 fff8e3aa8b4e45dea3bfe7cd1914e1d6--ca72949603a947c0bf1d377426cf6181 3156716450ba4ffe81707a8b90398fb1 ca72949603a947c0bf1d377426cf6181--3156716450ba4ffe81707a8b90398fb1 872950a89b19494283040fc080f0e359 3156716450ba4ffe81707a8b90398fb1--872950a89b19494283040fc080f0e359 e292133eadbd4c4c943a01d26c8ceac1 872950a89b19494283040fc080f0e359--e292133eadbd4c4c943a01d26c8ceac1 eaef6ea79b2347658692e7118a8c8603 e292133eadbd4c4c943a01d26c8ceac1--eaef6ea79b2347658692e7118a8c8603 15e2c440219a44d983bfe2a9f16da87d eaef6ea79b2347658692e7118a8c8603--15e2c440219a44d983bfe2a9f16da87d 00ae1818d8f243bf860a2d9776cfd4a9 X 15e2c440219a44d983bfe2a9f16da87d--00ae1818d8f243bf860a2d9776cfd4a9 00ae1818d8f243bf860a2d9776cfd4a9--e38e958d45384854a9efb2ac2c9e1fc1 71e24d1f3b9e4b40bc7410f4c0b61438 RZ(-1.0*g1) 00ae1818d8f243bf860a2d9776cfd4a9--71e24d1f3b9e4b40bc7410f4c0b61438 ca2ce4248b2b4a1c92adaff5416ab25f X 71e24d1f3b9e4b40bc7410f4c0b61438--ca2ce4248b2b4a1c92adaff5416ab25f ca2ce4248b2b4a1c92adaff5416ab25f--d8116b4f10794756a7770171e7c3bbde 1ebadff3ab9147d3b67c807fc4f6a6ca ca2ce4248b2b4a1c92adaff5416ab25f--1ebadff3ab9147d3b67c807fc4f6a6ca 471af442c67c41d6accb35a79101cebc 1ebadff3ab9147d3b67c807fc4f6a6ca--471af442c67c41d6accb35a79101cebc 57c86af463a3470e858b9a7fe890b057 471af442c67c41d6accb35a79101cebc--57c86af463a3470e858b9a7fe890b057 852fc24597f74bde8d081af85fa2097e 57c86af463a3470e858b9a7fe890b057--852fc24597f74bde8d081af85fa2097e dacc675089b24de4955ee2313a0ac169 852fc24597f74bde8d081af85fa2097e--dacc675089b24de4955ee2313a0ac169 049e1316a8be4b4e8d2e8e047674c3a3 dacc675089b24de4955ee2313a0ac169--049e1316a8be4b4e8d2e8e047674c3a3 1f8e46f429dc4d96953d0bd65916e6b7 X 049e1316a8be4b4e8d2e8e047674c3a3--1f8e46f429dc4d96953d0bd65916e6b7 1f8e46f429dc4d96953d0bd65916e6b7--f49389177ad44c71b20a2c84b112455f 1b9c3ec9011342e2b9b90e46979ec55b 1f8e46f429dc4d96953d0bd65916e6b7--1b9c3ec9011342e2b9b90e46979ec55b e4ab0a29b5d04b98ad75bd6a2f21d698 1b9c3ec9011342e2b9b90e46979ec55b--e4ab0a29b5d04b98ad75bd6a2f21d698 63ec8905b3e94162aed845c8f1276d64 e4ab0a29b5d04b98ad75bd6a2f21d698--63ec8905b3e94162aed845c8f1276d64 cab164b2b9304bb8aab662053a4b375d X 63ec8905b3e94162aed845c8f1276d64--cab164b2b9304bb8aab662053a4b375d cab164b2b9304bb8aab662053a4b375d--f2978dce84e74c1d9ed94cae3ede3ce5 4536d66b0af14875b2d3ad1e3544a837 cab164b2b9304bb8aab662053a4b375d--4536d66b0af14875b2d3ad1e3544a837 a7fe31a403e947a3ac7efe27d7e6448d 4536d66b0af14875b2d3ad1e3544a837--a7fe31a403e947a3ac7efe27d7e6448d f6d418ef7a834cfcbc01475667d77331 a7fe31a403e947a3ac7efe27d7e6448d--f6d418ef7a834cfcbc01475667d77331 71bc0cb735a14257a017baf356a159a0 f6d418ef7a834cfcbc01475667d77331--71bc0cb735a14257a017baf356a159a0 756e9eb5208e4e53899245f6be2a6f5b 71bc0cb735a14257a017baf356a159a0--756e9eb5208e4e53899245f6be2a6f5b b6619cf02297486587b348a0159309b6 756e9eb5208e4e53899245f6be2a6f5b--b6619cf02297486587b348a0159309b6 f075376463f84f08beb794ed775a060b b6619cf02297486587b348a0159309b6--f075376463f84f08beb794ed775a060b 58c79044be0a4a3ea1d1f0c4ca045dfe f075376463f84f08beb794ed775a060b--58c79044be0a4a3ea1d1f0c4ca045dfe 2c9dc33e021041faa203d1d016012314 58c79044be0a4a3ea1d1f0c4ca045dfe--2c9dc33e021041faa203d1d016012314 6dbfb7a1456045bc9f5ed19713d240f7 2c9dc33e021041faa203d1d016012314--6dbfb7a1456045bc9f5ed19713d240f7 237969cbde934f9388d9abc22b8d7473 6dbfb7a1456045bc9f5ed19713d240f7--237969cbde934f9388d9abc22b8d7473 8933dcad468f45d0bb6af61b25d4596e 237969cbde934f9388d9abc22b8d7473--8933dcad468f45d0bb6af61b25d4596e 7fee6bc585cc4fd2a0d3e31b6eced6cc 8933dcad468f45d0bb6af61b25d4596e--7fee6bc585cc4fd2a0d3e31b6eced6cc 9cc9c63a8a6f4fffa8d67e426db3f0f0 X 7fee6bc585cc4fd2a0d3e31b6eced6cc--9cc9c63a8a6f4fffa8d67e426db3f0f0 9cc9c63a8a6f4fffa8d67e426db3f0f0--0107245181f44505860fa6803ab14ef2 5c1447fa9813485284941f351484ee82 RZ(-1.0*g1) 9cc9c63a8a6f4fffa8d67e426db3f0f0--5c1447fa9813485284941f351484ee82 76ce77d8c4f549d09f5c416e30da0dd3 X 5c1447fa9813485284941f351484ee82--76ce77d8c4f549d09f5c416e30da0dd3 76ce77d8c4f549d09f5c416e30da0dd3--2c04cdc10b0b4746add9dbc4f8aff503 0d935cecf782401b8d84f9bae29972ff 76ce77d8c4f549d09f5c416e30da0dd3--0d935cecf782401b8d84f9bae29972ff d2af80b105d34f818193b3caece93078 0d935cecf782401b8d84f9bae29972ff--d2af80b105d34f818193b3caece93078 1f98e8016d044f14ac96e4538e469567 d2af80b105d34f818193b3caece93078--1f98e8016d044f14ac96e4538e469567 cf70736cb3264bb1b8672101cf14fe34 X 1f98e8016d044f14ac96e4538e469567--cf70736cb3264bb1b8672101cf14fe34 cf70736cb3264bb1b8672101cf14fe34--a88e1f464a9b4215928633822e0fa492 52de4d93066c49188c08fce65ff52630 RZ(-1.0*g1) cf70736cb3264bb1b8672101cf14fe34--52de4d93066c49188c08fce65ff52630 c649fc9de5a84289b63ed8cbc2faa5e6 X 52de4d93066c49188c08fce65ff52630--c649fc9de5a84289b63ed8cbc2faa5e6 c649fc9de5a84289b63ed8cbc2faa5e6--81dd9d4b9be24ec39445af889f66c6c3 a93de7f5414d4faca5f1d97f528b7046 c649fc9de5a84289b63ed8cbc2faa5e6--a93de7f5414d4faca5f1d97f528b7046 b15ab69a24774475ac8b7156cc2eae82 X a93de7f5414d4faca5f1d97f528b7046--b15ab69a24774475ac8b7156cc2eae82 b15ab69a24774475ac8b7156cc2eae82--f0fe82b58ace47caa1cd485b40add0ad e81653baaca741a18ba2a6a37ed4bea6 RZ(-1.0*g1) b15ab69a24774475ac8b7156cc2eae82--e81653baaca741a18ba2a6a37ed4bea6 1adcd524866248a1853e0cc51fe59aa0 X e81653baaca741a18ba2a6a37ed4bea6--1adcd524866248a1853e0cc51fe59aa0 1adcd524866248a1853e0cc51fe59aa0--3d701455f3a74f5783a25e010007c5ee e0f73b37b31a4d03890fb1edbba3fa36 RX(b16) 1adcd524866248a1853e0cc51fe59aa0--e0f73b37b31a4d03890fb1edbba3fa36 e0f73b37b31a4d03890fb1edbba3fa36--8f4557fd1c6f472b85c3c15b9ca5054d 04043f6d3e1c4f77bef2ed1e027d4cfb 02218d8a27354f59bec27d9634faf97a 43e60aa838e84d07ac139ce3d39d9b89--02218d8a27354f59bec27d9634faf97a 6ec8bbfdb7264682912d3e5a05d6cd60 02218d8a27354f59bec27d9634faf97a--6ec8bbfdb7264682912d3e5a05d6cd60 675250fb884840d385e42b8364a50176 6ec8bbfdb7264682912d3e5a05d6cd60--675250fb884840d385e42b8364a50176 8e11871a1b53463e91424fe20cd7a0ef 675250fb884840d385e42b8364a50176--8e11871a1b53463e91424fe20cd7a0ef 29bbb17b77764ea896a301d72fec07d0 8e11871a1b53463e91424fe20cd7a0ef--29bbb17b77764ea896a301d72fec07d0 018d898aad3d406da150035b05c939a7 29bbb17b77764ea896a301d72fec07d0--018d898aad3d406da150035b05c939a7 53fdb9b81c8940c3bd70f1956158edd5 X 018d898aad3d406da150035b05c939a7--53fdb9b81c8940c3bd70f1956158edd5 53fdb9b81c8940c3bd70f1956158edd5--f61ef106b88b464da62fa1b0ae5f4da2 6de95e60faad4d01aea0cd86c4cd4c39 RZ(1.0*g0) 53fdb9b81c8940c3bd70f1956158edd5--6de95e60faad4d01aea0cd86c4cd4c39 6057349305eb4830b12371b1b64403cc X 6de95e60faad4d01aea0cd86c4cd4c39--6057349305eb4830b12371b1b64403cc 6057349305eb4830b12371b1b64403cc--8876eafb95ff485585c159ef20a59172 96d91bb00b19436bb5f1944fd785b0ad 6057349305eb4830b12371b1b64403cc--96d91bb00b19436bb5f1944fd785b0ad 9752c0a557f44f9b964cbd7133c75e03 96d91bb00b19436bb5f1944fd785b0ad--9752c0a557f44f9b964cbd7133c75e03 0bcbf2e374fd4fbbad9a04d127bb8f4e 9752c0a557f44f9b964cbd7133c75e03--0bcbf2e374fd4fbbad9a04d127bb8f4e e6951261720a4785b230e8886d5cba55 0bcbf2e374fd4fbbad9a04d127bb8f4e--e6951261720a4785b230e8886d5cba55 f265645cbba540428c2787e827c948ce e6951261720a4785b230e8886d5cba55--f265645cbba540428c2787e827c948ce c76cc394fbf6495cb48337baa96df107 f265645cbba540428c2787e827c948ce--c76cc394fbf6495cb48337baa96df107 d926d7c5ba54426f9a60aeadc7428472 c76cc394fbf6495cb48337baa96df107--d926d7c5ba54426f9a60aeadc7428472 7cdfdee522ab450cbd0639180f641ee1 d926d7c5ba54426f9a60aeadc7428472--7cdfdee522ab450cbd0639180f641ee1 bebef2fca4b74aefbab5b7de4ad97a8b 7cdfdee522ab450cbd0639180f641ee1--bebef2fca4b74aefbab5b7de4ad97a8b 7c300e03124c4b41b245847585f9b006 bebef2fca4b74aefbab5b7de4ad97a8b--7c300e03124c4b41b245847585f9b006 ffbcab366e204e0e8335de5374500b1d 7c300e03124c4b41b245847585f9b006--ffbcab366e204e0e8335de5374500b1d f34707f8dffa4de08fcc1d1e47d66138 ffbcab366e204e0e8335de5374500b1d--f34707f8dffa4de08fcc1d1e47d66138 052f9d87e8394c7b8d345d21210933f7 f34707f8dffa4de08fcc1d1e47d66138--052f9d87e8394c7b8d345d21210933f7 a51b509ece8a4036808a51ba6bdcd25c 052f9d87e8394c7b8d345d21210933f7--a51b509ece8a4036808a51ba6bdcd25c 54a3bfea6d514d8ab19c4b0bfe4be752 a51b509ece8a4036808a51ba6bdcd25c--54a3bfea6d514d8ab19c4b0bfe4be752 b2e7fac183294710840577fc89893c47 54a3bfea6d514d8ab19c4b0bfe4be752--b2e7fac183294710840577fc89893c47 659882de5ff342b6b1cae87958de8082 b2e7fac183294710840577fc89893c47--659882de5ff342b6b1cae87958de8082 a37716b7a0514f1c9f3186f520372771 659882de5ff342b6b1cae87958de8082--a37716b7a0514f1c9f3186f520372771 37d85039af344fed934ce7c469d38651 a37716b7a0514f1c9f3186f520372771--37d85039af344fed934ce7c469d38651 fce250b84a9c460ca3545770ed546eeb 37d85039af344fed934ce7c469d38651--fce250b84a9c460ca3545770ed546eeb d6446b9cd1c04549a8a63d2324ccee43 fce250b84a9c460ca3545770ed546eeb--d6446b9cd1c04549a8a63d2324ccee43 dda4013a6af349809a076762025518c1 d6446b9cd1c04549a8a63d2324ccee43--dda4013a6af349809a076762025518c1 ebb94fc7c2d14b78946ada890c34a5e9 dda4013a6af349809a076762025518c1--ebb94fc7c2d14b78946ada890c34a5e9 3273981bf03a46298ad5857a2c14eb17 ebb94fc7c2d14b78946ada890c34a5e9--3273981bf03a46298ad5857a2c14eb17 76a94ad044304a47920ee6b13a5660b8 3273981bf03a46298ad5857a2c14eb17--76a94ad044304a47920ee6b13a5660b8 d7fecd77c2974638af42e6560b5b7c72 76a94ad044304a47920ee6b13a5660b8--d7fecd77c2974638af42e6560b5b7c72 0fa3f2ec0b304893b21714810bc3d449 d7fecd77c2974638af42e6560b5b7c72--0fa3f2ec0b304893b21714810bc3d449 88c5a477a52a41a0bf1bbf4217bf0206 0fa3f2ec0b304893b21714810bc3d449--88c5a477a52a41a0bf1bbf4217bf0206 2b4c2a0dcaf44748b4da8da924892ea1 88c5a477a52a41a0bf1bbf4217bf0206--2b4c2a0dcaf44748b4da8da924892ea1 afa08b7feeb1449baad17cb6cad4530d 2b4c2a0dcaf44748b4da8da924892ea1--afa08b7feeb1449baad17cb6cad4530d 582a122312954f67b7df23dad2d0a19f afa08b7feeb1449baad17cb6cad4530d--582a122312954f67b7df23dad2d0a19f 7d1e73ffb5fa47ca9a311914784fe9b5 582a122312954f67b7df23dad2d0a19f--7d1e73ffb5fa47ca9a311914784fe9b5 cdc35924d31242aa9b35037ae234b4e5 7d1e73ffb5fa47ca9a311914784fe9b5--cdc35924d31242aa9b35037ae234b4e5 21fea4a207f2479493c5be7b45624f76 cdc35924d31242aa9b35037ae234b4e5--21fea4a207f2479493c5be7b45624f76 794e1d39a3d9415497e256e081ff04bb 21fea4a207f2479493c5be7b45624f76--794e1d39a3d9415497e256e081ff04bb d27bab8809364ebda3286da44852b983 794e1d39a3d9415497e256e081ff04bb--d27bab8809364ebda3286da44852b983 b1f831d70332481d993027565535b8ad d27bab8809364ebda3286da44852b983--b1f831d70332481d993027565535b8ad af80c1a1ea474065800c9ab54edb3794 b1f831d70332481d993027565535b8ad--af80c1a1ea474065800c9ab54edb3794 88bce3d367d2451f96ffc785a7bd95e0 af80c1a1ea474065800c9ab54edb3794--88bce3d367d2451f96ffc785a7bd95e0 7990448b0158426abba7dddf3000a527 88bce3d367d2451f96ffc785a7bd95e0--7990448b0158426abba7dddf3000a527 80d3a04f347e4e218ab332dd17fb375f 7990448b0158426abba7dddf3000a527--80d3a04f347e4e218ab332dd17fb375f c553149038ec4a02bcff4fbdd391137b 80d3a04f347e4e218ab332dd17fb375f--c553149038ec4a02bcff4fbdd391137b 9c0a5855b30148f5ad33d2cbb937bfd9 c553149038ec4a02bcff4fbdd391137b--9c0a5855b30148f5ad33d2cbb937bfd9 f1406d7733a341ebbf2bbf18ec14b603 9c0a5855b30148f5ad33d2cbb937bfd9--f1406d7733a341ebbf2bbf18ec14b603 37f5cde1b4f94078963f3a32041d3412 X f1406d7733a341ebbf2bbf18ec14b603--37f5cde1b4f94078963f3a32041d3412 37f5cde1b4f94078963f3a32041d3412--c7256c35c903497fb485681252e83d4e f53f49b92dd94b47bd22c41d7a8a1df3 RZ(-1.0*g0) 37f5cde1b4f94078963f3a32041d3412--f53f49b92dd94b47bd22c41d7a8a1df3 08da7f5b8de340c6b757470f4f276670 X f53f49b92dd94b47bd22c41d7a8a1df3--08da7f5b8de340c6b757470f4f276670 08da7f5b8de340c6b757470f4f276670--affb4bdcfc1a4b63926c130dcb91cd52 c031b362a2624f51a7b055eb251ffe69 08da7f5b8de340c6b757470f4f276670--c031b362a2624f51a7b055eb251ffe69 be093e19ba174389ae8f5680f7bb553c c031b362a2624f51a7b055eb251ffe69--be093e19ba174389ae8f5680f7bb553c 507a07b775c742b18aff7596f2d734ac be093e19ba174389ae8f5680f7bb553c--507a07b775c742b18aff7596f2d734ac b9ddfb61c30e4de6b18dbe24ffdcd25a 507a07b775c742b18aff7596f2d734ac--b9ddfb61c30e4de6b18dbe24ffdcd25a d8995ff41d62480286d124ec2963fe60 b9ddfb61c30e4de6b18dbe24ffdcd25a--d8995ff41d62480286d124ec2963fe60 fc8bf63dfba842b69f81f7c2df4a037b d8995ff41d62480286d124ec2963fe60--fc8bf63dfba842b69f81f7c2df4a037b c1906cef65c144a1b65443d2d9333de6 fc8bf63dfba842b69f81f7c2df4a037b--c1906cef65c144a1b65443d2d9333de6 4184fe366dd7463580cc6133d1b5a700 c1906cef65c144a1b65443d2d9333de6--4184fe366dd7463580cc6133d1b5a700 a384043f9abd4c4297045565739d1ded 4184fe366dd7463580cc6133d1b5a700--a384043f9abd4c4297045565739d1ded cf7d4a5f33484734b73a5e7f23677406 a384043f9abd4c4297045565739d1ded--cf7d4a5f33484734b73a5e7f23677406 83f4eb45ea4f418bb4c20c7c86cada0d cf7d4a5f33484734b73a5e7f23677406--83f4eb45ea4f418bb4c20c7c86cada0d 209158db4522454884cc15ecea63a69a 83f4eb45ea4f418bb4c20c7c86cada0d--209158db4522454884cc15ecea63a69a 93c85f29349148bb8f72d92fba2b9331 209158db4522454884cc15ecea63a69a--93c85f29349148bb8f72d92fba2b9331 e146c90a47d943bf8a0c9ac350329bca 93c85f29349148bb8f72d92fba2b9331--e146c90a47d943bf8a0c9ac350329bca 7f62970d7ea34ac09933c15f207a169a e146c90a47d943bf8a0c9ac350329bca--7f62970d7ea34ac09933c15f207a169a e9ad733613684298b943810e1a56f480 7f62970d7ea34ac09933c15f207a169a--e9ad733613684298b943810e1a56f480 23a56335a2a845a3a79739c1f8f0a99d e9ad733613684298b943810e1a56f480--23a56335a2a845a3a79739c1f8f0a99d 92bb4a7ce7c24835b7beb3954fbb50fa 23a56335a2a845a3a79739c1f8f0a99d--92bb4a7ce7c24835b7beb3954fbb50fa 96e68426585b4400a1398cee2efa10b2 92bb4a7ce7c24835b7beb3954fbb50fa--96e68426585b4400a1398cee2efa10b2 7a5bccc641564289b2f7c92b62671394 96e68426585b4400a1398cee2efa10b2--7a5bccc641564289b2f7c92b62671394 17af86be70b2425eaf8964ed9e379f86 7a5bccc641564289b2f7c92b62671394--17af86be70b2425eaf8964ed9e379f86 c841af6486164e8ea6a7d6780e917d25 17af86be70b2425eaf8964ed9e379f86--c841af6486164e8ea6a7d6780e917d25 2328f7739ab045ecb59a0770ea646c7c c841af6486164e8ea6a7d6780e917d25--2328f7739ab045ecb59a0770ea646c7c e4918583b57744118c34b6ee784ad451 2328f7739ab045ecb59a0770ea646c7c--e4918583b57744118c34b6ee784ad451 12e141ef8ed84f82b0f9422642199284 e4918583b57744118c34b6ee784ad451--12e141ef8ed84f82b0f9422642199284 8a75e6e47171491180c6ca1b6fd6600a 12e141ef8ed84f82b0f9422642199284--8a75e6e47171491180c6ca1b6fd6600a 4bcfbcba63c04151b706ec8817a1ba64 8a75e6e47171491180c6ca1b6fd6600a--4bcfbcba63c04151b706ec8817a1ba64 c5716e88d66c4f21a5e054c700c68f0a 4bcfbcba63c04151b706ec8817a1ba64--c5716e88d66c4f21a5e054c700c68f0a 3119ec37673745ef8f10e46feaeb31b2 c5716e88d66c4f21a5e054c700c68f0a--3119ec37673745ef8f10e46feaeb31b2 1375f3ba623f4ecea7ca07e4d174239b 3119ec37673745ef8f10e46feaeb31b2--1375f3ba623f4ecea7ca07e4d174239b acdfe87437454dee9ae728f74f9cb90b 1375f3ba623f4ecea7ca07e4d174239b--acdfe87437454dee9ae728f74f9cb90b 37a1f8f408e3401080af22266a0c9d86 acdfe87437454dee9ae728f74f9cb90b--37a1f8f408e3401080af22266a0c9d86 e9314caaa2ae4c1aaf7d30f35c57e232 37a1f8f408e3401080af22266a0c9d86--e9314caaa2ae4c1aaf7d30f35c57e232 ee3bac465d5b4490a4979a8888f18e75 e9314caaa2ae4c1aaf7d30f35c57e232--ee3bac465d5b4490a4979a8888f18e75 9e3931be38014cc6865d387293c2f911 ee3bac465d5b4490a4979a8888f18e75--9e3931be38014cc6865d387293c2f911 7a9c87443b944ba59ef32e35533b438f 9e3931be38014cc6865d387293c2f911--7a9c87443b944ba59ef32e35533b438f b5d8ec9abee14006b44c821c2daae6f4 7a9c87443b944ba59ef32e35533b438f--b5d8ec9abee14006b44c821c2daae6f4 97b5884d0c1e4948bd9998146b4d6d52 b5d8ec9abee14006b44c821c2daae6f4--97b5884d0c1e4948bd9998146b4d6d52 651995619abf4d0bb4a3a37c9eb3b30f 97b5884d0c1e4948bd9998146b4d6d52--651995619abf4d0bb4a3a37c9eb3b30f 90911b0f1fd54b24b8b5a9f069f3ff3d 651995619abf4d0bb4a3a37c9eb3b30f--90911b0f1fd54b24b8b5a9f069f3ff3d 2c1ca37e970c47519b3065a69889c81b 90911b0f1fd54b24b8b5a9f069f3ff3d--2c1ca37e970c47519b3065a69889c81b 12a18c7cb31e44b6847b0d3d246b7310 2c1ca37e970c47519b3065a69889c81b--12a18c7cb31e44b6847b0d3d246b7310 3ad1173421894392a9e9066c1191859c 12a18c7cb31e44b6847b0d3d246b7310--3ad1173421894392a9e9066c1191859c 360f1931ab3a455c89a6ec74f9c6b2eb X 3ad1173421894392a9e9066c1191859c--360f1931ab3a455c89a6ec74f9c6b2eb 360f1931ab3a455c89a6ec74f9c6b2eb--4d04b6a0b5564648bff5d353a3f065e8 e095db876cd44bc69370ea147e896f5b RZ(-1.0*g0) 360f1931ab3a455c89a6ec74f9c6b2eb--e095db876cd44bc69370ea147e896f5b ede6e0a110ae4163b89528162aa5cb07 X e095db876cd44bc69370ea147e896f5b--ede6e0a110ae4163b89528162aa5cb07 ede6e0a110ae4163b89528162aa5cb07--acc7a93c6ba94827a5ef01fbdf79cd1c c4e45d6bdab54647b28b8733e73951af ede6e0a110ae4163b89528162aa5cb07--c4e45d6bdab54647b28b8733e73951af 1d0a4bea337249f88aa30b8eeb3398f4 c4e45d6bdab54647b28b8733e73951af--1d0a4bea337249f88aa30b8eeb3398f4 7f8d54748ccb4a5b9e85487570286794 1d0a4bea337249f88aa30b8eeb3398f4--7f8d54748ccb4a5b9e85487570286794 e332249cddab4f3f9212b6fc72e830d7 7f8d54748ccb4a5b9e85487570286794--e332249cddab4f3f9212b6fc72e830d7 f84d973e310248d2b16f7a148a370eb1 e332249cddab4f3f9212b6fc72e830d7--f84d973e310248d2b16f7a148a370eb1 eb4a6cc812b24b8382e2273c86a39d6e f84d973e310248d2b16f7a148a370eb1--eb4a6cc812b24b8382e2273c86a39d6e 4611cd341df74b0aabed7f82708f80c0 eb4a6cc812b24b8382e2273c86a39d6e--4611cd341df74b0aabed7f82708f80c0 0de2dfa2d423436f86bb15b88b4d549c 4611cd341df74b0aabed7f82708f80c0--0de2dfa2d423436f86bb15b88b4d549c 4640d65dcf474d8f8b5d8126ae5d735f 0de2dfa2d423436f86bb15b88b4d549c--4640d65dcf474d8f8b5d8126ae5d735f f94a9ec3406e444ea9af8a38f6161133 4640d65dcf474d8f8b5d8126ae5d735f--f94a9ec3406e444ea9af8a38f6161133 5b7108ff287c46c09d72a5905bebb721 f94a9ec3406e444ea9af8a38f6161133--5b7108ff287c46c09d72a5905bebb721 74cef04fcc044830a87b7d10b4f35dc9 5b7108ff287c46c09d72a5905bebb721--74cef04fcc044830a87b7d10b4f35dc9 458f06d1ba3146088317c735168b3225 74cef04fcc044830a87b7d10b4f35dc9--458f06d1ba3146088317c735168b3225 cba63b7ffa304379b89c0ad4d0942ba4 458f06d1ba3146088317c735168b3225--cba63b7ffa304379b89c0ad4d0942ba4 44d844c44bc84d3b98af3163ee019f81 cba63b7ffa304379b89c0ad4d0942ba4--44d844c44bc84d3b98af3163ee019f81 b635c1178b72411aa6d89e4e6e07be59 44d844c44bc84d3b98af3163ee019f81--b635c1178b72411aa6d89e4e6e07be59 99066780f8ca454aafbcac5c95cba34f b635c1178b72411aa6d89e4e6e07be59--99066780f8ca454aafbcac5c95cba34f 129b6d20ff484a5280fcc4ee6eb73045 99066780f8ca454aafbcac5c95cba34f--129b6d20ff484a5280fcc4ee6eb73045 c6820ab212634febadcc3d062b64a612 129b6d20ff484a5280fcc4ee6eb73045--c6820ab212634febadcc3d062b64a612 7f7f8338fe8d45b08b30d95db9e88ce6 c6820ab212634febadcc3d062b64a612--7f7f8338fe8d45b08b30d95db9e88ce6 b3ace6ae602047ba89a192fc6332249a 7f7f8338fe8d45b08b30d95db9e88ce6--b3ace6ae602047ba89a192fc6332249a 9e1fb1806ca748ba9e5a2e4fd5e5afa8 b3ace6ae602047ba89a192fc6332249a--9e1fb1806ca748ba9e5a2e4fd5e5afa8 218935aca86344919b5ddb59e7375da5 9e1fb1806ca748ba9e5a2e4fd5e5afa8--218935aca86344919b5ddb59e7375da5 b9c8bbaa3c72423b9e147f20cfbc9b0b 218935aca86344919b5ddb59e7375da5--b9c8bbaa3c72423b9e147f20cfbc9b0b a2f243b09d8c439997718055697f7660 b9c8bbaa3c72423b9e147f20cfbc9b0b--a2f243b09d8c439997718055697f7660 25a1eac22dc94eaeb15557686cfe0ea5 a2f243b09d8c439997718055697f7660--25a1eac22dc94eaeb15557686cfe0ea5 a4b2a07d798446d39f9f5e546980860c 25a1eac22dc94eaeb15557686cfe0ea5--a4b2a07d798446d39f9f5e546980860c 08f68b202b6e42c7b253fc0f4ee84b5c RX(b07) a4b2a07d798446d39f9f5e546980860c--08f68b202b6e42c7b253fc0f4ee84b5c 800f83e65a7942ce89576fe1f6023eaa 08f68b202b6e42c7b253fc0f4ee84b5c--800f83e65a7942ce89576fe1f6023eaa 21fa7f55b43f4a488d75d9fd5c29f423 800f83e65a7942ce89576fe1f6023eaa--21fa7f55b43f4a488d75d9fd5c29f423 ed9a982ca9f74171b8caa969a38bed66 21fa7f55b43f4a488d75d9fd5c29f423--ed9a982ca9f74171b8caa969a38bed66 16a0c2c538934c779ac75add81ae1834 ed9a982ca9f74171b8caa969a38bed66--16a0c2c538934c779ac75add81ae1834 b2923cf40aa146cb9bc9125fa70094a6 16a0c2c538934c779ac75add81ae1834--b2923cf40aa146cb9bc9125fa70094a6 922a41e48fee44eaada173a4f2d85bd9 b2923cf40aa146cb9bc9125fa70094a6--922a41e48fee44eaada173a4f2d85bd9 a7dc2752421342399f301e41beef7cbd X 922a41e48fee44eaada173a4f2d85bd9--a7dc2752421342399f301e41beef7cbd a7dc2752421342399f301e41beef7cbd--5e1fade828f24e8394a4b4070bff8e23 78a3cec084484ff7961f0ddfc221ce7c RZ(1.0*g1) a7dc2752421342399f301e41beef7cbd--78a3cec084484ff7961f0ddfc221ce7c c5c65a0f423c4d4bb05bffd06f4b6492 X 78a3cec084484ff7961f0ddfc221ce7c--c5c65a0f423c4d4bb05bffd06f4b6492 c5c65a0f423c4d4bb05bffd06f4b6492--73651646d0684ec799579c2dd784fcd5 fb13bb1895fb45d3be28a17364cb61cc c5c65a0f423c4d4bb05bffd06f4b6492--fb13bb1895fb45d3be28a17364cb61cc 9c6c81b8324b4e548a9d7895d0e15a11 fb13bb1895fb45d3be28a17364cb61cc--9c6c81b8324b4e548a9d7895d0e15a11 7889084c8e9948f5acb5864df8880fd4 9c6c81b8324b4e548a9d7895d0e15a11--7889084c8e9948f5acb5864df8880fd4 87cca268e1034901b1e8bb43fadc8e31 7889084c8e9948f5acb5864df8880fd4--87cca268e1034901b1e8bb43fadc8e31 9837df93483349b1b5ab59c92c334767 87cca268e1034901b1e8bb43fadc8e31--9837df93483349b1b5ab59c92c334767 4c66e07dab004fe483a0a95ee901ca31 9837df93483349b1b5ab59c92c334767--4c66e07dab004fe483a0a95ee901ca31 9f1e25ceb13c41b4beb194ae8de46388 4c66e07dab004fe483a0a95ee901ca31--9f1e25ceb13c41b4beb194ae8de46388 cca2ca11ba6e4643b8d68ef0d5cba68c 9f1e25ceb13c41b4beb194ae8de46388--cca2ca11ba6e4643b8d68ef0d5cba68c 61820b41ca8d4a56bec6feb94cf42f48 cca2ca11ba6e4643b8d68ef0d5cba68c--61820b41ca8d4a56bec6feb94cf42f48 f33c9b8006014e8f99fe2e3e001cf502 61820b41ca8d4a56bec6feb94cf42f48--f33c9b8006014e8f99fe2e3e001cf502 5fc9744f265845c7a0b2b2a420e4c12f f33c9b8006014e8f99fe2e3e001cf502--5fc9744f265845c7a0b2b2a420e4c12f a3e4ab40941241b68ac6ba7b6bb9b241 5fc9744f265845c7a0b2b2a420e4c12f--a3e4ab40941241b68ac6ba7b6bb9b241 5045dbe3d235457a95de91341d2c4a01 a3e4ab40941241b68ac6ba7b6bb9b241--5045dbe3d235457a95de91341d2c4a01 22ea63e1964c4811a3a038e96f623b31 5045dbe3d235457a95de91341d2c4a01--22ea63e1964c4811a3a038e96f623b31 d1dffb7cdbb449ad8b2de6d49ccbfc4d 22ea63e1964c4811a3a038e96f623b31--d1dffb7cdbb449ad8b2de6d49ccbfc4d e817c28af50b47f6a8ed871734f9a923 d1dffb7cdbb449ad8b2de6d49ccbfc4d--e817c28af50b47f6a8ed871734f9a923 0de6fcf456af47b7a5333f961c3e82f4 e817c28af50b47f6a8ed871734f9a923--0de6fcf456af47b7a5333f961c3e82f4 077e629095aa44f398710ac13dc00f22 0de6fcf456af47b7a5333f961c3e82f4--077e629095aa44f398710ac13dc00f22 fa186998e9174d07ba98b02383decc06 077e629095aa44f398710ac13dc00f22--fa186998e9174d07ba98b02383decc06 831155473a9743bb816a25801b003af1 fa186998e9174d07ba98b02383decc06--831155473a9743bb816a25801b003af1 f400e83f9f0141329ad2c3c04d30de01 831155473a9743bb816a25801b003af1--f400e83f9f0141329ad2c3c04d30de01 4d7efe932d6c46dfa9b18828a36f5b9c f400e83f9f0141329ad2c3c04d30de01--4d7efe932d6c46dfa9b18828a36f5b9c fe7ba61de7cf4209a43d5be202eb2a38 4d7efe932d6c46dfa9b18828a36f5b9c--fe7ba61de7cf4209a43d5be202eb2a38 da5577259c014d9b9bf6a7f5b27b316b fe7ba61de7cf4209a43d5be202eb2a38--da5577259c014d9b9bf6a7f5b27b316b fd91af9176634c709cebe36039ab3b9b da5577259c014d9b9bf6a7f5b27b316b--fd91af9176634c709cebe36039ab3b9b 46c6cff7aed34e6e8bcd5174e10e2e19 fd91af9176634c709cebe36039ab3b9b--46c6cff7aed34e6e8bcd5174e10e2e19 870e2cb2c62e4e009ca84d12444c46d6 46c6cff7aed34e6e8bcd5174e10e2e19--870e2cb2c62e4e009ca84d12444c46d6 ca885f3be8b64bae84afba89c3ee6a9d 870e2cb2c62e4e009ca84d12444c46d6--ca885f3be8b64bae84afba89c3ee6a9d 41a68e402c71400a8001278157b2f941 ca885f3be8b64bae84afba89c3ee6a9d--41a68e402c71400a8001278157b2f941 d57e9dea2bfd45fd8d3e542b9740dffc 41a68e402c71400a8001278157b2f941--d57e9dea2bfd45fd8d3e542b9740dffc 7fadc50a163c4a3993b592f7675733eb d57e9dea2bfd45fd8d3e542b9740dffc--7fadc50a163c4a3993b592f7675733eb c7732718246a44b98ea13ee16e0e9417 7fadc50a163c4a3993b592f7675733eb--c7732718246a44b98ea13ee16e0e9417 ea1364c683e74b99bb793efb903ffade c7732718246a44b98ea13ee16e0e9417--ea1364c683e74b99bb793efb903ffade e96b907c0fb845a386127995dc9f9ca6 ea1364c683e74b99bb793efb903ffade--e96b907c0fb845a386127995dc9f9ca6 0dc9f3d5fb4049eda77f9e372d7f8a60 e96b907c0fb845a386127995dc9f9ca6--0dc9f3d5fb4049eda77f9e372d7f8a60 b830d41da25741bbaa6e3d8f1e13a57c 0dc9f3d5fb4049eda77f9e372d7f8a60--b830d41da25741bbaa6e3d8f1e13a57c d98ad364e2494ee2b4604de4d8be231a b830d41da25741bbaa6e3d8f1e13a57c--d98ad364e2494ee2b4604de4d8be231a b5c3fdf806194f2abbe537facb24465b d98ad364e2494ee2b4604de4d8be231a--b5c3fdf806194f2abbe537facb24465b b91a72487cb842d780b2294c0208c06f b5c3fdf806194f2abbe537facb24465b--b91a72487cb842d780b2294c0208c06f 0940219087d7475893dd8d589d910db6 b91a72487cb842d780b2294c0208c06f--0940219087d7475893dd8d589d910db6 c2f7704ed95541e8876f6cc0aee94d72 0940219087d7475893dd8d589d910db6--c2f7704ed95541e8876f6cc0aee94d72 6b3c35aea1fa4718a3df87b94be7910b c2f7704ed95541e8876f6cc0aee94d72--6b3c35aea1fa4718a3df87b94be7910b 3fd56b54c8134c408fd813096f8961e1 6b3c35aea1fa4718a3df87b94be7910b--3fd56b54c8134c408fd813096f8961e1 113a4cffd7e94cf2a1ea6904795216a2 3fd56b54c8134c408fd813096f8961e1--113a4cffd7e94cf2a1ea6904795216a2 19fbf9e2397646cf9367687396f9a0d7 X 113a4cffd7e94cf2a1ea6904795216a2--19fbf9e2397646cf9367687396f9a0d7 19fbf9e2397646cf9367687396f9a0d7--aee57169c6c24066931ddce805f797d7 94e7f5ba56c5449a9765bad3e79e61b8 RZ(-1.0*g1) 19fbf9e2397646cf9367687396f9a0d7--94e7f5ba56c5449a9765bad3e79e61b8 4e70b9e6b14e4a21ac4f6c75fad67d0f X 94e7f5ba56c5449a9765bad3e79e61b8--4e70b9e6b14e4a21ac4f6c75fad67d0f 4e70b9e6b14e4a21ac4f6c75fad67d0f--15f207e1250e4937bbd32ddd6bb6ed06 8ec9c9e5c60c412586b7b3e385e82cac 4e70b9e6b14e4a21ac4f6c75fad67d0f--8ec9c9e5c60c412586b7b3e385e82cac ede424c705f54238ba196b9def3f5b6d 8ec9c9e5c60c412586b7b3e385e82cac--ede424c705f54238ba196b9def3f5b6d 5096bb9d628847cba5901ca14872eb11 ede424c705f54238ba196b9def3f5b6d--5096bb9d628847cba5901ca14872eb11 009c273176ef4f29bbafa1eb197d73ba 5096bb9d628847cba5901ca14872eb11--009c273176ef4f29bbafa1eb197d73ba 3486427ee4e14d7393819db6daddece9 009c273176ef4f29bbafa1eb197d73ba--3486427ee4e14d7393819db6daddece9 7c4c85d06c024cbc8aacdb6238110223 3486427ee4e14d7393819db6daddece9--7c4c85d06c024cbc8aacdb6238110223 f41e5ca56c1948f0bc812f1ca26cbfbf 7c4c85d06c024cbc8aacdb6238110223--f41e5ca56c1948f0bc812f1ca26cbfbf 208d8d28d9c14c1f8b9657857cf2ff8c f41e5ca56c1948f0bc812f1ca26cbfbf--208d8d28d9c14c1f8b9657857cf2ff8c 18885b39361644778de0c9bc6c9209e9 208d8d28d9c14c1f8b9657857cf2ff8c--18885b39361644778de0c9bc6c9209e9 52461a89edd04f52bec8ea5737ac0fa0 18885b39361644778de0c9bc6c9209e9--52461a89edd04f52bec8ea5737ac0fa0 9a26a31a0ef642dbb51f166e46886ad8 52461a89edd04f52bec8ea5737ac0fa0--9a26a31a0ef642dbb51f166e46886ad8 d0588fdc90844902b7fbb03dd70272f3 9a26a31a0ef642dbb51f166e46886ad8--d0588fdc90844902b7fbb03dd70272f3 5ebb3f4e86ae458e8dec594992d8f6ff d0588fdc90844902b7fbb03dd70272f3--5ebb3f4e86ae458e8dec594992d8f6ff eb02aaf61a3a42d8bc4a75d0b40a7f29 5ebb3f4e86ae458e8dec594992d8f6ff--eb02aaf61a3a42d8bc4a75d0b40a7f29 6ecd9962c399424484e53cab8e950707 eb02aaf61a3a42d8bc4a75d0b40a7f29--6ecd9962c399424484e53cab8e950707 977e53509c0c41948e21c5763fe751c6 6ecd9962c399424484e53cab8e950707--977e53509c0c41948e21c5763fe751c6 be0f2406a8ce478cb1d3c988bf738982 977e53509c0c41948e21c5763fe751c6--be0f2406a8ce478cb1d3c988bf738982 8198dd7d72524b6ea1566c92841e9c4f be0f2406a8ce478cb1d3c988bf738982--8198dd7d72524b6ea1566c92841e9c4f de05407c75324910b57034419460088f 8198dd7d72524b6ea1566c92841e9c4f--de05407c75324910b57034419460088f 710ba20e41ff4bf4838adf84f1f82289 de05407c75324910b57034419460088f--710ba20e41ff4bf4838adf84f1f82289 504007f8079e46708416e31bd34e2a39 710ba20e41ff4bf4838adf84f1f82289--504007f8079e46708416e31bd34e2a39 c367a919d4c34aecbd1aa9a95626c17a 504007f8079e46708416e31bd34e2a39--c367a919d4c34aecbd1aa9a95626c17a 6f2e9eb219ee44e3b6c91b6b203d8ddd c367a919d4c34aecbd1aa9a95626c17a--6f2e9eb219ee44e3b6c91b6b203d8ddd e714eccdd1cc478ea53c3e515598a854 6f2e9eb219ee44e3b6c91b6b203d8ddd--e714eccdd1cc478ea53c3e515598a854 64054b7403734bfc9d5d99cf89f682e5 e714eccdd1cc478ea53c3e515598a854--64054b7403734bfc9d5d99cf89f682e5 1efc09469a2b45b3b7b1c468de7a2a40 64054b7403734bfc9d5d99cf89f682e5--1efc09469a2b45b3b7b1c468de7a2a40 f749adb7f2f94f1d8d0a8a3296488f89 1efc09469a2b45b3b7b1c468de7a2a40--f749adb7f2f94f1d8d0a8a3296488f89 07ef2c8df7154ca1821262fbfdf3a5e2 f749adb7f2f94f1d8d0a8a3296488f89--07ef2c8df7154ca1821262fbfdf3a5e2 4abe4f95f1f247debdf2c756ead2b1ab 07ef2c8df7154ca1821262fbfdf3a5e2--4abe4f95f1f247debdf2c756ead2b1ab 15c757abea63478b9e6d12894f1476fa 4abe4f95f1f247debdf2c756ead2b1ab--15c757abea63478b9e6d12894f1476fa 631a2be4251b4011b54fc269e291a543 15c757abea63478b9e6d12894f1476fa--631a2be4251b4011b54fc269e291a543 398242a7c3744a38814c9ae73f245b10 631a2be4251b4011b54fc269e291a543--398242a7c3744a38814c9ae73f245b10 36d8d9d5e88749a2a301f06c03cd0e67 398242a7c3744a38814c9ae73f245b10--36d8d9d5e88749a2a301f06c03cd0e67 0d0df693c7ea46e0b1894a714dc62ee0 36d8d9d5e88749a2a301f06c03cd0e67--0d0df693c7ea46e0b1894a714dc62ee0 2de52cb5e2ec4d5b81ff2ea56ec22ea0 0d0df693c7ea46e0b1894a714dc62ee0--2de52cb5e2ec4d5b81ff2ea56ec22ea0 d93756d8e5b7484ea7b47c05d7db1461 2de52cb5e2ec4d5b81ff2ea56ec22ea0--d93756d8e5b7484ea7b47c05d7db1461 8471c5524e544a00aef17945910a877e d93756d8e5b7484ea7b47c05d7db1461--8471c5524e544a00aef17945910a877e be84f4b3d40d44df8406edfd58df5409 8471c5524e544a00aef17945910a877e--be84f4b3d40d44df8406edfd58df5409 96b95b18765447b892e68c4bc8d0296b be84f4b3d40d44df8406edfd58df5409--96b95b18765447b892e68c4bc8d0296b 3e360f84aefd499f8af5e279f9b68093 96b95b18765447b892e68c4bc8d0296b--3e360f84aefd499f8af5e279f9b68093 d25c1f721faf43b480566b5684bc13d9 3e360f84aefd499f8af5e279f9b68093--d25c1f721faf43b480566b5684bc13d9 a097cc5ed7d04ffc94beeabd1db48509 d25c1f721faf43b480566b5684bc13d9--a097cc5ed7d04ffc94beeabd1db48509 2313d9478c1a4042861b92861c7382fa a097cc5ed7d04ffc94beeabd1db48509--2313d9478c1a4042861b92861c7382fa 9906c97b5d4042ec8f6c8b4f0fba6793 X 2313d9478c1a4042861b92861c7382fa--9906c97b5d4042ec8f6c8b4f0fba6793 9906c97b5d4042ec8f6c8b4f0fba6793--1b9c3ec9011342e2b9b90e46979ec55b 18aa052cf3d04c0d9b0f79479fb38838 RZ(-1.0*g1) 9906c97b5d4042ec8f6c8b4f0fba6793--18aa052cf3d04c0d9b0f79479fb38838 82d46201bd5446b8a687eec237fa3501 X 18aa052cf3d04c0d9b0f79479fb38838--82d46201bd5446b8a687eec237fa3501 82d46201bd5446b8a687eec237fa3501--63ec8905b3e94162aed845c8f1276d64 0a8181af5b0e422fac7c959c7aedb4b4 82d46201bd5446b8a687eec237fa3501--0a8181af5b0e422fac7c959c7aedb4b4 ff7b3c0c6f444bac8497bb34102ce5fe 0a8181af5b0e422fac7c959c7aedb4b4--ff7b3c0c6f444bac8497bb34102ce5fe 1223289377cc411fb6170197fb918209 ff7b3c0c6f444bac8497bb34102ce5fe--1223289377cc411fb6170197fb918209 12cad69daf434f1eb4616499645450d5 1223289377cc411fb6170197fb918209--12cad69daf434f1eb4616499645450d5 7de3727f0631403b87df10600565a3e6 12cad69daf434f1eb4616499645450d5--7de3727f0631403b87df10600565a3e6 37be111c8455479281a2e22f78447b66 7de3727f0631403b87df10600565a3e6--37be111c8455479281a2e22f78447b66 c7cbf3b8844c41aeb5338fec9a6545e3 37be111c8455479281a2e22f78447b66--c7cbf3b8844c41aeb5338fec9a6545e3 7509bfb30ae040aea5bbf71268bd249e c7cbf3b8844c41aeb5338fec9a6545e3--7509bfb30ae040aea5bbf71268bd249e 03abff9d382447bdbc3e0ae97c787c5b 7509bfb30ae040aea5bbf71268bd249e--03abff9d382447bdbc3e0ae97c787c5b f530706a13c849b492e95e8a9b0e9031 03abff9d382447bdbc3e0ae97c787c5b--f530706a13c849b492e95e8a9b0e9031 9560144c04ad4f589a673cf777021c8f f530706a13c849b492e95e8a9b0e9031--9560144c04ad4f589a673cf777021c8f 2e3047d2c9cc432eabf84dcfc21f4f0e 9560144c04ad4f589a673cf777021c8f--2e3047d2c9cc432eabf84dcfc21f4f0e fef124ac4b7e4294b99aac6a75ec3505 2e3047d2c9cc432eabf84dcfc21f4f0e--fef124ac4b7e4294b99aac6a75ec3505 ab908c8c2bd64d4cbf2d630d461bd967 fef124ac4b7e4294b99aac6a75ec3505--ab908c8c2bd64d4cbf2d630d461bd967 6614a50bec1d44c1b968e2b166fba594 ab908c8c2bd64d4cbf2d630d461bd967--6614a50bec1d44c1b968e2b166fba594 bd950b592a764882877254e41c0e117f 6614a50bec1d44c1b968e2b166fba594--bd950b592a764882877254e41c0e117f 58e0c306adb7487cb0a40f79430b7828 bd950b592a764882877254e41c0e117f--58e0c306adb7487cb0a40f79430b7828 3ae85d1e7b164747879abd2f33d567dd 58e0c306adb7487cb0a40f79430b7828--3ae85d1e7b164747879abd2f33d567dd aee2da95b85843f9b35e4227eeb706bd 3ae85d1e7b164747879abd2f33d567dd--aee2da95b85843f9b35e4227eeb706bd b7405d9257f145b48cfd8b6d88d3138f aee2da95b85843f9b35e4227eeb706bd--b7405d9257f145b48cfd8b6d88d3138f 9958aeb651364fae8738293d4c5cd94c b7405d9257f145b48cfd8b6d88d3138f--9958aeb651364fae8738293d4c5cd94c 1d31306f5ba8410daba09f94aabe8f62 9958aeb651364fae8738293d4c5cd94c--1d31306f5ba8410daba09f94aabe8f62 e8289afdb8464607b13085872e2416b5 1d31306f5ba8410daba09f94aabe8f62--e8289afdb8464607b13085872e2416b5 c40420173e494105ae9a5e0d037a7bc7 e8289afdb8464607b13085872e2416b5--c40420173e494105ae9a5e0d037a7bc7 f9c5b6a6f2c34113b73a0031d07b08e9 c40420173e494105ae9a5e0d037a7bc7--f9c5b6a6f2c34113b73a0031d07b08e9 624c0270f2e14ba8b62576193c7804de f9c5b6a6f2c34113b73a0031d07b08e9--624c0270f2e14ba8b62576193c7804de c00ff638843a4e118c0897c14f06a916 624c0270f2e14ba8b62576193c7804de--c00ff638843a4e118c0897c14f06a916 cea9584e0f14404b9c9dbf400749a425 RX(b17) c00ff638843a4e118c0897c14f06a916--cea9584e0f14404b9c9dbf400749a425 cea9584e0f14404b9c9dbf400749a425--04043f6d3e1c4f77bef2ed1e027d4cfb"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -4.682667035374571\nMaxCut cost at iteration 10: 9.845557872125799\nMaxCut cost at iteration 20: 10.968831900313395\nMaxCut cost at iteration 30: 10.984600736021594\nMaxCut cost at iteration 40: 10.993870324614024\nMaxCut cost at iteration 50: 10.994954074264127\nMaxCut cost at iteration 60: 10.99584271549715\nMaxCut cost at iteration 70: 10.998423849823324\nMaxCut cost at iteration 80: 10.999702746916288\nMaxCut cost at iteration 90: 10.999948896438008\nMaxCut cost at iteration 100: 10.999990723632104\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 01011101  2024-02-01T18:45:47.032480 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2024-02-01T18:45:51.491810 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_7d519e247860467d88eba1ec5b81ab46 Constant Chebyshev FM cluster_d08197765e604db8b27ec90db2be68a5 Constant Fourier FM e847a459290f48de98b0b1f0d16b0f02 0 ae5a5dc9d3ce4ea298ce85306f322d1a RX(phi) e847a459290f48de98b0b1f0d16b0f02--ae5a5dc9d3ce4ea298ce85306f322d1a 4194332f95064ad6915c82c903cd6f7f 1 3719fc15901844cfb4cf904bf229e36a RX(acos(phi)) ae5a5dc9d3ce4ea298ce85306f322d1a--3719fc15901844cfb4cf904bf229e36a f262a22a873449fe82cf59c90e04f056 3719fc15901844cfb4cf904bf229e36a--f262a22a873449fe82cf59c90e04f056 6171347d5378464a816ef2745c3713d5 771132034b58459ea86565100bd38b5b RX(phi) 4194332f95064ad6915c82c903cd6f7f--771132034b58459ea86565100bd38b5b 2264249bb5664656b55e1d181872f567 2 6a5b84d6541f467aac0adc772b22bbb1 RX(acos(phi)) 771132034b58459ea86565100bd38b5b--6a5b84d6541f467aac0adc772b22bbb1 6a5b84d6541f467aac0adc772b22bbb1--6171347d5378464a816ef2745c3713d5 9e38dd7bd4234f3c9af48fbfe6b101b6 62daf4d8dbb24ac98636b78892b1cbe4 RX(phi) 2264249bb5664656b55e1d181872f567--62daf4d8dbb24ac98636b78892b1cbe4 eb52ae166c3947d99a44a43c6d39ac72 RX(acos(phi)) 62daf4d8dbb24ac98636b78892b1cbe4--eb52ae166c3947d99a44a43c6d39ac72 eb52ae166c3947d99a44a43c6d39ac72--9e38dd7bd4234f3c9af48fbfe6b101b6 <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom function\ndef custom_fn(x):\n    return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_fn)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_46c34881347e4b9eb5b2cb190da55617 Constant &lt;function custom_fn at 0x7f62f318fbe0&gt; FM cluster_601e8a708cb74900abd523e980149e63 Constant asin FM 0d4a687523204c31a0fdb38f78d1e28b 0 e2930aa95cb5446a8f00a1fea7928201 RX(asin(phi)) 0d4a687523204c31a0fdb38f78d1e28b--e2930aa95cb5446a8f00a1fea7928201 b05a6e523fe34c6cb4903c9a3ff13ac8 1 8acc24c9528d41c2a0efcf6769995a16 RX(phi**2 + asin(phi)) e2930aa95cb5446a8f00a1fea7928201--8acc24c9528d41c2a0efcf6769995a16 7be49fa780f149738430e020498702a8 8acc24c9528d41c2a0efcf6769995a16--7be49fa780f149738430e020498702a8 f196d6d669204775b0495a4dd45b93fe 3a2802413f1846038ee3014147ac557f RX(asin(phi)) b05a6e523fe34c6cb4903c9a3ff13ac8--3a2802413f1846038ee3014147ac557f e71e19ccf42940c6a5e2f5a1c5b6da92 2 b4da843a828d43f9a47b46038d0ccd20 RX(phi**2 + asin(phi)) 3a2802413f1846038ee3014147ac557f--b4da843a828d43f9a47b46038d0ccd20 b4da843a828d43f9a47b46038d0ccd20--f196d6d669204775b0495a4dd45b93fe 3a96ef571c7d441eb176e3be7226f325 6579f13ccc1748999997ff9a9d9e0e82 RX(asin(phi)) e71e19ccf42940c6a5e2f5a1c5b6da92--6579f13ccc1748999997ff9a9d9e0e82 cb46804b1b734c6eb8ce6026993f2cd1 RX(phi**2 + asin(phi)) 6579f13ccc1748999997ff9a9d9e0e82--cb46804b1b734c6eb8ce6026993f2cd1 cb46804b1b734c6eb8ce6026993f2cd1--3a96ef571c7d441eb176e3be7226f325 <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_259d0cf337804ed088c84934b7db6a5b Exponential Fourier FM cluster_195b38e94fb64aa09ac82c22a14dda5c Constant Fourier FM cluster_b2e582575b4b46f8911da87f81971f9f Tower Fourier FM 773ba4bdfc1340829ee1ca09ba40a10e 0 ec6b9aea58da4d3eafe59a775dd30ab7 RX(phi) 773ba4bdfc1340829ee1ca09ba40a10e--ec6b9aea58da4d3eafe59a775dd30ab7 cd3276c543f5446d91979e1d231eb3ac 1 c8a9782266a04ed5871f457f32ba90b5 RX(1.0*phi) ec6b9aea58da4d3eafe59a775dd30ab7--c8a9782266a04ed5871f457f32ba90b5 94a0029bb08045e2b262ac33b7a638eb RX(1.0*phi) c8a9782266a04ed5871f457f32ba90b5--94a0029bb08045e2b262ac33b7a638eb b619d6796bd44ce385b4ba1ea250d560 94a0029bb08045e2b262ac33b7a638eb--b619d6796bd44ce385b4ba1ea250d560 140160df7f1f4dc1a2af6843c5e03038 019fba474857478caba82c94a4e80e7c RX(phi) cd3276c543f5446d91979e1d231eb3ac--019fba474857478caba82c94a4e80e7c 7a752f81c12f4e5c93f23916f785d50e 2 734710b71f27461dabbd46eb0a4d6c86 RX(2.0*phi) 019fba474857478caba82c94a4e80e7c--734710b71f27461dabbd46eb0a4d6c86 a514406eb8764ef6a4a0765d4f27d046 RX(2.0*phi) 734710b71f27461dabbd46eb0a4d6c86--a514406eb8764ef6a4a0765d4f27d046 a514406eb8764ef6a4a0765d4f27d046--140160df7f1f4dc1a2af6843c5e03038 11b62e182323475b9dd4fe3fa5b44bf6 30adda81e3d84f6aa60abf815ebc8a66 RX(phi) 7a752f81c12f4e5c93f23916f785d50e--30adda81e3d84f6aa60abf815ebc8a66 7989685b2fa342ee98a4b9922cf2425a 3 d97858572c66431c86341dff5edcb3f1 RX(3.0*phi) 30adda81e3d84f6aa60abf815ebc8a66--d97858572c66431c86341dff5edcb3f1 ed65b71cf4ff475bbb2fee4b9aedfff3 RX(4.0*phi) d97858572c66431c86341dff5edcb3f1--ed65b71cf4ff475bbb2fee4b9aedfff3 ed65b71cf4ff475bbb2fee4b9aedfff3--11b62e182323475b9dd4fe3fa5b44bf6 63cf300f7d404ff6ad5d9005fdfc77a0 6a0d2dff380f41cebc3b989ea7a69aee RX(phi) 7989685b2fa342ee98a4b9922cf2425a--6a0d2dff380f41cebc3b989ea7a69aee 5b033e5712ae4eab94f37266dc56b39f 4 177664c66b34453da8df6a40114e4b96 RX(4.0*phi) 6a0d2dff380f41cebc3b989ea7a69aee--177664c66b34453da8df6a40114e4b96 f4b1c8c38e9b4ce1a22651f524b0f2a0 RX(8.0*phi) 177664c66b34453da8df6a40114e4b96--f4b1c8c38e9b4ce1a22651f524b0f2a0 f4b1c8c38e9b4ce1a22651f524b0f2a0--63cf300f7d404ff6ad5d9005fdfc77a0 34e07846867f426999137462d873c5ca cac752ba7a5c40aead172b7e77699ecd RX(phi) 5b033e5712ae4eab94f37266dc56b39f--cac752ba7a5c40aead172b7e77699ecd 760964fb02784965961800b0e3d7385b RX(5.0*phi) cac752ba7a5c40aead172b7e77699ecd--760964fb02784965961800b0e3d7385b 73623f12b3b04aae85650d1ed2f93f62 RX(16.0*phi) 760964fb02784965961800b0e3d7385b--73623f12b3b04aae85650d1ed2f93f62 73623f12b3b04aae85650d1ed2f93f62--34e07846867f426999137462d873c5ca <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 241601cc229643049ac595b2d12ded0b 0 a4dc449af1714c8e8581c91c2bcbb24c RX(1.0*acos(phi)) 241601cc229643049ac595b2d12ded0b--a4dc449af1714c8e8581c91c2bcbb24c 19d110f2ef8249708edae481b3959cdb 1 13c49039255245b1b6cc79a8553de000 a4dc449af1714c8e8581c91c2bcbb24c--13c49039255245b1b6cc79a8553de000 35270b95809343b3b1d6609ba42e0bdb 1bcfb8d401924570ae01b698601d1ef5 RX(1.414*acos(phi)) 19d110f2ef8249708edae481b3959cdb--1bcfb8d401924570ae01b698601d1ef5 f6581f1d20454f5abfe8f5bcb37274b1 2 1bcfb8d401924570ae01b698601d1ef5--35270b95809343b3b1d6609ba42e0bdb a37eff0c79f144e0b39b153da7e24b86 82436b28173d43a99550c5dc059035f1 RX(1.732*acos(phi)) f6581f1d20454f5abfe8f5bcb37274b1--82436b28173d43a99550c5dc059035f1 5fdb26472ead44119913d981cbacf651 3 82436b28173d43a99550c5dc059035f1--a37eff0c79f144e0b39b153da7e24b86 225d4a72bf8c4d25b5e93aa63564d845 517fb437e090434facc770b968c3c67e RX(2.0*acos(phi)) 5fdb26472ead44119913d981cbacf651--517fb437e090434facc770b968c3c67e 856df353b5f84effbd7f98c0f9b3ce66 4 517fb437e090434facc770b968c3c67e--225d4a72bf8c4d25b5e93aa63564d845 c87213d845fc40d4b8828f4549811af1 e02a25fae33242339620ca277b4c8b54 RX(2.236*acos(phi)) 856df353b5f84effbd7f98c0f9b3ce66--e02a25fae33242339620ca277b4c8b54 e02a25fae33242339620ca277b4c8b54--c87213d845fc40d4b8828f4549811af1 <p>To add a trainable parameter that multiplies the feature parameter inside the encoding function, simply pass a <code>param_prefix</code> string:</p> <pre><code>n_qubits = 5\n\nfm_trainable = feature_map(\n    n_qubits,\n    fm_type=BasisSet.FOURIER,\n    reupload_scaling=ReuploadScaling.EXP,\n    param_prefix = \"w\",\n)\n</code></pre> %3 c71bfb9e5fb14b31b6e7159674b70a05 0 2eabccafa86c441381093b15c1c82c2e RX(1.0*phi*w\u2080) c71bfb9e5fb14b31b6e7159674b70a05--2eabccafa86c441381093b15c1c82c2e 35a33eb8e45d449fba76f0f11650d560 1 878cef88ea614284a8ecdf8a9646dbbd 2eabccafa86c441381093b15c1c82c2e--878cef88ea614284a8ecdf8a9646dbbd 6f96fe2dc7cc420f80db972cbec3b988 ddaac3cadb1e4abaa0bc0df10d1a6746 RX(2.0*phi*w\u2081) 35a33eb8e45d449fba76f0f11650d560--ddaac3cadb1e4abaa0bc0df10d1a6746 74cbdb369c0b459aa565efeb1b67b948 2 ddaac3cadb1e4abaa0bc0df10d1a6746--6f96fe2dc7cc420f80db972cbec3b988 4629e2f9fb94451cb22639bd030a4335 0cb4da736cd14d93b0a7c339a5419050 RX(4.0*phi*w\u2082) 74cbdb369c0b459aa565efeb1b67b948--0cb4da736cd14d93b0a7c339a5419050 5e6d805ee01c4e26b592ded32cc607d0 3 0cb4da736cd14d93b0a7c339a5419050--4629e2f9fb94451cb22639bd030a4335 20a3fe22800645bb9e94491db8a569cc 19c3b16f297b4881b3c2162216313640 RX(8.0*phi*w\u2083) 5e6d805ee01c4e26b592ded32cc607d0--19c3b16f297b4881b3c2162216313640 dcb9f0acede944b698ee9e44a2cc9e1b 4 19c3b16f297b4881b3c2162216313640--20a3fe22800645bb9e94491db8a569cc 169b773680a24b2c8ab4831a7f62feb5 ff87bfcafd7249aab15d5dae07131bff RX(16.0*phi*w\u2084) dcb9f0acede944b698ee9e44a2cc9e1b--ff87bfcafd7249aab15d5dae07131bff ff87bfcafd7249aab15d5dae07131bff--169b773680a24b2c8ab4831a7f62feb5 <p>Note that for the Fourier feature map, the encoding function is simply \\(f(x)=x\\). For other cases, like the Chebyshev <code>acos()</code> encoding, the trainable parameter may cause the feature value to be outside the domain of the encoding function. This will eventually be fixed by adding range constraints to trainable parameters in Qadence.</p> <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0, # Extra multiplier, which can also be a Parameter\n    param_prefix = \"w\", # Add trainable parameters\n)\n</code></pre> %3 6792e7c18bfb4bc0af5bd2f71b85ee03 0 6c78bf5ee2a749f59e5f538209f79813 RY(80.0*acos(w\u2084*(0.667*x + 1.667))) 6792e7c18bfb4bc0af5bd2f71b85ee03--6c78bf5ee2a749f59e5f538209f79813 e4fde1667f2e4e87919c14061cb9e94b 1 f3321e51e494461da17463f16f88d9e3 6c78bf5ee2a749f59e5f538209f79813--f3321e51e494461da17463f16f88d9e3 f6eded8ded004575a1d19c1d6ca8922e c1d6f5abdc144357903e809c6cc1c81f RY(40.0*acos(w\u2083*(0.667*x + 1.667))) e4fde1667f2e4e87919c14061cb9e94b--c1d6f5abdc144357903e809c6cc1c81f c656f97aef834689bdbad30730b61411 2 c1d6f5abdc144357903e809c6cc1c81f--f6eded8ded004575a1d19c1d6ca8922e 99d9fbba7be743faa150b7f3b27eae4d 575e7688e5c148aea9ac81bbf588613e RY(20.0*acos(w\u2082*(0.667*x + 1.667))) c656f97aef834689bdbad30730b61411--575e7688e5c148aea9ac81bbf588613e a77fb7aaebf0468eb04158269dff4243 3 575e7688e5c148aea9ac81bbf588613e--99d9fbba7be743faa150b7f3b27eae4d fdb40c7b9c0c470ba10702a7d7710d8b a0e15327c14b4dc1acbefbbc377b8a2d RY(10.0*acos(w\u2081*(0.667*x + 1.667))) a77fb7aaebf0468eb04158269dff4243--a0e15327c14b4dc1acbefbbc377b8a2d 715443f025dc4388a3e52b8e95ba9785 4 a0e15327c14b4dc1acbefbbc377b8a2d--fdb40c7b9c0c470ba10702a7d7710d8b 57726cab1ce34c34ba5440e218c6b4fb 997f7648bba8420687a797e5d65bc23f RY(5.0*acos(w\u2080*(0.667*x + 1.667))) 715443f025dc4388a3e52b8e95ba9785--997f7648bba8420687a797e5d65bc23f 997f7648bba8420687a797e5d65bc23f--57726cab1ce34c34ba5440e218c6b4fb"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 9245744041ff48bea005963810dd8b4a 0 dff405eb1c874f9e9570c0bc3304cf04 RX(theta\u2080) 9245744041ff48bea005963810dd8b4a--dff405eb1c874f9e9570c0bc3304cf04 75e2163191ef40049aeede85c0a3b4fe 1 66cd1941610d4f0c9d35d0e162a07d1f RY(theta\u2083) dff405eb1c874f9e9570c0bc3304cf04--66cd1941610d4f0c9d35d0e162a07d1f 21bd772a6c7f4e84981eb5c704c43c69 RX(theta\u2086) 66cd1941610d4f0c9d35d0e162a07d1f--21bd772a6c7f4e84981eb5c704c43c69 c4eabed5655d42e783dad2252da22c24 21bd772a6c7f4e84981eb5c704c43c69--c4eabed5655d42e783dad2252da22c24 2baab582e53e47b6b67d5b8a143bba06 c4eabed5655d42e783dad2252da22c24--2baab582e53e47b6b67d5b8a143bba06 860fb9a5e24844638df67dc41751e560 RX(theta\u2089) 2baab582e53e47b6b67d5b8a143bba06--860fb9a5e24844638df67dc41751e560 418445d2edb745c2ad84e32268669034 RY(theta\u2081\u2082) 860fb9a5e24844638df67dc41751e560--418445d2edb745c2ad84e32268669034 5ded3271a6d442729bcafbc40fee9b3e RX(theta\u2081\u2085) 418445d2edb745c2ad84e32268669034--5ded3271a6d442729bcafbc40fee9b3e 3ad7475dcc994454909570a7b62550ce 5ded3271a6d442729bcafbc40fee9b3e--3ad7475dcc994454909570a7b62550ce 240d08d75f7a4299a05b8a94f1571943 3ad7475dcc994454909570a7b62550ce--240d08d75f7a4299a05b8a94f1571943 72ae0bed80c44ee4a0d39a5a8a7d1067 240d08d75f7a4299a05b8a94f1571943--72ae0bed80c44ee4a0d39a5a8a7d1067 3c0aafeb492543b0ac4937795163c2cd 049f6975c73e46b78e0eb73d74e770c8 RX(theta\u2081) 75e2163191ef40049aeede85c0a3b4fe--049f6975c73e46b78e0eb73d74e770c8 f110ed0c708745be805fa53be2d436a9 2 e8ea4f33004048ae9a8b59e6d24c858c RY(theta\u2084) 049f6975c73e46b78e0eb73d74e770c8--e8ea4f33004048ae9a8b59e6d24c858c 08891d8f4828485284b44a355f29e4f4 RX(theta\u2087) e8ea4f33004048ae9a8b59e6d24c858c--08891d8f4828485284b44a355f29e4f4 35c801680a0143e98fabd653375f1103 X 08891d8f4828485284b44a355f29e4f4--35c801680a0143e98fabd653375f1103 35c801680a0143e98fabd653375f1103--c4eabed5655d42e783dad2252da22c24 bd449a282ea7449c90530fe4bf21fe58 35c801680a0143e98fabd653375f1103--bd449a282ea7449c90530fe4bf21fe58 86a3accd34a4491197f09b87ff1cbac5 RX(theta\u2081\u2080) bd449a282ea7449c90530fe4bf21fe58--86a3accd34a4491197f09b87ff1cbac5 f6b01cc13e0a4c42b6cad1d1d3b02ce2 RY(theta\u2081\u2083) 86a3accd34a4491197f09b87ff1cbac5--f6b01cc13e0a4c42b6cad1d1d3b02ce2 e965f745ebd64d60816c640597fd4abd RX(theta\u2081\u2086) f6b01cc13e0a4c42b6cad1d1d3b02ce2--e965f745ebd64d60816c640597fd4abd aa10feab7a74413fa0b65b19684dfd4f X e965f745ebd64d60816c640597fd4abd--aa10feab7a74413fa0b65b19684dfd4f aa10feab7a74413fa0b65b19684dfd4f--3ad7475dcc994454909570a7b62550ce 9b7de9f9829e4131831ef0ec56b81aeb aa10feab7a74413fa0b65b19684dfd4f--9b7de9f9829e4131831ef0ec56b81aeb 9b7de9f9829e4131831ef0ec56b81aeb--3c0aafeb492543b0ac4937795163c2cd 88c873c957a2407892ac3033ee7271a8 f8a448a3af574f219a89a02c460bee1f RX(theta\u2082) f110ed0c708745be805fa53be2d436a9--f8a448a3af574f219a89a02c460bee1f 79a91c7a50ec4c64bd91a74da3b12498 RY(theta\u2085) f8a448a3af574f219a89a02c460bee1f--79a91c7a50ec4c64bd91a74da3b12498 236ff37bc0454edbbcc0454c639f0eae RX(theta\u2088) 79a91c7a50ec4c64bd91a74da3b12498--236ff37bc0454edbbcc0454c639f0eae beaaf4b7937549e9bd6f2a80f1775d8d 236ff37bc0454edbbcc0454c639f0eae--beaaf4b7937549e9bd6f2a80f1775d8d 8df328d5e5ad4bf69c2167897ff7c54b X beaaf4b7937549e9bd6f2a80f1775d8d--8df328d5e5ad4bf69c2167897ff7c54b 8df328d5e5ad4bf69c2167897ff7c54b--bd449a282ea7449c90530fe4bf21fe58 d7d01b0ebce74984b15ebffe525aa2a4 RX(theta\u2081\u2081) 8df328d5e5ad4bf69c2167897ff7c54b--d7d01b0ebce74984b15ebffe525aa2a4 5393f6e25ed94dc2a9960ec010432c7f RY(theta\u2081\u2084) d7d01b0ebce74984b15ebffe525aa2a4--5393f6e25ed94dc2a9960ec010432c7f 142fdfa0134a4a509f604b8da8eb9e3e RX(theta\u2081\u2087) 5393f6e25ed94dc2a9960ec010432c7f--142fdfa0134a4a509f604b8da8eb9e3e 3b149e334290424990ce34232325a41c 142fdfa0134a4a509f604b8da8eb9e3e--3b149e334290424990ce34232325a41c c42b69e68a8941f5b7d8382e44fa4817 X 3b149e334290424990ce34232325a41c--c42b69e68a8941f5b7d8382e44fa4817 c42b69e68a8941f5b7d8382e44fa4817--9b7de9f9829e4131831ef0ec56b81aeb c42b69e68a8941f5b7d8382e44fa4817--88c873c957a2407892ac3033ee7271a8 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 32d4bd181c5f422780bad3a082650d7e 0 1fb456a1e178454d927a21f1adfb0c8b RX(phi\u2080) 32d4bd181c5f422780bad3a082650d7e--1fb456a1e178454d927a21f1adfb0c8b 557b93587ebb4153bfdb00395ef30a40 1 15ba6ccd0ea2482882a8bc86f2853020 RY(phi\u2083) 1fb456a1e178454d927a21f1adfb0c8b--15ba6ccd0ea2482882a8bc86f2853020 e1281f7f503f4cf6a79696493e660a2d RX(phi\u2086) 15ba6ccd0ea2482882a8bc86f2853020--e1281f7f503f4cf6a79696493e660a2d ef5f4b528b464e659332c53d5d52bf1a e1281f7f503f4cf6a79696493e660a2d--ef5f4b528b464e659332c53d5d52bf1a 7efd0d7812aa4eb8a830ec8e04b798a3 ef5f4b528b464e659332c53d5d52bf1a--7efd0d7812aa4eb8a830ec8e04b798a3 9b4f59b56cb145218f829f07230b2c78 RX(phi\u2089) 7efd0d7812aa4eb8a830ec8e04b798a3--9b4f59b56cb145218f829f07230b2c78 cdf4cc6c81904ddc95bfc8d8390e4aa1 RY(phi\u2081\u2082) 9b4f59b56cb145218f829f07230b2c78--cdf4cc6c81904ddc95bfc8d8390e4aa1 45951289263e40948a5fabe71d6c5263 RX(phi\u2081\u2085) cdf4cc6c81904ddc95bfc8d8390e4aa1--45951289263e40948a5fabe71d6c5263 b2420e83b9b545e78482f1eb53d9ba29 45951289263e40948a5fabe71d6c5263--b2420e83b9b545e78482f1eb53d9ba29 f1bc635f8f724f01a9bc3247c322754c b2420e83b9b545e78482f1eb53d9ba29--f1bc635f8f724f01a9bc3247c322754c fb5b731f79354a9780f8beb9cad0230f f1bc635f8f724f01a9bc3247c322754c--fb5b731f79354a9780f8beb9cad0230f 8ccf320b286c448e9ede01c524797519 0fd0d14703d94e8c949f3713c1d9c3f9 RX(phi\u2081) 557b93587ebb4153bfdb00395ef30a40--0fd0d14703d94e8c949f3713c1d9c3f9 d0d86f0fd73c40a9830c707cdb186044 2 b0b2c1db598443939780af192fcc284e RY(phi\u2084) 0fd0d14703d94e8c949f3713c1d9c3f9--b0b2c1db598443939780af192fcc284e 5a0536fe50f54939ac46292803c6ce87 RX(phi\u2087) b0b2c1db598443939780af192fcc284e--5a0536fe50f54939ac46292803c6ce87 f989569101df4b709b8c135b32b3afae PHASE(phi_ent\u2080) 5a0536fe50f54939ac46292803c6ce87--f989569101df4b709b8c135b32b3afae f989569101df4b709b8c135b32b3afae--ef5f4b528b464e659332c53d5d52bf1a c716df32f907459ba615ec2b066426a7 f989569101df4b709b8c135b32b3afae--c716df32f907459ba615ec2b066426a7 29e56bcd86ea4dbf900ee54bd52bc802 RX(phi\u2081\u2080) c716df32f907459ba615ec2b066426a7--29e56bcd86ea4dbf900ee54bd52bc802 637cecd617ed472dbc71668962590f3c RY(phi\u2081\u2083) 29e56bcd86ea4dbf900ee54bd52bc802--637cecd617ed472dbc71668962590f3c 9dbc196a606b426681c46f547af2fd3a RX(phi\u2081\u2086) 637cecd617ed472dbc71668962590f3c--9dbc196a606b426681c46f547af2fd3a 7a1d58b00ff04813af96da61f81ce804 PHASE(phi_ent\u2082) 9dbc196a606b426681c46f547af2fd3a--7a1d58b00ff04813af96da61f81ce804 7a1d58b00ff04813af96da61f81ce804--b2420e83b9b545e78482f1eb53d9ba29 631ea3a2ca984ed4a2d6ac538a044f93 7a1d58b00ff04813af96da61f81ce804--631ea3a2ca984ed4a2d6ac538a044f93 631ea3a2ca984ed4a2d6ac538a044f93--8ccf320b286c448e9ede01c524797519 07e3d551d9fa4b898710d379f4ba009a 189a68626be94d64a029eb1d9cfd9e14 RX(phi\u2082) d0d86f0fd73c40a9830c707cdb186044--189a68626be94d64a029eb1d9cfd9e14 ceb83055ba9f41039446fc141590ec64 RY(phi\u2085) 189a68626be94d64a029eb1d9cfd9e14--ceb83055ba9f41039446fc141590ec64 ebb46ad3c9de459ca2e484d818244a87 RX(phi\u2088) ceb83055ba9f41039446fc141590ec64--ebb46ad3c9de459ca2e484d818244a87 8109fe7fe07242e48c5da9b116b1258c ebb46ad3c9de459ca2e484d818244a87--8109fe7fe07242e48c5da9b116b1258c 4bb043449b3940f2aabbd8f668a3e3c8 PHASE(phi_ent\u2081) 8109fe7fe07242e48c5da9b116b1258c--4bb043449b3940f2aabbd8f668a3e3c8 4bb043449b3940f2aabbd8f668a3e3c8--c716df32f907459ba615ec2b066426a7 1639550ec5e144c4b875fc0983756059 RX(phi\u2081\u2081) 4bb043449b3940f2aabbd8f668a3e3c8--1639550ec5e144c4b875fc0983756059 6fd6fc1c00674e2ba8e2fc73526a87bd RY(phi\u2081\u2084) 1639550ec5e144c4b875fc0983756059--6fd6fc1c00674e2ba8e2fc73526a87bd dbf7317b167a4e779a8ba382074796ec RX(phi\u2081\u2087) 6fd6fc1c00674e2ba8e2fc73526a87bd--dbf7317b167a4e779a8ba382074796ec b4587903901c406d80f970ded9d96daa dbf7317b167a4e779a8ba382074796ec--b4587903901c406d80f970ded9d96daa 1b219d1d9ac3465eb5b7c629f352ed29 PHASE(phi_ent\u2083) b4587903901c406d80f970ded9d96daa--1b219d1d9ac3465eb5b7c629f352ed29 1b219d1d9ac3465eb5b7c629f352ed29--631ea3a2ca984ed4a2d6ac538a044f93 1b219d1d9ac3465eb5b7c629f352ed29--07e3d551d9fa4b898710d379f4ba009a <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_5849f8c2f3c44db4b741e4868c75fc32 cluster_3a6ddfccd8394207ae5e8e4affd6dd73 50b9afc9553446458621fdb6caa75a9a 0 ec5a499bbb744b7fbd0727c0d2ef7a1b RX(theta\u2080) 50b9afc9553446458621fdb6caa75a9a--ec5a499bbb744b7fbd0727c0d2ef7a1b 86e04f7663ea439d8003b2fa22c27bb5 1 125b837833c84dfb88140f707c997c74 RY(theta\u2083) ec5a499bbb744b7fbd0727c0d2ef7a1b--125b837833c84dfb88140f707c997c74 2474d55679f94c9780e7bbc481d9e8d4 RX(theta\u2086) 125b837833c84dfb88140f707c997c74--2474d55679f94c9780e7bbc481d9e8d4 cf48c9fa0e3d4bf1ac239ad82d912777 HamEvo 2474d55679f94c9780e7bbc481d9e8d4--cf48c9fa0e3d4bf1ac239ad82d912777 21730ba726944f0caabac14ae5671f94 RX(theta\u2089) cf48c9fa0e3d4bf1ac239ad82d912777--21730ba726944f0caabac14ae5671f94 1e3ae29ca3ff4f5f9054d369b1aeeb63 RY(theta\u2081\u2082) 21730ba726944f0caabac14ae5671f94--1e3ae29ca3ff4f5f9054d369b1aeeb63 efd5f2dd9835458d95579e386d55d4dc RX(theta\u2081\u2085) 1e3ae29ca3ff4f5f9054d369b1aeeb63--efd5f2dd9835458d95579e386d55d4dc 9ac56d8db5fb4514ae3131abafbe61e0 HamEvo efd5f2dd9835458d95579e386d55d4dc--9ac56d8db5fb4514ae3131abafbe61e0 14f96742653d4278b709e00e24427c67 9ac56d8db5fb4514ae3131abafbe61e0--14f96742653d4278b709e00e24427c67 2291deb7879a4921abec65bc9412fba1 0bd38e5b46744652bb9f3898d77ca5e8 RX(theta\u2081) 86e04f7663ea439d8003b2fa22c27bb5--0bd38e5b46744652bb9f3898d77ca5e8 001a94358f364bb8a6469edb35d2f0c1 2 f4684743da2c46bdadd77eb639b5a20a RY(theta\u2084) 0bd38e5b46744652bb9f3898d77ca5e8--f4684743da2c46bdadd77eb639b5a20a 5a306bc39b9d4ee79070978d229bf92b RX(theta\u2087) f4684743da2c46bdadd77eb639b5a20a--5a306bc39b9d4ee79070978d229bf92b a6933f0a13874088a66789711cfb9974 t = theta_t\u2080 5a306bc39b9d4ee79070978d229bf92b--a6933f0a13874088a66789711cfb9974 9398f1f97f254fc6a50d0a6740808e85 RX(theta\u2081\u2080) a6933f0a13874088a66789711cfb9974--9398f1f97f254fc6a50d0a6740808e85 368e1c58eef44c9589a3b64123326922 RY(theta\u2081\u2083) 9398f1f97f254fc6a50d0a6740808e85--368e1c58eef44c9589a3b64123326922 5d76719da8364f2d9686fdaae0684024 RX(theta\u2081\u2086) 368e1c58eef44c9589a3b64123326922--5d76719da8364f2d9686fdaae0684024 c279e517c4a04c3391a22a75e8c33ef5 t = theta_t\u2081 5d76719da8364f2d9686fdaae0684024--c279e517c4a04c3391a22a75e8c33ef5 c279e517c4a04c3391a22a75e8c33ef5--2291deb7879a4921abec65bc9412fba1 be037051d82144ccaebcd600598f7cc0 12ce45e9d7d7452c8ade36e20c787608 RX(theta\u2082) 001a94358f364bb8a6469edb35d2f0c1--12ce45e9d7d7452c8ade36e20c787608 d06553a794fa4af89ae5afd4fcb9286f RY(theta\u2085) 12ce45e9d7d7452c8ade36e20c787608--d06553a794fa4af89ae5afd4fcb9286f 916d68d8d96d472c9eb3549260cea0f1 RX(theta\u2088) d06553a794fa4af89ae5afd4fcb9286f--916d68d8d96d472c9eb3549260cea0f1 d82d8f475cc84cb18c0ac65ad00c87b7 916d68d8d96d472c9eb3549260cea0f1--d82d8f475cc84cb18c0ac65ad00c87b7 2881ea50c9c7432ca32ca75d9dea256f RX(theta\u2081\u2081) d82d8f475cc84cb18c0ac65ad00c87b7--2881ea50c9c7432ca32ca75d9dea256f 12faceb3b65348af9c57888fff76531c RY(theta\u2081\u2084) 2881ea50c9c7432ca32ca75d9dea256f--12faceb3b65348af9c57888fff76531c c4d59f3348074615b20ffc1cc54a7ac5 RX(theta\u2081\u2087) 12faceb3b65348af9c57888fff76531c--c4d59f3348074615b20ffc1cc54a7ac5 4a73aa3a715d487dbe6bcf01ce8f7ea4 c4d59f3348074615b20ffc1cc54a7ac5--4a73aa3a715d487dbe6bcf01ce8f7ea4 4a73aa3a715d487dbe6bcf01ce8f7ea4--be037051d82144ccaebcd600598f7cc0 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_046d9a940733439a980de4d1b0ea0a62 cluster_2861d3cfc1284a898ba7d6af24a68789 67e55efb753f4d8f86103f0f2ddc8d0a 0 49b918a3917b43848fa67ab4ccd522d4 RX(theta\u2080) 67e55efb753f4d8f86103f0f2ddc8d0a--49b918a3917b43848fa67ab4ccd522d4 c76fef5150b4431aa2cc53537e053020 1 0471653e06e740da89fdd5a5ae4ac921 RY(theta\u2086) 49b918a3917b43848fa67ab4ccd522d4--0471653e06e740da89fdd5a5ae4ac921 0a2b94b8ce8b4d358ac60852cd4bd62b RX(theta\u2081\u2082) 0471653e06e740da89fdd5a5ae4ac921--0a2b94b8ce8b4d358ac60852cd4bd62b b4a64a869bbe488895a41db26e6584b9 0a2b94b8ce8b4d358ac60852cd4bd62b--b4a64a869bbe488895a41db26e6584b9 fd1e65daa3fc46aa893e657a89547097 RX(theta\u2081\u2088) b4a64a869bbe488895a41db26e6584b9--fd1e65daa3fc46aa893e657a89547097 2bfa13edff1b4bde8eaadae3f378dcbd RY(theta\u2082\u2084) fd1e65daa3fc46aa893e657a89547097--2bfa13edff1b4bde8eaadae3f378dcbd 64ea16c7ec7f4509b4452c2e1e920faf RX(theta\u2083\u2080) 2bfa13edff1b4bde8eaadae3f378dcbd--64ea16c7ec7f4509b4452c2e1e920faf 45ce8e98fb304e5284e30be74a8d4e5c 64ea16c7ec7f4509b4452c2e1e920faf--45ce8e98fb304e5284e30be74a8d4e5c 531bc840c6474794a8d13b320682d6e7 45ce8e98fb304e5284e30be74a8d4e5c--531bc840c6474794a8d13b320682d6e7 cda4056488754286a0aae56ef8489830 52f1cc3b65ea459cab13895635f0d290 RX(theta\u2081) c76fef5150b4431aa2cc53537e053020--52f1cc3b65ea459cab13895635f0d290 8504dff683064874bd5ff04759db822d 2 a534722271de40e29ca8e939b4100f69 RY(theta\u2087) 52f1cc3b65ea459cab13895635f0d290--a534722271de40e29ca8e939b4100f69 2caa1a80e37a436c95830a69ed960ba3 RX(theta\u2081\u2083) a534722271de40e29ca8e939b4100f69--2caa1a80e37a436c95830a69ed960ba3 fb33f005ab2541749157840f3de2650f 2caa1a80e37a436c95830a69ed960ba3--fb33f005ab2541749157840f3de2650f 5f9eb12670594de28c9a1ad19e4b051b RX(theta\u2081\u2089) fb33f005ab2541749157840f3de2650f--5f9eb12670594de28c9a1ad19e4b051b dca8b445266646dab4b125a54686da59 RY(theta\u2082\u2085) 5f9eb12670594de28c9a1ad19e4b051b--dca8b445266646dab4b125a54686da59 3d7abfa5f6e749b38562db9311ba93ff RX(theta\u2083\u2081) dca8b445266646dab4b125a54686da59--3d7abfa5f6e749b38562db9311ba93ff 543afd1fd00c4d388c3bcb853691506b 3d7abfa5f6e749b38562db9311ba93ff--543afd1fd00c4d388c3bcb853691506b 543afd1fd00c4d388c3bcb853691506b--cda4056488754286a0aae56ef8489830 c15260ce5fbe4bf68e6aa21da853a3bf 062c960982164198a91b98e5df9f091f RX(theta\u2082) 8504dff683064874bd5ff04759db822d--062c960982164198a91b98e5df9f091f 745da7beca7c4120a84809bd291db9bc 3 0b1d5996f8384aef9bd591bf07ba5e13 RY(theta\u2088) 062c960982164198a91b98e5df9f091f--0b1d5996f8384aef9bd591bf07ba5e13 507dd45fc8404bdd8084b9f69715c5d5 RX(theta\u2081\u2084) 0b1d5996f8384aef9bd591bf07ba5e13--507dd45fc8404bdd8084b9f69715c5d5 cfe50f54b9584e7187957231572a3936 HamEvo 507dd45fc8404bdd8084b9f69715c5d5--cfe50f54b9584e7187957231572a3936 b66c1832982f4fdc8f3928098e97be51 RX(theta\u2082\u2080) cfe50f54b9584e7187957231572a3936--b66c1832982f4fdc8f3928098e97be51 13eaa5e7c24a49c09ad1d27171466eb1 RY(theta\u2082\u2086) b66c1832982f4fdc8f3928098e97be51--13eaa5e7c24a49c09ad1d27171466eb1 b95eb9254ce24745975e0d48950ff2c9 RX(theta\u2083\u2082) 13eaa5e7c24a49c09ad1d27171466eb1--b95eb9254ce24745975e0d48950ff2c9 9e61fec11a494dc6bba1379afdb7da12 HamEvo b95eb9254ce24745975e0d48950ff2c9--9e61fec11a494dc6bba1379afdb7da12 9e61fec11a494dc6bba1379afdb7da12--c15260ce5fbe4bf68e6aa21da853a3bf 87ce4b9b578e48dbae3ed334f6fef28c 858176e426f848418fed64d54871a68f RX(theta\u2083) 745da7beca7c4120a84809bd291db9bc--858176e426f848418fed64d54871a68f e52bdab3b650441ea6702b0ced4410d3 4 70205c4c837a4a78937bf75d695e0e16 RY(theta\u2089) 858176e426f848418fed64d54871a68f--70205c4c837a4a78937bf75d695e0e16 3fd9b97b23154125a15e48b357de92d9 RX(theta\u2081\u2085) 70205c4c837a4a78937bf75d695e0e16--3fd9b97b23154125a15e48b357de92d9 ce23694be3a444ec8d1ff3e4a1544fd1 t = theta_t\u2080 3fd9b97b23154125a15e48b357de92d9--ce23694be3a444ec8d1ff3e4a1544fd1 22f3d473bd4b4396b830a0687d6cf815 RX(theta\u2082\u2081) ce23694be3a444ec8d1ff3e4a1544fd1--22f3d473bd4b4396b830a0687d6cf815 55c976bd8fa74fe5abdd6f73d6ce4e37 RY(theta\u2082\u2087) 22f3d473bd4b4396b830a0687d6cf815--55c976bd8fa74fe5abdd6f73d6ce4e37 fd1d51b632794dbeb293c4b5c245babe RX(theta\u2083\u2083) 55c976bd8fa74fe5abdd6f73d6ce4e37--fd1d51b632794dbeb293c4b5c245babe ad9c9549c0c04673b78e1bdd4ca8b9f5 t = theta_t\u2081 fd1d51b632794dbeb293c4b5c245babe--ad9c9549c0c04673b78e1bdd4ca8b9f5 ad9c9549c0c04673b78e1bdd4ca8b9f5--87ce4b9b578e48dbae3ed334f6fef28c 52294bc87fb645a590490cecdf26032d 0529491cc46c4771a1bc5ebe3fd2722d RX(theta\u2084) e52bdab3b650441ea6702b0ced4410d3--0529491cc46c4771a1bc5ebe3fd2722d a10037dc8130473b8bff018fff3d04c1 5 8b0232c04bee45c7b7f90af28da37717 RY(theta\u2081\u2080) 0529491cc46c4771a1bc5ebe3fd2722d--8b0232c04bee45c7b7f90af28da37717 cd22052c8f4c4637a78ecfad26f9d832 RX(theta\u2081\u2086) 8b0232c04bee45c7b7f90af28da37717--cd22052c8f4c4637a78ecfad26f9d832 2d9b64b6a61c4ac8846c9400e7c360d9 cd22052c8f4c4637a78ecfad26f9d832--2d9b64b6a61c4ac8846c9400e7c360d9 67f069aa78aa4e5890885873eb87c2e7 RX(theta\u2082\u2082) 2d9b64b6a61c4ac8846c9400e7c360d9--67f069aa78aa4e5890885873eb87c2e7 53149397b26046df97dac2eb614a02c2 RY(theta\u2082\u2088) 67f069aa78aa4e5890885873eb87c2e7--53149397b26046df97dac2eb614a02c2 c6e3617629bb46cfb376c23b15db84b1 RX(theta\u2083\u2084) 53149397b26046df97dac2eb614a02c2--c6e3617629bb46cfb376c23b15db84b1 b8ef440edfaf42c795af9f4ef5cccbd1 c6e3617629bb46cfb376c23b15db84b1--b8ef440edfaf42c795af9f4ef5cccbd1 b8ef440edfaf42c795af9f4ef5cccbd1--52294bc87fb645a590490cecdf26032d 455e04c4dbff426a9a97b8c1843f0ba9 85830d180b6942e6a6e59698ea3d5b11 RX(theta\u2085) a10037dc8130473b8bff018fff3d04c1--85830d180b6942e6a6e59698ea3d5b11 538aa9dda6184fe4b3614cef68427835 RY(theta\u2081\u2081) 85830d180b6942e6a6e59698ea3d5b11--538aa9dda6184fe4b3614cef68427835 b0f578dd94d0441dbed6cfbf36cc4a48 RX(theta\u2081\u2087) 538aa9dda6184fe4b3614cef68427835--b0f578dd94d0441dbed6cfbf36cc4a48 d9316f4288d04c4899a44b3669416278 b0f578dd94d0441dbed6cfbf36cc4a48--d9316f4288d04c4899a44b3669416278 e6cdd78215e34782b8a5d6efa7d5be7a RX(theta\u2082\u2083) d9316f4288d04c4899a44b3669416278--e6cdd78215e34782b8a5d6efa7d5be7a 695dfd8120234dd599b7d8fded91f87e RY(theta\u2082\u2089) e6cdd78215e34782b8a5d6efa7d5be7a--695dfd8120234dd599b7d8fded91f87e 8e1590f7c81b494a94d3946655953fb9 RX(theta\u2083\u2085) 695dfd8120234dd599b7d8fded91f87e--8e1590f7c81b494a94d3946655953fb9 6866c87213234bbdb6538084129b5d6c 8e1590f7c81b494a94d3946655953fb9--6866c87213234bbdb6538084129b5d6c 6866c87213234bbdb6538084129b5d6c--455e04c4dbff426a9a97b8c1843f0ba9"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_05e595adc2bb412085699fe3f106fc69 BPMA-1 cluster_b633f885c0224d5e8282434be92be9dd BPMA-0 6a98226391ad44ed8755b840acffa1c5 0 9c24b2b9957044e4b637be381b1064b0 RX(iia_\u03b1\u2080\u2080) 6a98226391ad44ed8755b840acffa1c5--9c24b2b9957044e4b637be381b1064b0 1af7612e6b734e6da3aaade5fed99f71 1 e237daa2349b42c8b93f15608e8fde33 RY(iia_\u03b1\u2080\u2083) 9c24b2b9957044e4b637be381b1064b0--e237daa2349b42c8b93f15608e8fde33 6f67560f31c545ad9d83498b5662e26a e237daa2349b42c8b93f15608e8fde33--6f67560f31c545ad9d83498b5662e26a fa5ef76502144074b1e672b7459f112d 6f67560f31c545ad9d83498b5662e26a--fa5ef76502144074b1e672b7459f112d 83875b7b10874af19a93e03d63bf7451 RX(iia_\u03b3\u2080\u2080) fa5ef76502144074b1e672b7459f112d--83875b7b10874af19a93e03d63bf7451 5d85d11ecd8f4ddc820cf9ce972eff0f 83875b7b10874af19a93e03d63bf7451--5d85d11ecd8f4ddc820cf9ce972eff0f 97000c3727d84590a5232ce471d92517 5d85d11ecd8f4ddc820cf9ce972eff0f--97000c3727d84590a5232ce471d92517 1fa62db562de4d1783856c2798ea8f8d RY(iia_\u03b2\u2080\u2083) 97000c3727d84590a5232ce471d92517--1fa62db562de4d1783856c2798ea8f8d 9e38b17bac0a4907a54dd06c83a6dab6 RX(iia_\u03b2\u2080\u2080) 1fa62db562de4d1783856c2798ea8f8d--9e38b17bac0a4907a54dd06c83a6dab6 9f9c9ea2720947c0a7e1dc777992d86a RX(iia_\u03b1\u2081\u2080) 9e38b17bac0a4907a54dd06c83a6dab6--9f9c9ea2720947c0a7e1dc777992d86a 9a9ecf28daa94b2ca5ec3cbb31f2aa9a RY(iia_\u03b1\u2081\u2083) 9f9c9ea2720947c0a7e1dc777992d86a--9a9ecf28daa94b2ca5ec3cbb31f2aa9a 68e55c12039843118fd425809cae86b3 9a9ecf28daa94b2ca5ec3cbb31f2aa9a--68e55c12039843118fd425809cae86b3 4e6fbb6eaed84dc1baf80463e0ab4c7f 68e55c12039843118fd425809cae86b3--4e6fbb6eaed84dc1baf80463e0ab4c7f c34d30c06b054259b879ef24b0ef1202 RX(iia_\u03b3\u2081\u2080) 4e6fbb6eaed84dc1baf80463e0ab4c7f--c34d30c06b054259b879ef24b0ef1202 364dc3ca341542dbac4336916c714517 c34d30c06b054259b879ef24b0ef1202--364dc3ca341542dbac4336916c714517 7ef3dc4d45f24297af01bb81ed23e7a7 364dc3ca341542dbac4336916c714517--7ef3dc4d45f24297af01bb81ed23e7a7 41e50fcc9817470a8ad69123f755ac96 RY(iia_\u03b2\u2081\u2083) 7ef3dc4d45f24297af01bb81ed23e7a7--41e50fcc9817470a8ad69123f755ac96 ffcaa4bc9e534ce3a20bea6c640c8ca7 RX(iia_\u03b2\u2081\u2080) 41e50fcc9817470a8ad69123f755ac96--ffcaa4bc9e534ce3a20bea6c640c8ca7 a1a5f99ea0d94d93aca50f764f780068 ffcaa4bc9e534ce3a20bea6c640c8ca7--a1a5f99ea0d94d93aca50f764f780068 0eaeaac4e6d944b49c1cd9f184afa8e0 048a14257ae44031bc2b21c249099040 RX(iia_\u03b1\u2080\u2081) 1af7612e6b734e6da3aaade5fed99f71--048a14257ae44031bc2b21c249099040 337da146122941899eae9425480c22d7 2 feaa402a01a941719da2a4906bbec8c5 RY(iia_\u03b1\u2080\u2084) 048a14257ae44031bc2b21c249099040--feaa402a01a941719da2a4906bbec8c5 985d0786ca234f48bee5a4b74dcf7b28 X feaa402a01a941719da2a4906bbec8c5--985d0786ca234f48bee5a4b74dcf7b28 985d0786ca234f48bee5a4b74dcf7b28--6f67560f31c545ad9d83498b5662e26a 325093122f6c42c2a6263f04da447087 985d0786ca234f48bee5a4b74dcf7b28--325093122f6c42c2a6263f04da447087 2f53892fa1324d39ab7ed4a1cd1b200a RX(iia_\u03b3\u2080\u2081) 325093122f6c42c2a6263f04da447087--2f53892fa1324d39ab7ed4a1cd1b200a 0cca0516f9bf46fcb961dcbeb52df947 2f53892fa1324d39ab7ed4a1cd1b200a--0cca0516f9bf46fcb961dcbeb52df947 7ce04f8f5c1c4415a164c323a6b01ec8 X 0cca0516f9bf46fcb961dcbeb52df947--7ce04f8f5c1c4415a164c323a6b01ec8 7ce04f8f5c1c4415a164c323a6b01ec8--97000c3727d84590a5232ce471d92517 ba2594246b8948e59e35d7ad0f346daa RY(iia_\u03b2\u2080\u2084) 7ce04f8f5c1c4415a164c323a6b01ec8--ba2594246b8948e59e35d7ad0f346daa 16284c58cd684b0384684190ab5e43ba RX(iia_\u03b2\u2080\u2081) ba2594246b8948e59e35d7ad0f346daa--16284c58cd684b0384684190ab5e43ba 07ad32806e104cd68418b35e09d1bd34 RX(iia_\u03b1\u2081\u2081) 16284c58cd684b0384684190ab5e43ba--07ad32806e104cd68418b35e09d1bd34 6e699b8e770a401d9950eb480d92802e RY(iia_\u03b1\u2081\u2084) 07ad32806e104cd68418b35e09d1bd34--6e699b8e770a401d9950eb480d92802e f6206757edb5497aa506fe3244d2313b X 6e699b8e770a401d9950eb480d92802e--f6206757edb5497aa506fe3244d2313b f6206757edb5497aa506fe3244d2313b--68e55c12039843118fd425809cae86b3 ac2918b7bf9346eda0d0c48e9fd5de78 f6206757edb5497aa506fe3244d2313b--ac2918b7bf9346eda0d0c48e9fd5de78 742bbeb9b29d4c569844879dd5a49b23 RX(iia_\u03b3\u2081\u2081) ac2918b7bf9346eda0d0c48e9fd5de78--742bbeb9b29d4c569844879dd5a49b23 2ec075ad9bf340c085cb5516bb41934d 742bbeb9b29d4c569844879dd5a49b23--2ec075ad9bf340c085cb5516bb41934d 261331c15143461586630102034220c9 X 2ec075ad9bf340c085cb5516bb41934d--261331c15143461586630102034220c9 261331c15143461586630102034220c9--7ef3dc4d45f24297af01bb81ed23e7a7 736647f153df41aebbf56ea9a4433c7c RY(iia_\u03b2\u2081\u2084) 261331c15143461586630102034220c9--736647f153df41aebbf56ea9a4433c7c d1330ab88a604e62b28485e150d4aadb RX(iia_\u03b2\u2081\u2081) 736647f153df41aebbf56ea9a4433c7c--d1330ab88a604e62b28485e150d4aadb d1330ab88a604e62b28485e150d4aadb--0eaeaac4e6d944b49c1cd9f184afa8e0 14cd9181b8ba4f5589191ac45c298930 d44513819eb948ec93e3090a27b606d8 RX(iia_\u03b1\u2080\u2082) 337da146122941899eae9425480c22d7--d44513819eb948ec93e3090a27b606d8 25c67b5ad2d349d6a75d3902d5684c0b RY(iia_\u03b1\u2080\u2085) d44513819eb948ec93e3090a27b606d8--25c67b5ad2d349d6a75d3902d5684c0b 589da59e74a743819cbad3a115099bff 25c67b5ad2d349d6a75d3902d5684c0b--589da59e74a743819cbad3a115099bff 204394ca5c1041b1987c415f508a079d X 589da59e74a743819cbad3a115099bff--204394ca5c1041b1987c415f508a079d 204394ca5c1041b1987c415f508a079d--325093122f6c42c2a6263f04da447087 477b7d493e80473f85c21a9b49f14271 RX(iia_\u03b3\u2080\u2082) 204394ca5c1041b1987c415f508a079d--477b7d493e80473f85c21a9b49f14271 06e28bfccb0a4193ae709f6d8ed0b70a X 477b7d493e80473f85c21a9b49f14271--06e28bfccb0a4193ae709f6d8ed0b70a 06e28bfccb0a4193ae709f6d8ed0b70a--0cca0516f9bf46fcb961dcbeb52df947 aed9b87f6edd485bbc4f5a745470888f 06e28bfccb0a4193ae709f6d8ed0b70a--aed9b87f6edd485bbc4f5a745470888f df4e0886aea147359b5b10e0daea0dd3 RY(iia_\u03b2\u2080\u2085) aed9b87f6edd485bbc4f5a745470888f--df4e0886aea147359b5b10e0daea0dd3 a3eddc838f114d4ebc9f9f3e3b12c12d RX(iia_\u03b2\u2080\u2082) df4e0886aea147359b5b10e0daea0dd3--a3eddc838f114d4ebc9f9f3e3b12c12d 0764bdf66afe4f4986ede915c8e56af2 RX(iia_\u03b1\u2081\u2082) a3eddc838f114d4ebc9f9f3e3b12c12d--0764bdf66afe4f4986ede915c8e56af2 bc15dcdb1ec4476a81a7a82571cb1eac RY(iia_\u03b1\u2081\u2085) 0764bdf66afe4f4986ede915c8e56af2--bc15dcdb1ec4476a81a7a82571cb1eac 3ed275b90df0401999a6f8df35e63ed0 bc15dcdb1ec4476a81a7a82571cb1eac--3ed275b90df0401999a6f8df35e63ed0 3552f03573434993b13a6d67d15a5b22 X 3ed275b90df0401999a6f8df35e63ed0--3552f03573434993b13a6d67d15a5b22 3552f03573434993b13a6d67d15a5b22--ac2918b7bf9346eda0d0c48e9fd5de78 c60562a9ae784afbba3e04dbe272d1d7 RX(iia_\u03b3\u2081\u2082) 3552f03573434993b13a6d67d15a5b22--c60562a9ae784afbba3e04dbe272d1d7 25a0502c06b1490aac040d7d0da3fe5e X c60562a9ae784afbba3e04dbe272d1d7--25a0502c06b1490aac040d7d0da3fe5e 25a0502c06b1490aac040d7d0da3fe5e--2ec075ad9bf340c085cb5516bb41934d 3966e6fd47b04652b5834a49651913cb 25a0502c06b1490aac040d7d0da3fe5e--3966e6fd47b04652b5834a49651913cb cb7420969d3242deae76965b2fd8c4ea RY(iia_\u03b2\u2081\u2085) 3966e6fd47b04652b5834a49651913cb--cb7420969d3242deae76965b2fd8c4ea 3a8f6659e2d14f9e9d62ab9a5bb6d70e RX(iia_\u03b2\u2081\u2082) cb7420969d3242deae76965b2fd8c4ea--3a8f6659e2d14f9e9d62ab9a5bb6d70e 3a8f6659e2d14f9e9d62ab9a5bb6d70e--14cd9181b8ba4f5589191ac45c298930"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>Sample-based measurement protocols are fundamental tools for the prediction and estimation of a quantum state as the result of NISQ programs executions. Their resource efficient implementation is a current and active research field. Qadence offers two main measurement protocols: quantum state tomography and classical shadows.</p>"},{"location":"realistic_sims/measurements/#quantum-state-tomography","title":"Quantum state tomography","text":"<p>The fundamental task of quantum state tomography is to learn an approximate classical description of an output quantum state described by a density matrix \\(\\rho\\), from repeated measurements of copies on a chosen basis. To do so, \\(\\rho\\) is expanded in a basis of observables (the tomography step) and for a given observable \\(\\hat{\\mathcal{O}}\\), the expectation value is calculated with \\(\\langle \\hat{\\mathcal{O}} \\rangle=\\textrm{Tr}(\\hat{\\mathcal{O}}\\rho)\\). A number of measurement repetitions in a suitable basis is then required to estimate \\(\\langle \\hat{\\mathcal{O}} \\rangle\\).</p> <p>The main drawback is the scaling in measurements for the retrieval of the classical expression for a \\(n\\)-qubit quantum state as \\(2^n \\times 2^n\\), together with a large amount of classical post-processing.</p> <p>For an observable expressed as a Pauli string \\(\\hat{\\mathcal{P}}\\), the expectation value for a state \\(|\\psi \\rangle\\) can be derived as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\langle \\psi | \\hat{\\mathcal{P}} |\\psi \\rangle=\\langle \\psi | \\hat{\\mathcal{R}}^\\dagger \\hat{\\mathcal{D}} \\hat{\\mathcal{R}} |\\psi \\rangle \\] <p>The operator \\(\\hat{\\mathcal{R}}\\) diagonalizes \\(\\hat{\\mathcal{P}}\\) and rotates the state into an eigenstate in the computational basis. Therefore, \\(\\hat{\\mathcal{R}}|\\psi \\rangle=\\sum\\limits_{z}a_z|z\\rangle\\) and the expectation value can finally be expressed as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\sum_{z,z'}\\langle z |\\bar{a}_z\\hat{\\mathcal{D}}a_{z'}|z'\\rangle = \\sum_{z}|a_z|^2(-1)^{\\phi_z(\\hat{\\mathcal{P}})} \\] <p>In Qadence, running a tomographical experiment is made simple by defining a <code>Measurements</code> object that captures all options for execution:</p> <pre><code>from torch import tensor\nfrom qadence import hamiltonian_factory, BackendName, DiffMode\nfrom qadence import Parameter, chain, kron, RX, RY, Z, QuantumCircuit, QuantumModel\nfrom qadence.measurements import Measurements\n\n# Define parameters for a circuit.\ntheta1 = Parameter(\"theta1\", trainable=False)\ntheta2 = Parameter(\"theta2\", trainable=False)\ntheta3 = Parameter(\"theta3\", trainable=False)\ntheta4 = Parameter(\"theta4\", trainable=False)\n\nblocks = chain(\n    kron(RX(0, theta1), RY(1, theta2)),\n    kron(RX(0, theta3), RY(1, theta4)),\n)\n\nvalues = {\n    \"theta1\": tensor([0.5]),\n    \"theta2\": tensor([1.5]),\n    \"theta3\": tensor([2.0]),\n    \"theta4\": tensor([2.5]),\n}\n\n# Create a circuit and an observable.\ncircuit = QuantumCircuit(2, blocks)\nobservable = hamiltonian_factory(2, detuning=Z)\n\n# Create a model.\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n)\n\n# Define a measurement protocol by passing the shot budget as an option.\ntomo_options = {\"n_shots\": 100000}\ntomo_measurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=tomo_options)\n\n# Get the exact expectation value.\nexact_values = model.expectation(\n    values=values,\n)\n\n# Run the tomography experiment.\nestimated_values_tomo = model.expectation(\n    values=values,\n    measurement=tomo_measurement,\n)\n</code></pre> <pre><code>Exact expectation value = tensor([[-1.4548]])\nEstimated expectation value tomo = tensor([[-1.4503]])\n</code></pre>"},{"location":"realistic_sims/measurements/#classical-shadows","title":"Classical shadows","text":"<p>Recently, a much less resource demanding protocol based on classical shadows has been proposed<sup>1</sup>. It combines ideas from shadow tomography<sup>2</sup> and randomized measurement protocols capable of learning a classical shadow of an unknown quantum state \\(\\rho\\). It relies on deliberately discarding the full classical characterization of the quantum state, and instead focuses on accurately predicting a restricted set of properties that provide efficient protocols for the study of the system.</p> <p>A random measurement consists of applying random unitary rotations before a fixed measurement on each copy of a state. Appropriately averaging over these measurements produces an efficient estimator for the expectation value of an observable. This protocol therefore creates a robust classical representation of the quantum state or classical shadow. The captured measurement information is then reuseable for multiple purposes, i.e. any observable expected value and available for noise mitigation postprocessing.</p> <p>A classical shadow is therefore an unbiased estimator of a quantum state \\(\\rho\\). Such an estimator is obtained with the following procedure<sup>1</sup>: first, apply a random unitary gate \\(U\\) to rotate the state: \\(\\rho \\rightarrow U \\rho U^\\dagger\\) and then perform a basis measurement to obtain a \\(n\\)-bit measurement \\(|\\hat{b}\\rangle \\in \\{0, 1\\}^n\\). Both unitary gates \\(U\\) and the measurement outcomes \\(|\\hat{b}\\rangle\\) are stored on a classical computer for postprocessing v \\(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U\\), a classical snapshot of the state \\(\\rho\\). The whole procedure can be seen as a quantum channel \\(\\mathcal{M}\\) that maps the initial unknown quantum state \\(\\rho\\) to the average result of the measurement protocol:</p> \\[ \\mathbb{E}[U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U] = \\mathcal{M}(\\rho) \\Rightarrow \\rho = \\mathbb{E}[\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)] \\] <p>It is worth noting that the single classical snapshot \\(\\hat{\\rho}=\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)\\) equals \\(\\rho\\) in expectation: \\(\\mathbb{E}[\\hat{\\rho}]=\\rho\\) despite \\(\\mathcal{M}^{-1}\\) not being a completely positive map. Repeating this procedure \\(N\\) times results in an array of \\(N\\) independent, classical snapshots of \\(\\rho\\) called the classical shadow:</p> \\[ S(\\rho, N) = \\{ \\hat{\\rho}_1=\\mathcal{M}^{-1}(U_1^\\dagger |\\hat{b}_1\\rangle\\langle \\hat{b}_1|U_1),\\cdots,\\hat{\\rho}_N=\\mathcal{M}^{-1}(U_N^\\dagger |\\hat{b}_N\\rangle\\langle \\hat{b}_N|U_N)\\} \\] <p>Along the same lines as the example before, estimating the expectation value using classical shadows in Qadence only requires to pass the right set of parameters to the <code>Measurements</code> object:</p> <pre><code># Classical shadows are defined up to some accuracy and confidence.\nshadow_options = {\"accuracy\": 0.1, \"confidence\": 0.1}  # Shadow size N=54400.\nshadow_measurement = Measurements(protocol=Measurements.SHADOW, options=shadow_options)\n\n# Run the experiment with classical shadows.\nestimated_values_shadow = model.expectation(\n    values=values,\n    measurement=shadow_measurement,\n)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-1.5018]])\n</code></pre>"},{"location":"realistic_sims/measurements/#references","title":"References","text":"<ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9\u21a9</p> </li> <li> <p>S. Aaronson. Shadow tomography of quantum states. In Proceedings of the 50th Annual A ACM SIGACT Symposium on Theory of Computing, STOC 2018, pages 325\u2013338, New York, NY, USA, 2018. ACM\u00a0\u21a9</p> </li> </ol>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>Beyond running noisy simulations, Qadence offers a number of noise mitigation techniques to achieve better accuracy of simulation outputs. Currently, mitigation addresses readout errors and depolarizing and dephasing noise for analog blocks.</p>"},{"location":"realistic_sims/mitigation/#readout-error-mitigation","title":"Readout error mitigation","text":"<p>The complete implementation of the mitigation technique is to measure \\(T\\) and classically apply \\(T^{\u22121}\\) to measured probability distributions. However there are several limitations of this approach:</p> <ul> <li>The complete implementation requires \\(2^n\\) characterization experiments (probability measurements), which is not scalable. The classical processing of the calibration data is also inefficient.</li> <li>The matrix \\(T\\) may become singular for large \\(n\\), preventing direct inversion.</li> <li>The inverse \\(T^{\u22121}\\) might not be a stochastic matrix, meaning that it can produce negative corrected probabilities.</li> <li>The correction is not rigorously justified, so we cannot be sure that we are only removing SPAM errors and not otherwise corrupting an estimated probability distribution.</li> </ul> <p>Qadence relies on the assumption of uncorrelated readout errors:</p> \\[ T=T_1\\otimes T_2\\otimes \\dots \\otimes T_n \\] <p>for which the inversion is straightforward:</p> \\[ T^{-1}=T_1^{-1}\\otimes T_2^{-1}\\otimes \\dots \\otimes T_n^{-1} \\] <p>However, even for a reduced \\(n\\) the third limitation holds. This can be avoided by reformulating into a minimization problem<sup>1</sup>:</p> \\[ \\lVert Tp_{\\textrm{corr}}-p_{\\textrm{raw}}\\rVert_{2}^{2} \\] <p>subjected to physicality constraints \\(0 \\leq p_{corr}(x) \\leq 1\\) and \\(\\lVert p_{corr} \\rVert = 1\\). At this point, two methods are implemented to solve this problem. The first one relies on solving using standard optimization tools, the second on Maximum-Likelihood Estimation<sup>2</sup>. In Qadence, this can be user defined using the mitigation protocol:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\nfrom qadence.mitigations import Mitigations\nfrom qadence.types import ReadOutOptimization\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use:\nnoise = Noise(protocol=Noise.READOUT)\n# Define the mitigation method solving the minimization problem:\noptions={\"optimization_type\": ReadOutOptimization.CONSTRAINED}  # ReadOutOptimization.MLE for the alternative method.\nmitigation = Mitigations(protocol=Mitigations.READOUT, options=options)\n\n# Run noiseless, noisy and mitigated simulations.\nn_shots = 100\nnoiseless_samples = model.sample(n_shots=n_shots)\nnoisy_samples = model.sample(noise=noise, n_shots=n_shots)\nmitigated_samples = model.sample(\n    noise=noise, mitigation=mitigation, n_shots=n_shots\n)\n\nprint(f\"noiseless {noiseless_samples}\")\nprint(f\"noisy {noisy_samples}\")\nprint(f\"mitigated {mitigated_samples}\")\n</code></pre> <pre><code>noiseless [Counter({'10': 54, '00': 46})]\nnoisy [Counter({'10': 52, '00': 39, '01': 6, '11': 3})]\nmitigated [Counter({'10': 44, '00': 43, '11': 7, '01': 6})]\n</code></pre>"},{"location":"realistic_sims/mitigation/#wip-zero-noise-extrapolation-for-analog-blocks","title":"[WIP] Zero-noise extrapolation for analog blocks","text":"<p>Zero-noise extrapolation (ZNE) is an error mitigation technique in which an expectation value is computed at different noise levels and, as a second step, the ideal expectation value is inferred by extrapolating the measured results to the zero-noise limit. In digital computing, this is typically implemented by \"folding\" the circuit and its dagger to artificially increase the noise through sequences of identities<sup>3</sup>. In the analog ZNE variation, analog blocks are time stretched to again artificially increase noise<sup>3</sup>.</p>"},{"location":"realistic_sims/mitigation/#references","title":"References","text":"<ol> <li> <p>Michael R. Geller and Mingyu Sun, Efficient correction of multiqubit measurement errors, (2020) \u21a9</p> </li> <li> <p>Smolin et al., Maximum Likelihood, Minimum Effort, (2011) \u21a9</p> </li> <li> <p>Mitiq: What's the theory behind ZNE? \u21a9\u21a9</p> </li> </ol>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. They are typically described using confusion matrices of the form:</p> \\[ T(x|x')=\\delta_{xx'} \\] <p>Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'10': 55, '00': 45})]\nnoisy = [Counter({'00': 49, '10': 46, '11': 4, '01': 1})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[0.7950]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9718]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': 3bf827ee-415e-49b1-afc6-9886015b2dee, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 4cd1826d-5760-4a18-abe9-f248a563fd95, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 0b5b3028-e30c-439f-a3e5-5b7f71dd5802, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 8d79b6cf-dcb3-4f4c-84fb-e5f5a2fffd33, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': d05efc7c-c445-4f8b-bf27-68c0b5a64e2c, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 98d4461c-369e-4373-b7da-568b56941c0b, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 8720e4ed-e6ba-494b-87b9-f82ae48f8771, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 594a8706-c215-477a-ba3b-d864f0bb12c8, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 3f596469-c39e-47ad-ba63-112f95dbcbfd, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 3095809d-a11c-4b15-a427-3c259baf3c62, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 840cddbc-2d14-49c0-b18f-01edc77fad4b, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_4: tensor([0.0048], requires_grad=True)\n  theta_3: tensor([0.1998], requires_grad=True)\n  theta_0: tensor([0.4202], requires_grad=True)\n  theta_2: tensor([0.0253], requires_grad=True)\n  theta_5: tensor([0.6525], requires_grad=True)\n  theta_6: tensor([0.6515], requires_grad=True)\n  theta_7: tensor([0.0871], requires_grad=True)\n  theta_1: tensor([0.1037], requires_grad=True)\n  theta_8: tensor([0.4130], requires_grad=True)\n}\nembedded = {\n  3bf827ee-415e-49b1-afc6-9886015b2dee: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  4cd1826d-5760-4a18-abe9-f248a563fd95: tensor([2., 2.])\n  0b5b3028-e30c-439f-a3e5-5b7f71dd5802: tensor([0.4202], grad_fn=&lt;ViewBackward0&gt;)\n  8d79b6cf-dcb3-4f4c-84fb-e5f5a2fffd33: tensor([0.1037], grad_fn=&lt;ViewBackward0&gt;)\n  d05efc7c-c445-4f8b-bf27-68c0b5a64e2c: tensor([0.0253], grad_fn=&lt;ViewBackward0&gt;)\n  98d4461c-369e-4373-b7da-568b56941c0b: tensor([0.1998], grad_fn=&lt;ViewBackward0&gt;)\n  8720e4ed-e6ba-494b-87b9-f82ae48f8771: tensor([0.0048], grad_fn=&lt;ViewBackward0&gt;)\n  594a8706-c215-477a-ba3b-d864f0bb12c8: tensor([0.6525], grad_fn=&lt;ViewBackward0&gt;)\n  3f596469-c39e-47ad-ba63-112f95dbcbfd: tensor([0.6515], grad_fn=&lt;ViewBackward0&gt;)\n  3095809d-a11c-4b15-a427-3c259baf3c62: tensor([0.0871], grad_fn=&lt;ViewBackward0&gt;)\n  840cddbc-2d14-49c0-b18f-01edc77fad4b: tensor([0.4130], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  theta_4: tensor([0.0048], grad_fn=&lt;ViewBackward0&gt;)\n  y: tensor([2., 2.])\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  theta_3: tensor([0.1998], grad_fn=&lt;ViewBackward0&gt;)\n  theta_0: tensor([0.4202], grad_fn=&lt;ViewBackward0&gt;)\n  theta_2: tensor([0.0253], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.6525], grad_fn=&lt;ViewBackward0&gt;)\n  theta_6: tensor([0.6515], grad_fn=&lt;ViewBackward0&gt;)\n  theta_7: tensor([0.0871], grad_fn=&lt;ViewBackward0&gt;)\n  theta_1: tensor([0.1037], grad_fn=&lt;ViewBackward0&gt;)\n  theta_8: tensor([0.4130], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.0700-3.6374e-02j,  0.0175-2.6802e-02j,  0.0365+1.8930e-01j,\n         -0.1506+4.5069e-01j, -0.6863-3.8708e-01j, -0.3197-1.3397e-04j,\n         -0.0128+2.8051e-02j, -0.0615+4.4707e-02j],\n        [ 0.0700-3.6374e-02j,  0.0175-2.6802e-02j,  0.0365+1.8930e-01j,\n         -0.1506+4.5069e-01j, -0.6863-3.8708e-01j, -0.3197-1.3397e-04j,\n         -0.0128+2.8051e-02j, -0.0615+4.4707e-02j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 247, '111': 165, '011': 147, '100': 139, '001': 105, '110': 72, '010': 66, '101': 59})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(3bf827ee-415e-49b1-afc6-9886015b2dee)-C----------------------------------------Rx(0b5b3028-e30c-439f-a3e5-5b7f71dd5802)-Ry(98d4461c-369e-4373-b7da-568b56941c0b)-Rx(3f596469-c39e-47ad-ba63-112f95dbcbfd)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(4cd1826d-5760-4a18-abe9-f248a563fd95)-X----------------------------------------Rx(8d79b6cf-dcb3-4f4c-84fb-e5f5a2fffd33)-Ry(8720e4ed-e6ba-494b-87b9-f82ae48f8771)-Rx(3095809d-a11c-4b15-a427-3c259baf3c62)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(d05efc7c-c445-4f8b-bf27-68c0b5a64e2c)-Ry(594a8706-c215-477a-ba3b-d864f0bb12c8)-Rx(840cddbc-2d14-49c0-b18f-01edc77fad4b)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [0b5b3028-e30c-439f-a3e5-5b7f71dd5802, 3095809d-a11c-4b15-a427-3c259baf3c62, 3bf827ee-415e-49b1-afc6-9886015b2dee, 3f596469-c39e-47ad-ba63-112f95dbcbfd, 4cd1826d-5760-4a18-abe9-f248a563fd95, 594a8706-c215-477a-ba3b-d864f0bb12c8, 840cddbc-2d14-49c0-b18f-01edc77fad4b, 8720e4ed-e6ba-494b-87b9-f82ae48f8771, 8d79b6cf-dcb3-4f4c-84fb-e5f5a2fffd33, 98d4461c-369e-4373-b7da-568b56941c0b, d05efc7c-c445-4f8b-bf27-68c0b5a64e2c].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(0.94)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.42)-DEPO(0.1)-Ry(0.20)-DEPO(0.1)-Rx(0.65)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.08)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.10)-DEPO(0.1)-Ry(0.00)-DEPO(0.1)-Rx(0.09)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.03)-DEPO(0.1)-Ry(0.65)-DEPO(0.1)-Rx(0.41)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 20d346c05bd248768e2af226cb3f9ec2 0 c7dbea98353c459990fe7f0d890198fe X 20d346c05bd248768e2af226cb3f9ec2--c7dbea98353c459990fe7f0d890198fe bc17223155a541d0ab068e83d9be6cd1 1 26b67d0810704a80b11ace544cb53016 c7dbea98353c459990fe7f0d890198fe--26b67d0810704a80b11ace544cb53016 e4c24e2976fd431da61e0bd03f49d1e9 b8f60607d022467da697ac7a7388e9dd Y bc17223155a541d0ab068e83d9be6cd1--b8f60607d022467da697ac7a7388e9dd b8f60607d022467da697ac7a7388e9dd--e4c24e2976fd431da61e0bd03f49d1e9 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 98397221d1a642a191e7b8c3db58549f 0 89c0a18f1070478a9138b80a86595533 RX(0.5) 98397221d1a642a191e7b8c3db58549f--89c0a18f1070478a9138b80a86595533 00402c1460d64da99e44ee8193a2d8d5 89c0a18f1070478a9138b80a86595533--00402c1460d64da99e44ee8193a2d8d5 <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 c82c6e0db3ec482baaff88e8cb60131a 0 0f396be59c574fd88b6fb27debf0e047 c82c6e0db3ec482baaff88e8cb60131a--0f396be59c574fd88b6fb27debf0e047 b1510963512042738c511d9e01146e5e 1 69d60084687143b5a934d23aa9874241 0f396be59c574fd88b6fb27debf0e047--69d60084687143b5a934d23aa9874241 e4ba67bb26d446f08cea7ced75cf5e9b f1b43b6189fb44b89433deeeccb944bc X b1510963512042738c511d9e01146e5e--f1b43b6189fb44b89433deeeccb944bc f1b43b6189fb44b89433deeeccb944bc--0f396be59c574fd88b6fb27debf0e047 f1b43b6189fb44b89433deeeccb944bc--e4ba67bb26d446f08cea7ced75cf5e9b <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 1ca9699ecfd046ecbb5a0df28d8c462a 0 797162402be541b6a74e007a97e44a75 X 1ca9699ecfd046ecbb5a0df28d8c462a--797162402be541b6a74e007a97e44a75 c009058b647642249dad13f60bbae513 X 797162402be541b6a74e007a97e44a75--c009058b647642249dad13f60bbae513 0505943044a4444a8d0fedce938bc5d5 c009058b647642249dad13f60bbae513--0505943044a4444a8d0fedce938bc5d5 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 d77e6aacc08c4b67b33569af143e3426 0 7e0fcadab82a4776b5711b5cc41ff406 X d77e6aacc08c4b67b33569af143e3426--7e0fcadab82a4776b5711b5cc41ff406 87f45ff6bb254f31abe484aaabeb0076 1 c7f825a798e9482ba5f17f01544c257b 7e0fcadab82a4776b5711b5cc41ff406--c7f825a798e9482ba5f17f01544c257b fe6c3e2eddde4383b4dc46f7e27e0bff c7f825a798e9482ba5f17f01544c257b--fe6c3e2eddde4383b4dc46f7e27e0bff e0b03052b71349ca8782596fd0b555ad 0476c65690c145be9a20aee92559bba7 87f45ff6bb254f31abe484aaabeb0076--0476c65690c145be9a20aee92559bba7 3ac50fcc2dbb45848e0c7ff851325a87 X 0476c65690c145be9a20aee92559bba7--3ac50fcc2dbb45848e0c7ff851325a87 3ac50fcc2dbb45848e0c7ff851325a87--e0b03052b71349ca8782596fd0b555ad </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 5226e1f061cd485d931356305e5a8455 0 59e1fc3f958d414295ff709473bb4f84 X 5226e1f061cd485d931356305e5a8455--59e1fc3f958d414295ff709473bb4f84 23d77099811340f08d768a7a9111c8cf 1 e0e53c7e67664c0b87203c83de548262 59e1fc3f958d414295ff709473bb4f84--e0e53c7e67664c0b87203c83de548262 e8f67bbfbc0943bcb86bc2495ba6dbb8 d460676fdbc743508203ed85b3678e98 X 23d77099811340f08d768a7a9111c8cf--d460676fdbc743508203ed85b3678e98 d460676fdbc743508203ed85b3678e98--e8f67bbfbc0943bcb86bc2495ba6dbb8 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_d859d98305414dda8bb3f4f72b7f6d6f subblock cluster_178c317730f840f8a7fc443ea640ba95 subblock e322b07e201e43cca7aefca59ad1f488 0 c170630cd9b948c5bc9d46b4a40bc202 X e322b07e201e43cca7aefca59ad1f488--c170630cd9b948c5bc9d46b4a40bc202 eede8b4ab4a2425383efc8715bd80dcd 1 9bae8c0857d44d6ab8f4b73aed459567 X c170630cd9b948c5bc9d46b4a40bc202--9bae8c0857d44d6ab8f4b73aed459567 30268aa3dcf14e5980253696b58c717f 9bae8c0857d44d6ab8f4b73aed459567--30268aa3dcf14e5980253696b58c717f d825bc54ca704a3ab15a8d91266c7577 ad741086e37644048f6e38a0a4aaf406 Y eede8b4ab4a2425383efc8715bd80dcd--ad741086e37644048f6e38a0a4aaf406 57e702753ae140989ae54b14619a5d88 2 9831928599ce47599d8d00f2ee399eb7 Y ad741086e37644048f6e38a0a4aaf406--9831928599ce47599d8d00f2ee399eb7 9831928599ce47599d8d00f2ee399eb7--d825bc54ca704a3ab15a8d91266c7577 1df3a2d1ac274bc58d246de0db15d1e0 c39454c5c0d44228b31c6e0853ccd5ea 57e702753ae140989ae54b14619a5d88--c39454c5c0d44228b31c6e0853ccd5ea 45fec5c245a444c4bff6b76c03913ebf 3 84f8a4748d1141a9aaeb0c8f8a30f6a7 c39454c5c0d44228b31c6e0853ccd5ea--84f8a4748d1141a9aaeb0c8f8a30f6a7 84f8a4748d1141a9aaeb0c8f8a30f6a7--1df3a2d1ac274bc58d246de0db15d1e0 ab02a0b776f54c4c9fd8512e8340cb92 05e8f6d7dd8f472db33c48a997d2568a 45fec5c245a444c4bff6b76c03913ebf--05e8f6d7dd8f472db33c48a997d2568a 3adcb148a4ed4ba69ed285b109b6e5be 4 0a7cab8b51714f448ca6323acce9388c 05e8f6d7dd8f472db33c48a997d2568a--0a7cab8b51714f448ca6323acce9388c 0a7cab8b51714f448ca6323acce9388c--ab02a0b776f54c4c9fd8512e8340cb92 49579329556e4357887b2f035435b127 a2985afa6ee146acb221af0eef266a3a X 3adcb148a4ed4ba69ed285b109b6e5be--a2985afa6ee146acb221af0eef266a3a a2985afa6ee146acb221af0eef266a3a--05e8f6d7dd8f472db33c48a997d2568a 2bd0b24fac0b49ae9c949d98e8fe59cf X a2985afa6ee146acb221af0eef266a3a--2bd0b24fac0b49ae9c949d98e8fe59cf 2bd0b24fac0b49ae9c949d98e8fe59cf--0a7cab8b51714f448ca6323acce9388c 2bd0b24fac0b49ae9c949d98e8fe59cf--49579329556e4357887b2f035435b127"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'01': 283, '11': 247, '10': 241, '00': 229})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'000': 29, '010': 29, '110': 27, '100': 15})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Alternatively, a custom interaction function can also be defined. The input should be two integer indices \\(i\\) and \\(j\\) and it should return a composition of pauli terms representing the interaction between qubits \\(i\\) and \\(j\\):</p> <pre><code>def custom_int(i: int, j: int):\n    return X(i) @ X(j) + Y(i) @ Y(j)\n\nn_qubits = 2\n\nhamilt = hamiltonian_factory(n_qubits, interaction=custom_int)\n</code></pre> <pre><code>AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 AddBlock(0,1)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u251c\u2500\u2500 X(0)\n        \u2502   \u2514\u2500\u2500 X(1)\n        \u2514\u2500\u2500 KronBlock(0,1)\n            \u251c\u2500\u2500 Y(0)\n            \u2514\u2500\u2500 Y(1)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(1)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import numpy as np\nfrom torch import tensor\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea, PI\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": tensor([PI / 2, PI])}\nvalues_ket = {\"psi\": tensor([PI / 2, PI])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[0.2618, 0.0050],\n        [0.0076, 0.0072]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from qadence import RX, run, PI\n\n# Let's use a torch type.\nblock = RX(0, PI)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9882+0.0000j, 0.0000-0.1531j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8785+0.0000j, 0.0000-0.4778j],\n        [0.9538+0.0000j, 0.0000-0.3006j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5500+0.0000j, 0.5257+0.0000j, 0.0000-0.4691j, 0.0000-0.4484j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_81dc7221722a4460a75c7e522bf9eb3d [* 2] cluster_f878e9a8370d4e22adee94c17ca7a2cc Rotations cde255f99dfe45f7818b055f2ccaac43 0 1a48214d76f744178db3cb87ae6304a9 RX(phi/theta) cde255f99dfe45f7818b055f2ccaac43--1a48214d76f744178db3cb87ae6304a9 596e5fc5a7114b0c8f531d6680c4954c 1 8d068210d0594aac992e2818ae9ff125 RX(phi) 1a48214d76f744178db3cb87ae6304a9--8d068210d0594aac992e2818ae9ff125 29d7c622505943efab4547e2062c1477 RX(phi) 8d068210d0594aac992e2818ae9ff125--29d7c622505943efab4547e2062c1477 0b78b02d0eda40128c38464ef8c34d2f RX(phi + theta) 29d7c622505943efab4547e2062c1477--0b78b02d0eda40128c38464ef8c34d2f f3b0f92f53a24e579018dca6d2004ef8 0b78b02d0eda40128c38464ef8c34d2f--f3b0f92f53a24e579018dca6d2004ef8 999e2da6675345f48bead0e20a9e7ecf f3b0f92f53a24e579018dca6d2004ef8--999e2da6675345f48bead0e20a9e7ecf a8ef52e4b01644d0801243571640fa2a Z 999e2da6675345f48bead0e20a9e7ecf--a8ef52e4b01644d0801243571640fa2a 7b12a7418f944434a3a7b3623de547cf a8ef52e4b01644d0801243571640fa2a--7b12a7418f944434a3a7b3623de547cf bd5383402eb54adf9f911d4d8727307b 80f90190f6ef4cf3a2ca9a677e1f27dc RY(2*theta) 596e5fc5a7114b0c8f531d6680c4954c--80f90190f6ef4cf3a2ca9a677e1f27dc e844b8b6e42848a1bc317457589ee118 2 d5adc1cb18aa4d518a96bfe08a581360 RY(theta) 80f90190f6ef4cf3a2ca9a677e1f27dc--d5adc1cb18aa4d518a96bfe08a581360 f764807f7eb34cadb405cbba7b6ad5a2 RY(theta) d5adc1cb18aa4d518a96bfe08a581360--f764807f7eb34cadb405cbba7b6ad5a2 295e447475a24b0c9cf5e9b29bf28b60 RY(theta**2) f764807f7eb34cadb405cbba7b6ad5a2--295e447475a24b0c9cf5e9b29bf28b60 e5dd6138cef8408f92e86bbf5faa0853 X 295e447475a24b0c9cf5e9b29bf28b60--e5dd6138cef8408f92e86bbf5faa0853 e5dd6138cef8408f92e86bbf5faa0853--f3b0f92f53a24e579018dca6d2004ef8 213328d0ad3d4bdfb64dab494295e684 e5dd6138cef8408f92e86bbf5faa0853--213328d0ad3d4bdfb64dab494295e684 db1a5b8671bb4cd7a7fb5c7e65676bf4 Z 213328d0ad3d4bdfb64dab494295e684--db1a5b8671bb4cd7a7fb5c7e65676bf4 db1a5b8671bb4cd7a7fb5c7e65676bf4--bd5383402eb54adf9f911d4d8727307b 54eef3f12b9b47899033077b1c444481 39d757f1749d4527bccdc9d956a0f40c RZ(cos(phi)) e844b8b6e42848a1bc317457589ee118--39d757f1749d4527bccdc9d956a0f40c c4838936e3614b7892a280f44cebb34f RZ(phi) 39d757f1749d4527bccdc9d956a0f40c--c4838936e3614b7892a280f44cebb34f f4b7c7560eb245baa9e1a41e424f580c RZ(phi) c4838936e3614b7892a280f44cebb34f--f4b7c7560eb245baa9e1a41e424f580c b6f2f801dd5a408fabfb50c34a3ddd2f RZ(cos(phi)) f4b7c7560eb245baa9e1a41e424f580c--b6f2f801dd5a408fabfb50c34a3ddd2f 12a9177f746d455a8df5e92fa0e3c7f8 b6f2f801dd5a408fabfb50c34a3ddd2f--12a9177f746d455a8df5e92fa0e3c7f8 10117d35642647dbbca421c789bd4d76 X 12a9177f746d455a8df5e92fa0e3c7f8--10117d35642647dbbca421c789bd4d76 10117d35642647dbbca421c789bd4d76--213328d0ad3d4bdfb64dab494295e684 1c18e9d590744c3a8dd829bcc1b6c77f Z 10117d35642647dbbca421c789bd4d76--1c18e9d590744c3a8dd829bcc1b6c77f 1c18e9d590744c3a8dd829bcc1b6c77f--54eef3f12b9b47899033077b1c444481 <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.2054]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.9677+0.0000j, 0.1768+0.0000j, 0.0000-0.1768j, 0.0000-0.0323j],\n        [0.9856+0.0000j, 0.1193+0.0000j, 0.0000-0.1193j, 0.0000-0.0144j],\n        [0.8356+0.0000j, 0.3706+0.0000j, 0.0000-0.3706j, 0.0000-0.1644j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 d16c84c33efe4dbd881ded07b32ec277 0 10bce040a4d342bc8f5cfdd0830d005a RX(theta\u2080) d16c84c33efe4dbd881ded07b32ec277--10bce040a4d342bc8f5cfdd0830d005a 1dabfb0efb754927a6bc1b758c421589 1 660625b8ce6e4a219443e2325418749c RY(theta\u2084) 10bce040a4d342bc8f5cfdd0830d005a--660625b8ce6e4a219443e2325418749c 7949b9a3d4554870bb93bc34c39756eb RX(theta\u2088) 660625b8ce6e4a219443e2325418749c--7949b9a3d4554870bb93bc34c39756eb 867029a335f0415eb0847bbc89cdaacd 7949b9a3d4554870bb93bc34c39756eb--867029a335f0415eb0847bbc89cdaacd 0cf3695773bf4707980d7842f96c6333 867029a335f0415eb0847bbc89cdaacd--0cf3695773bf4707980d7842f96c6333 cbc5b36079bb4933aad925984a6bddf4 RX(theta\u2081\u2082) 0cf3695773bf4707980d7842f96c6333--cbc5b36079bb4933aad925984a6bddf4 55716b3145f1408fa5e5bcf879799c69 RY(theta\u2081\u2086) cbc5b36079bb4933aad925984a6bddf4--55716b3145f1408fa5e5bcf879799c69 05a201773b9042cc8db2fa9b896aed4f RX(theta\u2082\u2080) 55716b3145f1408fa5e5bcf879799c69--05a201773b9042cc8db2fa9b896aed4f cb43cc2f6e01432cb6ff8e1f7ac2ae35 05a201773b9042cc8db2fa9b896aed4f--cb43cc2f6e01432cb6ff8e1f7ac2ae35 38efcfd3f14b4d4ba5d92b1b90d1a5ee cb43cc2f6e01432cb6ff8e1f7ac2ae35--38efcfd3f14b4d4ba5d92b1b90d1a5ee bec80bee671a4fb08824ee8d50cf13f1 38efcfd3f14b4d4ba5d92b1b90d1a5ee--bec80bee671a4fb08824ee8d50cf13f1 50810dc841e845dcb78abbdcc80320f6 e23e26f980164b1f865ae58d58263b1f RX(theta\u2081) 1dabfb0efb754927a6bc1b758c421589--e23e26f980164b1f865ae58d58263b1f 9124b9e8b8524962b8c53c99060b0285 2 3c66a7a16d354bd4ab17619c9304224f RY(theta\u2085) e23e26f980164b1f865ae58d58263b1f--3c66a7a16d354bd4ab17619c9304224f 70f46c301b244cd59e2dd042e2d8ec35 RX(theta\u2089) 3c66a7a16d354bd4ab17619c9304224f--70f46c301b244cd59e2dd042e2d8ec35 77a735b8bdbf4e3394aaf81d574461a3 X 70f46c301b244cd59e2dd042e2d8ec35--77a735b8bdbf4e3394aaf81d574461a3 77a735b8bdbf4e3394aaf81d574461a3--867029a335f0415eb0847bbc89cdaacd 15b963078106455da0524ba6b6eb707c 77a735b8bdbf4e3394aaf81d574461a3--15b963078106455da0524ba6b6eb707c 872ed5707c65426a9c0a6cc1893f929e RX(theta\u2081\u2083) 15b963078106455da0524ba6b6eb707c--872ed5707c65426a9c0a6cc1893f929e 78f3b8752cfb4e12a2844b84f44f7413 RY(theta\u2081\u2087) 872ed5707c65426a9c0a6cc1893f929e--78f3b8752cfb4e12a2844b84f44f7413 cce7f76fbd554e8294ba4af7f79810aa RX(theta\u2082\u2081) 78f3b8752cfb4e12a2844b84f44f7413--cce7f76fbd554e8294ba4af7f79810aa 916cf60f364c4e8dac09eec893b8bd64 X cce7f76fbd554e8294ba4af7f79810aa--916cf60f364c4e8dac09eec893b8bd64 916cf60f364c4e8dac09eec893b8bd64--cb43cc2f6e01432cb6ff8e1f7ac2ae35 ea26396e285e47129312a2694388440f 916cf60f364c4e8dac09eec893b8bd64--ea26396e285e47129312a2694388440f ea26396e285e47129312a2694388440f--50810dc841e845dcb78abbdcc80320f6 9d2835d000cb4cee883261a654a67c3a 9f14daa65eca4b2086663d52c7ba17ae RX(theta\u2082) 9124b9e8b8524962b8c53c99060b0285--9f14daa65eca4b2086663d52c7ba17ae 7881abfec0164f56a026c84a8d8df6f7 3 f56f461c289f4e3f83a8cd55f405c290 RY(theta\u2086) 9f14daa65eca4b2086663d52c7ba17ae--f56f461c289f4e3f83a8cd55f405c290 684b06e2fd534185a1c7afb1b2a5b46c RX(theta\u2081\u2080) f56f461c289f4e3f83a8cd55f405c290--684b06e2fd534185a1c7afb1b2a5b46c 9a1b3c1398ab4b3c947c39556a4c8305 684b06e2fd534185a1c7afb1b2a5b46c--9a1b3c1398ab4b3c947c39556a4c8305 03c622a103684f0fbf882fcbc742e6c2 X 9a1b3c1398ab4b3c947c39556a4c8305--03c622a103684f0fbf882fcbc742e6c2 03c622a103684f0fbf882fcbc742e6c2--15b963078106455da0524ba6b6eb707c 7c588e83a2c14058890adeb115f32a99 RX(theta\u2081\u2084) 03c622a103684f0fbf882fcbc742e6c2--7c588e83a2c14058890adeb115f32a99 e74b67c724514e1d91eaf86ade949188 RY(theta\u2081\u2088) 7c588e83a2c14058890adeb115f32a99--e74b67c724514e1d91eaf86ade949188 44eefb477c114dd4b452fa447e33e8fc RX(theta\u2082\u2082) e74b67c724514e1d91eaf86ade949188--44eefb477c114dd4b452fa447e33e8fc e85793ddd0774021ae8cb2ba276c7380 44eefb477c114dd4b452fa447e33e8fc--e85793ddd0774021ae8cb2ba276c7380 4c763d578954401fa2ec532142b9355d X e85793ddd0774021ae8cb2ba276c7380--4c763d578954401fa2ec532142b9355d 4c763d578954401fa2ec532142b9355d--ea26396e285e47129312a2694388440f 4c763d578954401fa2ec532142b9355d--9d2835d000cb4cee883261a654a67c3a fc6d68c340ba4a05819c2a96e0e07b60 1ee025e2c2c045a396ff0f91769ca144 RX(theta\u2083) 7881abfec0164f56a026c84a8d8df6f7--1ee025e2c2c045a396ff0f91769ca144 ae0df8d6aeaa4b3db6d57876b24249d9 RY(theta\u2087) 1ee025e2c2c045a396ff0f91769ca144--ae0df8d6aeaa4b3db6d57876b24249d9 8e72378d79af4951967d64bab9cf8302 RX(theta\u2081\u2081) ae0df8d6aeaa4b3db6d57876b24249d9--8e72378d79af4951967d64bab9cf8302 fa979dc2858144a6bebf1b2913fe9ff0 X 8e72378d79af4951967d64bab9cf8302--fa979dc2858144a6bebf1b2913fe9ff0 fa979dc2858144a6bebf1b2913fe9ff0--9a1b3c1398ab4b3c947c39556a4c8305 06810a9caf0840caa2b20fa0a8b7bc36 fa979dc2858144a6bebf1b2913fe9ff0--06810a9caf0840caa2b20fa0a8b7bc36 0353f505a4664ccf9aba31dc2a9bfae0 RX(theta\u2081\u2085) 06810a9caf0840caa2b20fa0a8b7bc36--0353f505a4664ccf9aba31dc2a9bfae0 6e54527cc473443189a0e883c58daf2a RY(theta\u2081\u2089) 0353f505a4664ccf9aba31dc2a9bfae0--6e54527cc473443189a0e883c58daf2a 875d5e4ea5d34cc6b1047e84787203dd RX(theta\u2082\u2083) 6e54527cc473443189a0e883c58daf2a--875d5e4ea5d34cc6b1047e84787203dd d2c932005dc54427ad39fd5cae6f0e40 X 875d5e4ea5d34cc6b1047e84787203dd--d2c932005dc54427ad39fd5cae6f0e40 d2c932005dc54427ad39fd5cae6f0e40--e85793ddd0774021ae8cb2ba276c7380 1dad8439ae29469787fc16968293471e d2c932005dc54427ad39fd5cae6f0e40--1dad8439ae29469787fc16968293471e 1dad8439ae29469787fc16968293471e--fc6d68c340ba4a05819c2a96e0e07b60 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_9d5be485247b4cc3811ca0dbac174112 HEA cluster_b19183dd56ca474c8b7aa8a1d9a0ce18 HEA 40655cec94ab4ce8a8d0d28199584703 0 3cf10b93c6b144cd97cce2cfc3a571f8 RX(theta\u2080) 40655cec94ab4ce8a8d0d28199584703--3cf10b93c6b144cd97cce2cfc3a571f8 b5c087c77a95487f8d57f22bfaa7d60d 1 f1cf25dc62054a7eb4f514704c4977e8 RY(theta\u2084) 3cf10b93c6b144cd97cce2cfc3a571f8--f1cf25dc62054a7eb4f514704c4977e8 fd2d881c10ab42e1819f1d401b8aa34a RX(theta\u2088) f1cf25dc62054a7eb4f514704c4977e8--fd2d881c10ab42e1819f1d401b8aa34a e7f212875180478c9b4d67455abe92cc fd2d881c10ab42e1819f1d401b8aa34a--e7f212875180478c9b4d67455abe92cc 5b26de7e790349d3921456ee67a8fc06 e7f212875180478c9b4d67455abe92cc--5b26de7e790349d3921456ee67a8fc06 1bf27141498344119e6db4a0b93026ef RX(theta\u2081\u2082) 5b26de7e790349d3921456ee67a8fc06--1bf27141498344119e6db4a0b93026ef 901af0614d5d49d49c5bf5e7f531677a RY(theta\u2081\u2086) 1bf27141498344119e6db4a0b93026ef--901af0614d5d49d49c5bf5e7f531677a 959308c977604040b172c87c8f17a6f4 RX(theta\u2082\u2080) 901af0614d5d49d49c5bf5e7f531677a--959308c977604040b172c87c8f17a6f4 7c384307bfb4467e87b677c432fe579a 959308c977604040b172c87c8f17a6f4--7c384307bfb4467e87b677c432fe579a dcf3a78f76274a3385d0c87b1faac08c 7c384307bfb4467e87b677c432fe579a--dcf3a78f76274a3385d0c87b1faac08c f70df7a8094b4b449aff3d9386ca22f8 RX(theta\u2080) dcf3a78f76274a3385d0c87b1faac08c--f70df7a8094b4b449aff3d9386ca22f8 4fe7447e42ba4a67ac3f2e0842b5c3de RY(theta\u2084) f70df7a8094b4b449aff3d9386ca22f8--4fe7447e42ba4a67ac3f2e0842b5c3de 1b6843b6cc7147d7a1e9be5a33b2cfa7 RX(theta\u2088) 4fe7447e42ba4a67ac3f2e0842b5c3de--1b6843b6cc7147d7a1e9be5a33b2cfa7 41dfbc9966cc44f0b292e6addc9580d2 1b6843b6cc7147d7a1e9be5a33b2cfa7--41dfbc9966cc44f0b292e6addc9580d2 9a209e0c0d2d4a88b747ad399b55ef0a 41dfbc9966cc44f0b292e6addc9580d2--9a209e0c0d2d4a88b747ad399b55ef0a 106e8b8b431a472abad3d71cd32f4b30 RX(theta\u2081\u2082) 9a209e0c0d2d4a88b747ad399b55ef0a--106e8b8b431a472abad3d71cd32f4b30 cf4e11b19a064f16b4b1bd5759379a9b RY(theta\u2081\u2086) 106e8b8b431a472abad3d71cd32f4b30--cf4e11b19a064f16b4b1bd5759379a9b acbecfe323f045eb9a421534ccd0c375 RX(theta\u2082\u2080) cf4e11b19a064f16b4b1bd5759379a9b--acbecfe323f045eb9a421534ccd0c375 35ecd83779ac4d7f9b9fdcc082aee2e0 acbecfe323f045eb9a421534ccd0c375--35ecd83779ac4d7f9b9fdcc082aee2e0 ad899d94fcbe4f31a1201f83b20bbf4a 35ecd83779ac4d7f9b9fdcc082aee2e0--ad899d94fcbe4f31a1201f83b20bbf4a 12f6bfab8b4b484d9fd6c661538f8a04 ad899d94fcbe4f31a1201f83b20bbf4a--12f6bfab8b4b484d9fd6c661538f8a04 59b4fcfb92ef409098f37e068eb1f56e 0cfde6bd74ad43d78251bfc6bc251f6d RX(theta\u2081) b5c087c77a95487f8d57f22bfaa7d60d--0cfde6bd74ad43d78251bfc6bc251f6d ebb363b8e7b741be99e96be92875a813 2 41efa23853a74a5c8da89628d121249e RY(theta\u2085) 0cfde6bd74ad43d78251bfc6bc251f6d--41efa23853a74a5c8da89628d121249e fa07e1dcddbb420aaf5800b5f4be5529 RX(theta\u2089) 41efa23853a74a5c8da89628d121249e--fa07e1dcddbb420aaf5800b5f4be5529 d3280de4b2ea4088b7911982a8e57a7a X fa07e1dcddbb420aaf5800b5f4be5529--d3280de4b2ea4088b7911982a8e57a7a d3280de4b2ea4088b7911982a8e57a7a--e7f212875180478c9b4d67455abe92cc e60bf3b6666849a3aa1eff0fd247dd1b d3280de4b2ea4088b7911982a8e57a7a--e60bf3b6666849a3aa1eff0fd247dd1b 93de5b2f03464878907170e0ded929f6 RX(theta\u2081\u2083) e60bf3b6666849a3aa1eff0fd247dd1b--93de5b2f03464878907170e0ded929f6 ca819af737dd446da8b9d488b88333ec RY(theta\u2081\u2087) 93de5b2f03464878907170e0ded929f6--ca819af737dd446da8b9d488b88333ec bcc92e72d95d42519dbc60254e96574a RX(theta\u2082\u2081) ca819af737dd446da8b9d488b88333ec--bcc92e72d95d42519dbc60254e96574a d9d489a98f9340f4b44f595a3595a27d X bcc92e72d95d42519dbc60254e96574a--d9d489a98f9340f4b44f595a3595a27d d9d489a98f9340f4b44f595a3595a27d--7c384307bfb4467e87b677c432fe579a 85dc2c5871384a179d4b886bb7e41702 d9d489a98f9340f4b44f595a3595a27d--85dc2c5871384a179d4b886bb7e41702 11c7d56b3563460994b1c2c987d07858 RX(theta\u2081) 85dc2c5871384a179d4b886bb7e41702--11c7d56b3563460994b1c2c987d07858 dc27d3d41dd5463e82db3ad6cb613aa6 RY(theta\u2085) 11c7d56b3563460994b1c2c987d07858--dc27d3d41dd5463e82db3ad6cb613aa6 36739fabc2ac4ca2a71b52224b2c8db1 RX(theta\u2089) dc27d3d41dd5463e82db3ad6cb613aa6--36739fabc2ac4ca2a71b52224b2c8db1 ad13cfcd24e54030ade80f8670a121d4 X 36739fabc2ac4ca2a71b52224b2c8db1--ad13cfcd24e54030ade80f8670a121d4 ad13cfcd24e54030ade80f8670a121d4--41dfbc9966cc44f0b292e6addc9580d2 0aa229b7c4f546eabd37b8040a4dcb5f ad13cfcd24e54030ade80f8670a121d4--0aa229b7c4f546eabd37b8040a4dcb5f f68563a2110a4ce4845565215e1a9d84 RX(theta\u2081\u2083) 0aa229b7c4f546eabd37b8040a4dcb5f--f68563a2110a4ce4845565215e1a9d84 aaeaf84447a54340852f2a9fd550d550 RY(theta\u2081\u2087) f68563a2110a4ce4845565215e1a9d84--aaeaf84447a54340852f2a9fd550d550 1319839000cb4ba9bedc60f0570a2483 RX(theta\u2082\u2081) aaeaf84447a54340852f2a9fd550d550--1319839000cb4ba9bedc60f0570a2483 c9c448797789459ea8f81bd78bcc07e5 X 1319839000cb4ba9bedc60f0570a2483--c9c448797789459ea8f81bd78bcc07e5 c9c448797789459ea8f81bd78bcc07e5--35ecd83779ac4d7f9b9fdcc082aee2e0 b83842b1ffe648499b7d34e89b5e207b c9c448797789459ea8f81bd78bcc07e5--b83842b1ffe648499b7d34e89b5e207b b83842b1ffe648499b7d34e89b5e207b--59b4fcfb92ef409098f37e068eb1f56e 71799526c7a8459981e0f2b1ecd20c36 7b8eb494f4d54a209251222e7456f472 RX(theta\u2082) ebb363b8e7b741be99e96be92875a813--7b8eb494f4d54a209251222e7456f472 bd784622cc534915afd84939011f0200 3 c17eff08cde649a59fde4273ddce1351 RY(theta\u2086) 7b8eb494f4d54a209251222e7456f472--c17eff08cde649a59fde4273ddce1351 242b69a3542e48c29b867ade45f68504 RX(theta\u2081\u2080) c17eff08cde649a59fde4273ddce1351--242b69a3542e48c29b867ade45f68504 b7e5f22c53494d47b554cfd329f47e4d 242b69a3542e48c29b867ade45f68504--b7e5f22c53494d47b554cfd329f47e4d 54e5ef8d36ed4d30998b8937c36b71c2 X b7e5f22c53494d47b554cfd329f47e4d--54e5ef8d36ed4d30998b8937c36b71c2 54e5ef8d36ed4d30998b8937c36b71c2--e60bf3b6666849a3aa1eff0fd247dd1b 5cb4c899cdaa47e4ae18ebc0880dc2e0 RX(theta\u2081\u2084) 54e5ef8d36ed4d30998b8937c36b71c2--5cb4c899cdaa47e4ae18ebc0880dc2e0 ef3cde80bcd844259ed2f206cadaa5fa RY(theta\u2081\u2088) 5cb4c899cdaa47e4ae18ebc0880dc2e0--ef3cde80bcd844259ed2f206cadaa5fa 394460716ed540f1ae5c5181e2e84b73 RX(theta\u2082\u2082) ef3cde80bcd844259ed2f206cadaa5fa--394460716ed540f1ae5c5181e2e84b73 e59f11b2d0564abcb681b67a0104e9e8 394460716ed540f1ae5c5181e2e84b73--e59f11b2d0564abcb681b67a0104e9e8 ebf705fc1e0d4d5ca1a4e0f69698a544 X e59f11b2d0564abcb681b67a0104e9e8--ebf705fc1e0d4d5ca1a4e0f69698a544 ebf705fc1e0d4d5ca1a4e0f69698a544--85dc2c5871384a179d4b886bb7e41702 637f32cc52cb49e491fe2fbf7e59c9d1 RX(theta\u2082) ebf705fc1e0d4d5ca1a4e0f69698a544--637f32cc52cb49e491fe2fbf7e59c9d1 e31b0367d2934ce0aa2c9fcd608e542b RY(theta\u2086) 637f32cc52cb49e491fe2fbf7e59c9d1--e31b0367d2934ce0aa2c9fcd608e542b 1a91999c2c9748fc85bbeeeb6f558069 RX(theta\u2081\u2080) e31b0367d2934ce0aa2c9fcd608e542b--1a91999c2c9748fc85bbeeeb6f558069 0873f2e54270465cbf3d25e596ae4f46 1a91999c2c9748fc85bbeeeb6f558069--0873f2e54270465cbf3d25e596ae4f46 4b5894841624478091f7363dac53f883 X 0873f2e54270465cbf3d25e596ae4f46--4b5894841624478091f7363dac53f883 4b5894841624478091f7363dac53f883--0aa229b7c4f546eabd37b8040a4dcb5f 8661514738cb4f6b8ef13b800d5c6d41 RX(theta\u2081\u2084) 4b5894841624478091f7363dac53f883--8661514738cb4f6b8ef13b800d5c6d41 d1d4be91444c4f1d8e78d2ea6867ad27 RY(theta\u2081\u2088) 8661514738cb4f6b8ef13b800d5c6d41--d1d4be91444c4f1d8e78d2ea6867ad27 2f8e37ce4633455d9cd22df4848c0fd5 RX(theta\u2082\u2082) d1d4be91444c4f1d8e78d2ea6867ad27--2f8e37ce4633455d9cd22df4848c0fd5 1fbe207f184c4370975be696928230db 2f8e37ce4633455d9cd22df4848c0fd5--1fbe207f184c4370975be696928230db 1a77b0f3e1614199a2fc8dc81cc6abec X 1fbe207f184c4370975be696928230db--1a77b0f3e1614199a2fc8dc81cc6abec 1a77b0f3e1614199a2fc8dc81cc6abec--b83842b1ffe648499b7d34e89b5e207b 1a77b0f3e1614199a2fc8dc81cc6abec--71799526c7a8459981e0f2b1ecd20c36 de8cfdd9fbc0471da32adf826c7fa9f7 50515a623d0f45f49553fa52697b21cc RX(theta\u2083) bd784622cc534915afd84939011f0200--50515a623d0f45f49553fa52697b21cc d755b28c8c4e4f9d8e988808fc153a35 RY(theta\u2087) 50515a623d0f45f49553fa52697b21cc--d755b28c8c4e4f9d8e988808fc153a35 fb3f60615cb446a29af2af0ac445f2bf RX(theta\u2081\u2081) d755b28c8c4e4f9d8e988808fc153a35--fb3f60615cb446a29af2af0ac445f2bf 6a180be146a340649e2283a402b59307 X fb3f60615cb446a29af2af0ac445f2bf--6a180be146a340649e2283a402b59307 6a180be146a340649e2283a402b59307--b7e5f22c53494d47b554cfd329f47e4d 1e94b73c33614bd2b72e2d71c16be3b4 6a180be146a340649e2283a402b59307--1e94b73c33614bd2b72e2d71c16be3b4 334be36a1b4e49e8b03622612d404b1f RX(theta\u2081\u2085) 1e94b73c33614bd2b72e2d71c16be3b4--334be36a1b4e49e8b03622612d404b1f 70ba2601c9184866a6af19c3cbf527e8 RY(theta\u2081\u2089) 334be36a1b4e49e8b03622612d404b1f--70ba2601c9184866a6af19c3cbf527e8 583ac3b298ae4686b64b6971383428d6 RX(theta\u2082\u2083) 70ba2601c9184866a6af19c3cbf527e8--583ac3b298ae4686b64b6971383428d6 f13d6a324a3246e3a90ff21b01f07a7d X 583ac3b298ae4686b64b6971383428d6--f13d6a324a3246e3a90ff21b01f07a7d f13d6a324a3246e3a90ff21b01f07a7d--e59f11b2d0564abcb681b67a0104e9e8 bdf6c6526bcd41dea64edce6e6b2b634 f13d6a324a3246e3a90ff21b01f07a7d--bdf6c6526bcd41dea64edce6e6b2b634 4c0f306328b94569b70674866c80454f RX(theta\u2083) bdf6c6526bcd41dea64edce6e6b2b634--4c0f306328b94569b70674866c80454f 06251b8a7a304aeabe2ce6dbcb4d3480 RY(theta\u2087) 4c0f306328b94569b70674866c80454f--06251b8a7a304aeabe2ce6dbcb4d3480 3dacd98a88d84623833fd45ff0c19a80 RX(theta\u2081\u2081) 06251b8a7a304aeabe2ce6dbcb4d3480--3dacd98a88d84623833fd45ff0c19a80 d893c7c5a6ed4069ad1116b137b62650 X 3dacd98a88d84623833fd45ff0c19a80--d893c7c5a6ed4069ad1116b137b62650 d893c7c5a6ed4069ad1116b137b62650--0873f2e54270465cbf3d25e596ae4f46 4e66acb243334c98a05c30d38c6c4e5d d893c7c5a6ed4069ad1116b137b62650--4e66acb243334c98a05c30d38c6c4e5d a7b8701f0d11431992dbe9760e91fa43 RX(theta\u2081\u2085) 4e66acb243334c98a05c30d38c6c4e5d--a7b8701f0d11431992dbe9760e91fa43 827a150735f2400ba2a64e961cf4c3d9 RY(theta\u2081\u2089) a7b8701f0d11431992dbe9760e91fa43--827a150735f2400ba2a64e961cf4c3d9 abc53dd2780d4675a3151ea30632e17e RX(theta\u2082\u2083) 827a150735f2400ba2a64e961cf4c3d9--abc53dd2780d4675a3151ea30632e17e 3429df8bb71542f1b8a37a90f37abd7f X abc53dd2780d4675a3151ea30632e17e--3429df8bb71542f1b8a37a90f37abd7f 3429df8bb71542f1b8a37a90f37abd7f--1fbe207f184c4370975be696928230db 22df1359dc1944c9bb72b0afc749ff71 3429df8bb71542f1b8a37a90f37abd7f--22df1359dc1944c9bb72b0afc749ff71 22df1359dc1944c9bb72b0afc749ff71--de8cfdd9fbc0471da32adf826c7fa9f7 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_6909ad5bec944ca89ab327c53ba4ca84 HEA cluster_104c104188be4986ab62f588e128dc76 HEA 80368b35db3742288861e6a5cff71c03 0 0fd16ecce3854a878ce78c8ab390fd32 RX(p1\u2080) 80368b35db3742288861e6a5cff71c03--0fd16ecce3854a878ce78c8ab390fd32 bfcf7ee9008f4d739fc184d67b2d924c 1 9794d0c330464f4393a229ad8d8c8fd7 RY(p1\u2084) 0fd16ecce3854a878ce78c8ab390fd32--9794d0c330464f4393a229ad8d8c8fd7 dd49849238784036a056f6bf4e4d79a2 RX(p1\u2088) 9794d0c330464f4393a229ad8d8c8fd7--dd49849238784036a056f6bf4e4d79a2 bf278718ceab44b7bf83024a7a6439b7 dd49849238784036a056f6bf4e4d79a2--bf278718ceab44b7bf83024a7a6439b7 6c452496745e42c9bacc4c3e012eb96f bf278718ceab44b7bf83024a7a6439b7--6c452496745e42c9bacc4c3e012eb96f bab5e61264c44b02ad1425be367ce6f3 RX(p1\u2081\u2082) 6c452496745e42c9bacc4c3e012eb96f--bab5e61264c44b02ad1425be367ce6f3 068d895a2d6c4cdf9887e4434f9d327e RY(p1\u2081\u2086) bab5e61264c44b02ad1425be367ce6f3--068d895a2d6c4cdf9887e4434f9d327e a1f4a0a34e54418ba281214c5d8c4193 RX(p1\u2082\u2080) 068d895a2d6c4cdf9887e4434f9d327e--a1f4a0a34e54418ba281214c5d8c4193 65a474e2305d4373b470c49b8f7c7eb1 a1f4a0a34e54418ba281214c5d8c4193--65a474e2305d4373b470c49b8f7c7eb1 c639f35d6e564aa3a6e0a3692a4dff62 65a474e2305d4373b470c49b8f7c7eb1--c639f35d6e564aa3a6e0a3692a4dff62 676f05889abf466992ea376604a55111 RX(p2\u2080) c639f35d6e564aa3a6e0a3692a4dff62--676f05889abf466992ea376604a55111 6951eeeac41c46c8a76da16ac9a2e0de RY(p2\u2084) 676f05889abf466992ea376604a55111--6951eeeac41c46c8a76da16ac9a2e0de b59448923b0d42e3949fe5d856f85760 RX(p2\u2088) 6951eeeac41c46c8a76da16ac9a2e0de--b59448923b0d42e3949fe5d856f85760 1779edf2c35746fba7b040ef17bd3495 b59448923b0d42e3949fe5d856f85760--1779edf2c35746fba7b040ef17bd3495 0eb22420247142d49c94a550e9c86904 1779edf2c35746fba7b040ef17bd3495--0eb22420247142d49c94a550e9c86904 683dfb137527481b84fb779e2337f9b0 RX(p2\u2081\u2082) 0eb22420247142d49c94a550e9c86904--683dfb137527481b84fb779e2337f9b0 ccc9846af0a74a4289524552e0d96d46 RY(p2\u2081\u2086) 683dfb137527481b84fb779e2337f9b0--ccc9846af0a74a4289524552e0d96d46 9f39fb9a53dd46de8d178258828188e9 RX(p2\u2082\u2080) ccc9846af0a74a4289524552e0d96d46--9f39fb9a53dd46de8d178258828188e9 e560f39474d342959012cab6b47d2ec2 9f39fb9a53dd46de8d178258828188e9--e560f39474d342959012cab6b47d2ec2 df9135879a6048ff81022a88654f7dcf e560f39474d342959012cab6b47d2ec2--df9135879a6048ff81022a88654f7dcf 82f1fcdc080b4efba935596b526d3e97 df9135879a6048ff81022a88654f7dcf--82f1fcdc080b4efba935596b526d3e97 38f2162848c4457a9ac7a69c87fb1f00 ab5bc2f597824035b13c152bc58db6f9 RX(p1\u2081) bfcf7ee9008f4d739fc184d67b2d924c--ab5bc2f597824035b13c152bc58db6f9 6fd29caeae3241658e224236b3847018 2 7ada71af8e854e71902fd7a948bf470d RY(p1\u2085) ab5bc2f597824035b13c152bc58db6f9--7ada71af8e854e71902fd7a948bf470d 7f3955e8fb2448f68ed803d026758ac0 RX(p1\u2089) 7ada71af8e854e71902fd7a948bf470d--7f3955e8fb2448f68ed803d026758ac0 cc904d9b96fc46ef88a7bbce63b71cfb X 7f3955e8fb2448f68ed803d026758ac0--cc904d9b96fc46ef88a7bbce63b71cfb cc904d9b96fc46ef88a7bbce63b71cfb--bf278718ceab44b7bf83024a7a6439b7 f3cb4c26f674428f935d73d3a0586429 cc904d9b96fc46ef88a7bbce63b71cfb--f3cb4c26f674428f935d73d3a0586429 080e1a14300f4f0ca9c3f3689212bd5b RX(p1\u2081\u2083) f3cb4c26f674428f935d73d3a0586429--080e1a14300f4f0ca9c3f3689212bd5b 4c4d829b60c0405e801428f3c8fbcbe0 RY(p1\u2081\u2087) 080e1a14300f4f0ca9c3f3689212bd5b--4c4d829b60c0405e801428f3c8fbcbe0 f98a4a4929af4bc9b0d58ce1bbb3c65b RX(p1\u2082\u2081) 4c4d829b60c0405e801428f3c8fbcbe0--f98a4a4929af4bc9b0d58ce1bbb3c65b 869a821dbf2844b98fe28d6c68f9bbda X f98a4a4929af4bc9b0d58ce1bbb3c65b--869a821dbf2844b98fe28d6c68f9bbda 869a821dbf2844b98fe28d6c68f9bbda--65a474e2305d4373b470c49b8f7c7eb1 55708b826f3b4fe9a1494a6f7c454aeb 869a821dbf2844b98fe28d6c68f9bbda--55708b826f3b4fe9a1494a6f7c454aeb 53db89e52a46494d8b293a7e0da044b6 RX(p2\u2081) 55708b826f3b4fe9a1494a6f7c454aeb--53db89e52a46494d8b293a7e0da044b6 c56550e7d2ee4f879017de278b77c00d RY(p2\u2085) 53db89e52a46494d8b293a7e0da044b6--c56550e7d2ee4f879017de278b77c00d 9458dddf06714239b48220802de25168 RX(p2\u2089) c56550e7d2ee4f879017de278b77c00d--9458dddf06714239b48220802de25168 c6d8780d8ce841e7b09b05a0eaf3606f X 9458dddf06714239b48220802de25168--c6d8780d8ce841e7b09b05a0eaf3606f c6d8780d8ce841e7b09b05a0eaf3606f--1779edf2c35746fba7b040ef17bd3495 969fb38996c74c90b4af45507cf679b2 c6d8780d8ce841e7b09b05a0eaf3606f--969fb38996c74c90b4af45507cf679b2 63314a45c96e499a8563cee9760f3275 RX(p2\u2081\u2083) 969fb38996c74c90b4af45507cf679b2--63314a45c96e499a8563cee9760f3275 f2938f6cedaa4c5c8371a939e60c89b4 RY(p2\u2081\u2087) 63314a45c96e499a8563cee9760f3275--f2938f6cedaa4c5c8371a939e60c89b4 37bf10bdc1c04c088988d074e8c898fa RX(p2\u2082\u2081) f2938f6cedaa4c5c8371a939e60c89b4--37bf10bdc1c04c088988d074e8c898fa a91f25f00a054b038ece9ab05d6986bb X 37bf10bdc1c04c088988d074e8c898fa--a91f25f00a054b038ece9ab05d6986bb a91f25f00a054b038ece9ab05d6986bb--e560f39474d342959012cab6b47d2ec2 4396bd87d1ab428fa61d199331d10700 a91f25f00a054b038ece9ab05d6986bb--4396bd87d1ab428fa61d199331d10700 4396bd87d1ab428fa61d199331d10700--38f2162848c4457a9ac7a69c87fb1f00 ebf5fba8d42649af8b78b8cbb8070b8f 438cbf4738b649efb97fc0066f2dcaef RX(p1\u2082) 6fd29caeae3241658e224236b3847018--438cbf4738b649efb97fc0066f2dcaef f64d5108975246798b602468f2dcb5ae 3 191a4b0c360346ed86f00f91ab23358b RY(p1\u2086) 438cbf4738b649efb97fc0066f2dcaef--191a4b0c360346ed86f00f91ab23358b 34f9a1022afd4ec5a9c5be0c828b1b5b RX(p1\u2081\u2080) 191a4b0c360346ed86f00f91ab23358b--34f9a1022afd4ec5a9c5be0c828b1b5b 3f41412786bd47dc9b6a5a9f818ef94d 34f9a1022afd4ec5a9c5be0c828b1b5b--3f41412786bd47dc9b6a5a9f818ef94d a42475b684e042e396d85f16da58669f X 3f41412786bd47dc9b6a5a9f818ef94d--a42475b684e042e396d85f16da58669f a42475b684e042e396d85f16da58669f--f3cb4c26f674428f935d73d3a0586429 397031953b644c92b6808f7df38f93fb RX(p1\u2081\u2084) a42475b684e042e396d85f16da58669f--397031953b644c92b6808f7df38f93fb 99b138e4d36a48ee8f67e160359afa32 RY(p1\u2081\u2088) 397031953b644c92b6808f7df38f93fb--99b138e4d36a48ee8f67e160359afa32 5be4bb4d281f4cfb973bb921350e7e6a RX(p1\u2082\u2082) 99b138e4d36a48ee8f67e160359afa32--5be4bb4d281f4cfb973bb921350e7e6a 68ad187919074ddf81267ffb34583bb9 5be4bb4d281f4cfb973bb921350e7e6a--68ad187919074ddf81267ffb34583bb9 e076edb829984e4987c42ab1129eb609 X 68ad187919074ddf81267ffb34583bb9--e076edb829984e4987c42ab1129eb609 e076edb829984e4987c42ab1129eb609--55708b826f3b4fe9a1494a6f7c454aeb baa4f139269a43b6a4372dc2805bab11 RX(p2\u2082) e076edb829984e4987c42ab1129eb609--baa4f139269a43b6a4372dc2805bab11 1035fad2ef2849e8a3e8cc32302da81d RY(p2\u2086) baa4f139269a43b6a4372dc2805bab11--1035fad2ef2849e8a3e8cc32302da81d 319cde2fe7334e7fae541051d25d3eef RX(p2\u2081\u2080) 1035fad2ef2849e8a3e8cc32302da81d--319cde2fe7334e7fae541051d25d3eef 3afbfef7ae7a42288994b105dc0d787a 319cde2fe7334e7fae541051d25d3eef--3afbfef7ae7a42288994b105dc0d787a df22fa899c2a4c0d85f61b458f51fac3 X 3afbfef7ae7a42288994b105dc0d787a--df22fa899c2a4c0d85f61b458f51fac3 df22fa899c2a4c0d85f61b458f51fac3--969fb38996c74c90b4af45507cf679b2 e8f78b96260f4d3dad75e20e26760876 RX(p2\u2081\u2084) df22fa899c2a4c0d85f61b458f51fac3--e8f78b96260f4d3dad75e20e26760876 49f62c6d52a249e49e2591d06e9cfa06 RY(p2\u2081\u2088) e8f78b96260f4d3dad75e20e26760876--49f62c6d52a249e49e2591d06e9cfa06 973635210bb5483593bf79ad0696296c RX(p2\u2082\u2082) 49f62c6d52a249e49e2591d06e9cfa06--973635210bb5483593bf79ad0696296c 29cfcb7b9a4e4713ab86fc97a7c4c155 973635210bb5483593bf79ad0696296c--29cfcb7b9a4e4713ab86fc97a7c4c155 820a14b6b98e4b88965888cb1ff3d803 X 29cfcb7b9a4e4713ab86fc97a7c4c155--820a14b6b98e4b88965888cb1ff3d803 820a14b6b98e4b88965888cb1ff3d803--4396bd87d1ab428fa61d199331d10700 820a14b6b98e4b88965888cb1ff3d803--ebf5fba8d42649af8b78b8cbb8070b8f f1ec94e562d94b659b48434629eca77d 7537e3d4c4e94637847927ea5903fb04 RX(p1\u2083) f64d5108975246798b602468f2dcb5ae--7537e3d4c4e94637847927ea5903fb04 8795896473fd43aea4d9a8f4cc7efc79 RY(p1\u2087) 7537e3d4c4e94637847927ea5903fb04--8795896473fd43aea4d9a8f4cc7efc79 9bc4b00ee99b4c82ae871d7c30b73253 RX(p1\u2081\u2081) 8795896473fd43aea4d9a8f4cc7efc79--9bc4b00ee99b4c82ae871d7c30b73253 a492c1e4d4cf4da89a7fea543c592d87 X 9bc4b00ee99b4c82ae871d7c30b73253--a492c1e4d4cf4da89a7fea543c592d87 a492c1e4d4cf4da89a7fea543c592d87--3f41412786bd47dc9b6a5a9f818ef94d 333ca9f53e644048a8589318c26c4d30 a492c1e4d4cf4da89a7fea543c592d87--333ca9f53e644048a8589318c26c4d30 5e5a9f6f5782446aa555353ef0a12535 RX(p1\u2081\u2085) 333ca9f53e644048a8589318c26c4d30--5e5a9f6f5782446aa555353ef0a12535 0b939f42a225456991d9386b16946312 RY(p1\u2081\u2089) 5e5a9f6f5782446aa555353ef0a12535--0b939f42a225456991d9386b16946312 670e8fb58cdb4e1faa115c9a03c7426a RX(p1\u2082\u2083) 0b939f42a225456991d9386b16946312--670e8fb58cdb4e1faa115c9a03c7426a a7a4832b73ad4f64933669dfe3ed5d42 X 670e8fb58cdb4e1faa115c9a03c7426a--a7a4832b73ad4f64933669dfe3ed5d42 a7a4832b73ad4f64933669dfe3ed5d42--68ad187919074ddf81267ffb34583bb9 ea023757cc8547508c300296db36d0e1 a7a4832b73ad4f64933669dfe3ed5d42--ea023757cc8547508c300296db36d0e1 34bb5d4c42914795bcb8daba39dbca07 RX(p2\u2083) ea023757cc8547508c300296db36d0e1--34bb5d4c42914795bcb8daba39dbca07 2e17cd9faacc49cb9444b97f0afc2120 RY(p2\u2087) 34bb5d4c42914795bcb8daba39dbca07--2e17cd9faacc49cb9444b97f0afc2120 bda7da9ecbc34c54874a28c33a7631ad RX(p2\u2081\u2081) 2e17cd9faacc49cb9444b97f0afc2120--bda7da9ecbc34c54874a28c33a7631ad 4718411f3ac542478be242adb0301af6 X bda7da9ecbc34c54874a28c33a7631ad--4718411f3ac542478be242adb0301af6 4718411f3ac542478be242adb0301af6--3afbfef7ae7a42288994b105dc0d787a f5892e56df2046c68670228ec152d49f 4718411f3ac542478be242adb0301af6--f5892e56df2046c68670228ec152d49f 2689571f35be4e99bcaf556a52977d54 RX(p2\u2081\u2085) f5892e56df2046c68670228ec152d49f--2689571f35be4e99bcaf556a52977d54 3b9693985df24a60a238f602638a1580 RY(p2\u2081\u2089) 2689571f35be4e99bcaf556a52977d54--3b9693985df24a60a238f602638a1580 9e0969a514cc44a6941765ea212872ab RX(p2\u2082\u2083) 3b9693985df24a60a238f602638a1580--9e0969a514cc44a6941765ea212872ab 49f8e416aba3499589573b2130634290 X 9e0969a514cc44a6941765ea212872ab--49f8e416aba3499589573b2130634290 49f8e416aba3499589573b2130634290--29cfcb7b9a4e4713ab86fc97a7c4c155 560ecd2dcefb437b939a52d8ee2c37ff 49f8e416aba3499589573b2130634290--560ecd2dcefb437b939a52d8ee2c37ff 560ecd2dcefb437b939a52d8ee2c37ff--f1ec94e562d94b659b48434629eca77d </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.4060])), ('theta_0', tensor([0.7295])), ('theta_1', tensor([0.4842])), ('theta_10', tensor([0.2934])), ('theta_11', tensor([0.9087])), ('theta_12', tensor([0.5591])), ('theta_13', tensor([0.2918])), ('theta_14', tensor([0.6196])), ('theta_15', tensor([0.0873])), ('theta_16', tensor([0.7099])), ('theta_17', tensor([0.5362])), ('theta_18', tensor([0.3060])), ('theta_19', tensor([0.0122])), ('theta_2', tensor([0.4173])), ('theta_20', tensor([0.5521])), ('theta_21', tensor([0.0399])), ('theta_22', tensor([0.4448])), ('theta_23', tensor([0.8476])), ('theta_3', tensor([0.6639])), ('theta_4', tensor([0.6974])), ('theta_5', tensor([0.1438])), ('theta_6', tensor([0.6251])), ('theta_7', tensor([0.3880])), ('theta_8', tensor([0.2627])), ('theta_9', tensor([0.4693]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.4050])), ('theta_0', tensor([0.7285])), ('theta_1', tensor([0.4832])), ('theta_10', tensor([0.2944])), ('theta_11', tensor([0.9097])), ('theta_12', tensor([0.5601])), ('theta_13', tensor([0.2908])), ('theta_14', tensor([0.6186])), ('theta_15', tensor([0.0883])), ('theta_16', tensor([0.7109])), ('theta_17', tensor([0.5372])), ('theta_18', tensor([0.3070])), ('theta_19', tensor([0.0112])), ('theta_2', tensor([0.4183])), ('theta_20', tensor([0.5531])), ('theta_21', tensor([0.0389])), ('theta_22', tensor([0.4438])), ('theta_23', tensor([0.8486])), ('theta_3', tensor([0.6649])), ('theta_4', tensor([0.6984])), ('theta_5', tensor([0.1448])), ('theta_6', tensor([0.6261])), ('theta_7', tensor([0.3870])), ('theta_8', tensor([0.2617])), ('theta_9', tensor([0.4683]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9842+0.0000j,  0.0000-0.1246j,  0.0000-0.1246j, -0.0158+0.0000j],\n        [ 0.7807+0.0000j,  0.0000-0.4137j,  0.0000-0.4137j, -0.2193+0.0000j],\n        [ 0.8637+0.0000j,  0.0000-0.3431j,  0.0000-0.3431j, -0.1363+0.0000j]])\nxs = [Counter({'00': 99, '01': 1}), Counter({'00': 63, '10': 19, '01': 15, '11': 3}), Counter({'00': 73, '01': 16, '10': 9, '11': 2})]\nex = tensor([[0.9684],\n        [0.5615],\n        [0.7273]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9684, 0.9684],\n        [0.5615, 0.5615],\n        [0.7273, 0.7273]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2024-02-01T18:46:28.934766 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register, PI\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*PI, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2024-02-01T18:46:29.300143 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'00': 55, '01': 45})]\nSample in little endian = [Counter({'00': 56, '10': 44})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'00': 55, '10': 45})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample, PI\n\n# RX(PI/4) on qubit 1\nn_qubits = 2\nop = RX(1, PI/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 79, '01': 21})]\nOn Braket = [Counter({'00': 84, '01': 16})]\nOn Pulser = [Counter({'00': 82, '01': 18})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [ 0.65634205+0.j -0.66770083+0.j -0.24624557+0.j  0.25050714+0.j]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_ccd90cedff37425a8adc40e2f75f20ef Circuit block cluster_7da7592c5bd245e58e0ec45efdeb28c7 Prep block 9fa97f011c1d4f5aa21aa200504751b4 0 7144b62fb9b9449c9487a5119c356483 9fa97f011c1d4f5aa21aa200504751b4--7144b62fb9b9449c9487a5119c356483 3d94cc2873154f368711b867d5ac3956 1 c218c9ba3dbd4c6d9883ecdb034db1e9 RX(theta\u2080) 7144b62fb9b9449c9487a5119c356483--c218c9ba3dbd4c6d9883ecdb034db1e9 4878e4ef1b9242d7886fca417ec189f8 RY(theta\u2084) c218c9ba3dbd4c6d9883ecdb034db1e9--4878e4ef1b9242d7886fca417ec189f8 537dbe74cd4b4fa2baba90643955d689 RX(theta\u2088) 4878e4ef1b9242d7886fca417ec189f8--537dbe74cd4b4fa2baba90643955d689 7ab76ffcd50942b886dddd24f752d8fe 537dbe74cd4b4fa2baba90643955d689--7ab76ffcd50942b886dddd24f752d8fe d301ecbf676e451e9cb0033e4e38ea11 7ab76ffcd50942b886dddd24f752d8fe--d301ecbf676e451e9cb0033e4e38ea11 81486de531a0497c8616a791c513cdcc RX(theta\u2081\u2082) d301ecbf676e451e9cb0033e4e38ea11--81486de531a0497c8616a791c513cdcc 1375542c964941f2a24059f8a1bbee4e RY(theta\u2081\u2086) 81486de531a0497c8616a791c513cdcc--1375542c964941f2a24059f8a1bbee4e c1189a8dae4f4d28a2168e0f88fa88eb RX(theta\u2082\u2080) 1375542c964941f2a24059f8a1bbee4e--c1189a8dae4f4d28a2168e0f88fa88eb 78a39259b5254794b2e685d7b921ac41 c1189a8dae4f4d28a2168e0f88fa88eb--78a39259b5254794b2e685d7b921ac41 22926004f5fa47a59d8badd11e7073b7 78a39259b5254794b2e685d7b921ac41--22926004f5fa47a59d8badd11e7073b7 e1a291d557ca4fdcb64abd78e1919640 22926004f5fa47a59d8badd11e7073b7--e1a291d557ca4fdcb64abd78e1919640 8ead09137df44204bb0ccec089f5db5f b26bf1cefd5444c494e308849d81abe8 3d94cc2873154f368711b867d5ac3956--b26bf1cefd5444c494e308849d81abe8 4ec60ec7f956424fb1077a152406d3d5 2 b4e67592771e404faf5202ab34669cef RX(theta\u2081) b26bf1cefd5444c494e308849d81abe8--b4e67592771e404faf5202ab34669cef 8d141b7739864181abf4eebcead545d6 RY(theta\u2085) b4e67592771e404faf5202ab34669cef--8d141b7739864181abf4eebcead545d6 7ed0502a39f14cb49c17f298fccf9f52 RX(theta\u2089) 8d141b7739864181abf4eebcead545d6--7ed0502a39f14cb49c17f298fccf9f52 c7674878131b475dad1b11fe0d7c3804 X 7ed0502a39f14cb49c17f298fccf9f52--c7674878131b475dad1b11fe0d7c3804 c7674878131b475dad1b11fe0d7c3804--7ab76ffcd50942b886dddd24f752d8fe f05cbbdb0bd2426fa0ac0f7b4e6a12c9 c7674878131b475dad1b11fe0d7c3804--f05cbbdb0bd2426fa0ac0f7b4e6a12c9 1e8e0e81921f4bac97dce730405d1c28 RX(theta\u2081\u2083) f05cbbdb0bd2426fa0ac0f7b4e6a12c9--1e8e0e81921f4bac97dce730405d1c28 692a893bb36e44c1a3e34eab5dc9f27d RY(theta\u2081\u2087) 1e8e0e81921f4bac97dce730405d1c28--692a893bb36e44c1a3e34eab5dc9f27d ea7b3e6b45444f7c91173d6b6c7fc426 RX(theta\u2082\u2081) 692a893bb36e44c1a3e34eab5dc9f27d--ea7b3e6b45444f7c91173d6b6c7fc426 79cec9126b034468aaa0d9b38d9c0542 X ea7b3e6b45444f7c91173d6b6c7fc426--79cec9126b034468aaa0d9b38d9c0542 79cec9126b034468aaa0d9b38d9c0542--78a39259b5254794b2e685d7b921ac41 cd3e3c9ddf574cb99ccf36b0c8cda8e9 79cec9126b034468aaa0d9b38d9c0542--cd3e3c9ddf574cb99ccf36b0c8cda8e9 cd3e3c9ddf574cb99ccf36b0c8cda8e9--8ead09137df44204bb0ccec089f5db5f 979e58eb3e3a4611a023b1479a6b90d0 d344f8157a8c4e3b811085ffc18595f1 4ec60ec7f956424fb1077a152406d3d5--d344f8157a8c4e3b811085ffc18595f1 e15eeb2a902243399069b5b5964d72f4 3 77a2a81f71f440278824cc227d1c1d65 RX(theta\u2082) d344f8157a8c4e3b811085ffc18595f1--77a2a81f71f440278824cc227d1c1d65 99d4a953e3ae4414b012e231432a4a86 RY(theta\u2086) 77a2a81f71f440278824cc227d1c1d65--99d4a953e3ae4414b012e231432a4a86 24384a377c014928a04bd6663001cece RX(theta\u2081\u2080) 99d4a953e3ae4414b012e231432a4a86--24384a377c014928a04bd6663001cece a9d75322a49f433aaa95c37aaeff8b61 24384a377c014928a04bd6663001cece--a9d75322a49f433aaa95c37aaeff8b61 3b18c4d2a0b645deac6ca34f9a051838 X a9d75322a49f433aaa95c37aaeff8b61--3b18c4d2a0b645deac6ca34f9a051838 3b18c4d2a0b645deac6ca34f9a051838--f05cbbdb0bd2426fa0ac0f7b4e6a12c9 caff9a01331a40c99ac678baf4d260fc RX(theta\u2081\u2084) 3b18c4d2a0b645deac6ca34f9a051838--caff9a01331a40c99ac678baf4d260fc 1bad4b117036489193bc5a6a8e8ced81 RY(theta\u2081\u2088) caff9a01331a40c99ac678baf4d260fc--1bad4b117036489193bc5a6a8e8ced81 7f1d47e3e4d34fb7ab062041d8d2034a RX(theta\u2082\u2082) 1bad4b117036489193bc5a6a8e8ced81--7f1d47e3e4d34fb7ab062041d8d2034a a5446cf095a74bec9b19a929c52c049e 7f1d47e3e4d34fb7ab062041d8d2034a--a5446cf095a74bec9b19a929c52c049e 850a200a12ff4add8ebfc392622ceba1 X a5446cf095a74bec9b19a929c52c049e--850a200a12ff4add8ebfc392622ceba1 850a200a12ff4add8ebfc392622ceba1--cd3e3c9ddf574cb99ccf36b0c8cda8e9 850a200a12ff4add8ebfc392622ceba1--979e58eb3e3a4611a023b1479a6b90d0 5d949eb37ab64a758225a66450ed0704 3f334fd32ddc4c10a69e1728dc77f0fb X e15eeb2a902243399069b5b5964d72f4--3f334fd32ddc4c10a69e1728dc77f0fb 8bdbdf4746744154ab897de757b53a78 RX(theta\u2083) 3f334fd32ddc4c10a69e1728dc77f0fb--8bdbdf4746744154ab897de757b53a78 c64504872d1d41d192a072fa505c1c22 RY(theta\u2087) 8bdbdf4746744154ab897de757b53a78--c64504872d1d41d192a072fa505c1c22 03fe3f97d90948c8ae0fa2926997fd02 RX(theta\u2081\u2081) c64504872d1d41d192a072fa505c1c22--03fe3f97d90948c8ae0fa2926997fd02 7d5cc2cf011d459aac4d61a4c1897267 X 03fe3f97d90948c8ae0fa2926997fd02--7d5cc2cf011d459aac4d61a4c1897267 7d5cc2cf011d459aac4d61a4c1897267--a9d75322a49f433aaa95c37aaeff8b61 f75dd560f7cb49ceb8eacab70db2a71e 7d5cc2cf011d459aac4d61a4c1897267--f75dd560f7cb49ceb8eacab70db2a71e b557849a245343d0a48ca5b8bb7d49bf RX(theta\u2081\u2085) f75dd560f7cb49ceb8eacab70db2a71e--b557849a245343d0a48ca5b8bb7d49bf cdfe1e17ca964850826121bf881390b4 RY(theta\u2081\u2089) b557849a245343d0a48ca5b8bb7d49bf--cdfe1e17ca964850826121bf881390b4 cb91a63466ad49a4b0d71ae26f6dc85d RX(theta\u2082\u2083) cdfe1e17ca964850826121bf881390b4--cb91a63466ad49a4b0d71ae26f6dc85d b307da20f5824c4691fb94c024d1ed51 X cb91a63466ad49a4b0d71ae26f6dc85d--b307da20f5824c4691fb94c024d1ed51 b307da20f5824c4691fb94c024d1ed51--a5446cf095a74bec9b19a929c52c049e 173797292ac04b59aca3e2cb5992a59a b307da20f5824c4691fb94c024d1ed51--173797292ac04b59aca3e2cb5992a59a 173797292ac04b59aca3e2cb5992a59a--5d949eb37ab64a758225a66450ed0704  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[-0.1413-0.0314j,  0.4271+0.0558j,  0.1211-0.0650j, -0.2887-0.3458j,\n          0.1520-0.5908j, -0.2196-0.1824j,  0.0992-0.2272j,  0.2243+0.0795j],\n        [ 0.3506+0.1673j,  0.0850-0.2147j, -0.0631+0.6737j,  0.0306+0.2123j,\n          0.3492+0.2833j,  0.0531-0.1610j,  0.1590-0.0134j,  0.1670+0.0875j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}