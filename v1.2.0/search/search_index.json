{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n\n# Global analog RX block.\nblock = AnalogRX(pi)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 39, '01': 36, '10': 25})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    self.inputs = [p for p in circuit.unique_parameters if not p.trainable and not p.is_number]\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-12-11T15:40:56.052144 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: dict[str, Tensor] = {},\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, Tensor] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>Module</code></p> <p>A class to abstract the operations done by the autodiff engine.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__()\n\n    self.backend = backend\n    self.diff_mode = diff_mode\n    self.psr_args = psr_args\n    # TODO: Add differentiable overlap calculation\n    self._overlap: Callable = None  # type: ignore [assignment]\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of a given observable.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A backend native observable to compute the expectation value from.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>A dict of values for symbolic substitution.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>An initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>A shot-based measurement protocol.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the state.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of expectation values.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: dict[str, Tensor] = {},\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute the expectation value of a given observable.\n\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        observable: A backend native observable to compute the expectation value from.\n        param_values: A dict of values for symbolic substitution.\n        state: An initial state.\n        measurement: A shot-based measurement protocol.\n        endianness: Endianness of the state.\n\n    Returns:\n        A tensor of expectation values.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Run on the underlying backend.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run on the underlying backend.\"\"\"\n    return self.backend.run(\n        circuit=circuit, param_values=param_values, state=state, endianness=endianness\n    )\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.sample","title":"<code>sample(circuit, param_values, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Sample bitstring from the registered circuit.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>The values of the parameters after embedding</p> <p> TYPE: <code>dict[str, Tensor]</code> </p> <code>n_shots</code> <p>The number of shots. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>A mitigation protocol to apply to noisy samples.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>An iterable with all the sampled bitstrings</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor],\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bitstring from the registered circuit.\n\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        param_values: The values of the parameters after embedding\n        n_shots: The number of shots. Defaults to 1.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: A mitigation protocol to apply to noisy samples.\n        endianness: Endianness of the resulting bitstrings.\n\n    Returns:\n        An iterable with all the sampled bitstrings\n    \"\"\"\n    with torch.no_grad():\n        return self.backend.sample(\n            circuit=circuit,\n            param_values=param_values,\n            n_shots=n_shots,\n            state=state,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        )\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation","title":"<code>DifferentiableExpectation</code>  <code>dataclass</code>","text":"<p>A handler for differentiating expectation estimation using various engines.</p>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation.construct_rules","title":"<code>construct_rules(circuit, observable, psr_fn, **psr_args)</code>  <code>staticmethod</code>","text":"<p>Create a mapping between parameters and PSR functions.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>@staticmethod\ndef construct_rules(\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock],\n    psr_fn: Callable,\n    **psr_args: int | float | None,\n) -&gt; dict[str, Callable]:\n    \"\"\"Create a mapping between parameters and PSR functions.\"\"\"\n\n    uuid_to_eigs = uuid_to_eigen(circuit.block)\n    # We currently rely on implicit ordering to match the PSR to the parameter,\n    # because we want to cache PSRs.\n\n    param_to_psr = OrderedDict()\n    for param_id, eigenvalues in uuid_to_eigs.items():\n        if eigenvalues is None:\n            raise ValueError(\n                f\"Eigenvalues are not defined for param_id {param_id}\\n\"\n                # f\"of type {type(block)}.\\n\"\n                \"PSR cannot be defined in that case.\"\n            )\n\n        param_to_psr[param_id] = psr_fn(eigenvalues, **psr_args)\n    for obs in observable:\n        for param_id, _ in uuid_to_eigen(obs).items():\n            # We need the embedded fixed params of the observable in the param_values dict\n            # to be able to call expectation. Since torch backward requires\n            # a list of param_ids and values of equal length, we need to pass them to PSR too.\n            # Since they are constants their gradients are 0.\n            param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n    return param_to_psr\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.PSRExpectation","title":"<code>PSRExpectation</code>","text":"<p>             Bases: <code>Function</code></p> <p>Overloads the PyTorch AD system to perform parameter shift rule on quantum circuits.</p>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Currently, the only implemented differentiation engine is PyTorch but it is easy to add support to another one like Jax.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are implemented by extending the PyTorch autograd engine using custom <code>Function</code> objects. The implementation is based on this PyTorch guide.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 0f985066561f43289b27b20d1f347610 0 89b5dab7f33f4ec59b7a7afd453e7747 X 0f985066561f43289b27b20d1f347610--89b5dab7f33f4ec59b7a7afd453e7747 5fca571199b34ea5b07aa6c0e593ba19 1 eb8746f4848246b08e5ed49562cd4c69 89b5dab7f33f4ec59b7a7afd453e7747--eb8746f4848246b08e5ed49562cd4c69 0ea649cf208a40baac1da4a3ca06351c aea06944a92a405496a9610fcd999b4f Y 5fca571199b34ea5b07aa6c0e593ba19--aea06944a92a405496a9610fcd999b4f aea06944a92a405496a9610fcd999b4f--0ea649cf208a40baac1da4a3ca06351c <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 b791f011a76e4085af4dbcdbd0c65458 0 9318355879614cf0a3ab36477cc51b43 X b791f011a76e4085af4dbcdbd0c65458--9318355879614cf0a3ab36477cc51b43 c236454f4878467b83130f7eda3ae060 Y 9318355879614cf0a3ab36477cc51b43--c236454f4878467b83130f7eda3ae060 c6d7e5cd3d8049b38f11aa60bdbd3a56 c236454f4878467b83130f7eda3ae060--c6d7e5cd3d8049b38f11aa60bdbd3a56 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 44c3696076714c9da04bb62fb455e777 0 034e3bae76734a9e997a0e2f38660169 X 44c3696076714c9da04bb62fb455e777--034e3bae76734a9e997a0e2f38660169 f6be07c094c541b89629e48b7b0cc2d1 1 01c984f9163e46dfab9e3c6e14f5e54a 034e3bae76734a9e997a0e2f38660169--01c984f9163e46dfab9e3c6e14f5e54a f5ba07e411b045bdba1ad8bfabec3243 01c984f9163e46dfab9e3c6e14f5e54a--f5ba07e411b045bdba1ad8bfabec3243 c5c508f74b4646daa00d2689353b58b1 f57cf67ba3b045049d157f46b8279dce f6be07c094c541b89629e48b7b0cc2d1--f57cf67ba3b045049d157f46b8279dce 64c4fb6ea1e04c05a4ef937fefbf6057 Y f57cf67ba3b045049d157f46b8279dce--64c4fb6ea1e04c05a4ef937fefbf6057 64c4fb6ea1e04c05a4ef937fefbf6057--c5c508f74b4646daa00d2689353b58b1 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_1d7af96499ae4f76abcb66e10d551bd0 ce519cebe8114e44951096d072e6ed63 0 9955f73a9fbb408eb9996f4e8649e61e ce519cebe8114e44951096d072e6ed63--9955f73a9fbb408eb9996f4e8649e61e e250108b1e9b4c32bf0afc437359a424 1 1bdd05ad086e463ebd87ff7f38803716 9955f73a9fbb408eb9996f4e8649e61e--1bdd05ad086e463ebd87ff7f38803716 b27ffe92ddae4385a35ad960cbb5568f 706956d452ee47768866077ab6017084 AddBlock e250108b1e9b4c32bf0afc437359a424--706956d452ee47768866077ab6017084 b419bbebe1d2434681c338093c88d211 2 706956d452ee47768866077ab6017084--b27ffe92ddae4385a35ad960cbb5568f 7ba57305f95c4ddebb96e5a68b981bfb 99fc3257d35d464ca882930263847d0e b419bbebe1d2434681c338093c88d211--99fc3257d35d464ca882930263847d0e 99fc3257d35d464ca882930263847d0e--7ba57305f95c4ddebb96e5a68b981bfb <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_5461e5fe55074e119b42d14a07183d38 cluster_f937245e35aa42938b55d942cdd7df4e rx 145110803dad4b759bb46ec3d0821582 0 a75a1719a14241cab0004e4ae29eb834 X 145110803dad4b759bb46ec3d0821582--a75a1719a14241cab0004e4ae29eb834 78746e663e5f449f9411cdf90f678f93 1 767e84d7ba5d4e21b578ea8854ae285f a75a1719a14241cab0004e4ae29eb834--767e84d7ba5d4e21b578ea8854ae285f 523d148d92f849c3b5503a1bacf64709 767e84d7ba5d4e21b578ea8854ae285f--523d148d92f849c3b5503a1bacf64709 1454c4b003f94c2f9176a275b4fc9c36 523d148d92f849c3b5503a1bacf64709--1454c4b003f94c2f9176a275b4fc9c36 fdc3ba62621143b09d63abcd2d611d6c 7a21fd6ca96440b8a22b5d0156994a2f Y 78746e663e5f449f9411cdf90f678f93--7a21fd6ca96440b8a22b5d0156994a2f aa2dbf00a92246919bc0f8667a066833 2 6286ba4497cd45afacb1e563b60cd330 7a21fd6ca96440b8a22b5d0156994a2f--6286ba4497cd45afacb1e563b60cd330 3b5d359f09a9480cbf8b18a787e2dbdf HamEvo 6286ba4497cd45afacb1e563b60cd330--3b5d359f09a9480cbf8b18a787e2dbdf 3b5d359f09a9480cbf8b18a787e2dbdf--fdc3ba62621143b09d63abcd2d611d6c 44df5274898e474280d762b6ec7b4ece 2f8dbdff62d54ff7a228ccccfc750426 RX(x) aa2dbf00a92246919bc0f8667a066833--2f8dbdff62d54ff7a228ccccfc750426 25239e06293b459d928586a2366acae7 3 b186236aa8e147bb8380da1e387f357e 2f8dbdff62d54ff7a228ccccfc750426--b186236aa8e147bb8380da1e387f357e 7a8e743a51cb4690950e55b20dbb2392 t = 10 b186236aa8e147bb8380da1e387f357e--7a8e743a51cb4690950e55b20dbb2392 7a8e743a51cb4690950e55b20dbb2392--44df5274898e474280d762b6ec7b4ece 8f722010c5c74c2f955bc333848dd97f 009ba00ff207448ba20728df73fb1df0 RX(0.5) 25239e06293b459d928586a2366acae7--009ba00ff207448ba20728df73fb1df0 6b828b4f50d94bee99148ff67a503c7d X 009ba00ff207448ba20728df73fb1df0--6b828b4f50d94bee99148ff67a503c7d 6b828b4f50d94bee99148ff67a503c7d--b186236aa8e147bb8380da1e387f357e 6376a265226747ddb2cf8b6e2494498b 6b828b4f50d94bee99148ff67a503c7d--6376a265226747ddb2cf8b6e2494498b 6376a265226747ddb2cf8b6e2494498b--8f722010c5c74c2f955bc333848dd97f <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_5efad37a8f114dafaf3b6ca689fd1759 HEA cluster_1c3fb2a7e77c47c28a4b812c4c7eeb8f Tower Fourier FM bcc3b077a49f4aabaeadb9141788bc80 0 16b87521288343cb8e2105f26e13e056 RX(1.0*phi) bcc3b077a49f4aabaeadb9141788bc80--16b87521288343cb8e2105f26e13e056 96e2dce3ed7b463386e5a08d6d1df92e 1 c2aa6aebb2b14dfab7cc92420335d392 RX(theta\u2080) 16b87521288343cb8e2105f26e13e056--c2aa6aebb2b14dfab7cc92420335d392 2c7b3521bcf54faaad36666cf0bea26e RY(theta\u2084) c2aa6aebb2b14dfab7cc92420335d392--2c7b3521bcf54faaad36666cf0bea26e 54ae1da71fbd43da8ac55c4ca5cba58c RX(theta\u2088) 2c7b3521bcf54faaad36666cf0bea26e--54ae1da71fbd43da8ac55c4ca5cba58c cab912a0c9d345bcba6935fea338c090 54ae1da71fbd43da8ac55c4ca5cba58c--cab912a0c9d345bcba6935fea338c090 f0a062f46eec4fdf93e351d357ba1f65 cab912a0c9d345bcba6935fea338c090--f0a062f46eec4fdf93e351d357ba1f65 e08544ac462749f497d810bb7fe4fc75 RX(theta\u2081\u2082) f0a062f46eec4fdf93e351d357ba1f65--e08544ac462749f497d810bb7fe4fc75 52286ab27aa34d09afce773c595bd01a RY(theta\u2081\u2086) e08544ac462749f497d810bb7fe4fc75--52286ab27aa34d09afce773c595bd01a 66b4bc78bb194898959ab461f73e68f7 RX(theta\u2082\u2080) 52286ab27aa34d09afce773c595bd01a--66b4bc78bb194898959ab461f73e68f7 0461816a0beb472f9ece4023776bc773 66b4bc78bb194898959ab461f73e68f7--0461816a0beb472f9ece4023776bc773 9158108739ab41fa96db888a2ba420c8 0461816a0beb472f9ece4023776bc773--9158108739ab41fa96db888a2ba420c8 b497a93817324c6aa7436f6e2ed1a18f 9158108739ab41fa96db888a2ba420c8--b497a93817324c6aa7436f6e2ed1a18f 2c09a74c611743158c08fe324015283d d609a7a3ba834e12afd8efdfa061692c RX(2.0*phi) 96e2dce3ed7b463386e5a08d6d1df92e--d609a7a3ba834e12afd8efdfa061692c 15947be51ee742f5a9261ebb5d8f3504 2 ff2ede35fe9b4945812aff57116598ba RX(theta\u2081) d609a7a3ba834e12afd8efdfa061692c--ff2ede35fe9b4945812aff57116598ba 689595c985b9418e9cb9143637a41b72 RY(theta\u2085) ff2ede35fe9b4945812aff57116598ba--689595c985b9418e9cb9143637a41b72 277835ca4fba48139d250b3a861f74bf RX(theta\u2089) 689595c985b9418e9cb9143637a41b72--277835ca4fba48139d250b3a861f74bf db52a66a024d475aab97b303880e0165 X 277835ca4fba48139d250b3a861f74bf--db52a66a024d475aab97b303880e0165 db52a66a024d475aab97b303880e0165--cab912a0c9d345bcba6935fea338c090 d5a4a1e6274541ada3f086fbb3e62395 db52a66a024d475aab97b303880e0165--d5a4a1e6274541ada3f086fbb3e62395 d0b5da6ea2c94d18bc78281b6fc0b504 RX(theta\u2081\u2083) d5a4a1e6274541ada3f086fbb3e62395--d0b5da6ea2c94d18bc78281b6fc0b504 dee6c6b0f92c4a579c7633e9dd401d5e RY(theta\u2081\u2087) d0b5da6ea2c94d18bc78281b6fc0b504--dee6c6b0f92c4a579c7633e9dd401d5e 29face3172d1474c82ee2178c77cc06d RX(theta\u2082\u2081) dee6c6b0f92c4a579c7633e9dd401d5e--29face3172d1474c82ee2178c77cc06d 8e0cc42d58164a799be834280cc91d5f X 29face3172d1474c82ee2178c77cc06d--8e0cc42d58164a799be834280cc91d5f 8e0cc42d58164a799be834280cc91d5f--0461816a0beb472f9ece4023776bc773 89576f3cc4c04d53ae02a03dc2906a89 8e0cc42d58164a799be834280cc91d5f--89576f3cc4c04d53ae02a03dc2906a89 89576f3cc4c04d53ae02a03dc2906a89--2c09a74c611743158c08fe324015283d f3a7eb5ceca04d9cb32042cb2b8a2f60 de57af4d1a604deeac26c5877403e97c RX(3.0*phi) 15947be51ee742f5a9261ebb5d8f3504--de57af4d1a604deeac26c5877403e97c 03a47ac20eb94fefb47a0bf1b2c2d151 3 82713002d6884bf0a07d1422bd5b5045 RX(theta\u2082) de57af4d1a604deeac26c5877403e97c--82713002d6884bf0a07d1422bd5b5045 9a91a75b47a343f48b2a5d82e8ec91a3 RY(theta\u2086) 82713002d6884bf0a07d1422bd5b5045--9a91a75b47a343f48b2a5d82e8ec91a3 67b610168e5643df9e1436e2ced5acc4 RX(theta\u2081\u2080) 9a91a75b47a343f48b2a5d82e8ec91a3--67b610168e5643df9e1436e2ced5acc4 37be3d2797f144d3bf06266368757be4 67b610168e5643df9e1436e2ced5acc4--37be3d2797f144d3bf06266368757be4 3c433290fd0544d9a23077d02dd2c4bf X 37be3d2797f144d3bf06266368757be4--3c433290fd0544d9a23077d02dd2c4bf 3c433290fd0544d9a23077d02dd2c4bf--d5a4a1e6274541ada3f086fbb3e62395 928eabddc60d4b1ab664ee0383bfb0b2 RX(theta\u2081\u2084) 3c433290fd0544d9a23077d02dd2c4bf--928eabddc60d4b1ab664ee0383bfb0b2 0158d84df25d4a4f84b00fdb1cb15042 RY(theta\u2081\u2088) 928eabddc60d4b1ab664ee0383bfb0b2--0158d84df25d4a4f84b00fdb1cb15042 d22024e791784a8ba6176b4c6fa26bbf RX(theta\u2082\u2082) 0158d84df25d4a4f84b00fdb1cb15042--d22024e791784a8ba6176b4c6fa26bbf 6902b34c84c0433b9b7592961903f4d6 d22024e791784a8ba6176b4c6fa26bbf--6902b34c84c0433b9b7592961903f4d6 c92804c0552e4078bfc852ec63a3674e X 6902b34c84c0433b9b7592961903f4d6--c92804c0552e4078bfc852ec63a3674e c92804c0552e4078bfc852ec63a3674e--89576f3cc4c04d53ae02a03dc2906a89 c92804c0552e4078bfc852ec63a3674e--f3a7eb5ceca04d9cb32042cb2b8a2f60 2908ff6d577148789656662e77110cf3 38f9d445a3654439b1d0f2b7d329f5f9 RX(4.0*phi) 03a47ac20eb94fefb47a0bf1b2c2d151--38f9d445a3654439b1d0f2b7d329f5f9 abeb7bcdbe9f45b58c739adadff67c77 RX(theta\u2083) 38f9d445a3654439b1d0f2b7d329f5f9--abeb7bcdbe9f45b58c739adadff67c77 66ed7ea34ac44cba9d84a94b31e731df RY(theta\u2087) abeb7bcdbe9f45b58c739adadff67c77--66ed7ea34ac44cba9d84a94b31e731df 662cf91fe39048cb9efac6833baa5512 RX(theta\u2081\u2081) 66ed7ea34ac44cba9d84a94b31e731df--662cf91fe39048cb9efac6833baa5512 34885334693840ba800c97f01a8c7a15 X 662cf91fe39048cb9efac6833baa5512--34885334693840ba800c97f01a8c7a15 34885334693840ba800c97f01a8c7a15--37be3d2797f144d3bf06266368757be4 98a045e813a84828b5b6184cfaadbb51 34885334693840ba800c97f01a8c7a15--98a045e813a84828b5b6184cfaadbb51 e69f6c9d5e474796b9368b3aa05c5723 RX(theta\u2081\u2085) 98a045e813a84828b5b6184cfaadbb51--e69f6c9d5e474796b9368b3aa05c5723 a67e60edc2694321bcaf87ec61670de6 RY(theta\u2081\u2089) e69f6c9d5e474796b9368b3aa05c5723--a67e60edc2694321bcaf87ec61670de6 f018830e1d7c44858eeb59c88c5be8c8 RX(theta\u2082\u2083) a67e60edc2694321bcaf87ec61670de6--f018830e1d7c44858eeb59c88c5be8c8 2a4b2adb0789434aa3bfd2b606b3f14b X f018830e1d7c44858eeb59c88c5be8c8--2a4b2adb0789434aa3bfd2b606b3f14b 2a4b2adb0789434aa3bfd2b606b3f14b--6902b34c84c0433b9b7592961903f4d6 3cd76861b889410aa8528b2737e20c61 2a4b2adb0789434aa3bfd2b606b3f14b--3cd76861b889410aa8528b2737e20c61 3cd76861b889410aa8528b2737e20c61--2908ff6d577148789656662e77110cf3 <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_2d5ad19cf8784211ae5b27c613cf7b9f Obs. cluster_ff68cce0e2194640b884dbdd6169a4cc cluster_67f8ed83fa064be9b8c437e0032de920 HEA 771ecdcb1fb9476c9bec55d5bf5e2a12 0 94699c45168843a9bc5ce30aa56bf329 RX(theta\u2080) 771ecdcb1fb9476c9bec55d5bf5e2a12--94699c45168843a9bc5ce30aa56bf329 6b5f53f431c3452d81723ac15497b65a 1 6f7d168c863e40ec88f937ef2d1d5213 RY(theta\u2083) 94699c45168843a9bc5ce30aa56bf329--6f7d168c863e40ec88f937ef2d1d5213 3c97611b3e6a45158802e9e660bf6669 RX(theta\u2086) 6f7d168c863e40ec88f937ef2d1d5213--3c97611b3e6a45158802e9e660bf6669 9d413e57baf9422aa7a948a31e30250c 3c97611b3e6a45158802e9e660bf6669--9d413e57baf9422aa7a948a31e30250c 8d295d34c0a64f7cb21057cb7a64ae9a 9d413e57baf9422aa7a948a31e30250c--8d295d34c0a64f7cb21057cb7a64ae9a f9617ccae08c4ed8b082f40a0c1c47ea RX(theta\u2089) 8d295d34c0a64f7cb21057cb7a64ae9a--f9617ccae08c4ed8b082f40a0c1c47ea 8c0bd92a9e244a63a0eda4aa406f9026 RY(theta\u2081\u2082) f9617ccae08c4ed8b082f40a0c1c47ea--8c0bd92a9e244a63a0eda4aa406f9026 2b7e84532cad4983a2fba85abd72d0c0 RX(theta\u2081\u2085) 8c0bd92a9e244a63a0eda4aa406f9026--2b7e84532cad4983a2fba85abd72d0c0 6850064d019b47c6855c8bd9046615bc 2b7e84532cad4983a2fba85abd72d0c0--6850064d019b47c6855c8bd9046615bc 1181f8f285974adf822a0089068d05a4 6850064d019b47c6855c8bd9046615bc--1181f8f285974adf822a0089068d05a4 8227aec187eb4e90bec81e551b26fe54 1181f8f285974adf822a0089068d05a4--8227aec187eb4e90bec81e551b26fe54 aeb675fd874949fdb638c64677d15564 8227aec187eb4e90bec81e551b26fe54--aeb675fd874949fdb638c64677d15564 88d28d7f0e7d4f1abca04ccb42014b08 7be1df487f2644bd989239bf857539e1 RX(theta\u2081) 6b5f53f431c3452d81723ac15497b65a--7be1df487f2644bd989239bf857539e1 5b3a4b19cb0b4e939ab1f53fcd317c6f 2 d9dee2bd28914ea1be61e4bdb4255b71 RY(theta\u2084) 7be1df487f2644bd989239bf857539e1--d9dee2bd28914ea1be61e4bdb4255b71 44a027ee6eb8443f9948893302440cbd RX(theta\u2087) d9dee2bd28914ea1be61e4bdb4255b71--44a027ee6eb8443f9948893302440cbd ff2b31fdf2c0492aa9efccaeded4ece1 X 44a027ee6eb8443f9948893302440cbd--ff2b31fdf2c0492aa9efccaeded4ece1 ff2b31fdf2c0492aa9efccaeded4ece1--9d413e57baf9422aa7a948a31e30250c 40ffab57211340979583bad5807bfe2f ff2b31fdf2c0492aa9efccaeded4ece1--40ffab57211340979583bad5807bfe2f 169d243fd1014ad0bec2404d666703b3 RX(theta\u2081\u2080) 40ffab57211340979583bad5807bfe2f--169d243fd1014ad0bec2404d666703b3 34afdbc15c3d477c9504f2eacc788816 RY(theta\u2081\u2083) 169d243fd1014ad0bec2404d666703b3--34afdbc15c3d477c9504f2eacc788816 17bab37b87804fbdb6fe3e19e22dc061 RX(theta\u2081\u2086) 34afdbc15c3d477c9504f2eacc788816--17bab37b87804fbdb6fe3e19e22dc061 c1f07f24e4b34c15a8f30864c986b6fa X 17bab37b87804fbdb6fe3e19e22dc061--c1f07f24e4b34c15a8f30864c986b6fa c1f07f24e4b34c15a8f30864c986b6fa--6850064d019b47c6855c8bd9046615bc 86216aef7c5f4b4f8fe5eca3006f65a2 c1f07f24e4b34c15a8f30864c986b6fa--86216aef7c5f4b4f8fe5eca3006f65a2 b9d308f58535404fa5f5fa7da9ac771a AddBlock 86216aef7c5f4b4f8fe5eca3006f65a2--b9d308f58535404fa5f5fa7da9ac771a b9d308f58535404fa5f5fa7da9ac771a--88d28d7f0e7d4f1abca04ccb42014b08 31241182d7f045fe9f3eedf0991c8b47 27074f634103443eaa588ff30d18c1a1 RX(theta\u2082) 5b3a4b19cb0b4e939ab1f53fcd317c6f--27074f634103443eaa588ff30d18c1a1 35dde30c55fc4e028b2d14dc0c741f2e RY(theta\u2085) 27074f634103443eaa588ff30d18c1a1--35dde30c55fc4e028b2d14dc0c741f2e 008d4945f60f4045b54e3965d9734dd0 RX(theta\u2088) 35dde30c55fc4e028b2d14dc0c741f2e--008d4945f60f4045b54e3965d9734dd0 f6efe1d7334f4df6894c4a484160c31f 008d4945f60f4045b54e3965d9734dd0--f6efe1d7334f4df6894c4a484160c31f d7f82f7238ec42368e591a583ec58601 X f6efe1d7334f4df6894c4a484160c31f--d7f82f7238ec42368e591a583ec58601 d7f82f7238ec42368e591a583ec58601--40ffab57211340979583bad5807bfe2f 9dd57690cbd34c54be02f74ca852bd8f RX(theta\u2081\u2081) d7f82f7238ec42368e591a583ec58601--9dd57690cbd34c54be02f74ca852bd8f 5c75b48fc56a4153bff72e8fdba31136 RY(theta\u2081\u2084) 9dd57690cbd34c54be02f74ca852bd8f--5c75b48fc56a4153bff72e8fdba31136 ae4dc147b4f44265b46b359dfe8c28a4 RX(theta\u2081\u2087) 5c75b48fc56a4153bff72e8fdba31136--ae4dc147b4f44265b46b359dfe8c28a4 cfcf86e95fbd4f3f8cb90ee746093e2b ae4dc147b4f44265b46b359dfe8c28a4--cfcf86e95fbd4f3f8cb90ee746093e2b 940fdc57b12d43fe87f73478e6a5c89e X cfcf86e95fbd4f3f8cb90ee746093e2b--940fdc57b12d43fe87f73478e6a5c89e 940fdc57b12d43fe87f73478e6a5c89e--86216aef7c5f4b4f8fe5eca3006f65a2 b500889547384596b69628cc356dafdd 940fdc57b12d43fe87f73478e6a5c89e--b500889547384596b69628cc356dafdd b500889547384596b69628cc356dafdd--31241182d7f045fe9f3eedf0991c8b47 <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 99cb0f8cb0104ca295efd821022dad94 0 47e9e1e4f2ce4f89b4a0dff70503050e 99cb0f8cb0104ca295efd821022dad94--47e9e1e4f2ce4f89b4a0dff70503050e 10ec06d9888e4b1e8c02dcf83df5f98c 1 ed2702daccf94c3ba8c2fdafa0cb4e11 0446e8614060455297d0c3d7b5941f87 47e9e1e4f2ce4f89b4a0dff70503050e--0446e8614060455297d0c3d7b5941f87 4b909f7ada92472b9a19a884b9e73e44 ed2702daccf94c3ba8c2fdafa0cb4e11--4b909f7ada92472b9a19a884b9e73e44 59e6c6ff80d043a1bc53dcc977947168 5bd84cfa109c43649c8ca43c53cc28f8 4b909f7ada92472b9a19a884b9e73e44--5bd84cfa109c43649c8ca43c53cc28f8 094ddac59ab24078843f1d35024df5a2 59e6c6ff80d043a1bc53dcc977947168--094ddac59ab24078843f1d35024df5a2 8eab7729c3d243c1a655da4e53b0ab4c d7b3a133300e4df5a54ffdc856d587b3 10ec06d9888e4b1e8c02dcf83df5f98c--d7b3a133300e4df5a54ffdc856d587b3 95dd4ac2ff1f4520947532567e84a644 2 d7b3a133300e4df5a54ffdc856d587b3--ed2702daccf94c3ba8c2fdafa0cb4e11 122d3b1f13024c98bab4dabed4afd73f 0446e8614060455297d0c3d7b5941f87--122d3b1f13024c98bab4dabed4afd73f fc4b01845ac740519379ac77a84a1762 122d3b1f13024c98bab4dabed4afd73f--fc4b01845ac740519379ac77a84a1762 fc4b01845ac740519379ac77a84a1762--8eab7729c3d243c1a655da4e53b0ab4c 8827a0fc719241b8bd6161a075a4dfb3 8680f84e122a4025a6d2167f8a6a3981 95dd4ac2ff1f4520947532567e84a644--8680f84e122a4025a6d2167f8a6a3981 115aeaed902249d3a869cfd7abf880d1 3 0b7d295ea44540aca7be27453495109e 8680f84e122a4025a6d2167f8a6a3981--0b7d295ea44540aca7be27453495109e 3949118c27f243b19e04066a2a7e876d 0b7d295ea44540aca7be27453495109e--3949118c27f243b19e04066a2a7e876d 90b61f867e4740f8a82700c6e49a4f33 3949118c27f243b19e04066a2a7e876d--90b61f867e4740f8a82700c6e49a4f33 90b61f867e4740f8a82700c6e49a4f33--8827a0fc719241b8bd6161a075a4dfb3 e1bd0a44b8bc498bbba11413b7bfefe5 cdc32e9cbff24b30b0a2512b7ee8085d 115aeaed902249d3a869cfd7abf880d1--cdc32e9cbff24b30b0a2512b7ee8085d a84cd3b192a743ff890a3a51de9f1cc5 cdc32e9cbff24b30b0a2512b7ee8085d--a84cd3b192a743ff890a3a51de9f1cc5 02d1f8fa0d654f98a7c9ca6e325826a9 a84cd3b192a743ff890a3a51de9f1cc5--02d1f8fa0d654f98a7c9ca6e325826a9 02d1f8fa0d654f98a7c9ca6e325826a9--59e6c6ff80d043a1bc53dcc977947168 5bd84cfa109c43649c8ca43c53cc28f8--e1bd0a44b8bc498bbba11413b7bfefe5 <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 70526a7a02f04715aae4e615ddf9426a 0 69621b554559434ca08047bcfe44d2b6 70526a7a02f04715aae4e615ddf9426a--69621b554559434ca08047bcfe44d2b6 979a17bb5ca24af28fe1c144c134116e 1 c41caf9442974e799201a8ba19637273 69621b554559434ca08047bcfe44d2b6--c41caf9442974e799201a8ba19637273 d0ffd086875744b699700ded66c05abb c41caf9442974e799201a8ba19637273--d0ffd086875744b699700ded66c05abb 02de47381fb240b38d89b3bdf7d702b2 d0ffd086875744b699700ded66c05abb--02de47381fb240b38d89b3bdf7d702b2 d6180c88e44c41809427c7aec3ccfe55 cbc83b6408bf4cf28ec05f37de4cee14 PHASE(0.5) 979a17bb5ca24af28fe1c144c134116e--cbc83b6408bf4cf28ec05f37de4cee14 39dca53b66ce41b3a3c4602155981a10 2 cbc83b6408bf4cf28ec05f37de4cee14--69621b554559434ca08047bcfe44d2b6 bb46a79cd2de40acb7c1f77d36913679 cbc83b6408bf4cf28ec05f37de4cee14--bb46a79cd2de40acb7c1f77d36913679 69e820b84f824a69b05364921119dfc5 bb46a79cd2de40acb7c1f77d36913679--69e820b84f824a69b05364921119dfc5 69e820b84f824a69b05364921119dfc5--d6180c88e44c41809427c7aec3ccfe55 d5d31bcb5c27483f8069ef300ecb12f0 16d5b82d42374eefa0e4fbae8ac5e939 39dca53b66ce41b3a3c4602155981a10--16d5b82d42374eefa0e4fbae8ac5e939 eaef0e76ebdc49b186aebb5f6ebcc8ca 3 967d60cd9091464e869bef94f7a36e3d PHASE(0.5) 16d5b82d42374eefa0e4fbae8ac5e939--967d60cd9091464e869bef94f7a36e3d 967d60cd9091464e869bef94f7a36e3d--c41caf9442974e799201a8ba19637273 b7fe0de363284640b32afae267cefe79 967d60cd9091464e869bef94f7a36e3d--b7fe0de363284640b32afae267cefe79 b7fe0de363284640b32afae267cefe79--d5d31bcb5c27483f8069ef300ecb12f0 1367d8a26eef4eed9f4ed794598066ef 074f8f62e23f4232be7e6cebab834004 eaef0e76ebdc49b186aebb5f6ebcc8ca--074f8f62e23f4232be7e6cebab834004 0de83e23a0404ca18639724ccb5f5179 074f8f62e23f4232be7e6cebab834004--0de83e23a0404ca18639724ccb5f5179 b6693b3698c748dca2057c45403149d2 PHASE(0.5) 0de83e23a0404ca18639724ccb5f5179--b6693b3698c748dca2057c45403149d2 b6693b3698c748dca2057c45403149d2--d0ffd086875744b699700ded66c05abb b6693b3698c748dca2057c45403149d2--1367d8a26eef4eed9f4ed794598066ef"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from math import pi\nfrom qadence import AnalogRot\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = pi, # [rad/\u03bcs]\n    delta = pi, # [rad/\u03bcs]\n    phase = pi, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run\nfrom qadence.analog.constants import C6_DICT\nfrom math import pi, cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = pi\ndelta = pi\nphase = pi\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run\nfrom math import pi\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = pi\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>wait</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, wait, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = wait(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction\nfrom math import pi\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * pi * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * pi * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice\nfrom math import pi\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = pi)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all the Analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>wait</code> operation initializes a <code>WaitBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = \"global\"</code>. However, the blocks do support local qubit supports, with some constraints. The main constraint is that using <code>kron</code> on operators with different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, wait\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    wait(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    wait(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    wait(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2023-12-11T15:40:59.871041 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>Warning</p> <p>Tutorial to be updated</p> <p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\nfrom pulser.devices import Chadoq2\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n\n\ndef qubo_register_coords(Q):\n    \"\"\"Compute coordinates for register.\"\"\"\n    bitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\n    costs = []\n    # this takes exponential time with the dimension of the QUBO\n    for b in bitstrings:\n        z = np.array(list(b), dtype=int)\n        cost = z.T @ Q @ z\n        costs.append(cost)\n    zipped = zip(bitstrings, costs)\n    sort_zipped = sorted(zipped, key=lambda x: x[1])\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        new_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    costs = []\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\n\nfrom qadence import chain\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRZ, AnalogRX\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\n    z = np.array(list(bitstring), dtype=int)\n    cost = z.T @ Q @ z\n    return cost\n\n# Cost function.\ndef cost_fn(counter, Q):\n    cost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\n    return cost / sum(counter.values())  # Divide by total samples\n\n\n# Weights.\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in Pulser, and set the device specs with the updated Rydberg level.</p> <pre><code># Register with device specs\ndevice = RydbergDevice(rydberg_level = 70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q),\n    device_specs = device\n)\n\n# Analog circuit\nlayers = 2\n\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\n</code></pre> <pre><code>\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(\n    QuantumCircuit(reg, block),\n    backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 101, '10000': 87, '01000': 75, '00110': 72, '00100': 70, '01010': 64, '01001': 62, '00101': 53, '00010': 51, '00011': 48, '01011': 46, '00001': 45, '10010': 45, '00111': 38, '10001': 34, '11000': 29, '10100': 18, '01100': 14, '01110': 11, '01111': 10, '10110': 7, '11001': 7, '11010': 6, '01101': 4, '10101': 2, '10011': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\n    Q = args[0]\n    param = torch.tensor(param)\n    model.reset_vparams(param)\n    C = model.sample({}, n_shots=1000)[0]\n    return cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\n    res = minimize(\n        loss,\n        args=Q,\n        x0=np.random.uniform(1, 10, size=2 * layers),\n        method=\"COBYLA\",\n        tol=1e-8,\n        options={\"maxiter\": 20},\n    )\n\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 233, '01011': 208, '00000': 104, '01001': 85, '00100': 75, '00110': 71, '01000': 70, '00101': 33, '00010': 27, '00001': 26, '01010': 24, '00011': 15, '10011': 11, '10000': 10, '01100': 3, '10101': 2, '01111': 1, '10100': 1, '10110': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-12-11T15:41:01.755344 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=torch.pi,      # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_835a46a87cb94040826fe3a1c274e586 cluster_59e577323f02423c8c0ebe5cce1e07df cluster_9243984b32c3461383764a8e090c218f cluster_2515503bb3264f6d9fb048899c05b3ed cluster_90f54e4b67a34187bb6edce0ecfdae0d cluster_188f60174ba442d0a603dc352ab90037 cluster_5e1134da1dad48d081c37d6f7848ada4 dd811887e8f342e18b39c75e4920c5a7 0 ce4650fec0314f3fa31870af7b11226d HamEvo dd811887e8f342e18b39c75e4920c5a7--ce4650fec0314f3fa31870af7b11226d a0300f6403f74d2eaca53938485a9dff 1 049e4cdb01a74b00ba55138c23bde77f HamEvo ce4650fec0314f3fa31870af7b11226d--049e4cdb01a74b00ba55138c23bde77f b64a73d4626a42f19b90b84b0606f33c HamEvo 049e4cdb01a74b00ba55138c23bde77f--b64a73d4626a42f19b90b84b0606f33c caeba3313b5f451f9f2e0d9d9ac38770 X b64a73d4626a42f19b90b84b0606f33c--caeba3313b5f451f9f2e0d9d9ac38770 414f246d8da443dd9fe6bf85fc299de9 HamEvo caeba3313b5f451f9f2e0d9d9ac38770--414f246d8da443dd9fe6bf85fc299de9 999cac7a808c4f74be3b140db19f98e7 HamEvo 414f246d8da443dd9fe6bf85fc299de9--999cac7a808c4f74be3b140db19f98e7 fa57aa5f73004c219bc716a048a8e5eb X 999cac7a808c4f74be3b140db19f98e7--fa57aa5f73004c219bc716a048a8e5eb 9e8f17b1a2a54530a713030cdea22b25 fa57aa5f73004c219bc716a048a8e5eb--9e8f17b1a2a54530a713030cdea22b25 75f5fb1265a4422c81969a4a54bdb350 HamEvo 9e8f17b1a2a54530a713030cdea22b25--75f5fb1265a4422c81969a4a54bdb350 80b4b2c6b5b243c5abf02ccc1d37232c HamEvo 75f5fb1265a4422c81969a4a54bdb350--80b4b2c6b5b243c5abf02ccc1d37232c 60316991a60b450988f6a2c7bbe31fa5 80b4b2c6b5b243c5abf02ccc1d37232c--60316991a60b450988f6a2c7bbe31fa5 f2309cf940264a209f34ab8d88b1a395 60316991a60b450988f6a2c7bbe31fa5--f2309cf940264a209f34ab8d88b1a395 be005a8362214f93a576a97670a9c28f bd059aa00af94d4ba9a8dd4b24fa91a7 t = -3.142 a0300f6403f74d2eaca53938485a9dff--bd059aa00af94d4ba9a8dd4b24fa91a7 b1a9ca89fb4d4a99b923ae1933ddeeef 2 325d695819164815b84c404e19bd6b12 t = 3.142 bd059aa00af94d4ba9a8dd4b24fa91a7--325d695819164815b84c404e19bd6b12 5ffaa1b4b52a4520b093f3e53d9aa21b t = -3.142 325d695819164815b84c404e19bd6b12--5ffaa1b4b52a4520b093f3e53d9aa21b 9262dcaacbd046fd902d43d503bd3884 5ffaa1b4b52a4520b093f3e53d9aa21b--9262dcaacbd046fd902d43d503bd3884 5481a2bf662444909befbb2149334cda t = 1.571 9262dcaacbd046fd902d43d503bd3884--5481a2bf662444909befbb2149334cda 2ff73281df83480895a959e25cc284d3 t = 1.571 5481a2bf662444909befbb2149334cda--2ff73281df83480895a959e25cc284d3 fdcffe82997641a8abb5880337c8d7e0 2ff73281df83480895a959e25cc284d3--fdcffe82997641a8abb5880337c8d7e0 b45cd5bec5214f289a2ffe0c29698369 X fdcffe82997641a8abb5880337c8d7e0--b45cd5bec5214f289a2ffe0c29698369 b57b9cf86f4a4c55a9dcfbb9ddb15575 t = 1.571 b45cd5bec5214f289a2ffe0c29698369--b57b9cf86f4a4c55a9dcfbb9ddb15575 02e058ca78e2442d9f7ac4f861600b14 t = 1.571 b57b9cf86f4a4c55a9dcfbb9ddb15575--02e058ca78e2442d9f7ac4f861600b14 e1dadf1723f44f2cac8be40660ab58a9 X 02e058ca78e2442d9f7ac4f861600b14--e1dadf1723f44f2cac8be40660ab58a9 e1dadf1723f44f2cac8be40660ab58a9--be005a8362214f93a576a97670a9c28f 17801a9218b74ced83f93e7d77ffa5a5 08a7a833c592436c870909cff4abf8fd b1a9ca89fb4d4a99b923ae1933ddeeef--08a7a833c592436c870909cff4abf8fd 1da83862f8e849328cb12db2bf39998b 08a7a833c592436c870909cff4abf8fd--1da83862f8e849328cb12db2bf39998b 817f3b0e6ce54dc0a14e40ee3fe5baae 1da83862f8e849328cb12db2bf39998b--817f3b0e6ce54dc0a14e40ee3fe5baae a55e1dceb33244a18fd404f0480098b8 X 817f3b0e6ce54dc0a14e40ee3fe5baae--a55e1dceb33244a18fd404f0480098b8 c4300b508f214c248c5e5a04debf86ff a55e1dceb33244a18fd404f0480098b8--c4300b508f214c248c5e5a04debf86ff 409722c02c164b7db6b78737ffc992d2 c4300b508f214c248c5e5a04debf86ff--409722c02c164b7db6b78737ffc992d2 3bdaebecd4c64deebcc9a381c6ce0a53 X 409722c02c164b7db6b78737ffc992d2--3bdaebecd4c64deebcc9a381c6ce0a53 08503b09178e430db1b16f6f316edceb X 3bdaebecd4c64deebcc9a381c6ce0a53--08503b09178e430db1b16f6f316edceb 6aeefd9d1a6f4acb8c03af685e8cfe1d 08503b09178e430db1b16f6f316edceb--6aeefd9d1a6f4acb8c03af685e8cfe1d 9a7a78d000564dbd8316d1670ee05bad 6aeefd9d1a6f4acb8c03af685e8cfe1d--9a7a78d000564dbd8316d1670ee05bad 80d5f16e42ff498c84304a8c74de38a2 X 9a7a78d000564dbd8316d1670ee05bad--80d5f16e42ff498c84304a8c74de38a2 80d5f16e42ff498c84304a8c74de38a2--17801a9218b74ced83f93e7d77ffa5a5 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_a481d69c7f1a4c8ca97e07aa941fd2ee cluster_6b630c0d0dca49319bd58034eb32190d c981cb0908be4001a280b48b656ba099 0 4ca335760aa44987a964c5840fb923c0 X c981cb0908be4001a280b48b656ba099--4ca335760aa44987a964c5840fb923c0 4955a7c33ba7452485c73f7d1e8a06ec 1 f3689c142c7749daa4ac0b03b65a1264 HamEvo 4ca335760aa44987a964c5840fb923c0--f3689c142c7749daa4ac0b03b65a1264 03532028ffc44c4484a709ed085d5ff0 X f3689c142c7749daa4ac0b03b65a1264--03532028ffc44c4484a709ed085d5ff0 8feb3ef847f046ee876f4ddaacc23c87 03532028ffc44c4484a709ed085d5ff0--8feb3ef847f046ee876f4ddaacc23c87 a8074e03c8614ccab09a30194032560d HamEvo 8feb3ef847f046ee876f4ddaacc23c87--a8074e03c8614ccab09a30194032560d 30f62e179fac49b98cf22557f52443e0 a8074e03c8614ccab09a30194032560d--30f62e179fac49b98cf22557f52443e0 1736b7bc09754e0d94f56a49ca3f745f 30f62e179fac49b98cf22557f52443e0--1736b7bc09754e0d94f56a49ca3f745f cf0a2a9132d34b8ca8049067471e37f4 572f8c07e7f7497e8cd6041424ec5f42 4955a7c33ba7452485c73f7d1e8a06ec--572f8c07e7f7497e8cd6041424ec5f42 2da4c246a709423088b0f10ae96bcb26 2 a18203fc04a3438285fa6260256a87ff t = -0.500 572f8c07e7f7497e8cd6041424ec5f42--a18203fc04a3438285fa6260256a87ff 62dbdd3ab96b497e8283a5217305c1e1 a18203fc04a3438285fa6260256a87ff--62dbdd3ab96b497e8283a5217305c1e1 487df8cdfaa9423c85ec6ca175bf97c5 X 62dbdd3ab96b497e8283a5217305c1e1--487df8cdfaa9423c85ec6ca175bf97c5 532b45fe79cd48c3bdf258b8840eaece t = -0.500 487df8cdfaa9423c85ec6ca175bf97c5--532b45fe79cd48c3bdf258b8840eaece 75188421ada3482a9ca2372a8945342b X 532b45fe79cd48c3bdf258b8840eaece--75188421ada3482a9ca2372a8945342b 75188421ada3482a9ca2372a8945342b--cf0a2a9132d34b8ca8049067471e37f4 10d536b9ee24493590ebfda4366bd386 28364f2f8c5a4e458f75c299047fb7f6 X 2da4c246a709423088b0f10ae96bcb26--28364f2f8c5a4e458f75c299047fb7f6 83920240b59641999b1b04bded18f27c 28364f2f8c5a4e458f75c299047fb7f6--83920240b59641999b1b04bded18f27c 88828eef25e94ba7b24438a5d274ba89 X 83920240b59641999b1b04bded18f27c--88828eef25e94ba7b24438a5d274ba89 c0a3a8aec3054deeaa7317d33878414c X 88828eef25e94ba7b24438a5d274ba89--c0a3a8aec3054deeaa7317d33878414c 0034b8bcd33c4f0da5753742a732fced c0a3a8aec3054deeaa7317d33878414c--0034b8bcd33c4f0da5753742a732fced 0cbac1ebb3f946b9879b61e29281a268 X 0034b8bcd33c4f0da5753742a732fced--0cbac1ebb3f946b9879b61e29281a268 0cbac1ebb3f946b9879b61e29281a268--10d536b9ee24493590ebfda4366bd386 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_9ab6937356df49919608e3e242af313b cluster_ba820ab16b144ceaa67fe23ba0637791 2b018add244d4fb1b8f4fd249f2d261d 0 cd94f5f7d8004b639d17690883b44a2e X 2b018add244d4fb1b8f4fd249f2d261d--cd94f5f7d8004b639d17690883b44a2e dd3d675698994b7faabd5378399c5386 1 294c7bbfb88044d3a571cbf00c89c672 HamEvo cd94f5f7d8004b639d17690883b44a2e--294c7bbfb88044d3a571cbf00c89c672 481ea78bf0e541cc914e5fe1d54bcdef X 294c7bbfb88044d3a571cbf00c89c672--481ea78bf0e541cc914e5fe1d54bcdef cb40b0fd2de64a0eb745bdb6a802c1a3 481ea78bf0e541cc914e5fe1d54bcdef--cb40b0fd2de64a0eb745bdb6a802c1a3 2894c3d3f4f64bbda090445f487cda44 HamEvo cb40b0fd2de64a0eb745bdb6a802c1a3--2894c3d3f4f64bbda090445f487cda44 1f31a94fc3af4fa5b0895f77856380e2 2894c3d3f4f64bbda090445f487cda44--1f31a94fc3af4fa5b0895f77856380e2 99970495c4c4476895b7e34de1ba87c3 1f31a94fc3af4fa5b0895f77856380e2--99970495c4c4476895b7e34de1ba87c3 4d3dfb27b26b4ad5bbb5b027254a5282 0c148f6f023b4fe5a6f4a3c4a21cfeb8 dd3d675698994b7faabd5378399c5386--0c148f6f023b4fe5a6f4a3c4a21cfeb8 ace6473cdd4347188107d4110f02a9e8 2 bc0ce15515494a1da689f51fe30fc339 t = -500.000000000000 0c148f6f023b4fe5a6f4a3c4a21cfeb8--bc0ce15515494a1da689f51fe30fc339 60890ab2358b4067adf4516e79178016 bc0ce15515494a1da689f51fe30fc339--60890ab2358b4067adf4516e79178016 2eb7210692124b9dbf7ad518de4426fd X 60890ab2358b4067adf4516e79178016--2eb7210692124b9dbf7ad518de4426fd 0c97e923068f4d71803d8ff4491a1333 t = -500.000000000000 2eb7210692124b9dbf7ad518de4426fd--0c97e923068f4d71803d8ff4491a1333 cc5ba7b20a1748a2acf43097f06c3b61 X 0c97e923068f4d71803d8ff4491a1333--cc5ba7b20a1748a2acf43097f06c3b61 cc5ba7b20a1748a2acf43097f06c3b61--4d3dfb27b26b4ad5bbb5b027254a5282 3f4388c4d7c0465f948221e114e32754 5a5f5e75f63b442593c30fef19e4811e X ace6473cdd4347188107d4110f02a9e8--5a5f5e75f63b442593c30fef19e4811e a159644e4d9e4ceb82e3b1fc2129b968 5a5f5e75f63b442593c30fef19e4811e--a159644e4d9e4ceb82e3b1fc2129b968 dce9207a4b99467aa56a363fd5069d29 X a159644e4d9e4ceb82e3b1fc2129b968--dce9207a4b99467aa56a363fd5069d29 8ba114b900f94e648ec4f134d5184461 X dce9207a4b99467aa56a363fd5069d29--8ba114b900f94e648ec4f134d5184461 a52db6a7f87c46a4a43ccd6690bf42e4 8ba114b900f94e648ec4f134d5184461--a52db6a7f87c46a4a43ccd6690bf42e4 223518ceccc84dfcadd06e91dac3f738 X a52db6a7f87c46a4a43ccd6690bf42e4--223518ceccc84dfcadd06e91dac3f738 223518ceccc84dfcadd06e91dac3f738--3f4388c4d7c0465f948221e114e32754 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.847190727211437, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*torch.pi/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 27, '11': 23})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-12-11T15:41:02.298728 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-12-11T15:41:02.423042 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*torch.pi/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 23})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-torch.pi / 2),\n        wait(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([torch.pi / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-12-11T15:41:02.908053 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(torch.pi/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-12-11T15:41:03.070799 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.2723])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.2742])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(torch.pi)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.1391]) The trained function value:  tensor([[0.1391]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\n\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.3978-0.0938j, -0.7308-0.5009j, -0.1796-0.0595j,  0.0092+0.1104j],\n         [ 0.6745-0.4435j,  0.3860+0.1615j, -0.2943-0.2427j, -0.1161-0.1194j],\n         [ 0.0071-0.3775j, -0.0791-0.1563j,  0.7486-0.2045j,  0.0188-0.4734j],\n         [-0.1418-0.1366j,  0.0787-0.0558j, -0.0827-0.4578j,  0.8310+0.2120j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * pi),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | type[Function] | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data is assumed to come from.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | type[Function] | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data is assumed to come from.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    transformed_feature = fm_parameter(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    # Backwards compatibility\n    if fm_type == \"tower\":\n        logger.warning(\"Forcing reupload scaling strategy to TOWER\")\n        reupload_scaling = ReuploadScaling.TOWER\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    for i, qubit in enumerate(support):\n        op_list.append(op(qubit, multiplier * rs_func(i) * transformed_feature))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        int_fn = INTERACTION_DICT.get(interaction, None)\n        if int_fn is None:\n            raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f028c9f67a0&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f028c9f6680&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, None)\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    data = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.8553, 0.4821]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.0584, 0.0124, 0.3985, 0.7267, 0.4795]), tensor([0.2762, 0.3432, 0.2289, 0.4323, 0.2156]), tensor([0.1925, 0.1755, 0.1534, 0.1746, 0.5921])]\n[tensor([0.8860, 0.1588, 0.1412, 0.8215, 0.9256]), tensor([0.6628, 0.0107, 0.0522, 0.5735, 0.7052]), tensor([0.0385, 0.0183, 0.7463, 0.0388, 0.6066])]\n[tensor([0.0584, 0.0124, 0.3985, 0.7267, 0.4795]), tensor([0.2762, 0.3432, 0.2289, 0.4323, 0.2156]), tensor([0.1925, 0.1755, 0.1534, 0.1746, 0.5921])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.0448-1.9079e-17j, -0.3027+5.5272e-18j],\n        [ 1.0892-2.7965e-17j, -0.4317+1.1084e-17j]])\ntensor([[1.5334-1.1262j, 0.9423-0.6638j],\n        [1.2765-0.4016j, 0.4069-0.1863j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-np.pi / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = np.pi\n    duration = alpha / delta * 1000\n    ps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=0.0)\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter = 1000.0,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    alpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000\n    ps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; WaitBlock:\n    \"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n\n    Returns:\n        a `WaitBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return WaitBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['339c514d-822f-4fa1-a81f-7312a76b6f91', 'ecffac12-0508-4dfa-a2f9-382be20be676'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.7262773469971591\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.450972795899503\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = torchify(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.torchify","title":"<code>torchify(expr)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\n</code></pre> RETURNS DESCRIPTION <code>SymPyModule</code> <p>A torchified, differentiable Expression.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def torchify(expr: Expr) -&gt; SymPyModule:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n\n    Returns:\n        A torchified, differentiable Expression.\n    \"\"\"\n\n    def heaviside_func(x: Tensor, _: Any) -&gt; Tensor:\n        with no_grad():\n            res = heaviside(x, tensor(0.5))\n        return res\n\n    extra_funcs = {sympy.core.numbers.ImaginaryUnit: 1.0j, sympy.Heaviside: heaviside_func}\n    return SymPyModule(expressions=[sympy.N(expr)], extra_funcs=extra_funcs)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False)</code>","text":"<p>Construct embedding function.</p> <p>It maps user-facing parameters to either expression-level parameters or gate-level parameters. The construced embedding function has the signature:</p> <pre><code> embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False\n) -&gt; tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict],]:\n    \"\"\"Construct embedding function.\n\n    It maps user-facing parameters to either *expression-level*\n    parameters or *gate-level* parameters. The construced embedding function has the signature:\n\n         embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, sympytorch.SymPyModule] = {\n        expr: torchify(expr) for expr in unique_expressions if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n        embedded_params: dict[sympy.Expr, Tensor] = {}\n        for expr, fn in embeddings.items():\n            angle: Tensor\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: StrTensorDict = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: StrTensorDict\n    params = {p.name: torch.tensor([p.value], requires_grad=True) for p in trainable_symbols}\n    params.update(\n        {\n            stringify(expr): torch.tensor([evaluate(expr)], requires_grad=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): torch.tensor(\n                np.array(expr.tolist(), dtype=np.cdouble), requires_grad=False\n            )\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('6fec0af6-8d15-496e-85eb-390e06a2e80d', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.3978401946895035'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('fad1b7b6-b79e-4445-b0dc-fc8b4974fca7', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.5107891929577533'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('607c5c8a-316f-44d7-9804-b87124a1901b', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.16650538174477025'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('70404852-76a4-4c63-9ff8-b698976ca5ff', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.42675966503419094'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('481b1974-07e8-4e0c-b944-511e2bae6d96', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6686059935634905'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('85feef69-760b-4ea1-95ea-d0dc41ef6e66', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.2969019264041437'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('eaa2515d-d496-4c50-a5ee-fe6d94752851', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.657268166920075'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('99373a9c-e96a-4fb1-8fb1-3478dd0cc13f', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.9040698059531549'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('ede49a96-90ce-4df0-898c-278d63ce8c92', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.11147726187362894'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('c74f8aac-fc3a-4a75-83fb-ec2320c05672', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.3319225908813115'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('8a8ed356-868f-4e59-9cfd-fc8bf0a74059', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.732528137502527'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e7df4c57-8114-4882-aa93-ddc497960c62', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.6009734758603325'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>10111110\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.0972+0.0300j,  0.7390-0.0408j,  0.2991-0.5066j, -0.2463-0.1876j]])\ntensor([[0.6861+0.0323j, 0.0000+0.0000j, 0.7259+0.0341j, 0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 91, '0010': 3, '0001': 2, '0100': 2, '1000': 2})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[0.1102],\n        [0.0714],\n        [0.1501],\n        [0.0039],\n        [0.0344],\n        [0.1196],\n        [0.0958],\n        [0.1658],\n        [0.0453],\n        [0.1395]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 2.8360, -0.3155, -0.3298, -0.1653, -0.2689, -0.3334, -0.3288, -0.3244,\n        -0.2874, -0.3322], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 2.8360, -0.3155, -0.3298, -0.1653, -0.2689, -0.3334, -0.3288, -0.3244,\n        -0.2874, -0.3322], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4482],\n        [0.2437],\n        [0.1200],\n        [0.5725],\n        [0.5203]]), tensor([[0.4334],\n        [0.2413],\n        [0.1197],\n        [0.5417],\n        [0.4971]])], 'y2': [tensor([[0.0801],\n        [0.4220],\n        [0.5646],\n        [0.1147],\n        [0.5553]]), tensor([[0.0800],\n        [0.4096],\n        [0.5351],\n        [0.1144],\n        [0.5272]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2023-12-11T15:41:26.747116 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2023-12-11T15:41:27.349972 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_239ff47aa7cc4230acdd0bfef77b9695 mixing cluster_881b1c5abeb24de581149eb8fd2f1f7a mixing cluster_3c770a6a039849799d4318e8c2503491 cost cluster_c1492b12f16a49fe927ffc1f77eeb006 cost 37f0b45db68144a5b670483c8bc5233a 0 998eb0b72027408aa6657aecb76fe8ca 37f0b45db68144a5b670483c8bc5233a--998eb0b72027408aa6657aecb76fe8ca 1211593c6d5d4a6bb7ac344aaf769640 1 76f90a9efed44de7a0f51444f3cfd95a 998eb0b72027408aa6657aecb76fe8ca--76f90a9efed44de7a0f51444f3cfd95a 9ba8853f85a248c999f34d7b25412b59 76f90a9efed44de7a0f51444f3cfd95a--9ba8853f85a248c999f34d7b25412b59 22806070f1b1477fa8127041925adc9e 9ba8853f85a248c999f34d7b25412b59--22806070f1b1477fa8127041925adc9e b8d4737e407a4e99bd8b7b9f178e96c9 22806070f1b1477fa8127041925adc9e--b8d4737e407a4e99bd8b7b9f178e96c9 4518ab4943d14ed2b974ed0f39cca748 b8d4737e407a4e99bd8b7b9f178e96c9--4518ab4943d14ed2b974ed0f39cca748 496ab1d13bbf43428a04856a0b71e1c0 4518ab4943d14ed2b974ed0f39cca748--496ab1d13bbf43428a04856a0b71e1c0 c9096705f9c64662882e10cf9f739fe6 496ab1d13bbf43428a04856a0b71e1c0--c9096705f9c64662882e10cf9f739fe6 eda12ce6abce47f5bc470a2fb8a2da99 c9096705f9c64662882e10cf9f739fe6--eda12ce6abce47f5bc470a2fb8a2da99 61ab8b5ec1224c788e5afdbf872cd06b eda12ce6abce47f5bc470a2fb8a2da99--61ab8b5ec1224c788e5afdbf872cd06b 0e7fb1cbe5c64010b71747b193cac77f 61ab8b5ec1224c788e5afdbf872cd06b--0e7fb1cbe5c64010b71747b193cac77f 742cdbea127946e890a12150bdc7e4de 0e7fb1cbe5c64010b71747b193cac77f--742cdbea127946e890a12150bdc7e4de 9fbcacfbd5214d95ad8cb11dc5ca6721 742cdbea127946e890a12150bdc7e4de--9fbcacfbd5214d95ad8cb11dc5ca6721 8714a5fc74f2491aa54b576afa6b244f 9fbcacfbd5214d95ad8cb11dc5ca6721--8714a5fc74f2491aa54b576afa6b244f 0f94fbd742eb4d30a32efb9dc219ba02 8714a5fc74f2491aa54b576afa6b244f--0f94fbd742eb4d30a32efb9dc219ba02 cd0e0c62d47b419a9b9a59974babf916 0f94fbd742eb4d30a32efb9dc219ba02--cd0e0c62d47b419a9b9a59974babf916 1422efa06bc644288ee6f75d3c50495f cd0e0c62d47b419a9b9a59974babf916--1422efa06bc644288ee6f75d3c50495f 602c961611714eae8b73142aeb7f13e1 1422efa06bc644288ee6f75d3c50495f--602c961611714eae8b73142aeb7f13e1 d8f478be26b942a6bd5619eb35d60716 602c961611714eae8b73142aeb7f13e1--d8f478be26b942a6bd5619eb35d60716 35a72f745ee54f7a9febef510cdc6ea4 d8f478be26b942a6bd5619eb35d60716--35a72f745ee54f7a9febef510cdc6ea4 efd5a47345b541bf8d5489e05532dc12 35a72f745ee54f7a9febef510cdc6ea4--efd5a47345b541bf8d5489e05532dc12 5a96ac2848624d1b86c102f6fcc58c0e efd5a47345b541bf8d5489e05532dc12--5a96ac2848624d1b86c102f6fcc58c0e 45fdf19434ea495ab4b51bf8d1fe39e9 5a96ac2848624d1b86c102f6fcc58c0e--45fdf19434ea495ab4b51bf8d1fe39e9 c5411198636d40deb8b1dc7f9d69db9f 45fdf19434ea495ab4b51bf8d1fe39e9--c5411198636d40deb8b1dc7f9d69db9f 8745b578f4ba4a5b8f8e09bc20ad2e6a c5411198636d40deb8b1dc7f9d69db9f--8745b578f4ba4a5b8f8e09bc20ad2e6a e8c0b7482c7d4a069a206b7d47b7f2c1 8745b578f4ba4a5b8f8e09bc20ad2e6a--e8c0b7482c7d4a069a206b7d47b7f2c1 02a9217af71848d6bc188ae06112bfa0 e8c0b7482c7d4a069a206b7d47b7f2c1--02a9217af71848d6bc188ae06112bfa0 a13040d13f6944499b7140633dc75e9e 02a9217af71848d6bc188ae06112bfa0--a13040d13f6944499b7140633dc75e9e 1725bdb5d9ed4b5b8f368ce9fcb01b7d a13040d13f6944499b7140633dc75e9e--1725bdb5d9ed4b5b8f368ce9fcb01b7d fb4dd7b5b5864c08a245d5738ab28ddb 1725bdb5d9ed4b5b8f368ce9fcb01b7d--fb4dd7b5b5864c08a245d5738ab28ddb cf2fa1e536e340beb5745ff59053ef08 fb4dd7b5b5864c08a245d5738ab28ddb--cf2fa1e536e340beb5745ff59053ef08 7ee81b8f6cd7411a95ee2c92912c51f8 cf2fa1e536e340beb5745ff59053ef08--7ee81b8f6cd7411a95ee2c92912c51f8 d4bb3d60f40f471da0eb5b1210de758b 7ee81b8f6cd7411a95ee2c92912c51f8--d4bb3d60f40f471da0eb5b1210de758b 202530cda8a3462199aa18273d6ad1da d4bb3d60f40f471da0eb5b1210de758b--202530cda8a3462199aa18273d6ad1da 51a760aa21684d31a5ca72b7d8eabe4b 202530cda8a3462199aa18273d6ad1da--51a760aa21684d31a5ca72b7d8eabe4b 7156cb017af7465ca2df51f831ba0db5 51a760aa21684d31a5ca72b7d8eabe4b--7156cb017af7465ca2df51f831ba0db5 2018497af419445aa623bbf60edab6ee 7156cb017af7465ca2df51f831ba0db5--2018497af419445aa623bbf60edab6ee b583314f3b6d4ca3a9e5a128759c5284 2018497af419445aa623bbf60edab6ee--b583314f3b6d4ca3a9e5a128759c5284 0ad078a91c0a470589c190b3f545700d b583314f3b6d4ca3a9e5a128759c5284--0ad078a91c0a470589c190b3f545700d 90e25773539147e1ba95ee78c97453fc 0ad078a91c0a470589c190b3f545700d--90e25773539147e1ba95ee78c97453fc 1a4864396ba24dce893f5543f284e89a 90e25773539147e1ba95ee78c97453fc--1a4864396ba24dce893f5543f284e89a 1717b55ad5ef42689bfbc67ed1ecf82d 1a4864396ba24dce893f5543f284e89a--1717b55ad5ef42689bfbc67ed1ecf82d 69663ae2463a4d4eab0206405c1283d8 1717b55ad5ef42689bfbc67ed1ecf82d--69663ae2463a4d4eab0206405c1283d8 51944809caad4882a744b9531b1af806 69663ae2463a4d4eab0206405c1283d8--51944809caad4882a744b9531b1af806 a4e0228fcd9f47aeaf68d225ccfd24e0 51944809caad4882a744b9531b1af806--a4e0228fcd9f47aeaf68d225ccfd24e0 6f867b1e01144fc5bb6a73f38028a448 a4e0228fcd9f47aeaf68d225ccfd24e0--6f867b1e01144fc5bb6a73f38028a448 0867b2d5bdfc4a72a3240cb0fd156d30 6f867b1e01144fc5bb6a73f38028a448--0867b2d5bdfc4a72a3240cb0fd156d30 9ec04a6ea0ce49208ecdddfd19a9f647 0867b2d5bdfc4a72a3240cb0fd156d30--9ec04a6ea0ce49208ecdddfd19a9f647 b82a29b848a64225a39f9a0ba72fea38 9ec04a6ea0ce49208ecdddfd19a9f647--b82a29b848a64225a39f9a0ba72fea38 fba2ed66a34647f187e32b6ac879ab77 b82a29b848a64225a39f9a0ba72fea38--fba2ed66a34647f187e32b6ac879ab77 62a62ba098434bf39f65bb54bd5d7b86 fba2ed66a34647f187e32b6ac879ab77--62a62ba098434bf39f65bb54bd5d7b86 264fc73f68514a07b2505940b2a654ae 62a62ba098434bf39f65bb54bd5d7b86--264fc73f68514a07b2505940b2a654ae b3c0b7c75815419eb036b4933ba4dd57 264fc73f68514a07b2505940b2a654ae--b3c0b7c75815419eb036b4933ba4dd57 052f048c62f44b918b82ca71acaa6e76 b3c0b7c75815419eb036b4933ba4dd57--052f048c62f44b918b82ca71acaa6e76 6f3f11ad6ebe4d7f9ba4dd5219b45cb2 052f048c62f44b918b82ca71acaa6e76--6f3f11ad6ebe4d7f9ba4dd5219b45cb2 76545d3cedfb468f8cf9b30e3f428456 6f3f11ad6ebe4d7f9ba4dd5219b45cb2--76545d3cedfb468f8cf9b30e3f428456 3307f72396984aecac43b707b3f08db6 76545d3cedfb468f8cf9b30e3f428456--3307f72396984aecac43b707b3f08db6 ba8caba223f14f059e72ad7f24765e54 3307f72396984aecac43b707b3f08db6--ba8caba223f14f059e72ad7f24765e54 c34877bfa7ce43049799d4530fab36dd ba8caba223f14f059e72ad7f24765e54--c34877bfa7ce43049799d4530fab36dd a9cdd08978f24b1086ea85471cb06ed9 c34877bfa7ce43049799d4530fab36dd--a9cdd08978f24b1086ea85471cb06ed9 1b6734f3a1214c4cb6f4f50279b693bf a9cdd08978f24b1086ea85471cb06ed9--1b6734f3a1214c4cb6f4f50279b693bf dccfcc510bfd47f688a06d2b1e3a691e 1b6734f3a1214c4cb6f4f50279b693bf--dccfcc510bfd47f688a06d2b1e3a691e 5c03a15d0ea143bd8da3177fc66097f8 dccfcc510bfd47f688a06d2b1e3a691e--5c03a15d0ea143bd8da3177fc66097f8 aabf0e7ffb284c8f8e41f94f20e78783 5c03a15d0ea143bd8da3177fc66097f8--aabf0e7ffb284c8f8e41f94f20e78783 3e21f573c16f4c4a837549e5bda55b46 aabf0e7ffb284c8f8e41f94f20e78783--3e21f573c16f4c4a837549e5bda55b46 f30dff0cf5aa46efa5afaa9f082a2493 3e21f573c16f4c4a837549e5bda55b46--f30dff0cf5aa46efa5afaa9f082a2493 f08c32f76fd848c095ab7a872d475ccb f30dff0cf5aa46efa5afaa9f082a2493--f08c32f76fd848c095ab7a872d475ccb a61091f60a6149fcb97b4d026e54f0cb f08c32f76fd848c095ab7a872d475ccb--a61091f60a6149fcb97b4d026e54f0cb 75314f30a11940d6bf49e295c6f2572b a61091f60a6149fcb97b4d026e54f0cb--75314f30a11940d6bf49e295c6f2572b 053196366d6b49e5b0784aa063b9e8e5 75314f30a11940d6bf49e295c6f2572b--053196366d6b49e5b0784aa063b9e8e5 bdc68bd0dc39422d807be4a4e78be208 053196366d6b49e5b0784aa063b9e8e5--bdc68bd0dc39422d807be4a4e78be208 7740af9148054b17b3e66ee397180fce bdc68bd0dc39422d807be4a4e78be208--7740af9148054b17b3e66ee397180fce a9c1797e80154e72a822331a66bbdd83 7740af9148054b17b3e66ee397180fce--a9c1797e80154e72a822331a66bbdd83 c96ae1e8e9f1451598dd5cbfa271052f a9c1797e80154e72a822331a66bbdd83--c96ae1e8e9f1451598dd5cbfa271052f e3c7a0ed4adc462488da67ba1f98b08f c96ae1e8e9f1451598dd5cbfa271052f--e3c7a0ed4adc462488da67ba1f98b08f 870053010e304d3da7bdf6a4c57cd577 e3c7a0ed4adc462488da67ba1f98b08f--870053010e304d3da7bdf6a4c57cd577 b233cb6d540144ba94946d285df7d9d9 870053010e304d3da7bdf6a4c57cd577--b233cb6d540144ba94946d285df7d9d9 69b62c4278fa41d1ab9c6673f7a4cd46 b233cb6d540144ba94946d285df7d9d9--69b62c4278fa41d1ab9c6673f7a4cd46 4225f01c686d49f08911751811c9e6be 69b62c4278fa41d1ab9c6673f7a4cd46--4225f01c686d49f08911751811c9e6be 2ad659b7e37f4e9dbcaf081d52e3b24a 4225f01c686d49f08911751811c9e6be--2ad659b7e37f4e9dbcaf081d52e3b24a e155468174c7445ea1ddcfa244fbf665 2ad659b7e37f4e9dbcaf081d52e3b24a--e155468174c7445ea1ddcfa244fbf665 6e67389bef40443ca306d484800a1bc5 e155468174c7445ea1ddcfa244fbf665--6e67389bef40443ca306d484800a1bc5 fc7863e2707d4a659eea7d1f0c988dc1 6e67389bef40443ca306d484800a1bc5--fc7863e2707d4a659eea7d1f0c988dc1 9f14be3c3d244a4fab97640b1ce5f2f8 fc7863e2707d4a659eea7d1f0c988dc1--9f14be3c3d244a4fab97640b1ce5f2f8 053cf58911414127bc81346de3a0b1af 9f14be3c3d244a4fab97640b1ce5f2f8--053cf58911414127bc81346de3a0b1af f21340d5ce2b461fa1d856b48cd24826 053cf58911414127bc81346de3a0b1af--f21340d5ce2b461fa1d856b48cd24826 f9db494bb1f349868c26f451e0854ba3 f21340d5ce2b461fa1d856b48cd24826--f9db494bb1f349868c26f451e0854ba3 9fed75c786b949748c098ff0da09f858 f9db494bb1f349868c26f451e0854ba3--9fed75c786b949748c098ff0da09f858 932270e7b642445fa198389bc629660c 9fed75c786b949748c098ff0da09f858--932270e7b642445fa198389bc629660c 09306c9ab4444318bdbad2d519067d31 932270e7b642445fa198389bc629660c--09306c9ab4444318bdbad2d519067d31 7149c356b82d4a58af01cb15316f91f3 09306c9ab4444318bdbad2d519067d31--7149c356b82d4a58af01cb15316f91f3 681bf3149c594821ab696281e27c52c1 7149c356b82d4a58af01cb15316f91f3--681bf3149c594821ab696281e27c52c1 7bfd6cc053024c23b5ff371f1c81843a 681bf3149c594821ab696281e27c52c1--7bfd6cc053024c23b5ff371f1c81843a bde90cff592b4d96a93c558f151c9563 7bfd6cc053024c23b5ff371f1c81843a--bde90cff592b4d96a93c558f151c9563 8abc71e3cf024b3fa14e050647e6a8db bde90cff592b4d96a93c558f151c9563--8abc71e3cf024b3fa14e050647e6a8db a357d128bba142509a659b3f77552f4e 8abc71e3cf024b3fa14e050647e6a8db--a357d128bba142509a659b3f77552f4e 31e95bf055514d7b96acbedad02feea2 a357d128bba142509a659b3f77552f4e--31e95bf055514d7b96acbedad02feea2 5e328324d89f4686866b2574b2f8c9f0 31e95bf055514d7b96acbedad02feea2--5e328324d89f4686866b2574b2f8c9f0 0993f4b7c99f45f6a746171a741c3fbd 5e328324d89f4686866b2574b2f8c9f0--0993f4b7c99f45f6a746171a741c3fbd 99560a18bb2344afa595cf0155573091 0993f4b7c99f45f6a746171a741c3fbd--99560a18bb2344afa595cf0155573091 9fc43ae2c29649469828753fe9e66a06 99560a18bb2344afa595cf0155573091--9fc43ae2c29649469828753fe9e66a06 aefeae94e43e49608ac17fb225229f28 9fc43ae2c29649469828753fe9e66a06--aefeae94e43e49608ac17fb225229f28 122f37177af74b498af2009149df8ae3 aefeae94e43e49608ac17fb225229f28--122f37177af74b498af2009149df8ae3 5f13c93206e34bb58f9521d7642e7468 122f37177af74b498af2009149df8ae3--5f13c93206e34bb58f9521d7642e7468 019eef53469d4f06918346401c695367 5f13c93206e34bb58f9521d7642e7468--019eef53469d4f06918346401c695367 bcef165101f0439bb8e1ce2f8c7c2773 019eef53469d4f06918346401c695367--bcef165101f0439bb8e1ce2f8c7c2773 4f5b73b923714621ab7e0c56fe18f3ea bcef165101f0439bb8e1ce2f8c7c2773--4f5b73b923714621ab7e0c56fe18f3ea 6d76776e5bbb419bb9f77172c955e994 4f5b73b923714621ab7e0c56fe18f3ea--6d76776e5bbb419bb9f77172c955e994 3b1724427380438ca7089ed3e24059c9 6d76776e5bbb419bb9f77172c955e994--3b1724427380438ca7089ed3e24059c9 0dcae1d3a00a4be8900f27f886c78eff 3b1724427380438ca7089ed3e24059c9--0dcae1d3a00a4be8900f27f886c78eff 8a8878e7e4024643b4cef9596a2ef0d2 0dcae1d3a00a4be8900f27f886c78eff--8a8878e7e4024643b4cef9596a2ef0d2 9eb8afdeb5fa4f1a8f0b5a57a2e1c8dc 8a8878e7e4024643b4cef9596a2ef0d2--9eb8afdeb5fa4f1a8f0b5a57a2e1c8dc 6dd1171f6ca24f318ec91ae025c3377c 9eb8afdeb5fa4f1a8f0b5a57a2e1c8dc--6dd1171f6ca24f318ec91ae025c3377c 5e67a2e8d1634fbdae3d7f15ee37a73f 6dd1171f6ca24f318ec91ae025c3377c--5e67a2e8d1634fbdae3d7f15ee37a73f e84148c843d641d2b357ec1a106db407 5e67a2e8d1634fbdae3d7f15ee37a73f--e84148c843d641d2b357ec1a106db407 54e2f5ef47714a008a2e9bd7fc27ff68 e84148c843d641d2b357ec1a106db407--54e2f5ef47714a008a2e9bd7fc27ff68 750c8b43fa81471b9be2993c1b13fba9 54e2f5ef47714a008a2e9bd7fc27ff68--750c8b43fa81471b9be2993c1b13fba9 e648b2b3e53649ddb808373f28691db3 750c8b43fa81471b9be2993c1b13fba9--e648b2b3e53649ddb808373f28691db3 dec0e611875a4b4696dab0229183c561 e648b2b3e53649ddb808373f28691db3--dec0e611875a4b4696dab0229183c561 f93d38e0aa9f4e60b9cc8c2eccc1c99d dec0e611875a4b4696dab0229183c561--f93d38e0aa9f4e60b9cc8c2eccc1c99d 631f2f4ba714433c895e902abdb5b71c f93d38e0aa9f4e60b9cc8c2eccc1c99d--631f2f4ba714433c895e902abdb5b71c e6edb1e8c7f042b4bc4a8932ff0429b7 631f2f4ba714433c895e902abdb5b71c--e6edb1e8c7f042b4bc4a8932ff0429b7 a839415ae5cc43ada3a03a11c38bb4dc e6edb1e8c7f042b4bc4a8932ff0429b7--a839415ae5cc43ada3a03a11c38bb4dc 44e969805660404c9f428757541bfcc3 RX(b00) a839415ae5cc43ada3a03a11c38bb4dc--44e969805660404c9f428757541bfcc3 572f19b08f94400ca7209a08b77391d4 44e969805660404c9f428757541bfcc3--572f19b08f94400ca7209a08b77391d4 0ad2ac94652b445daf5a603f832cc675 572f19b08f94400ca7209a08b77391d4--0ad2ac94652b445daf5a603f832cc675 63f37114874b47bda0be0c0a390b3902 0ad2ac94652b445daf5a603f832cc675--63f37114874b47bda0be0c0a390b3902 54a332e3e88245dd826cca9c5517f876 63f37114874b47bda0be0c0a390b3902--54a332e3e88245dd826cca9c5517f876 e84bd2cf0fa94c67952dd181a11e3363 54a332e3e88245dd826cca9c5517f876--e84bd2cf0fa94c67952dd181a11e3363 19615444659444558ea92eb77a718513 e84bd2cf0fa94c67952dd181a11e3363--19615444659444558ea92eb77a718513 d372254168c8418098ff7879f9709ea1 19615444659444558ea92eb77a718513--d372254168c8418098ff7879f9709ea1 c8fd212fec9440ceac7096d5b5585384 d372254168c8418098ff7879f9709ea1--c8fd212fec9440ceac7096d5b5585384 1b866c4bdc184299981f6d59f19f5c29 c8fd212fec9440ceac7096d5b5585384--1b866c4bdc184299981f6d59f19f5c29 e87138217dd149ac89f798406bb89762 1b866c4bdc184299981f6d59f19f5c29--e87138217dd149ac89f798406bb89762 669a873a435c4256804703400700ad92 e87138217dd149ac89f798406bb89762--669a873a435c4256804703400700ad92 c10cb7c830a446d1a674e491923b3fcc 669a873a435c4256804703400700ad92--c10cb7c830a446d1a674e491923b3fcc b8b90d836a454cfe9b949e6faca27721 c10cb7c830a446d1a674e491923b3fcc--b8b90d836a454cfe9b949e6faca27721 befdef55ea4140da81974620f1caf664 b8b90d836a454cfe9b949e6faca27721--befdef55ea4140da81974620f1caf664 fa11865580a1439ab0f29485a48a0892 befdef55ea4140da81974620f1caf664--fa11865580a1439ab0f29485a48a0892 4a5cccdd4364444fad1994bdedf654ec fa11865580a1439ab0f29485a48a0892--4a5cccdd4364444fad1994bdedf654ec 06d5bb3c592d4f20ba1c99a9949b2bc1 4a5cccdd4364444fad1994bdedf654ec--06d5bb3c592d4f20ba1c99a9949b2bc1 8c5938008c9a45c69bfd8058b68d1d33 06d5bb3c592d4f20ba1c99a9949b2bc1--8c5938008c9a45c69bfd8058b68d1d33 bca4d25de94345da9838741bfbef0595 8c5938008c9a45c69bfd8058b68d1d33--bca4d25de94345da9838741bfbef0595 3e6200d0998847788c97868c09fd417f bca4d25de94345da9838741bfbef0595--3e6200d0998847788c97868c09fd417f 6e71a23fc16a4c6badf90c713b7cae64 3e6200d0998847788c97868c09fd417f--6e71a23fc16a4c6badf90c713b7cae64 9f8395c1487640dc9ccf77ddf4f168bf 6e71a23fc16a4c6badf90c713b7cae64--9f8395c1487640dc9ccf77ddf4f168bf fcf0f739c52f4815b54fa6e7172a4537 9f8395c1487640dc9ccf77ddf4f168bf--fcf0f739c52f4815b54fa6e7172a4537 6c92fae23a794174ae99c45a8cf571e8 fcf0f739c52f4815b54fa6e7172a4537--6c92fae23a794174ae99c45a8cf571e8 816c959b1cbe424c9dae4afc3cd66086 6c92fae23a794174ae99c45a8cf571e8--816c959b1cbe424c9dae4afc3cd66086 83fb33f4fe6443f291673b3220948704 816c959b1cbe424c9dae4afc3cd66086--83fb33f4fe6443f291673b3220948704 bcf1b6d2835f40d5ae2083e7753542bb 83fb33f4fe6443f291673b3220948704--bcf1b6d2835f40d5ae2083e7753542bb e6a30b686277436b997656be027d4807 bcf1b6d2835f40d5ae2083e7753542bb--e6a30b686277436b997656be027d4807 6f35907b72ec4518a6f1fab200b1584f e6a30b686277436b997656be027d4807--6f35907b72ec4518a6f1fab200b1584f 5401eb89b88c435ca595d76ee514e483 6f35907b72ec4518a6f1fab200b1584f--5401eb89b88c435ca595d76ee514e483 3d415e9436874158afd3049417c29d9b 5401eb89b88c435ca595d76ee514e483--3d415e9436874158afd3049417c29d9b 33dbce7174ad40c8bf20da7d2afa3928 3d415e9436874158afd3049417c29d9b--33dbce7174ad40c8bf20da7d2afa3928 b68ff78855284b0b81c7a59c84c7f7bd 33dbce7174ad40c8bf20da7d2afa3928--b68ff78855284b0b81c7a59c84c7f7bd fa691e9276544a278d9d474f264fc3b1 b68ff78855284b0b81c7a59c84c7f7bd--fa691e9276544a278d9d474f264fc3b1 da57c7d298484232b835dd32330dfc5b fa691e9276544a278d9d474f264fc3b1--da57c7d298484232b835dd32330dfc5b 26d41d7efeff4ddfb5fe6beecee0cfb9 da57c7d298484232b835dd32330dfc5b--26d41d7efeff4ddfb5fe6beecee0cfb9 defa93e7f56a4be6baa103ec6964877d 26d41d7efeff4ddfb5fe6beecee0cfb9--defa93e7f56a4be6baa103ec6964877d fdae0349afbe4f76a658aa9576142e07 defa93e7f56a4be6baa103ec6964877d--fdae0349afbe4f76a658aa9576142e07 7b8f55eb178b49b692f71f9f63f196cf fdae0349afbe4f76a658aa9576142e07--7b8f55eb178b49b692f71f9f63f196cf eebc5bef66544b46969f89ab8f8ed74e 7b8f55eb178b49b692f71f9f63f196cf--eebc5bef66544b46969f89ab8f8ed74e 0e8ee030966a465a8d5ce8a2ebb57725 eebc5bef66544b46969f89ab8f8ed74e--0e8ee030966a465a8d5ce8a2ebb57725 90cc765125594989977bce280ededa9a 0e8ee030966a465a8d5ce8a2ebb57725--90cc765125594989977bce280ededa9a a94dfc7585a5481ea39b7cfd2c2f5e55 90cc765125594989977bce280ededa9a--a94dfc7585a5481ea39b7cfd2c2f5e55 094ea7398703414195b7ed1d44e6bee5 a94dfc7585a5481ea39b7cfd2c2f5e55--094ea7398703414195b7ed1d44e6bee5 fcbb27e02eec4a2fbd818829f51897b1 094ea7398703414195b7ed1d44e6bee5--fcbb27e02eec4a2fbd818829f51897b1 07af74838e78458b82b87267f0b9b4e7 fcbb27e02eec4a2fbd818829f51897b1--07af74838e78458b82b87267f0b9b4e7 7255cb9b6c4d4a51a90c99c7c2cfe127 07af74838e78458b82b87267f0b9b4e7--7255cb9b6c4d4a51a90c99c7c2cfe127 efd54942d9ae4cdfab8ec9b0e9e40d04 7255cb9b6c4d4a51a90c99c7c2cfe127--efd54942d9ae4cdfab8ec9b0e9e40d04 c2ad425e804941cc90ca9c0f8311c23e efd54942d9ae4cdfab8ec9b0e9e40d04--c2ad425e804941cc90ca9c0f8311c23e 3c438d36e6e44c8fa125c3187d5aed05 c2ad425e804941cc90ca9c0f8311c23e--3c438d36e6e44c8fa125c3187d5aed05 9188682e00f447cabea23cd8de477562 3c438d36e6e44c8fa125c3187d5aed05--9188682e00f447cabea23cd8de477562 a182b20abe90499a96cf6a97b9744b09 9188682e00f447cabea23cd8de477562--a182b20abe90499a96cf6a97b9744b09 b6662e9d0e88438cbb626d5a45da6804 a182b20abe90499a96cf6a97b9744b09--b6662e9d0e88438cbb626d5a45da6804 9ac68ccac0ef4056bca54bd018a65ce8 b6662e9d0e88438cbb626d5a45da6804--9ac68ccac0ef4056bca54bd018a65ce8 0883777609ab4dcb84785926149550fc 9ac68ccac0ef4056bca54bd018a65ce8--0883777609ab4dcb84785926149550fc aa10135a38ca4ff698d205ece37e9c9a 0883777609ab4dcb84785926149550fc--aa10135a38ca4ff698d205ece37e9c9a b019360ac3364401a2b527c9af5ef853 aa10135a38ca4ff698d205ece37e9c9a--b019360ac3364401a2b527c9af5ef853 9ef5cc52c2134affbfa48c3b035539d0 b019360ac3364401a2b527c9af5ef853--9ef5cc52c2134affbfa48c3b035539d0 d2c98cb39eff49c8aba7a8e4c2665d20 9ef5cc52c2134affbfa48c3b035539d0--d2c98cb39eff49c8aba7a8e4c2665d20 d52df918c5604cdc8425627a41632ecc d2c98cb39eff49c8aba7a8e4c2665d20--d52df918c5604cdc8425627a41632ecc f5aecf9a1a4348718d98f4fe7012fe0e d52df918c5604cdc8425627a41632ecc--f5aecf9a1a4348718d98f4fe7012fe0e 16a939f4cd8c4d82838fd30b2fe6a8e9 f5aecf9a1a4348718d98f4fe7012fe0e--16a939f4cd8c4d82838fd30b2fe6a8e9 494e5cf1fa384f67af721e34f35474ec 16a939f4cd8c4d82838fd30b2fe6a8e9--494e5cf1fa384f67af721e34f35474ec eee58e2304944bd8b75e5fa17962bb66 494e5cf1fa384f67af721e34f35474ec--eee58e2304944bd8b75e5fa17962bb66 b96f42d3c64f43c8b0e0d50e1d7e5fa0 eee58e2304944bd8b75e5fa17962bb66--b96f42d3c64f43c8b0e0d50e1d7e5fa0 1965541b04bb40ae967064c1dc096105 b96f42d3c64f43c8b0e0d50e1d7e5fa0--1965541b04bb40ae967064c1dc096105 df15bde454104de4bf78e425b072818d 1965541b04bb40ae967064c1dc096105--df15bde454104de4bf78e425b072818d b838f9ade7704b6f896969d2b52d6684 df15bde454104de4bf78e425b072818d--b838f9ade7704b6f896969d2b52d6684 8894ee15ea0540a0864ee243ace34c3f b838f9ade7704b6f896969d2b52d6684--8894ee15ea0540a0864ee243ace34c3f f9b42a413a7f4c5bbfe9a9a3c3ac4edd 8894ee15ea0540a0864ee243ace34c3f--f9b42a413a7f4c5bbfe9a9a3c3ac4edd fc7d2918f6e54f6f9ddcb7ba15378fea f9b42a413a7f4c5bbfe9a9a3c3ac4edd--fc7d2918f6e54f6f9ddcb7ba15378fea 81d7e3df569d4a3f90c61e78a196fc93 fc7d2918f6e54f6f9ddcb7ba15378fea--81d7e3df569d4a3f90c61e78a196fc93 164e42773fab4c5ab8e289fcea3bc857 81d7e3df569d4a3f90c61e78a196fc93--164e42773fab4c5ab8e289fcea3bc857 a7cddc420b6049f58d03e9417d9ce1f1 164e42773fab4c5ab8e289fcea3bc857--a7cddc420b6049f58d03e9417d9ce1f1 d862e620fbb44babb7f24537b23ac900 a7cddc420b6049f58d03e9417d9ce1f1--d862e620fbb44babb7f24537b23ac900 a5bb6dbe364a4d3cac8cc0391bed8e00 d862e620fbb44babb7f24537b23ac900--a5bb6dbe364a4d3cac8cc0391bed8e00 a9d13001f46248ac9b6e95327ab5665f a5bb6dbe364a4d3cac8cc0391bed8e00--a9d13001f46248ac9b6e95327ab5665f 70ac8ce9413446159c65620485813e4d a9d13001f46248ac9b6e95327ab5665f--70ac8ce9413446159c65620485813e4d d9bd61e3c157470988fad129f512391b 70ac8ce9413446159c65620485813e4d--d9bd61e3c157470988fad129f512391b 87b3ad1cce5648ff86452ed061ed3c9f d9bd61e3c157470988fad129f512391b--87b3ad1cce5648ff86452ed061ed3c9f d0130b8f4d7b4cf7815ccefab6d44d89 87b3ad1cce5648ff86452ed061ed3c9f--d0130b8f4d7b4cf7815ccefab6d44d89 c5bc40b5c4e04cc7999e671eb01ca20b d0130b8f4d7b4cf7815ccefab6d44d89--c5bc40b5c4e04cc7999e671eb01ca20b 84d796674be1461db5feb73eb8cd555a c5bc40b5c4e04cc7999e671eb01ca20b--84d796674be1461db5feb73eb8cd555a 6165c5b766fd4672ae21d30b15b489b2 84d796674be1461db5feb73eb8cd555a--6165c5b766fd4672ae21d30b15b489b2 06ccfdef4aeb4270b3974e1073465e52 6165c5b766fd4672ae21d30b15b489b2--06ccfdef4aeb4270b3974e1073465e52 13d4b813408042fd9b9b1cdea2ac9997 06ccfdef4aeb4270b3974e1073465e52--13d4b813408042fd9b9b1cdea2ac9997 d77a25324305408ea41044ca0f61f5a6 13d4b813408042fd9b9b1cdea2ac9997--d77a25324305408ea41044ca0f61f5a6 3c90ae90ca43420e8d3349f1728d7197 d77a25324305408ea41044ca0f61f5a6--3c90ae90ca43420e8d3349f1728d7197 423ef4b33f9d490a969c859db5797fe6 3c90ae90ca43420e8d3349f1728d7197--423ef4b33f9d490a969c859db5797fe6 06a9908d8faa490ea27749fa09fccdd0 423ef4b33f9d490a969c859db5797fe6--06a9908d8faa490ea27749fa09fccdd0 e447639e882344b991f74bf10c5a27aa 06a9908d8faa490ea27749fa09fccdd0--e447639e882344b991f74bf10c5a27aa d1bd85e793184b268a1ac27404173123 e447639e882344b991f74bf10c5a27aa--d1bd85e793184b268a1ac27404173123 ef9b31014a0d42eaa416aa26d4234fce d1bd85e793184b268a1ac27404173123--ef9b31014a0d42eaa416aa26d4234fce 44a3d9c2d91b46b2a4906e6b80731fe4 ef9b31014a0d42eaa416aa26d4234fce--44a3d9c2d91b46b2a4906e6b80731fe4 776ef0eebd4c48f6bd24b98297124077 44a3d9c2d91b46b2a4906e6b80731fe4--776ef0eebd4c48f6bd24b98297124077 700488f881f741ac927434aa21a722f5 776ef0eebd4c48f6bd24b98297124077--700488f881f741ac927434aa21a722f5 3fbe1a6a99b74472ab386a2fbd11f63f 700488f881f741ac927434aa21a722f5--3fbe1a6a99b74472ab386a2fbd11f63f a9ddfe078b5845dab7db835db3cf79fb 3fbe1a6a99b74472ab386a2fbd11f63f--a9ddfe078b5845dab7db835db3cf79fb b2109ad1a01b4498ad5f8c4cf73c36eb a9ddfe078b5845dab7db835db3cf79fb--b2109ad1a01b4498ad5f8c4cf73c36eb 083bb281e80747929fe4c757e635fe34 b2109ad1a01b4498ad5f8c4cf73c36eb--083bb281e80747929fe4c757e635fe34 80a43f004a294f2385c613d509e343c4 083bb281e80747929fe4c757e635fe34--80a43f004a294f2385c613d509e343c4 5a5518ed3b624f7888cfb7dc09b47e58 80a43f004a294f2385c613d509e343c4--5a5518ed3b624f7888cfb7dc09b47e58 d8d953815ea74c05af5fcc61634c811a 5a5518ed3b624f7888cfb7dc09b47e58--d8d953815ea74c05af5fcc61634c811a dc4a3ad354974039b74a99e82db356e1 d8d953815ea74c05af5fcc61634c811a--dc4a3ad354974039b74a99e82db356e1 c1f0ad015d7941f39e233937a1f40670 dc4a3ad354974039b74a99e82db356e1--c1f0ad015d7941f39e233937a1f40670 dce985aa43e0417da71fa98750943f17 c1f0ad015d7941f39e233937a1f40670--dce985aa43e0417da71fa98750943f17 2e57f0f906064987aa2da4a90537394d dce985aa43e0417da71fa98750943f17--2e57f0f906064987aa2da4a90537394d c1ec35f6963542bfb2bfa3327a509658 2e57f0f906064987aa2da4a90537394d--c1ec35f6963542bfb2bfa3327a509658 1fbc89dfdf2e4351a158044190933344 c1ec35f6963542bfb2bfa3327a509658--1fbc89dfdf2e4351a158044190933344 6e7cd8d9ab404037aae06340bad809ee 1fbc89dfdf2e4351a158044190933344--6e7cd8d9ab404037aae06340bad809ee 25ad9964295847b48ec3315ff3762d38 6e7cd8d9ab404037aae06340bad809ee--25ad9964295847b48ec3315ff3762d38 0316610d416940c7b15dace4cd2ed282 25ad9964295847b48ec3315ff3762d38--0316610d416940c7b15dace4cd2ed282 1c9752844fdf48ef80dc03570fef8b47 0316610d416940c7b15dace4cd2ed282--1c9752844fdf48ef80dc03570fef8b47 67f0ebe286d5455e9b5770c6b802f1b0 1c9752844fdf48ef80dc03570fef8b47--67f0ebe286d5455e9b5770c6b802f1b0 628b429c475a424ca00e08bfe966d512 67f0ebe286d5455e9b5770c6b802f1b0--628b429c475a424ca00e08bfe966d512 50153218736c4611877b6b436e429f80 628b429c475a424ca00e08bfe966d512--50153218736c4611877b6b436e429f80 c91bdc51cf834087a45b875fb156d13f 50153218736c4611877b6b436e429f80--c91bdc51cf834087a45b875fb156d13f a79d87aff8834b91a74ae5bd51507b27 c91bdc51cf834087a45b875fb156d13f--a79d87aff8834b91a74ae5bd51507b27 1e0ec7a2dd6f470ebee1306b8aebcfb7 a79d87aff8834b91a74ae5bd51507b27--1e0ec7a2dd6f470ebee1306b8aebcfb7 213665bac1b545729ec15043e18eda35 1e0ec7a2dd6f470ebee1306b8aebcfb7--213665bac1b545729ec15043e18eda35 a0255c01039f4665859f9366936a7965 213665bac1b545729ec15043e18eda35--a0255c01039f4665859f9366936a7965 ed3d0f694d42472587c0ff19000b1e72 a0255c01039f4665859f9366936a7965--ed3d0f694d42472587c0ff19000b1e72 d96be3bd3d8945298782ad80b45f57b0 ed3d0f694d42472587c0ff19000b1e72--d96be3bd3d8945298782ad80b45f57b0 7710405f7f584e45a4ac2d08b0521265 RX(b10) d96be3bd3d8945298782ad80b45f57b0--7710405f7f584e45a4ac2d08b0521265 3c6c5c91b4e14661892a61ef45cd8f00 7710405f7f584e45a4ac2d08b0521265--3c6c5c91b4e14661892a61ef45cd8f00 49cf43f90e434ec6a8eb9b84e875abf8 ee04b3fc1bbb4f4bae3b9972aae93af0 X 1211593c6d5d4a6bb7ac344aaf769640--ee04b3fc1bbb4f4bae3b9972aae93af0 fa369e0fbbce4e3f827448da4f7e33b6 2 ee04b3fc1bbb4f4bae3b9972aae93af0--998eb0b72027408aa6657aecb76fe8ca 8aa5214fde2f421dbadaaaf519f8f768 ee04b3fc1bbb4f4bae3b9972aae93af0--8aa5214fde2f421dbadaaaf519f8f768 1059fbf4c6dd4f4eb5bf39d8a7e8828b 8aa5214fde2f421dbadaaaf519f8f768--1059fbf4c6dd4f4eb5bf39d8a7e8828b 6e58e2eb6d804aad8c1f00be061598dc 1059fbf4c6dd4f4eb5bf39d8a7e8828b--6e58e2eb6d804aad8c1f00be061598dc 59d04d3d5ebd4258bbe587fadba60ad5 6e58e2eb6d804aad8c1f00be061598dc--59d04d3d5ebd4258bbe587fadba60ad5 e02cb784a348406392191ab4919664ea 59d04d3d5ebd4258bbe587fadba60ad5--e02cb784a348406392191ab4919664ea 4601af5e985f4e108d480f9901158067 e02cb784a348406392191ab4919664ea--4601af5e985f4e108d480f9901158067 eea8df504cdb4863b20c9eb43f8a2323 4601af5e985f4e108d480f9901158067--eea8df504cdb4863b20c9eb43f8a2323 4132ed9f96004a5a86fae9f4f97fd9e3 eea8df504cdb4863b20c9eb43f8a2323--4132ed9f96004a5a86fae9f4f97fd9e3 a64ec5e911c6402fb94b5224f25a2cb3 4132ed9f96004a5a86fae9f4f97fd9e3--a64ec5e911c6402fb94b5224f25a2cb3 23df3d75c54d4c6989c2910fcf083b38 a64ec5e911c6402fb94b5224f25a2cb3--23df3d75c54d4c6989c2910fcf083b38 a2f22da9328b43d9b6426785d0a0169c 23df3d75c54d4c6989c2910fcf083b38--a2f22da9328b43d9b6426785d0a0169c db70fa84e89641a790b1ab49d16056c9 a2f22da9328b43d9b6426785d0a0169c--db70fa84e89641a790b1ab49d16056c9 7b2db80c706e47e5ae30dd5d985e1738 db70fa84e89641a790b1ab49d16056c9--7b2db80c706e47e5ae30dd5d985e1738 d62bbad64d07424cb923cac60609f7e5 X 7b2db80c706e47e5ae30dd5d985e1738--d62bbad64d07424cb923cac60609f7e5 d62bbad64d07424cb923cac60609f7e5--0f94fbd742eb4d30a32efb9dc219ba02 f1609f7c99b04ec1808761aef578d854 X d62bbad64d07424cb923cac60609f7e5--f1609f7c99b04ec1808761aef578d854 f1609f7c99b04ec1808761aef578d854--cd0e0c62d47b419a9b9a59974babf916 491e0870fde9486798946df152dcccc3 RZ(-1.0*g0) f1609f7c99b04ec1808761aef578d854--491e0870fde9486798946df152dcccc3 945c21e3ddcf4688beba78013bbc4c58 X 491e0870fde9486798946df152dcccc3--945c21e3ddcf4688beba78013bbc4c58 945c21e3ddcf4688beba78013bbc4c58--602c961611714eae8b73142aeb7f13e1 725a7af142f5434582f5e3323f9e65c1 X 945c21e3ddcf4688beba78013bbc4c58--725a7af142f5434582f5e3323f9e65c1 725a7af142f5434582f5e3323f9e65c1--d8f478be26b942a6bd5619eb35d60716 cfc60f6b404f4465bd0b5b3671ea1e9f 725a7af142f5434582f5e3323f9e65c1--cfc60f6b404f4465bd0b5b3671ea1e9f 5bfe631ef03148398d9ed8390c4a82d8 cfc60f6b404f4465bd0b5b3671ea1e9f--5bfe631ef03148398d9ed8390c4a82d8 7257a144c4604dfe999cee1d8b00fff7 5bfe631ef03148398d9ed8390c4a82d8--7257a144c4604dfe999cee1d8b00fff7 9ebea577450e4d8488331124ee1c7d25 X 7257a144c4604dfe999cee1d8b00fff7--9ebea577450e4d8488331124ee1c7d25 9ebea577450e4d8488331124ee1c7d25--45fdf19434ea495ab4b51bf8d1fe39e9 b3112f5879e546769f470326437f4621 X 9ebea577450e4d8488331124ee1c7d25--b3112f5879e546769f470326437f4621 b3112f5879e546769f470326437f4621--c5411198636d40deb8b1dc7f9d69db9f dbde5de26d2548049a6a2c0fa1576ba9 b3112f5879e546769f470326437f4621--dbde5de26d2548049a6a2c0fa1576ba9 8fc9bba20c594831828e86fe38487414 dbde5de26d2548049a6a2c0fa1576ba9--8fc9bba20c594831828e86fe38487414 6a7c9949857f45898ba68820d707ee4c 8fc9bba20c594831828e86fe38487414--6a7c9949857f45898ba68820d707ee4c 8b8153687907435b86fcbe692c25ff0c 6a7c9949857f45898ba68820d707ee4c--8b8153687907435b86fcbe692c25ff0c 57245c10c3c449ccbc50efe757905132 8b8153687907435b86fcbe692c25ff0c--57245c10c3c449ccbc50efe757905132 465045cb0ce94d988c7ba791be066f8a X 57245c10c3c449ccbc50efe757905132--465045cb0ce94d988c7ba791be066f8a 465045cb0ce94d988c7ba791be066f8a--fb4dd7b5b5864c08a245d5738ab28ddb f2b185720bc44eefb75c5ff07574b547 X 465045cb0ce94d988c7ba791be066f8a--f2b185720bc44eefb75c5ff07574b547 f2b185720bc44eefb75c5ff07574b547--cf2fa1e536e340beb5745ff59053ef08 d38c325fc524466296a0be64d65ee93d f2b185720bc44eefb75c5ff07574b547--d38c325fc524466296a0be64d65ee93d 4857128aacb4402f932f72a22632f2e0 d38c325fc524466296a0be64d65ee93d--4857128aacb4402f932f72a22632f2e0 365149c18f79419c9017bd811568f139 4857128aacb4402f932f72a22632f2e0--365149c18f79419c9017bd811568f139 f8a9860cdc734cf087220673916a05a4 365149c18f79419c9017bd811568f139--f8a9860cdc734cf087220673916a05a4 df0a2a6c6c244c7d866e6d1dacd637f8 f8a9860cdc734cf087220673916a05a4--df0a2a6c6c244c7d866e6d1dacd637f8 8f5cecc869ce44a2ae2a15b789b0f9c0 df0a2a6c6c244c7d866e6d1dacd637f8--8f5cecc869ce44a2ae2a15b789b0f9c0 3ebd5988ebfc452094c524207d25fed0 8f5cecc869ce44a2ae2a15b789b0f9c0--3ebd5988ebfc452094c524207d25fed0 4e589842b9194d818bb22a03a324306e X 3ebd5988ebfc452094c524207d25fed0--4e589842b9194d818bb22a03a324306e 4e589842b9194d818bb22a03a324306e--0ad078a91c0a470589c190b3f545700d 7154f0c3348b4968afb295509c670277 X 4e589842b9194d818bb22a03a324306e--7154f0c3348b4968afb295509c670277 7154f0c3348b4968afb295509c670277--90e25773539147e1ba95ee78c97453fc 0013aa2f60734a4cb089555d3894c938 7154f0c3348b4968afb295509c670277--0013aa2f60734a4cb089555d3894c938 f3ac136132ac439fbbbecfc1cf14c1c2 0013aa2f60734a4cb089555d3894c938--f3ac136132ac439fbbbecfc1cf14c1c2 b7f61bba465340209f4a4f0ca385739d f3ac136132ac439fbbbecfc1cf14c1c2--b7f61bba465340209f4a4f0ca385739d 921daf23c0674d26841a425088fde408 b7f61bba465340209f4a4f0ca385739d--921daf23c0674d26841a425088fde408 735d855b8a9d4726921e99281193567c 921daf23c0674d26841a425088fde408--735d855b8a9d4726921e99281193567c a4300db50d604748b6a9586f107b3a7c 735d855b8a9d4726921e99281193567c--a4300db50d604748b6a9586f107b3a7c 1f544c3970c04b0cba228be51119c6bb a4300db50d604748b6a9586f107b3a7c--1f544c3970c04b0cba228be51119c6bb c541cccd40ad47cca244849769da1463 1f544c3970c04b0cba228be51119c6bb--c541cccd40ad47cca244849769da1463 3e2174cf6e8d4ded9429fbdcf2a7f8f1 c541cccd40ad47cca244849769da1463--3e2174cf6e8d4ded9429fbdcf2a7f8f1 4340fffdd7354d8082622159dd517622 3e2174cf6e8d4ded9429fbdcf2a7f8f1--4340fffdd7354d8082622159dd517622 daf652080398452a942ca017b0fcdf0c 4340fffdd7354d8082622159dd517622--daf652080398452a942ca017b0fcdf0c 7857d7788b024f609e588f810af39237 X daf652080398452a942ca017b0fcdf0c--7857d7788b024f609e588f810af39237 7857d7788b024f609e588f810af39237--264fc73f68514a07b2505940b2a654ae b7e5a85caed64b319e297ba02bfd3010 7857d7788b024f609e588f810af39237--b7e5a85caed64b319e297ba02bfd3010 9648cf0513e14c5192b0f2c37d4d98d4 b7e5a85caed64b319e297ba02bfd3010--9648cf0513e14c5192b0f2c37d4d98d4 2fcbd54079774f9b92744d378ad5d366 9648cf0513e14c5192b0f2c37d4d98d4--2fcbd54079774f9b92744d378ad5d366 e57cabb5a0fb476ea058ee99b52a4468 2fcbd54079774f9b92744d378ad5d366--e57cabb5a0fb476ea058ee99b52a4468 ab671ce03b644c8abccec8992ff01bc6 e57cabb5a0fb476ea058ee99b52a4468--ab671ce03b644c8abccec8992ff01bc6 762197024b0b46d09da764bac7e1ab42 ab671ce03b644c8abccec8992ff01bc6--762197024b0b46d09da764bac7e1ab42 d305efb248924cbcbbcba262b21b4a9b 762197024b0b46d09da764bac7e1ab42--d305efb248924cbcbbcba262b21b4a9b 549d9157b970444bbbba87789d71d9f3 d305efb248924cbcbbcba262b21b4a9b--549d9157b970444bbbba87789d71d9f3 65b73081fa114182a70aa0af6f5e44ce 549d9157b970444bbbba87789d71d9f3--65b73081fa114182a70aa0af6f5e44ce 2c34e37e6a674e909894a53b871bedc3 65b73081fa114182a70aa0af6f5e44ce--2c34e37e6a674e909894a53b871bedc3 39a73a0f8bbc44cc83e9ba5fef57a166 2c34e37e6a674e909894a53b871bedc3--39a73a0f8bbc44cc83e9ba5fef57a166 b6107359c97e4b8a8adbc2ece64d54a7 39a73a0f8bbc44cc83e9ba5fef57a166--b6107359c97e4b8a8adbc2ece64d54a7 867e3babbec2410da53d1dd5f768ab11 b6107359c97e4b8a8adbc2ece64d54a7--867e3babbec2410da53d1dd5f768ab11 33387d6aeac04c7f91cc911995c2974e 867e3babbec2410da53d1dd5f768ab11--33387d6aeac04c7f91cc911995c2974e 0595e325e8fe413193c932d33611a4d1 33387d6aeac04c7f91cc911995c2974e--0595e325e8fe413193c932d33611a4d1 9f238592313e4b1e8ec08e2f4bc3191c 0595e325e8fe413193c932d33611a4d1--9f238592313e4b1e8ec08e2f4bc3191c 8ef7fa5a806b43a48eba4400b5ac8cde 9f238592313e4b1e8ec08e2f4bc3191c--8ef7fa5a806b43a48eba4400b5ac8cde f4271934fa944dd7bf16ea45dc25f26d 8ef7fa5a806b43a48eba4400b5ac8cde--f4271934fa944dd7bf16ea45dc25f26d b7478a1ca834436e97ab6bfe38e2e6e0 f4271934fa944dd7bf16ea45dc25f26d--b7478a1ca834436e97ab6bfe38e2e6e0 66f149ab8e5c4080bff6aa7b3600f1f6 b7478a1ca834436e97ab6bfe38e2e6e0--66f149ab8e5c4080bff6aa7b3600f1f6 df35412eb7564dfe866eec11276bfa74 66f149ab8e5c4080bff6aa7b3600f1f6--df35412eb7564dfe866eec11276bfa74 bdc4345ca94a4718b615e1678c63a708 df35412eb7564dfe866eec11276bfa74--bdc4345ca94a4718b615e1678c63a708 ba3b534cb6b04eb5a2faa89fcc30e899 bdc4345ca94a4718b615e1678c63a708--ba3b534cb6b04eb5a2faa89fcc30e899 af363d6248a3457cb5e09a040940c8f7 ba3b534cb6b04eb5a2faa89fcc30e899--af363d6248a3457cb5e09a040940c8f7 503513429a0c4779b2dfcecf8ea08317 af363d6248a3457cb5e09a040940c8f7--503513429a0c4779b2dfcecf8ea08317 93ee76f8e22942e1b66d216fc3bc2c23 503513429a0c4779b2dfcecf8ea08317--93ee76f8e22942e1b66d216fc3bc2c23 028024503a154382ae24a1b137e32cf3 93ee76f8e22942e1b66d216fc3bc2c23--028024503a154382ae24a1b137e32cf3 3d9bb8c3e5ea48e6b47d55eac59bedd6 028024503a154382ae24a1b137e32cf3--3d9bb8c3e5ea48e6b47d55eac59bedd6 dc272e8a8c92427cae1d8cf5b7dce836 3d9bb8c3e5ea48e6b47d55eac59bedd6--dc272e8a8c92427cae1d8cf5b7dce836 ef41e908a69e44fcb3175fa54840d7ac dc272e8a8c92427cae1d8cf5b7dce836--ef41e908a69e44fcb3175fa54840d7ac 97554e4b966e49c2a6852976cdf4a187 ef41e908a69e44fcb3175fa54840d7ac--97554e4b966e49c2a6852976cdf4a187 0ed72dd8f60041c993311b7d9c926bf8 97554e4b966e49c2a6852976cdf4a187--0ed72dd8f60041c993311b7d9c926bf8 ad67437f5c3b4d9bb837fd4895f3e097 0ed72dd8f60041c993311b7d9c926bf8--ad67437f5c3b4d9bb837fd4895f3e097 d33bd8c2b1684274bbadca15d62805ce ad67437f5c3b4d9bb837fd4895f3e097--d33bd8c2b1684274bbadca15d62805ce 8c23eff30ebc4501ab819b070ddc96f1 d33bd8c2b1684274bbadca15d62805ce--8c23eff30ebc4501ab819b070ddc96f1 67b063efb8734c5da512d7c1161894ae 8c23eff30ebc4501ab819b070ddc96f1--67b063efb8734c5da512d7c1161894ae 7afa5be8c3a0461aaf50bbfb6a2e06db 67b063efb8734c5da512d7c1161894ae--7afa5be8c3a0461aaf50bbfb6a2e06db 32ab3710e2da492e84d04f1dc893bbe3 7afa5be8c3a0461aaf50bbfb6a2e06db--32ab3710e2da492e84d04f1dc893bbe3 7cecd30665a64c938206c1c94f44ec67 32ab3710e2da492e84d04f1dc893bbe3--7cecd30665a64c938206c1c94f44ec67 003a2051846145de97b674f98a643baa 7cecd30665a64c938206c1c94f44ec67--003a2051846145de97b674f98a643baa bb435a018358403c96011bd93c2e5171 003a2051846145de97b674f98a643baa--bb435a018358403c96011bd93c2e5171 1d52f9a2f393448caf6dd526631538ff bb435a018358403c96011bd93c2e5171--1d52f9a2f393448caf6dd526631538ff f6306d1237144f49bfa9aea515b64bac 1d52f9a2f393448caf6dd526631538ff--f6306d1237144f49bfa9aea515b64bac 7cafd5ccc394460b8e67470b95c31834 f6306d1237144f49bfa9aea515b64bac--7cafd5ccc394460b8e67470b95c31834 bd91e5d4c740426ba2e5e1cccb2925bd 7cafd5ccc394460b8e67470b95c31834--bd91e5d4c740426ba2e5e1cccb2925bd 1c74fbc43c654b86aafebc32cbb20308 bd91e5d4c740426ba2e5e1cccb2925bd--1c74fbc43c654b86aafebc32cbb20308 daa6d02369ee4489af8c8f5780844950 1c74fbc43c654b86aafebc32cbb20308--daa6d02369ee4489af8c8f5780844950 6e82f68696f746c9a043e007ab474736 daa6d02369ee4489af8c8f5780844950--6e82f68696f746c9a043e007ab474736 df58de325d3049b9a6a1438b591c5e08 6e82f68696f746c9a043e007ab474736--df58de325d3049b9a6a1438b591c5e08 9f45e6c71d7542a19a61cc5a60b6ccd2 df58de325d3049b9a6a1438b591c5e08--9f45e6c71d7542a19a61cc5a60b6ccd2 6e981a572da645fc8035ab4e27575e26 9f45e6c71d7542a19a61cc5a60b6ccd2--6e981a572da645fc8035ab4e27575e26 ea54938eb0ee466aba001b2cf7298c30 6e981a572da645fc8035ab4e27575e26--ea54938eb0ee466aba001b2cf7298c30 fc757cd2b2704db2ba0d32aeccef4c56 ea54938eb0ee466aba001b2cf7298c30--fc757cd2b2704db2ba0d32aeccef4c56 d43eefad898a4e86b165107b099a68ca fc757cd2b2704db2ba0d32aeccef4c56--d43eefad898a4e86b165107b099a68ca 33bd13d8a98f432fa7806e06357e54f9 d43eefad898a4e86b165107b099a68ca--33bd13d8a98f432fa7806e06357e54f9 4322fa7bc87e4911b7030c7f4fa08f3f 33bd13d8a98f432fa7806e06357e54f9--4322fa7bc87e4911b7030c7f4fa08f3f 0aaf2c12250a406b846d6e018d77c2b6 4322fa7bc87e4911b7030c7f4fa08f3f--0aaf2c12250a406b846d6e018d77c2b6 40812ecb69e14315bd028253325ae7ca 0aaf2c12250a406b846d6e018d77c2b6--40812ecb69e14315bd028253325ae7ca b4687acd6807465fab8d9d630af295a3 40812ecb69e14315bd028253325ae7ca--b4687acd6807465fab8d9d630af295a3 e4694fca0018460ba4993733a0197d37 b4687acd6807465fab8d9d630af295a3--e4694fca0018460ba4993733a0197d37 86d3ee9ad72e418ba83592901f30e711 e4694fca0018460ba4993733a0197d37--86d3ee9ad72e418ba83592901f30e711 9adc014b9b4842f49b76749431b07ef8 86d3ee9ad72e418ba83592901f30e711--9adc014b9b4842f49b76749431b07ef8 7fa411e42a3b4469a725e64a7c21ca85 9adc014b9b4842f49b76749431b07ef8--7fa411e42a3b4469a725e64a7c21ca85 cec4b4e58f3246ffa4444d88051e4dce 7fa411e42a3b4469a725e64a7c21ca85--cec4b4e58f3246ffa4444d88051e4dce 5f913a27da3a4301a06290e5bf65f32a cec4b4e58f3246ffa4444d88051e4dce--5f913a27da3a4301a06290e5bf65f32a 0838dd85372842dc9d8675851137332e 5f913a27da3a4301a06290e5bf65f32a--0838dd85372842dc9d8675851137332e b519a76464c24c65a09e045f6498e189 0838dd85372842dc9d8675851137332e--b519a76464c24c65a09e045f6498e189 9e3ae4dbba6a48e5b6627529a62a8b2f b519a76464c24c65a09e045f6498e189--9e3ae4dbba6a48e5b6627529a62a8b2f 99f3f8966b96469e8cab4a475c9f544c 9e3ae4dbba6a48e5b6627529a62a8b2f--99f3f8966b96469e8cab4a475c9f544c 54f1979236ba4d50b81aa9c82084610b 99f3f8966b96469e8cab4a475c9f544c--54f1979236ba4d50b81aa9c82084610b 883b923774384e1ab345b033b3f8c121 54f1979236ba4d50b81aa9c82084610b--883b923774384e1ab345b033b3f8c121 a531c00443e446c38a11e6c74ca9c718 RX(b01) 883b923774384e1ab345b033b3f8c121--a531c00443e446c38a11e6c74ca9c718 c816fb0970c944a2b182e8f627a7484f X a531c00443e446c38a11e6c74ca9c718--c816fb0970c944a2b182e8f627a7484f c816fb0970c944a2b182e8f627a7484f--572f19b08f94400ca7209a08b77391d4 26f1b3db5bc34280aeeeade08d466768 c816fb0970c944a2b182e8f627a7484f--26f1b3db5bc34280aeeeade08d466768 aafe543ed1204db89a398c66917aa7ed 26f1b3db5bc34280aeeeade08d466768--aafe543ed1204db89a398c66917aa7ed b5f0b8bc780f45fc9110d13322f9ca80 aafe543ed1204db89a398c66917aa7ed--b5f0b8bc780f45fc9110d13322f9ca80 d68afb764a884b789e1b682e39b03233 b5f0b8bc780f45fc9110d13322f9ca80--d68afb764a884b789e1b682e39b03233 1a7960bd43f74d2282150d7ce3fd3746 d68afb764a884b789e1b682e39b03233--1a7960bd43f74d2282150d7ce3fd3746 81208da660eb4d5db60b2342e0d44cc1 1a7960bd43f74d2282150d7ce3fd3746--81208da660eb4d5db60b2342e0d44cc1 469a3889e52a4283ac39619950a6a242 81208da660eb4d5db60b2342e0d44cc1--469a3889e52a4283ac39619950a6a242 e0a601656a8446478215b19a55724695 469a3889e52a4283ac39619950a6a242--e0a601656a8446478215b19a55724695 6a4c5d29860042ca97b7c05c6f79d378 e0a601656a8446478215b19a55724695--6a4c5d29860042ca97b7c05c6f79d378 ec055f23f1b9438284bec6b96579fe9f 6a4c5d29860042ca97b7c05c6f79d378--ec055f23f1b9438284bec6b96579fe9f 7be1464ce07f4e2c8ca1ba9f0f205c75 ec055f23f1b9438284bec6b96579fe9f--7be1464ce07f4e2c8ca1ba9f0f205c75 2628f20e37c5404e8183bc700d4a8fc6 7be1464ce07f4e2c8ca1ba9f0f205c75--2628f20e37c5404e8183bc700d4a8fc6 68823aaff96640a7885a3a8b9ec414d1 2628f20e37c5404e8183bc700d4a8fc6--68823aaff96640a7885a3a8b9ec414d1 54a9034da7114eb6a90169c99c31ec8c X 68823aaff96640a7885a3a8b9ec414d1--54a9034da7114eb6a90169c99c31ec8c 54a9034da7114eb6a90169c99c31ec8c--fa11865580a1439ab0f29485a48a0892 1b6a3d24ef0c4461b3232920045d518b X 54a9034da7114eb6a90169c99c31ec8c--1b6a3d24ef0c4461b3232920045d518b 1b6a3d24ef0c4461b3232920045d518b--4a5cccdd4364444fad1994bdedf654ec ad44c9d06e1c4fb39e7a00e693294a48 RZ(-1.0*g1) 1b6a3d24ef0c4461b3232920045d518b--ad44c9d06e1c4fb39e7a00e693294a48 0c4f8777fb7c4985a063092c0d7192f1 X ad44c9d06e1c4fb39e7a00e693294a48--0c4f8777fb7c4985a063092c0d7192f1 0c4f8777fb7c4985a063092c0d7192f1--8c5938008c9a45c69bfd8058b68d1d33 9f7b32157e7a4f298ccf7711100e2ac2 X 0c4f8777fb7c4985a063092c0d7192f1--9f7b32157e7a4f298ccf7711100e2ac2 9f7b32157e7a4f298ccf7711100e2ac2--bca4d25de94345da9838741bfbef0595 fe5d2ce7cfd44359afc620ccb6314b32 9f7b32157e7a4f298ccf7711100e2ac2--fe5d2ce7cfd44359afc620ccb6314b32 f1cb55a63cb34c8da5221fa5512ef8f4 fe5d2ce7cfd44359afc620ccb6314b32--f1cb55a63cb34c8da5221fa5512ef8f4 259c08f27f494072a3a966b027cbfff9 f1cb55a63cb34c8da5221fa5512ef8f4--259c08f27f494072a3a966b027cbfff9 efe92325ce324eb88555151ccdb6244d X 259c08f27f494072a3a966b027cbfff9--efe92325ce324eb88555151ccdb6244d efe92325ce324eb88555151ccdb6244d--fcf0f739c52f4815b54fa6e7172a4537 69dcfff9729d4d5fb7355701556a65e6 X efe92325ce324eb88555151ccdb6244d--69dcfff9729d4d5fb7355701556a65e6 69dcfff9729d4d5fb7355701556a65e6--6c92fae23a794174ae99c45a8cf571e8 59616988d22449bab683d805da503c94 69dcfff9729d4d5fb7355701556a65e6--59616988d22449bab683d805da503c94 72ee69f3458443f789c10cea8b17a22a 59616988d22449bab683d805da503c94--72ee69f3458443f789c10cea8b17a22a b396cce62f0f4264898b3443ad381de8 72ee69f3458443f789c10cea8b17a22a--b396cce62f0f4264898b3443ad381de8 d5cc07c6e48d4be8a3c9089b85c1ac5a b396cce62f0f4264898b3443ad381de8--d5cc07c6e48d4be8a3c9089b85c1ac5a a6b81f5bc45444ef96cbba812a2afee3 d5cc07c6e48d4be8a3c9089b85c1ac5a--a6b81f5bc45444ef96cbba812a2afee3 b3791c7f6f2641569cfc587c66ea5dd6 X a6b81f5bc45444ef96cbba812a2afee3--b3791c7f6f2641569cfc587c66ea5dd6 b3791c7f6f2641569cfc587c66ea5dd6--5401eb89b88c435ca595d76ee514e483 a6ca48b37c9143c39376df87d486a3e3 X b3791c7f6f2641569cfc587c66ea5dd6--a6ca48b37c9143c39376df87d486a3e3 a6ca48b37c9143c39376df87d486a3e3--3d415e9436874158afd3049417c29d9b f9e7d63d9c174ddbad0bcda4e20574ad a6ca48b37c9143c39376df87d486a3e3--f9e7d63d9c174ddbad0bcda4e20574ad d5b70820171e4955b32d146785512a36 f9e7d63d9c174ddbad0bcda4e20574ad--d5b70820171e4955b32d146785512a36 b8e5f007b6c64f78bf412b95b8feb03e d5b70820171e4955b32d146785512a36--b8e5f007b6c64f78bf412b95b8feb03e 0f02ff0bbc414d07a013ba0d7449e630 b8e5f007b6c64f78bf412b95b8feb03e--0f02ff0bbc414d07a013ba0d7449e630 7dc21b6ea9f94714be293bd9926f0d3f 0f02ff0bbc414d07a013ba0d7449e630--7dc21b6ea9f94714be293bd9926f0d3f 189f48904e7c4d9f9b1e820722785d5b 7dc21b6ea9f94714be293bd9926f0d3f--189f48904e7c4d9f9b1e820722785d5b 30c719f3c264447d84597014babddebc 189f48904e7c4d9f9b1e820722785d5b--30c719f3c264447d84597014babddebc 6625691a778a451887b6915c8556719f X 30c719f3c264447d84597014babddebc--6625691a778a451887b6915c8556719f 6625691a778a451887b6915c8556719f--7b8f55eb178b49b692f71f9f63f196cf 8a34f751dcca494189395f8d8859bd86 X 6625691a778a451887b6915c8556719f--8a34f751dcca494189395f8d8859bd86 8a34f751dcca494189395f8d8859bd86--eebc5bef66544b46969f89ab8f8ed74e 4b66c77790a4431781c48d1e303d8c77 8a34f751dcca494189395f8d8859bd86--4b66c77790a4431781c48d1e303d8c77 4059d00fe5d54325851b41aac3477744 4b66c77790a4431781c48d1e303d8c77--4059d00fe5d54325851b41aac3477744 d643aa3336d944209fb8687453c49242 4059d00fe5d54325851b41aac3477744--d643aa3336d944209fb8687453c49242 54001889df654db894cb031766d9b785 d643aa3336d944209fb8687453c49242--54001889df654db894cb031766d9b785 3d277dae9bdc40079c96cd77277d8fac 54001889df654db894cb031766d9b785--3d277dae9bdc40079c96cd77277d8fac 118eab76506745a6a67e40f9f83a6171 3d277dae9bdc40079c96cd77277d8fac--118eab76506745a6a67e40f9f83a6171 69d8cc2e7b6f4485aff5ba70227155bd 118eab76506745a6a67e40f9f83a6171--69d8cc2e7b6f4485aff5ba70227155bd db89c5c0d47b40eb8c3de324c5681175 69d8cc2e7b6f4485aff5ba70227155bd--db89c5c0d47b40eb8c3de324c5681175 777c4cd78a154c23a458f1ada95ecc3e db89c5c0d47b40eb8c3de324c5681175--777c4cd78a154c23a458f1ada95ecc3e efdc742ce0c948f7bfdcf6d93e543a0c 777c4cd78a154c23a458f1ada95ecc3e--efdc742ce0c948f7bfdcf6d93e543a0c 35868a910eee499e92e7449e341e8bd3 efdc742ce0c948f7bfdcf6d93e543a0c--35868a910eee499e92e7449e341e8bd3 19f65578ee3b495f981278a0a8f53ae7 X 35868a910eee499e92e7449e341e8bd3--19f65578ee3b495f981278a0a8f53ae7 19f65578ee3b495f981278a0a8f53ae7--a182b20abe90499a96cf6a97b9744b09 d5b2e5aac7cb46bf8b8567b5df4e2eb1 19f65578ee3b495f981278a0a8f53ae7--d5b2e5aac7cb46bf8b8567b5df4e2eb1 3ea94c775155463e95158abd740a3d0b d5b2e5aac7cb46bf8b8567b5df4e2eb1--3ea94c775155463e95158abd740a3d0b 056c5ba2bf854d49b92e3889e9f85909 3ea94c775155463e95158abd740a3d0b--056c5ba2bf854d49b92e3889e9f85909 b7311f4f043f4a47803b5aa5cfe412ed 056c5ba2bf854d49b92e3889e9f85909--b7311f4f043f4a47803b5aa5cfe412ed cb2da72a77ec4bfe962ec2f394d5e4a2 b7311f4f043f4a47803b5aa5cfe412ed--cb2da72a77ec4bfe962ec2f394d5e4a2 93f7636c91fa4919b1ad4800fe96b2a0 cb2da72a77ec4bfe962ec2f394d5e4a2--93f7636c91fa4919b1ad4800fe96b2a0 bbea560e57424fb7b94a22641778fc74 93f7636c91fa4919b1ad4800fe96b2a0--bbea560e57424fb7b94a22641778fc74 fc543fb9b84644bbae1e036c00b00353 bbea560e57424fb7b94a22641778fc74--fc543fb9b84644bbae1e036c00b00353 95151d61d8624988ba4958cedadf0154 fc543fb9b84644bbae1e036c00b00353--95151d61d8624988ba4958cedadf0154 623f688426874708971af1fade150d66 95151d61d8624988ba4958cedadf0154--623f688426874708971af1fade150d66 7af3993bd10b426fb6ac1812d11425b9 623f688426874708971af1fade150d66--7af3993bd10b426fb6ac1812d11425b9 8e2e4c8323da4f1085e8b1a7628d38f4 7af3993bd10b426fb6ac1812d11425b9--8e2e4c8323da4f1085e8b1a7628d38f4 440102ef903e4c87871f1703d48f4b4a 8e2e4c8323da4f1085e8b1a7628d38f4--440102ef903e4c87871f1703d48f4b4a 434703d7b2524df38d8bcd2d37d542ea 440102ef903e4c87871f1703d48f4b4a--434703d7b2524df38d8bcd2d37d542ea 8fb3b5366a904c3197f06f033b7afa9f 434703d7b2524df38d8bcd2d37d542ea--8fb3b5366a904c3197f06f033b7afa9f dc5c054e2bc84738ad240f2ffa902102 8fb3b5366a904c3197f06f033b7afa9f--dc5c054e2bc84738ad240f2ffa902102 59ff64c0f4dc427680b57517e8d0b6dc dc5c054e2bc84738ad240f2ffa902102--59ff64c0f4dc427680b57517e8d0b6dc 5d08bcb0479340038456c715502f1300 59ff64c0f4dc427680b57517e8d0b6dc--5d08bcb0479340038456c715502f1300 95649aa771c744b49beac18697f825de 5d08bcb0479340038456c715502f1300--95649aa771c744b49beac18697f825de 79c918419d854e37be6a536c23434e4d 95649aa771c744b49beac18697f825de--79c918419d854e37be6a536c23434e4d 05f7fcf71b884ac7b673355453abbb95 79c918419d854e37be6a536c23434e4d--05f7fcf71b884ac7b673355453abbb95 ab13605ff4b24f57b3ffa2e2e8152e4d 05f7fcf71b884ac7b673355453abbb95--ab13605ff4b24f57b3ffa2e2e8152e4d 23610667e79841cb94f90293b5337a9c ab13605ff4b24f57b3ffa2e2e8152e4d--23610667e79841cb94f90293b5337a9c f1313a9eba28407c9a51330a00437d7f 23610667e79841cb94f90293b5337a9c--f1313a9eba28407c9a51330a00437d7f acfda005bd244488923d463e2f6fadbe f1313a9eba28407c9a51330a00437d7f--acfda005bd244488923d463e2f6fadbe 732c6222b6d44ae28feea6d3ab230081 acfda005bd244488923d463e2f6fadbe--732c6222b6d44ae28feea6d3ab230081 7d1298e8409848c0a9e917b61923fe43 732c6222b6d44ae28feea6d3ab230081--7d1298e8409848c0a9e917b61923fe43 72baf73948894c81a280cf26358efd58 7d1298e8409848c0a9e917b61923fe43--72baf73948894c81a280cf26358efd58 6c383d4731574609a70474955875156c 72baf73948894c81a280cf26358efd58--6c383d4731574609a70474955875156c 11b7f6f50cc24e1fb24a964c8d1d8cee 6c383d4731574609a70474955875156c--11b7f6f50cc24e1fb24a964c8d1d8cee 535ed3850183411794f382e3879b3d8c 11b7f6f50cc24e1fb24a964c8d1d8cee--535ed3850183411794f382e3879b3d8c a5d5aae7839d4ed5bbab89cadb0fb372 535ed3850183411794f382e3879b3d8c--a5d5aae7839d4ed5bbab89cadb0fb372 4a7a6a92522f418a9208e9ea26c13ccb a5d5aae7839d4ed5bbab89cadb0fb372--4a7a6a92522f418a9208e9ea26c13ccb 0390f30928ee47e99a0b0054e94a6e98 4a7a6a92522f418a9208e9ea26c13ccb--0390f30928ee47e99a0b0054e94a6e98 a23d2441ea6f42febd3d868accf8757e 0390f30928ee47e99a0b0054e94a6e98--a23d2441ea6f42febd3d868accf8757e 604cfd3299fa4443970f735f2c3ad469 a23d2441ea6f42febd3d868accf8757e--604cfd3299fa4443970f735f2c3ad469 2ebf4e640776413097b752891866844b 604cfd3299fa4443970f735f2c3ad469--2ebf4e640776413097b752891866844b a508f9afeb4a4d75abea109f0d150e37 2ebf4e640776413097b752891866844b--a508f9afeb4a4d75abea109f0d150e37 e59c4749799e435b8da3aa9e19bb3f6e a508f9afeb4a4d75abea109f0d150e37--e59c4749799e435b8da3aa9e19bb3f6e 9edaec00a4b7420fb6690fdc92084c1e e59c4749799e435b8da3aa9e19bb3f6e--9edaec00a4b7420fb6690fdc92084c1e af4d146774af4c8182c487840fab8c05 9edaec00a4b7420fb6690fdc92084c1e--af4d146774af4c8182c487840fab8c05 7d00affe342e40678c38ee13290fe9a2 af4d146774af4c8182c487840fab8c05--7d00affe342e40678c38ee13290fe9a2 2206a2a9d4e847c9938a5fe5382f8071 7d00affe342e40678c38ee13290fe9a2--2206a2a9d4e847c9938a5fe5382f8071 1d360e39d8d746eabd1fbeab5e27c6c5 2206a2a9d4e847c9938a5fe5382f8071--1d360e39d8d746eabd1fbeab5e27c6c5 5eeae439ef8f4380ad71b54df6e87b18 1d360e39d8d746eabd1fbeab5e27c6c5--5eeae439ef8f4380ad71b54df6e87b18 c094aaac88844545ae8eb8dae0321e21 5eeae439ef8f4380ad71b54df6e87b18--c094aaac88844545ae8eb8dae0321e21 56386ef5550b43708e84687cc7ce6e49 c094aaac88844545ae8eb8dae0321e21--56386ef5550b43708e84687cc7ce6e49 fccc22b148a14a8b9a88a713c5f56e86 56386ef5550b43708e84687cc7ce6e49--fccc22b148a14a8b9a88a713c5f56e86 ff8d16a6fce44aa196864dec042f1e62 fccc22b148a14a8b9a88a713c5f56e86--ff8d16a6fce44aa196864dec042f1e62 744639641e254f139b76b49152f2b928 ff8d16a6fce44aa196864dec042f1e62--744639641e254f139b76b49152f2b928 92fc35cdb4004549a9062bff14efcab0 744639641e254f139b76b49152f2b928--92fc35cdb4004549a9062bff14efcab0 97d4cc0e32af467caccf195a47eee105 92fc35cdb4004549a9062bff14efcab0--97d4cc0e32af467caccf195a47eee105 284be7a7394147d1bdb953f5bda0b00b 97d4cc0e32af467caccf195a47eee105--284be7a7394147d1bdb953f5bda0b00b f412881ee8364277a0899ec57c3c9c94 284be7a7394147d1bdb953f5bda0b00b--f412881ee8364277a0899ec57c3c9c94 f26ce5cc429c47b0b92a7cb478ea70ff f412881ee8364277a0899ec57c3c9c94--f26ce5cc429c47b0b92a7cb478ea70ff aafd1384db2a449e80fa1686a1b38fbb f26ce5cc429c47b0b92a7cb478ea70ff--aafd1384db2a449e80fa1686a1b38fbb 37d3ff4c37354efe8b6babd9a4abae05 aafd1384db2a449e80fa1686a1b38fbb--37d3ff4c37354efe8b6babd9a4abae05 bcc838a2590d4280a2e79bac945ccc76 37d3ff4c37354efe8b6babd9a4abae05--bcc838a2590d4280a2e79bac945ccc76 f89e5a7d36ae4f259ed42d9aac841fb8 bcc838a2590d4280a2e79bac945ccc76--f89e5a7d36ae4f259ed42d9aac841fb8 dd4ff10922274cbdb4b22040b24c0e87 f89e5a7d36ae4f259ed42d9aac841fb8--dd4ff10922274cbdb4b22040b24c0e87 08cf9daa57ff4366b43db9cb7730c23b dd4ff10922274cbdb4b22040b24c0e87--08cf9daa57ff4366b43db9cb7730c23b be3cdbaedb664bda8232a324501ca235 08cf9daa57ff4366b43db9cb7730c23b--be3cdbaedb664bda8232a324501ca235 b41ba04aa1fd467fa0e03634bf1ad9b6 be3cdbaedb664bda8232a324501ca235--b41ba04aa1fd467fa0e03634bf1ad9b6 4c88529011054a248f451e58242b7ede b41ba04aa1fd467fa0e03634bf1ad9b6--4c88529011054a248f451e58242b7ede 80ecf63c6aca489a80f69df273452727 4c88529011054a248f451e58242b7ede--80ecf63c6aca489a80f69df273452727 7c355411f4e8462ba06358bdd23624bb 80ecf63c6aca489a80f69df273452727--7c355411f4e8462ba06358bdd23624bb a1d3d28c0ce94126b92a0d94e24fe23c 7c355411f4e8462ba06358bdd23624bb--a1d3d28c0ce94126b92a0d94e24fe23c e6fc42ebb9f4482ebf594f49c375b3a8 a1d3d28c0ce94126b92a0d94e24fe23c--e6fc42ebb9f4482ebf594f49c375b3a8 33fbc6d3176b4455a763995be6ef887b e6fc42ebb9f4482ebf594f49c375b3a8--33fbc6d3176b4455a763995be6ef887b aa8dbd506cdc4441b59ffed870985cca 33fbc6d3176b4455a763995be6ef887b--aa8dbd506cdc4441b59ffed870985cca fd032f53ba6a4111a0b9f613702c3f1d aa8dbd506cdc4441b59ffed870985cca--fd032f53ba6a4111a0b9f613702c3f1d b5976698003248ffb70a58f61964364f RX(b11) fd032f53ba6a4111a0b9f613702c3f1d--b5976698003248ffb70a58f61964364f b5976698003248ffb70a58f61964364f--49cf43f90e434ec6a8eb9b84e875abf8 fc845b9084334b99b8a6d1ece2ab060c 1a231286ad624e91b3aeb94017b14c02 fa369e0fbbce4e3f827448da4f7e33b6--1a231286ad624e91b3aeb94017b14c02 6d4d6caed8124622be2e882ed9a49829 3 2056de7ef5ae4f38bde2e4e9abfdeeee X 1a231286ad624e91b3aeb94017b14c02--2056de7ef5ae4f38bde2e4e9abfdeeee 2056de7ef5ae4f38bde2e4e9abfdeeee--8aa5214fde2f421dbadaaaf519f8f768 8c21e905ee994f01a163056a89fc5753 2056de7ef5ae4f38bde2e4e9abfdeeee--8c21e905ee994f01a163056a89fc5753 3a8df6ea3e6241b399ad0980ed1cc33a 8c21e905ee994f01a163056a89fc5753--3a8df6ea3e6241b399ad0980ed1cc33a 85afd2eb98ed4bffad24fb8c1f1b981b 3a8df6ea3e6241b399ad0980ed1cc33a--85afd2eb98ed4bffad24fb8c1f1b981b 7848610f1c7d47f184d983919109b46b 85afd2eb98ed4bffad24fb8c1f1b981b--7848610f1c7d47f184d983919109b46b c55bf06d6e3642fbb32133f2279867b8 7848610f1c7d47f184d983919109b46b--c55bf06d6e3642fbb32133f2279867b8 e4af058e4ca34041a0f1c4aa37950dda c55bf06d6e3642fbb32133f2279867b8--e4af058e4ca34041a0f1c4aa37950dda 155b69631672451190b4324c9602a062 e4af058e4ca34041a0f1c4aa37950dda--155b69631672451190b4324c9602a062 cc00833b75244d9db0c47e244e6fa832 155b69631672451190b4324c9602a062--cc00833b75244d9db0c47e244e6fa832 43b1faaa67a94ec2946cddce6149c244 cc00833b75244d9db0c47e244e6fa832--43b1faaa67a94ec2946cddce6149c244 6a8efd191963467c9ebe607bdbc49fdd 43b1faaa67a94ec2946cddce6149c244--6a8efd191963467c9ebe607bdbc49fdd 6ca56b54e04c455aa639932ea1c8e601 6a8efd191963467c9ebe607bdbc49fdd--6ca56b54e04c455aa639932ea1c8e601 49569403b978486a96bd2c5ee344fdb3 X 6ca56b54e04c455aa639932ea1c8e601--49569403b978486a96bd2c5ee344fdb3 49569403b978486a96bd2c5ee344fdb3--7b2db80c706e47e5ae30dd5d985e1738 1ca9e602ca5848f8bd2dd3b271c0383d 49569403b978486a96bd2c5ee344fdb3--1ca9e602ca5848f8bd2dd3b271c0383d 22e0a27528db48508b181f24e8976abc 1ca9e602ca5848f8bd2dd3b271c0383d--22e0a27528db48508b181f24e8976abc df30f2a6a6c44c26a861d71fb28e18c2 22e0a27528db48508b181f24e8976abc--df30f2a6a6c44c26a861d71fb28e18c2 e22bde26118041629ca348316b454a6b df30f2a6a6c44c26a861d71fb28e18c2--e22bde26118041629ca348316b454a6b a0b7578e0d5c49ac8dbcf74ca93f28b6 e22bde26118041629ca348316b454a6b--a0b7578e0d5c49ac8dbcf74ca93f28b6 636eeaf9e2ff4e748972dfb5b1afd3e7 X a0b7578e0d5c49ac8dbcf74ca93f28b6--636eeaf9e2ff4e748972dfb5b1afd3e7 636eeaf9e2ff4e748972dfb5b1afd3e7--cfc60f6b404f4465bd0b5b3671ea1e9f 8e292af30cb54f3d8c817dca068a7380 RZ(-1.0*g0) 636eeaf9e2ff4e748972dfb5b1afd3e7--8e292af30cb54f3d8c817dca068a7380 0894d13d013f46cc8cfd15815577477b X 8e292af30cb54f3d8c817dca068a7380--0894d13d013f46cc8cfd15815577477b 0894d13d013f46cc8cfd15815577477b--7257a144c4604dfe999cee1d8b00fff7 a9944fe3265b4274a81fd5fde80dc583 0894d13d013f46cc8cfd15815577477b--a9944fe3265b4274a81fd5fde80dc583 844b08cdfc2243f68794d6a95a34b5c3 a9944fe3265b4274a81fd5fde80dc583--844b08cdfc2243f68794d6a95a34b5c3 f86afe97241f4a9180c8fc6bfc1ee500 X 844b08cdfc2243f68794d6a95a34b5c3--f86afe97241f4a9180c8fc6bfc1ee500 f86afe97241f4a9180c8fc6bfc1ee500--dbde5de26d2548049a6a2c0fa1576ba9 05f757c339e24883a4dcf1f754e2ec85 f86afe97241f4a9180c8fc6bfc1ee500--05f757c339e24883a4dcf1f754e2ec85 4fc5fda8a9f84cc58f2af95078790cbd 05f757c339e24883a4dcf1f754e2ec85--4fc5fda8a9f84cc58f2af95078790cbd b343db0cb47e425cb1f21fabea8f58de 4fc5fda8a9f84cc58f2af95078790cbd--b343db0cb47e425cb1f21fabea8f58de ca1de354869c487c96c778d1ed0f02fe X b343db0cb47e425cb1f21fabea8f58de--ca1de354869c487c96c778d1ed0f02fe ca1de354869c487c96c778d1ed0f02fe--57245c10c3c449ccbc50efe757905132 702e5405d46a47aba7e2a80c9f94eda0 ca1de354869c487c96c778d1ed0f02fe--702e5405d46a47aba7e2a80c9f94eda0 16254cacfceb4919a5cfa81ba5ee1efb 702e5405d46a47aba7e2a80c9f94eda0--16254cacfceb4919a5cfa81ba5ee1efb 4beb973c4913464fbe27ff501773ed50 X 16254cacfceb4919a5cfa81ba5ee1efb--4beb973c4913464fbe27ff501773ed50 4beb973c4913464fbe27ff501773ed50--d38c325fc524466296a0be64d65ee93d e1527e947e514ad4ba32f111e7b824c8 4beb973c4913464fbe27ff501773ed50--e1527e947e514ad4ba32f111e7b824c8 cd6a0b6a2ed743da85501f1114b685d7 e1527e947e514ad4ba32f111e7b824c8--cd6a0b6a2ed743da85501f1114b685d7 66125fe919124fa09e925039b23de77f cd6a0b6a2ed743da85501f1114b685d7--66125fe919124fa09e925039b23de77f 9bcd5b01ac5840588b00becf81b8f866 66125fe919124fa09e925039b23de77f--9bcd5b01ac5840588b00becf81b8f866 f10a643cb5fc4bc584a9e0c6ecd3d820 9bcd5b01ac5840588b00becf81b8f866--f10a643cb5fc4bc584a9e0c6ecd3d820 80fbbd0454544745aa28b73833821463 X f10a643cb5fc4bc584a9e0c6ecd3d820--80fbbd0454544745aa28b73833821463 80fbbd0454544745aa28b73833821463--3ebd5988ebfc452094c524207d25fed0 78436f0b2a304da887f6b24e0219da4f 80fbbd0454544745aa28b73833821463--78436f0b2a304da887f6b24e0219da4f a074b516a8ce49d5a0a11039e29969c2 78436f0b2a304da887f6b24e0219da4f--a074b516a8ce49d5a0a11039e29969c2 28a8c5498c5c41a6a0cd288ad2ad3197 X a074b516a8ce49d5a0a11039e29969c2--28a8c5498c5c41a6a0cd288ad2ad3197 28a8c5498c5c41a6a0cd288ad2ad3197--0013aa2f60734a4cb089555d3894c938 b4c91b03a34147fe828b5a4bcfa73897 28a8c5498c5c41a6a0cd288ad2ad3197--b4c91b03a34147fe828b5a4bcfa73897 fe343cfddc0149e99f08868214ff2b45 b4c91b03a34147fe828b5a4bcfa73897--fe343cfddc0149e99f08868214ff2b45 6469f9c4f8c644ad99be9c3e268a9529 fe343cfddc0149e99f08868214ff2b45--6469f9c4f8c644ad99be9c3e268a9529 9aea6273d7e045ed8cb4977602052061 6469f9c4f8c644ad99be9c3e268a9529--9aea6273d7e045ed8cb4977602052061 ffe365cac8a24ba3b6c0a14f4bd2e65b 9aea6273d7e045ed8cb4977602052061--ffe365cac8a24ba3b6c0a14f4bd2e65b 71949e86ff57408e88cdc146ac7ef2af ffe365cac8a24ba3b6c0a14f4bd2e65b--71949e86ff57408e88cdc146ac7ef2af c16681d432354f25b5bee4d441a27002 71949e86ff57408e88cdc146ac7ef2af--c16681d432354f25b5bee4d441a27002 bc55c9fe22824eb990a764f4ffd3b03a c16681d432354f25b5bee4d441a27002--bc55c9fe22824eb990a764f4ffd3b03a fe33c7c4fa334b589ac7d397e10b3b8e bc55c9fe22824eb990a764f4ffd3b03a--fe33c7c4fa334b589ac7d397e10b3b8e 3bb525e36ae945cbb52a141877d1abd0 X fe33c7c4fa334b589ac7d397e10b3b8e--3bb525e36ae945cbb52a141877d1abd0 3bb525e36ae945cbb52a141877d1abd0--daf652080398452a942ca017b0fcdf0c a5d442b04f6d4555a3f4afb67b50cfc5 3bb525e36ae945cbb52a141877d1abd0--a5d442b04f6d4555a3f4afb67b50cfc5 8e65fbdbef82474f81cb52b6f65cc0bb X a5d442b04f6d4555a3f4afb67b50cfc5--8e65fbdbef82474f81cb52b6f65cc0bb 8e65fbdbef82474f81cb52b6f65cc0bb--b7e5a85caed64b319e297ba02bfd3010 a94a86bf14384e0f8da26d9095b51697 8e65fbdbef82474f81cb52b6f65cc0bb--a94a86bf14384e0f8da26d9095b51697 321eb7ccdb8e45e2893d88008ba58593 a94a86bf14384e0f8da26d9095b51697--321eb7ccdb8e45e2893d88008ba58593 afbabdc0a3f140908a0fb60d36809797 321eb7ccdb8e45e2893d88008ba58593--afbabdc0a3f140908a0fb60d36809797 a844af953d144decbcaf71ccd618c504 afbabdc0a3f140908a0fb60d36809797--a844af953d144decbcaf71ccd618c504 abb8753bf82148db8a66e330aa53032d a844af953d144decbcaf71ccd618c504--abb8753bf82148db8a66e330aa53032d f95800c9a9d74ee48fc8b690ffbd8db0 X abb8753bf82148db8a66e330aa53032d--f95800c9a9d74ee48fc8b690ffbd8db0 f95800c9a9d74ee48fc8b690ffbd8db0--d305efb248924cbcbbcba262b21b4a9b 311025c9496342ca96bf1ee52172d375 X f95800c9a9d74ee48fc8b690ffbd8db0--311025c9496342ca96bf1ee52172d375 311025c9496342ca96bf1ee52172d375--549d9157b970444bbbba87789d71d9f3 bbb6bcb17de5405d817444c1c25868aa 311025c9496342ca96bf1ee52172d375--bbb6bcb17de5405d817444c1c25868aa 7bbe81065bee41b88466087f699c7e3b bbb6bcb17de5405d817444c1c25868aa--7bbe81065bee41b88466087f699c7e3b 710aef23d8084d21b9ac8d3bbbcfdfb2 7bbe81065bee41b88466087f699c7e3b--710aef23d8084d21b9ac8d3bbbcfdfb2 e8da01f44ed5450f85f8f5a314e7397d 710aef23d8084d21b9ac8d3bbbcfdfb2--e8da01f44ed5450f85f8f5a314e7397d e7dc62a94b3743e985088fbc8c02cbf9 e8da01f44ed5450f85f8f5a314e7397d--e7dc62a94b3743e985088fbc8c02cbf9 1cfb20917c38409ba37f74a2f03efc32 e7dc62a94b3743e985088fbc8c02cbf9--1cfb20917c38409ba37f74a2f03efc32 2ae22766f5f04d55adf228367a2c8e6b 1cfb20917c38409ba37f74a2f03efc32--2ae22766f5f04d55adf228367a2c8e6b 7af46f272c214d9ca260b55c5a34e608 X 2ae22766f5f04d55adf228367a2c8e6b--7af46f272c214d9ca260b55c5a34e608 7af46f272c214d9ca260b55c5a34e608--9f238592313e4b1e8ec08e2f4bc3191c 4acc7fdaabda496989a6f6a0d5da0f27 X 7af46f272c214d9ca260b55c5a34e608--4acc7fdaabda496989a6f6a0d5da0f27 4acc7fdaabda496989a6f6a0d5da0f27--8ef7fa5a806b43a48eba4400b5ac8cde c582c42cb934464fae1d0e5a48eb268e 4acc7fdaabda496989a6f6a0d5da0f27--c582c42cb934464fae1d0e5a48eb268e 572b126928a24e2c89ade18907cd0cd4 c582c42cb934464fae1d0e5a48eb268e--572b126928a24e2c89ade18907cd0cd4 f47cc157c671455f965326fc17e63cf8 572b126928a24e2c89ade18907cd0cd4--f47cc157c671455f965326fc17e63cf8 316199a0004347dfb8a1005e099763c2 f47cc157c671455f965326fc17e63cf8--316199a0004347dfb8a1005e099763c2 f759d2ab8de34b4986dfc1d1e30b7917 316199a0004347dfb8a1005e099763c2--f759d2ab8de34b4986dfc1d1e30b7917 fd413e7bfc0b4d72aad6a3934974f042 f759d2ab8de34b4986dfc1d1e30b7917--fd413e7bfc0b4d72aad6a3934974f042 13d33acdf7bd42669698c72342eda22a fd413e7bfc0b4d72aad6a3934974f042--13d33acdf7bd42669698c72342eda22a bb757789fccd455ea10e2cdc0f5a122c 13d33acdf7bd42669698c72342eda22a--bb757789fccd455ea10e2cdc0f5a122c f0afab115c234b6bbe5a09338c79896e bb757789fccd455ea10e2cdc0f5a122c--f0afab115c234b6bbe5a09338c79896e d83827881bcf4b0f984069c7f2cce3bf X f0afab115c234b6bbe5a09338c79896e--d83827881bcf4b0f984069c7f2cce3bf d83827881bcf4b0f984069c7f2cce3bf--028024503a154382ae24a1b137e32cf3 38c799f3955a4b33bbd35c1c3c51cf5c X d83827881bcf4b0f984069c7f2cce3bf--38c799f3955a4b33bbd35c1c3c51cf5c 38c799f3955a4b33bbd35c1c3c51cf5c--3d9bb8c3e5ea48e6b47d55eac59bedd6 a554ac52329347268ee0a7a4c4766e6e 38c799f3955a4b33bbd35c1c3c51cf5c--a554ac52329347268ee0a7a4c4766e6e 8f809056921f4150bb59cb8bf4e99b72 a554ac52329347268ee0a7a4c4766e6e--8f809056921f4150bb59cb8bf4e99b72 02958b547e53448cbfd0815b8bea8234 8f809056921f4150bb59cb8bf4e99b72--02958b547e53448cbfd0815b8bea8234 c83cce4ebd2c462eabf4f81b57d63122 02958b547e53448cbfd0815b8bea8234--c83cce4ebd2c462eabf4f81b57d63122 e6eee76b229b4485a59cf969d530511e c83cce4ebd2c462eabf4f81b57d63122--e6eee76b229b4485a59cf969d530511e c06356d614d34f6db76da2dddb62f55f e6eee76b229b4485a59cf969d530511e--c06356d614d34f6db76da2dddb62f55f 72cab2f707124c04a4463a663d9b2dad c06356d614d34f6db76da2dddb62f55f--72cab2f707124c04a4463a663d9b2dad 12ab195e342746e7a0f81904c83cf62e 72cab2f707124c04a4463a663d9b2dad--12ab195e342746e7a0f81904c83cf62e 2080ff8485cc4647905475c362932bf9 12ab195e342746e7a0f81904c83cf62e--2080ff8485cc4647905475c362932bf9 14264e74e4984460812cac4ac9ae7806 2080ff8485cc4647905475c362932bf9--14264e74e4984460812cac4ac9ae7806 ff1f8556842d4b17956351c82f809e1f 14264e74e4984460812cac4ac9ae7806--ff1f8556842d4b17956351c82f809e1f 15d5ef48bedc42969facc7d57884b334 X ff1f8556842d4b17956351c82f809e1f--15d5ef48bedc42969facc7d57884b334 15d5ef48bedc42969facc7d57884b334--003a2051846145de97b674f98a643baa 50b3cf8c51b941b9894c2352a594f556 15d5ef48bedc42969facc7d57884b334--50b3cf8c51b941b9894c2352a594f556 1061984c7f4743ab997cc42b0dc31317 50b3cf8c51b941b9894c2352a594f556--1061984c7f4743ab997cc42b0dc31317 c40cde448a11440384403f471e24efba 1061984c7f4743ab997cc42b0dc31317--c40cde448a11440384403f471e24efba b07db01a29804264ae897f02fb5ac7c9 c40cde448a11440384403f471e24efba--b07db01a29804264ae897f02fb5ac7c9 7e2d634c635f44b2940ab47fa0239c4a b07db01a29804264ae897f02fb5ac7c9--7e2d634c635f44b2940ab47fa0239c4a c39e179e6ff841d0a2717aa3a0bdc0b7 7e2d634c635f44b2940ab47fa0239c4a--c39e179e6ff841d0a2717aa3a0bdc0b7 53d438ee62824f81b89bb0766f197184 c39e179e6ff841d0a2717aa3a0bdc0b7--53d438ee62824f81b89bb0766f197184 660358723f3b4a55a6ce4172b7991069 53d438ee62824f81b89bb0766f197184--660358723f3b4a55a6ce4172b7991069 ee5613103df141b18588e5e5672a9c2d 660358723f3b4a55a6ce4172b7991069--ee5613103df141b18588e5e5672a9c2d 0f9240ddf80e498d90c367a967925ee4 ee5613103df141b18588e5e5672a9c2d--0f9240ddf80e498d90c367a967925ee4 1c12da9c9e39456b9965112f51f15382 0f9240ddf80e498d90c367a967925ee4--1c12da9c9e39456b9965112f51f15382 0f95cc78a42f403d86fd8e2c23f2b670 1c12da9c9e39456b9965112f51f15382--0f95cc78a42f403d86fd8e2c23f2b670 30fc31f7730b4ecd8c22700f2270a36c 0f95cc78a42f403d86fd8e2c23f2b670--30fc31f7730b4ecd8c22700f2270a36c 8167004858464395a9852ac509da65a5 30fc31f7730b4ecd8c22700f2270a36c--8167004858464395a9852ac509da65a5 76a2311af1aa40058ac0e43180e86a1f 8167004858464395a9852ac509da65a5--76a2311af1aa40058ac0e43180e86a1f ffffab86ca994c199e7d4681e93cda71 76a2311af1aa40058ac0e43180e86a1f--ffffab86ca994c199e7d4681e93cda71 6fbf5a12e0514653b71d54cddd040176 ffffab86ca994c199e7d4681e93cda71--6fbf5a12e0514653b71d54cddd040176 676c72d6cf72487588b96b34a44af079 6fbf5a12e0514653b71d54cddd040176--676c72d6cf72487588b96b34a44af079 8394abebc031438897cd18aaba252392 676c72d6cf72487588b96b34a44af079--8394abebc031438897cd18aaba252392 ef117326b6424ea7b1ceef77c8aafee0 8394abebc031438897cd18aaba252392--ef117326b6424ea7b1ceef77c8aafee0 5b73a28aac3048039edd0a63111f6f28 ef117326b6424ea7b1ceef77c8aafee0--5b73a28aac3048039edd0a63111f6f28 4cb48d13c3cf471f8f18fc0726a2f9a8 5b73a28aac3048039edd0a63111f6f28--4cb48d13c3cf471f8f18fc0726a2f9a8 89c8702db6334474af67a35ba20ac930 4cb48d13c3cf471f8f18fc0726a2f9a8--89c8702db6334474af67a35ba20ac930 8a5df721fc384e1cb09b358190dfdc5e 89c8702db6334474af67a35ba20ac930--8a5df721fc384e1cb09b358190dfdc5e 1f4753bf52484509a00201a8d908f8be 8a5df721fc384e1cb09b358190dfdc5e--1f4753bf52484509a00201a8d908f8be 534618102fbd4c9ba6caf1733c24a4d8 1f4753bf52484509a00201a8d908f8be--534618102fbd4c9ba6caf1733c24a4d8 06910c5c03ac4a55b129f0a1c0399a96 534618102fbd4c9ba6caf1733c24a4d8--06910c5c03ac4a55b129f0a1c0399a96 9eac33481dfc44a59fe9cecee52334a7 06910c5c03ac4a55b129f0a1c0399a96--9eac33481dfc44a59fe9cecee52334a7 861d0128bd7f416d91d2f12d4e212cbc 9eac33481dfc44a59fe9cecee52334a7--861d0128bd7f416d91d2f12d4e212cbc 47eab447db644f3f8047a7169a3281ec 861d0128bd7f416d91d2f12d4e212cbc--47eab447db644f3f8047a7169a3281ec 00cf5272f9884e29a03f5280d242c2af 47eab447db644f3f8047a7169a3281ec--00cf5272f9884e29a03f5280d242c2af 772f798441724958862b37fb8c037992 RX(b02) 00cf5272f9884e29a03f5280d242c2af--772f798441724958862b37fb8c037992 6f8fa0e5ba54416dae9a3d9aca6b72c3 772f798441724958862b37fb8c037992--6f8fa0e5ba54416dae9a3d9aca6b72c3 7829748836624f62966ea9c8fce7b04b X 6f8fa0e5ba54416dae9a3d9aca6b72c3--7829748836624f62966ea9c8fce7b04b 7829748836624f62966ea9c8fce7b04b--26f1b3db5bc34280aeeeade08d466768 6d3e9262bd834f95950a3937900d8c41 7829748836624f62966ea9c8fce7b04b--6d3e9262bd834f95950a3937900d8c41 def1574ce4114c0e82977926ac464bd1 6d3e9262bd834f95950a3937900d8c41--def1574ce4114c0e82977926ac464bd1 84e2379377ec4f78af74fe766112b31c def1574ce4114c0e82977926ac464bd1--84e2379377ec4f78af74fe766112b31c d4ade73ff9754c3eb7172d69b04ebd72 84e2379377ec4f78af74fe766112b31c--d4ade73ff9754c3eb7172d69b04ebd72 3817ac4d4191437681e25add7cab2384 d4ade73ff9754c3eb7172d69b04ebd72--3817ac4d4191437681e25add7cab2384 c1f61fe607754f8091da2bd8c0daa28a 3817ac4d4191437681e25add7cab2384--c1f61fe607754f8091da2bd8c0daa28a ff4ffc2c8e1d4118b64dcdff1eaf00fd c1f61fe607754f8091da2bd8c0daa28a--ff4ffc2c8e1d4118b64dcdff1eaf00fd 3f53d7de6cf4478c8cd934a907c20e9f ff4ffc2c8e1d4118b64dcdff1eaf00fd--3f53d7de6cf4478c8cd934a907c20e9f 1c0bbf70b4954d8aa5947f5333716cbc 3f53d7de6cf4478c8cd934a907c20e9f--1c0bbf70b4954d8aa5947f5333716cbc 8f8114efb895465aa6eb8048cf1fc75a 1c0bbf70b4954d8aa5947f5333716cbc--8f8114efb895465aa6eb8048cf1fc75a 8f6a6e5d3d204203881e5578ff73505c 8f8114efb895465aa6eb8048cf1fc75a--8f6a6e5d3d204203881e5578ff73505c f1af5ef4b0414b5ca15c531546acfc32 X 8f6a6e5d3d204203881e5578ff73505c--f1af5ef4b0414b5ca15c531546acfc32 f1af5ef4b0414b5ca15c531546acfc32--68823aaff96640a7885a3a8b9ec414d1 859686bdc9b34dd78af0f5d8801e77bf f1af5ef4b0414b5ca15c531546acfc32--859686bdc9b34dd78af0f5d8801e77bf aa1cf52a8d00457298d4e12c519c29d7 859686bdc9b34dd78af0f5d8801e77bf--aa1cf52a8d00457298d4e12c519c29d7 74a1f68d5f024d63823a7abeb88053bd aa1cf52a8d00457298d4e12c519c29d7--74a1f68d5f024d63823a7abeb88053bd d1e01e2cf8b0422083a62a7a9ea6fdd6 74a1f68d5f024d63823a7abeb88053bd--d1e01e2cf8b0422083a62a7a9ea6fdd6 10478ac4f5614675b2cd239aef89d622 d1e01e2cf8b0422083a62a7a9ea6fdd6--10478ac4f5614675b2cd239aef89d622 6b6670f181ac47ab9c8e2d2d7b0da380 X 10478ac4f5614675b2cd239aef89d622--6b6670f181ac47ab9c8e2d2d7b0da380 6b6670f181ac47ab9c8e2d2d7b0da380--fe5d2ce7cfd44359afc620ccb6314b32 187ed07a8bac413eb1273da32ea5f146 RZ(-1.0*g1) 6b6670f181ac47ab9c8e2d2d7b0da380--187ed07a8bac413eb1273da32ea5f146 0707c47406234b339e42db6eae7db247 X 187ed07a8bac413eb1273da32ea5f146--0707c47406234b339e42db6eae7db247 0707c47406234b339e42db6eae7db247--259c08f27f494072a3a966b027cbfff9 f49146043ad545efa6add34454273904 0707c47406234b339e42db6eae7db247--f49146043ad545efa6add34454273904 e706ffb011694b88901472dbabe40720 f49146043ad545efa6add34454273904--e706ffb011694b88901472dbabe40720 95e4ede98fcc408f9a2481d07bbd7b6c X e706ffb011694b88901472dbabe40720--95e4ede98fcc408f9a2481d07bbd7b6c 95e4ede98fcc408f9a2481d07bbd7b6c--59616988d22449bab683d805da503c94 759b146dd3b149eb8970df6998c8ee42 95e4ede98fcc408f9a2481d07bbd7b6c--759b146dd3b149eb8970df6998c8ee42 d92526e79ac04365b81bb54d1ad0dfb5 759b146dd3b149eb8970df6998c8ee42--d92526e79ac04365b81bb54d1ad0dfb5 b1c236747bb74190b86e34b3a6092960 d92526e79ac04365b81bb54d1ad0dfb5--b1c236747bb74190b86e34b3a6092960 e99ea41203084f5bb815d2974c640279 X b1c236747bb74190b86e34b3a6092960--e99ea41203084f5bb815d2974c640279 e99ea41203084f5bb815d2974c640279--a6b81f5bc45444ef96cbba812a2afee3 b8706f9496744e40ac743db72e7002d7 e99ea41203084f5bb815d2974c640279--b8706f9496744e40ac743db72e7002d7 da0b714988f84e3da6820525522a45f8 b8706f9496744e40ac743db72e7002d7--da0b714988f84e3da6820525522a45f8 a705cde7a80145e285889b02465feb44 X da0b714988f84e3da6820525522a45f8--a705cde7a80145e285889b02465feb44 a705cde7a80145e285889b02465feb44--f9e7d63d9c174ddbad0bcda4e20574ad cc134f7feb5b41038274d766ae7688d6 a705cde7a80145e285889b02465feb44--cc134f7feb5b41038274d766ae7688d6 6b5c31dda8f64a3ab78a41550f3293a7 cc134f7feb5b41038274d766ae7688d6--6b5c31dda8f64a3ab78a41550f3293a7 3e155313d7b74a1bb06f8f34a046059c 6b5c31dda8f64a3ab78a41550f3293a7--3e155313d7b74a1bb06f8f34a046059c 09574732446b4745a8a8ed26a3d83ad6 3e155313d7b74a1bb06f8f34a046059c--09574732446b4745a8a8ed26a3d83ad6 035bdd1a18934a21ac4b07a389fd0b43 09574732446b4745a8a8ed26a3d83ad6--035bdd1a18934a21ac4b07a389fd0b43 c21b70de1910465983c5964784b35adc X 035bdd1a18934a21ac4b07a389fd0b43--c21b70de1910465983c5964784b35adc c21b70de1910465983c5964784b35adc--30c719f3c264447d84597014babddebc 659b7cc3cfe2444183cf5cca5593457b c21b70de1910465983c5964784b35adc--659b7cc3cfe2444183cf5cca5593457b 300c5ddca916440d9273aeb7745bcb5c 659b7cc3cfe2444183cf5cca5593457b--300c5ddca916440d9273aeb7745bcb5c 15552267b6194fbf8694291a8a81a926 X 300c5ddca916440d9273aeb7745bcb5c--15552267b6194fbf8694291a8a81a926 15552267b6194fbf8694291a8a81a926--4b66c77790a4431781c48d1e303d8c77 1ba05d3f519a4062ac89366ff0253151 15552267b6194fbf8694291a8a81a926--1ba05d3f519a4062ac89366ff0253151 4d7599216e824cfba442995c8c936c14 1ba05d3f519a4062ac89366ff0253151--4d7599216e824cfba442995c8c936c14 587f5eb4da084a33a2288837559938cb 4d7599216e824cfba442995c8c936c14--587f5eb4da084a33a2288837559938cb e1992d37830942bf90c85c38f8c546fc 587f5eb4da084a33a2288837559938cb--e1992d37830942bf90c85c38f8c546fc 11c2324cb54f4b51ab023262a273ba23 e1992d37830942bf90c85c38f8c546fc--11c2324cb54f4b51ab023262a273ba23 ba1e2fcc95514e138016f877be4ca28a 11c2324cb54f4b51ab023262a273ba23--ba1e2fcc95514e138016f877be4ca28a cc6fb2099c174608b0316ff6f43d1843 ba1e2fcc95514e138016f877be4ca28a--cc6fb2099c174608b0316ff6f43d1843 5588cb39065a41b48c2f121c47a27475 cc6fb2099c174608b0316ff6f43d1843--5588cb39065a41b48c2f121c47a27475 27b8f76c74ef4859a98af30466376326 5588cb39065a41b48c2f121c47a27475--27b8f76c74ef4859a98af30466376326 9d4301d09a51442589fa7261f2e49993 X 27b8f76c74ef4859a98af30466376326--9d4301d09a51442589fa7261f2e49993 9d4301d09a51442589fa7261f2e49993--35868a910eee499e92e7449e341e8bd3 e82ac10b603e412f99b51590ea49dc94 9d4301d09a51442589fa7261f2e49993--e82ac10b603e412f99b51590ea49dc94 c9a0c5751fc54a1bbe787c1a2da50cfe X e82ac10b603e412f99b51590ea49dc94--c9a0c5751fc54a1bbe787c1a2da50cfe c9a0c5751fc54a1bbe787c1a2da50cfe--d5b2e5aac7cb46bf8b8567b5df4e2eb1 6e73a307ea9a4b338f74162b6f43f48a c9a0c5751fc54a1bbe787c1a2da50cfe--6e73a307ea9a4b338f74162b6f43f48a 82ee720f4fb249b4b0217a5f89a07e8f 6e73a307ea9a4b338f74162b6f43f48a--82ee720f4fb249b4b0217a5f89a07e8f d3c635294c7649c2bdc611fa21e37ae2 82ee720f4fb249b4b0217a5f89a07e8f--d3c635294c7649c2bdc611fa21e37ae2 60b89492d01b4781b45cfe4685cf7fdf d3c635294c7649c2bdc611fa21e37ae2--60b89492d01b4781b45cfe4685cf7fdf fb728d82bc8a4031892d200431ce471d 60b89492d01b4781b45cfe4685cf7fdf--fb728d82bc8a4031892d200431ce471d 00868cd3e9e54939b839c86b83ebeebc X fb728d82bc8a4031892d200431ce471d--00868cd3e9e54939b839c86b83ebeebc 00868cd3e9e54939b839c86b83ebeebc--bbea560e57424fb7b94a22641778fc74 e044f7b5cd6a4b0ab2ff8003dcf89709 X 00868cd3e9e54939b839c86b83ebeebc--e044f7b5cd6a4b0ab2ff8003dcf89709 e044f7b5cd6a4b0ab2ff8003dcf89709--fc543fb9b84644bbae1e036c00b00353 5ef8c6f4e44b40d182056c3ecbbf24dc e044f7b5cd6a4b0ab2ff8003dcf89709--5ef8c6f4e44b40d182056c3ecbbf24dc 26b62e1f04cf44ac8ccf2dac75890ea7 5ef8c6f4e44b40d182056c3ecbbf24dc--26b62e1f04cf44ac8ccf2dac75890ea7 272451ac23154521b52b10b29172b73d 26b62e1f04cf44ac8ccf2dac75890ea7--272451ac23154521b52b10b29172b73d e9e1696bfad64db7a56c3468b8796032 272451ac23154521b52b10b29172b73d--e9e1696bfad64db7a56c3468b8796032 31fee52ece344a22ad6589cc54e5222e e9e1696bfad64db7a56c3468b8796032--31fee52ece344a22ad6589cc54e5222e fc2e23d523584de69434ce971f69abff 31fee52ece344a22ad6589cc54e5222e--fc2e23d523584de69434ce971f69abff e071fc92fd3045d3b1b81ed1118055b1 fc2e23d523584de69434ce971f69abff--e071fc92fd3045d3b1b81ed1118055b1 60d2c416c5ee4d92955014e296a40164 X e071fc92fd3045d3b1b81ed1118055b1--60d2c416c5ee4d92955014e296a40164 60d2c416c5ee4d92955014e296a40164--dc5c054e2bc84738ad240f2ffa902102 4f9220a7f9a54988a6af18b946a24724 X 60d2c416c5ee4d92955014e296a40164--4f9220a7f9a54988a6af18b946a24724 4f9220a7f9a54988a6af18b946a24724--59ff64c0f4dc427680b57517e8d0b6dc 1dd60793ef1b45038b025ad9d1b7e3fd 4f9220a7f9a54988a6af18b946a24724--1dd60793ef1b45038b025ad9d1b7e3fd 79fdb9080240436892b874780cd4d526 1dd60793ef1b45038b025ad9d1b7e3fd--79fdb9080240436892b874780cd4d526 6b578371be5746dca6561f6a9bdeebc5 79fdb9080240436892b874780cd4d526--6b578371be5746dca6561f6a9bdeebc5 cb22531ab33543c6840c0ab63fb9ba9d 6b578371be5746dca6561f6a9bdeebc5--cb22531ab33543c6840c0ab63fb9ba9d a47b05dc9d4944689c79d37af1a715e8 cb22531ab33543c6840c0ab63fb9ba9d--a47b05dc9d4944689c79d37af1a715e8 3285c3b4996a4e0997e8d6d671fc0326 a47b05dc9d4944689c79d37af1a715e8--3285c3b4996a4e0997e8d6d671fc0326 0ccbf56ddfe846b89a3a4017d3eb7f4e 3285c3b4996a4e0997e8d6d671fc0326--0ccbf56ddfe846b89a3a4017d3eb7f4e f5bd092d15f14217a4d5900591303164 0ccbf56ddfe846b89a3a4017d3eb7f4e--f5bd092d15f14217a4d5900591303164 da25b865044c4bc79ea68fbb729305af f5bd092d15f14217a4d5900591303164--da25b865044c4bc79ea68fbb729305af 6c59c2210df54c12ac6abf3572bb85e3 X da25b865044c4bc79ea68fbb729305af--6c59c2210df54c12ac6abf3572bb85e3 6c59c2210df54c12ac6abf3572bb85e3--7d1298e8409848c0a9e917b61923fe43 1f63b071e48f4d55a87d5447e04ca908 X 6c59c2210df54c12ac6abf3572bb85e3--1f63b071e48f4d55a87d5447e04ca908 1f63b071e48f4d55a87d5447e04ca908--72baf73948894c81a280cf26358efd58 693eee487426499e9a3b3bb7ed947da2 1f63b071e48f4d55a87d5447e04ca908--693eee487426499e9a3b3bb7ed947da2 78d66b76bb354e4abe312440539b4cd8 693eee487426499e9a3b3bb7ed947da2--78d66b76bb354e4abe312440539b4cd8 3eaf89fa0a1649dc95003ba8a98455a2 78d66b76bb354e4abe312440539b4cd8--3eaf89fa0a1649dc95003ba8a98455a2 21f6547c84d24b4fbeb154f622cad1db 3eaf89fa0a1649dc95003ba8a98455a2--21f6547c84d24b4fbeb154f622cad1db 4a6ed35d908c4c4aac16e2107bb23a87 21f6547c84d24b4fbeb154f622cad1db--4a6ed35d908c4c4aac16e2107bb23a87 bdf6b97fc912445292ae5f7c1f6500d5 4a6ed35d908c4c4aac16e2107bb23a87--bdf6b97fc912445292ae5f7c1f6500d5 d80355e17e474967b90caf85d0a6d696 bdf6b97fc912445292ae5f7c1f6500d5--d80355e17e474967b90caf85d0a6d696 3f19b38385844e8f942c118a0e0c7cae d80355e17e474967b90caf85d0a6d696--3f19b38385844e8f942c118a0e0c7cae 1c6ca9f55c0f4865a02f0db3542acd53 3f19b38385844e8f942c118a0e0c7cae--1c6ca9f55c0f4865a02f0db3542acd53 03e9b70909a8451ba36c5b24ce7834d7 1c6ca9f55c0f4865a02f0db3542acd53--03e9b70909a8451ba36c5b24ce7834d7 0ee6aa8749f248c09ffe37dd05b15021 03e9b70909a8451ba36c5b24ce7834d7--0ee6aa8749f248c09ffe37dd05b15021 7f1d5e979daf40fbb521cf1f332a8940 X 0ee6aa8749f248c09ffe37dd05b15021--7f1d5e979daf40fbb521cf1f332a8940 7f1d5e979daf40fbb521cf1f332a8940--9edaec00a4b7420fb6690fdc92084c1e ebfa906792834be9b5164d43ba66af85 7f1d5e979daf40fbb521cf1f332a8940--ebfa906792834be9b5164d43ba66af85 738e4c022b86430cad05c9f494a6185b ebfa906792834be9b5164d43ba66af85--738e4c022b86430cad05c9f494a6185b 760e4ec328df4c90b969ecf9d838cb2b 738e4c022b86430cad05c9f494a6185b--760e4ec328df4c90b969ecf9d838cb2b 0482d923f4084a13982dc98bc0ea2040 760e4ec328df4c90b969ecf9d838cb2b--0482d923f4084a13982dc98bc0ea2040 4d4cce8898674113b733af91dcf65fac 0482d923f4084a13982dc98bc0ea2040--4d4cce8898674113b733af91dcf65fac b333f668a52f488aa84537c3f2b9854a 4d4cce8898674113b733af91dcf65fac--b333f668a52f488aa84537c3f2b9854a dd05c66b3a63411c8616c0c12c81e0ef b333f668a52f488aa84537c3f2b9854a--dd05c66b3a63411c8616c0c12c81e0ef f885c050cfd44f1c8a8761087704b37b dd05c66b3a63411c8616c0c12c81e0ef--f885c050cfd44f1c8a8761087704b37b 126f5e80e2a44e4188b4bda13078a8d7 f885c050cfd44f1c8a8761087704b37b--126f5e80e2a44e4188b4bda13078a8d7 e24408a13b22411da2930471c5e0a77f 126f5e80e2a44e4188b4bda13078a8d7--e24408a13b22411da2930471c5e0a77f 0c3e20509e8b44b4a495a9ff99e41653 e24408a13b22411da2930471c5e0a77f--0c3e20509e8b44b4a495a9ff99e41653 33e0e9ed48394ddda077bff99ee00c01 0c3e20509e8b44b4a495a9ff99e41653--33e0e9ed48394ddda077bff99ee00c01 19db265a7ab24eb6928e6b5117c5c59c 33e0e9ed48394ddda077bff99ee00c01--19db265a7ab24eb6928e6b5117c5c59c 0224420f6f0340998e3d192dfc08e9bc 19db265a7ab24eb6928e6b5117c5c59c--0224420f6f0340998e3d192dfc08e9bc 37e7eb97542c4ff2bd8a5e8ac5734ebc 0224420f6f0340998e3d192dfc08e9bc--37e7eb97542c4ff2bd8a5e8ac5734ebc 2fe0b3e22c814b348235a8e7cf4e84d3 37e7eb97542c4ff2bd8a5e8ac5734ebc--2fe0b3e22c814b348235a8e7cf4e84d3 269d9885c9f04339a65d143d0d666ddb 2fe0b3e22c814b348235a8e7cf4e84d3--269d9885c9f04339a65d143d0d666ddb 32defb80ef85428fa45dc767942068f2 269d9885c9f04339a65d143d0d666ddb--32defb80ef85428fa45dc767942068f2 b12a193c7d7249a98424790323688f09 32defb80ef85428fa45dc767942068f2--b12a193c7d7249a98424790323688f09 eb45570b9e4c48d7b37dcfdf3a5fd0e2 b12a193c7d7249a98424790323688f09--eb45570b9e4c48d7b37dcfdf3a5fd0e2 7a335ee1ddab4c5294cdf5a04ec20ef2 eb45570b9e4c48d7b37dcfdf3a5fd0e2--7a335ee1ddab4c5294cdf5a04ec20ef2 ffdd756f6c2943eaaa15659fb475efd2 7a335ee1ddab4c5294cdf5a04ec20ef2--ffdd756f6c2943eaaa15659fb475efd2 8220ed4c39bf4b5d80cc566158a857a8 ffdd756f6c2943eaaa15659fb475efd2--8220ed4c39bf4b5d80cc566158a857a8 95bce72bcd5543cdb76e7cc0e3a85b24 8220ed4c39bf4b5d80cc566158a857a8--95bce72bcd5543cdb76e7cc0e3a85b24 7f0bce0223144f2e8e92bdafce433db6 95bce72bcd5543cdb76e7cc0e3a85b24--7f0bce0223144f2e8e92bdafce433db6 d65dc38ff041485cb59569997c40f302 7f0bce0223144f2e8e92bdafce433db6--d65dc38ff041485cb59569997c40f302 dbcead31b20c4989b6a1447febc39f21 d65dc38ff041485cb59569997c40f302--dbcead31b20c4989b6a1447febc39f21 03ee45a7e6464a42b3ac599d1f22d909 dbcead31b20c4989b6a1447febc39f21--03ee45a7e6464a42b3ac599d1f22d909 89e0db449fd04387ad20168e4b5ca170 03ee45a7e6464a42b3ac599d1f22d909--89e0db449fd04387ad20168e4b5ca170 5bf6f01673094de489a942494e746505 89e0db449fd04387ad20168e4b5ca170--5bf6f01673094de489a942494e746505 d5374611a6e64814ade383fe9b6eec9b 5bf6f01673094de489a942494e746505--d5374611a6e64814ade383fe9b6eec9b cef65cdb7ca7497289f31242f2258f54 RX(b12) d5374611a6e64814ade383fe9b6eec9b--cef65cdb7ca7497289f31242f2258f54 cef65cdb7ca7497289f31242f2258f54--fc845b9084334b99b8a6d1ece2ab060c b5f76321495046598c4e036572d814c9 e5a77aa232084105a28319645973c3eb 6d4d6caed8124622be2e882ed9a49829--e5a77aa232084105a28319645973c3eb f5ec58c878af489192b2c666836d7c9f 4 4e489c3beb124b60bcde4f9ed67f95de e5a77aa232084105a28319645973c3eb--4e489c3beb124b60bcde4f9ed67f95de 09a3ef6b3f5347c4b894a16550dfd83d X 4e489c3beb124b60bcde4f9ed67f95de--09a3ef6b3f5347c4b894a16550dfd83d 09a3ef6b3f5347c4b894a16550dfd83d--8c21e905ee994f01a163056a89fc5753 d65f5f72e596497bb8aef46bbb3e4a37 09a3ef6b3f5347c4b894a16550dfd83d--d65f5f72e596497bb8aef46bbb3e4a37 9867f5f24cd94f1892c7410aa8e70bdc d65f5f72e596497bb8aef46bbb3e4a37--9867f5f24cd94f1892c7410aa8e70bdc 14830c98b2a6443388424c75ebdfac7c 9867f5f24cd94f1892c7410aa8e70bdc--14830c98b2a6443388424c75ebdfac7c 0b562acb901344d9b11c16596a6baa1d 14830c98b2a6443388424c75ebdfac7c--0b562acb901344d9b11c16596a6baa1d 32b15886f4f84662bcab26406faf3c1b 0b562acb901344d9b11c16596a6baa1d--32b15886f4f84662bcab26406faf3c1b 63d428505b8a4dc0a9f7d815f0bf02cc 32b15886f4f84662bcab26406faf3c1b--63d428505b8a4dc0a9f7d815f0bf02cc c62dd445b0d24699a2f240bcb14fbf71 63d428505b8a4dc0a9f7d815f0bf02cc--c62dd445b0d24699a2f240bcb14fbf71 a286cfddcf84417dab7ef8fd7b1ba574 c62dd445b0d24699a2f240bcb14fbf71--a286cfddcf84417dab7ef8fd7b1ba574 abcfd2bacd154f0bb7840c39eabbbfef a286cfddcf84417dab7ef8fd7b1ba574--abcfd2bacd154f0bb7840c39eabbbfef 2156d0a59ea748fdb68fd62d8d8bfc2c X abcfd2bacd154f0bb7840c39eabbbfef--2156d0a59ea748fdb68fd62d8d8bfc2c 2156d0a59ea748fdb68fd62d8d8bfc2c--6ca56b54e04c455aa639932ea1c8e601 7c8561784c714f51819b68672cf7172b 2156d0a59ea748fdb68fd62d8d8bfc2c--7c8561784c714f51819b68672cf7172b 91485e2784e245c7b67bfe7e857d2abd 7c8561784c714f51819b68672cf7172b--91485e2784e245c7b67bfe7e857d2abd d4a6351fd2864f1ba33eaa65e441b559 91485e2784e245c7b67bfe7e857d2abd--d4a6351fd2864f1ba33eaa65e441b559 a3a6dc0ebcd5486f90784321fb334641 d4a6351fd2864f1ba33eaa65e441b559--a3a6dc0ebcd5486f90784321fb334641 368a3fb0beba475f940949ed80f5ba0d a3a6dc0ebcd5486f90784321fb334641--368a3fb0beba475f940949ed80f5ba0d aabdc6c05cab4c538ac6b3d4064c0114 368a3fb0beba475f940949ed80f5ba0d--aabdc6c05cab4c538ac6b3d4064c0114 cf2f4160146c4d76b899cb947004e24f aabdc6c05cab4c538ac6b3d4064c0114--cf2f4160146c4d76b899cb947004e24f 27eaf172aaa140eba33c95626a7e2a48 cf2f4160146c4d76b899cb947004e24f--27eaf172aaa140eba33c95626a7e2a48 9d8da79158f341cfa5a6e1d93db094a1 27eaf172aaa140eba33c95626a7e2a48--9d8da79158f341cfa5a6e1d93db094a1 86763a73b3124f079dd57c9c4169d659 9d8da79158f341cfa5a6e1d93db094a1--86763a73b3124f079dd57c9c4169d659 3efc8fb059544c108919abbf307b2772 86763a73b3124f079dd57c9c4169d659--3efc8fb059544c108919abbf307b2772 68ac548de74247a4bffeca0d4419e84d 3efc8fb059544c108919abbf307b2772--68ac548de74247a4bffeca0d4419e84d dbb9a22b88784d1b886cc3312833d109 X 68ac548de74247a4bffeca0d4419e84d--dbb9a22b88784d1b886cc3312833d109 dbb9a22b88784d1b886cc3312833d109--05f757c339e24883a4dcf1f754e2ec85 80a13ecac3c54c5bb9844c0bb7c9acc5 RZ(-1.0*g0) dbb9a22b88784d1b886cc3312833d109--80a13ecac3c54c5bb9844c0bb7c9acc5 7b5f48ef73444664ae9f429f0e02203e X 80a13ecac3c54c5bb9844c0bb7c9acc5--7b5f48ef73444664ae9f429f0e02203e 7b5f48ef73444664ae9f429f0e02203e--b343db0cb47e425cb1f21fabea8f58de f47a460055eb4b9f865bae2b2a4f1980 7b5f48ef73444664ae9f429f0e02203e--f47a460055eb4b9f865bae2b2a4f1980 94a66d7f0b844c3799200acb2b48c86d f47a460055eb4b9f865bae2b2a4f1980--94a66d7f0b844c3799200acb2b48c86d 0171c7b5b9d843e895910310e2bef9e6 94a66d7f0b844c3799200acb2b48c86d--0171c7b5b9d843e895910310e2bef9e6 544e771720004b768797abe07042d3b6 0171c7b5b9d843e895910310e2bef9e6--544e771720004b768797abe07042d3b6 4d539b0c256b4fc582d3dae99a84dbc6 X 544e771720004b768797abe07042d3b6--4d539b0c256b4fc582d3dae99a84dbc6 4d539b0c256b4fc582d3dae99a84dbc6--e1527e947e514ad4ba32f111e7b824c8 04a89f95fbb3470a9b3c2c41596d37d9 4d539b0c256b4fc582d3dae99a84dbc6--04a89f95fbb3470a9b3c2c41596d37d9 0482db1868194d289543b9cf7f54720e 04a89f95fbb3470a9b3c2c41596d37d9--0482db1868194d289543b9cf7f54720e 6d03c3dcfbdb44cda6d33b9a03548a21 0482db1868194d289543b9cf7f54720e--6d03c3dcfbdb44cda6d33b9a03548a21 55468fab99ca449aa91ee07836afbf85 X 6d03c3dcfbdb44cda6d33b9a03548a21--55468fab99ca449aa91ee07836afbf85 55468fab99ca449aa91ee07836afbf85--f10a643cb5fc4bc584a9e0c6ecd3d820 b8aa98be2d7e4a24966b9d7dae731612 55468fab99ca449aa91ee07836afbf85--b8aa98be2d7e4a24966b9d7dae731612 40fa6d2876c44ae2b3b9c2744a835401 b8aa98be2d7e4a24966b9d7dae731612--40fa6d2876c44ae2b3b9c2744a835401 e1f7468bed114cb48c615f6073b35737 40fa6d2876c44ae2b3b9c2744a835401--e1f7468bed114cb48c615f6073b35737 d94708e194814ce3b39ef3dcdb0aea42 e1f7468bed114cb48c615f6073b35737--d94708e194814ce3b39ef3dcdb0aea42 044bcbbab7eb45bda753a3e54c0ee81e X d94708e194814ce3b39ef3dcdb0aea42--044bcbbab7eb45bda753a3e54c0ee81e 044bcbbab7eb45bda753a3e54c0ee81e--b4c91b03a34147fe828b5a4bcfa73897 8e929ce1b94a4ceea1daae53bf8aa56f 044bcbbab7eb45bda753a3e54c0ee81e--8e929ce1b94a4ceea1daae53bf8aa56f bdf97138bf3440cfb40f1e981ee34001 8e929ce1b94a4ceea1daae53bf8aa56f--bdf97138bf3440cfb40f1e981ee34001 44d1f182f46646ccbd030e473636415b bdf97138bf3440cfb40f1e981ee34001--44d1f182f46646ccbd030e473636415b f7c128fa387c44abbbea71d4b42b9f06 44d1f182f46646ccbd030e473636415b--f7c128fa387c44abbbea71d4b42b9f06 83b0958f7738439a85348cbf4d649a5b f7c128fa387c44abbbea71d4b42b9f06--83b0958f7738439a85348cbf4d649a5b 30a888eadd16466c9554331b9f305edc 83b0958f7738439a85348cbf4d649a5b--30a888eadd16466c9554331b9f305edc c6e8a316a8b64e99a662b7eb0647f624 30a888eadd16466c9554331b9f305edc--c6e8a316a8b64e99a662b7eb0647f624 ea9a3108d43c4aa592deb953709903fd X c6e8a316a8b64e99a662b7eb0647f624--ea9a3108d43c4aa592deb953709903fd ea9a3108d43c4aa592deb953709903fd--fe33c7c4fa334b589ac7d397e10b3b8e 9f9b2415e3b04c3083e95a92ee5e4ab5 ea9a3108d43c4aa592deb953709903fd--9f9b2415e3b04c3083e95a92ee5e4ab5 fa1a1283f63841d0947d155ee4f4bf99 9f9b2415e3b04c3083e95a92ee5e4ab5--fa1a1283f63841d0947d155ee4f4bf99 87497b36196347f298b92e01045bdce7 fa1a1283f63841d0947d155ee4f4bf99--87497b36196347f298b92e01045bdce7 a3dbeb32636b4082a8b6eadd870cac06 X 87497b36196347f298b92e01045bdce7--a3dbeb32636b4082a8b6eadd870cac06 a3dbeb32636b4082a8b6eadd870cac06--a94a86bf14384e0f8da26d9095b51697 5a2b96c93eb144a7b12f7058c2f3a2a0 a3dbeb32636b4082a8b6eadd870cac06--5a2b96c93eb144a7b12f7058c2f3a2a0 8dccecb4d668433aa1892c04fbeb5f51 5a2b96c93eb144a7b12f7058c2f3a2a0--8dccecb4d668433aa1892c04fbeb5f51 98146cdcf1ba492abc1ce7fb56ee3f46 8dccecb4d668433aa1892c04fbeb5f51--98146cdcf1ba492abc1ce7fb56ee3f46 9cca8a514b9342fab0f73ff6a679f8c4 X 98146cdcf1ba492abc1ce7fb56ee3f46--9cca8a514b9342fab0f73ff6a679f8c4 9cca8a514b9342fab0f73ff6a679f8c4--abb8753bf82148db8a66e330aa53032d 0df86f9faf1346e89493f370df4f14fa 9cca8a514b9342fab0f73ff6a679f8c4--0df86f9faf1346e89493f370df4f14fa b99f8149f2c84dd792ff4cd809811c3a 0df86f9faf1346e89493f370df4f14fa--b99f8149f2c84dd792ff4cd809811c3a d0bcacee1d774a68b92de546e9127a8c X b99f8149f2c84dd792ff4cd809811c3a--d0bcacee1d774a68b92de546e9127a8c d0bcacee1d774a68b92de546e9127a8c--bbb6bcb17de5405d817444c1c25868aa b626f22e98e546948a3631b359bba090 d0bcacee1d774a68b92de546e9127a8c--b626f22e98e546948a3631b359bba090 3fd528d0b20e4205ae6d2c2dfdf78632 b626f22e98e546948a3631b359bba090--3fd528d0b20e4205ae6d2c2dfdf78632 afb8f7af74b7475db577b16c15257b9f 3fd528d0b20e4205ae6d2c2dfdf78632--afb8f7af74b7475db577b16c15257b9f 32a8a194d19a49689e6b60bf3078ae57 afb8f7af74b7475db577b16c15257b9f--32a8a194d19a49689e6b60bf3078ae57 f0522071a1ee4a77940a673c6139be6c 32a8a194d19a49689e6b60bf3078ae57--f0522071a1ee4a77940a673c6139be6c 0cbdd16963fb4fbdae0e2254852b1c1a X f0522071a1ee4a77940a673c6139be6c--0cbdd16963fb4fbdae0e2254852b1c1a 0cbdd16963fb4fbdae0e2254852b1c1a--2ae22766f5f04d55adf228367a2c8e6b 7be939792bcf47f6be3cc5fae513d048 0cbdd16963fb4fbdae0e2254852b1c1a--7be939792bcf47f6be3cc5fae513d048 36832d5ef9d348d886592d910756e93f 7be939792bcf47f6be3cc5fae513d048--36832d5ef9d348d886592d910756e93f ad470926b4844da68fc633fd5d58f378 X 36832d5ef9d348d886592d910756e93f--ad470926b4844da68fc633fd5d58f378 ad470926b4844da68fc633fd5d58f378--c582c42cb934464fae1d0e5a48eb268e ca4ec57453594f4e8b50706592c6d19c ad470926b4844da68fc633fd5d58f378--ca4ec57453594f4e8b50706592c6d19c cddf041b0ffe44acab070192277b53ce ca4ec57453594f4e8b50706592c6d19c--cddf041b0ffe44acab070192277b53ce a1d470dd4d824d89898760b5a927576a cddf041b0ffe44acab070192277b53ce--a1d470dd4d824d89898760b5a927576a d22ac73d1df94fbb9cd114ef7594abe0 a1d470dd4d824d89898760b5a927576a--d22ac73d1df94fbb9cd114ef7594abe0 4319c8f77f0b4be195543b90b6fc8e8a d22ac73d1df94fbb9cd114ef7594abe0--4319c8f77f0b4be195543b90b6fc8e8a 13b6d5a2d0fc4e6a91e2e0c8ed515e68 4319c8f77f0b4be195543b90b6fc8e8a--13b6d5a2d0fc4e6a91e2e0c8ed515e68 040b6d3681fa45d8ad017ddb8002a72d 13b6d5a2d0fc4e6a91e2e0c8ed515e68--040b6d3681fa45d8ad017ddb8002a72d fe7ebe4c4310461c9387b422ed5ad036 X 040b6d3681fa45d8ad017ddb8002a72d--fe7ebe4c4310461c9387b422ed5ad036 fe7ebe4c4310461c9387b422ed5ad036--f0afab115c234b6bbe5a09338c79896e a2d79416e9f94292916ac093613c78c0 fe7ebe4c4310461c9387b422ed5ad036--a2d79416e9f94292916ac093613c78c0 7814fca98edc4d0aaa60c78565901cd4 a2d79416e9f94292916ac093613c78c0--7814fca98edc4d0aaa60c78565901cd4 672fbe35227243019b4ca5c6a9e45326 X 7814fca98edc4d0aaa60c78565901cd4--672fbe35227243019b4ca5c6a9e45326 672fbe35227243019b4ca5c6a9e45326--a554ac52329347268ee0a7a4c4766e6e e535be7194924df8a34a74120b262315 672fbe35227243019b4ca5c6a9e45326--e535be7194924df8a34a74120b262315 559293dffb6d4f7b997ff81961c4dfb6 e535be7194924df8a34a74120b262315--559293dffb6d4f7b997ff81961c4dfb6 40715d4a545b4f8db59af1c92a305a47 559293dffb6d4f7b997ff81961c4dfb6--40715d4a545b4f8db59af1c92a305a47 362e6cf746d1453fb5a7ac38f43202f2 40715d4a545b4f8db59af1c92a305a47--362e6cf746d1453fb5a7ac38f43202f2 6b1e02abb01a43548d1538f108099fb9 362e6cf746d1453fb5a7ac38f43202f2--6b1e02abb01a43548d1538f108099fb9 0dfa0090123a475e8f50927f941f0004 6b1e02abb01a43548d1538f108099fb9--0dfa0090123a475e8f50927f941f0004 d7e7144ee61a45088d6ec251ba1cda5c 0dfa0090123a475e8f50927f941f0004--d7e7144ee61a45088d6ec251ba1cda5c e26e854357c546e6bb309cfbf84e9f46 d7e7144ee61a45088d6ec251ba1cda5c--e26e854357c546e6bb309cfbf84e9f46 782f46a9e75f4afd822034164607b1a1 e26e854357c546e6bb309cfbf84e9f46--782f46a9e75f4afd822034164607b1a1 d730e2bc48004d6aab53fdc7126ad9f4 X 782f46a9e75f4afd822034164607b1a1--d730e2bc48004d6aab53fdc7126ad9f4 d730e2bc48004d6aab53fdc7126ad9f4--ff1f8556842d4b17956351c82f809e1f 7ba485f1ebc146b985093e3f435bbb01 d730e2bc48004d6aab53fdc7126ad9f4--7ba485f1ebc146b985093e3f435bbb01 a64e4870064843c5a63a3e2c382325d4 X 7ba485f1ebc146b985093e3f435bbb01--a64e4870064843c5a63a3e2c382325d4 a64e4870064843c5a63a3e2c382325d4--50b3cf8c51b941b9894c2352a594f556 497d5a2870444446b03a9c4c969cefce RZ(-1.0*g0) a64e4870064843c5a63a3e2c382325d4--497d5a2870444446b03a9c4c969cefce 094322ed19a94e9895e41ea8ce526139 X 497d5a2870444446b03a9c4c969cefce--094322ed19a94e9895e41ea8ce526139 094322ed19a94e9895e41ea8ce526139--c40cde448a11440384403f471e24efba ec2e9421000845aea59c2f443d24f0d4 X 094322ed19a94e9895e41ea8ce526139--ec2e9421000845aea59c2f443d24f0d4 ec2e9421000845aea59c2f443d24f0d4--b07db01a29804264ae897f02fb5ac7c9 03a9ecc7ffea4b6ea877e730feefa4bf ec2e9421000845aea59c2f443d24f0d4--03a9ecc7ffea4b6ea877e730feefa4bf 185bd5498fdb43a7adf8e6c73e3e4dc6 03a9ecc7ffea4b6ea877e730feefa4bf--185bd5498fdb43a7adf8e6c73e3e4dc6 9e7d32ca665d44ca828432c9bd141cf4 185bd5498fdb43a7adf8e6c73e3e4dc6--9e7d32ca665d44ca828432c9bd141cf4 f3c52036f4ed4cca80b1f21750ec2a73 9e7d32ca665d44ca828432c9bd141cf4--f3c52036f4ed4cca80b1f21750ec2a73 45b2cf6142484be88e86eecfb8edd839 f3c52036f4ed4cca80b1f21750ec2a73--45b2cf6142484be88e86eecfb8edd839 1e82f99a5d2e4ea888f96b15bb1d583f 45b2cf6142484be88e86eecfb8edd839--1e82f99a5d2e4ea888f96b15bb1d583f 2cafa14693cc4b129eb1f9cf7f9a115c 1e82f99a5d2e4ea888f96b15bb1d583f--2cafa14693cc4b129eb1f9cf7f9a115c 0dcea9c181c3438391febb3770255512 X 2cafa14693cc4b129eb1f9cf7f9a115c--0dcea9c181c3438391febb3770255512 0dcea9c181c3438391febb3770255512--0f95cc78a42f403d86fd8e2c23f2b670 31eaec6ed2e4445591253a216b866661 0dcea9c181c3438391febb3770255512--31eaec6ed2e4445591253a216b866661 bc37d71f9c054c98a86d867ca22af95c 31eaec6ed2e4445591253a216b866661--bc37d71f9c054c98a86d867ca22af95c 3dc51389b0be4fc6a7f68a06adc66643 bc37d71f9c054c98a86d867ca22af95c--3dc51389b0be4fc6a7f68a06adc66643 14d75e226fb1444bb0dd51ccc1f70e1e 3dc51389b0be4fc6a7f68a06adc66643--14d75e226fb1444bb0dd51ccc1f70e1e 54afb1ac76204fa6929701ca87cf29b4 14d75e226fb1444bb0dd51ccc1f70e1e--54afb1ac76204fa6929701ca87cf29b4 5b2b6e2168bb467cbc0dcbabe66ea9cb 54afb1ac76204fa6929701ca87cf29b4--5b2b6e2168bb467cbc0dcbabe66ea9cb ff1c6cabc49c446c8c52344bac621107 5b2b6e2168bb467cbc0dcbabe66ea9cb--ff1c6cabc49c446c8c52344bac621107 7da0037eb0a2466da3cc33d25bf3faef ff1c6cabc49c446c8c52344bac621107--7da0037eb0a2466da3cc33d25bf3faef 586c0c1ec60b42599e99cbb20f3a4086 7da0037eb0a2466da3cc33d25bf3faef--586c0c1ec60b42599e99cbb20f3a4086 8eaca1b9093441b39378ebbf2626ed59 586c0c1ec60b42599e99cbb20f3a4086--8eaca1b9093441b39378ebbf2626ed59 99165802fb994aac93528aec1c84b53e 8eaca1b9093441b39378ebbf2626ed59--99165802fb994aac93528aec1c84b53e 67bc5e683c8b41969ce2aca11647dcfe 99165802fb994aac93528aec1c84b53e--67bc5e683c8b41969ce2aca11647dcfe 440d6ec113c9415cb285762266eb04b8 67bc5e683c8b41969ce2aca11647dcfe--440d6ec113c9415cb285762266eb04b8 3a5f98ad843447d5ae4323d217c19dea 440d6ec113c9415cb285762266eb04b8--3a5f98ad843447d5ae4323d217c19dea eb0ceab9805e493188b4e4d557c4cefb 3a5f98ad843447d5ae4323d217c19dea--eb0ceab9805e493188b4e4d557c4cefb 16fd9010ebc5455bac876bec6e21f948 eb0ceab9805e493188b4e4d557c4cefb--16fd9010ebc5455bac876bec6e21f948 fce3ba16c18840c0a8eb330db4cd8165 16fd9010ebc5455bac876bec6e21f948--fce3ba16c18840c0a8eb330db4cd8165 3b755e55ef98445596fb1d5918225a8f fce3ba16c18840c0a8eb330db4cd8165--3b755e55ef98445596fb1d5918225a8f 3f4ca5ce106c4ccaa34889b80cc997e8 3b755e55ef98445596fb1d5918225a8f--3f4ca5ce106c4ccaa34889b80cc997e8 03a1f0f6e4ef4844ae8cfed1dc87efca RX(b03) 3f4ca5ce106c4ccaa34889b80cc997e8--03a1f0f6e4ef4844ae8cfed1dc87efca f8beae1b4ee34b6f97fe2091b007ee56 03a1f0f6e4ef4844ae8cfed1dc87efca--f8beae1b4ee34b6f97fe2091b007ee56 4ec8ad86a6554020a2675a1603fbde91 f8beae1b4ee34b6f97fe2091b007ee56--4ec8ad86a6554020a2675a1603fbde91 a2e9cffbeaee41e3bb79c32571e432c0 X 4ec8ad86a6554020a2675a1603fbde91--a2e9cffbeaee41e3bb79c32571e432c0 a2e9cffbeaee41e3bb79c32571e432c0--6d3e9262bd834f95950a3937900d8c41 abae29d175454ba2bd021c04169efd28 a2e9cffbeaee41e3bb79c32571e432c0--abae29d175454ba2bd021c04169efd28 71fcc17401dd40299978d5e43165e1dd abae29d175454ba2bd021c04169efd28--71fcc17401dd40299978d5e43165e1dd 72fb060b851f41c48dbd418215b2a3ed 71fcc17401dd40299978d5e43165e1dd--72fb060b851f41c48dbd418215b2a3ed 156438f8b6cb47bd9ab479d475a6749f 72fb060b851f41c48dbd418215b2a3ed--156438f8b6cb47bd9ab479d475a6749f 70d4fec308fe4224ade378e648b398b0 156438f8b6cb47bd9ab479d475a6749f--70d4fec308fe4224ade378e648b398b0 9807ab5f2d3c493ca9d0445dd3d7976a 70d4fec308fe4224ade378e648b398b0--9807ab5f2d3c493ca9d0445dd3d7976a ef7d93f5037044eab38aea1961921c02 9807ab5f2d3c493ca9d0445dd3d7976a--ef7d93f5037044eab38aea1961921c02 49cb98f6f5cc43da89d2908591188f14 ef7d93f5037044eab38aea1961921c02--49cb98f6f5cc43da89d2908591188f14 13f2c3f6275d4759a49ea58e03c50ef8 49cb98f6f5cc43da89d2908591188f14--13f2c3f6275d4759a49ea58e03c50ef8 ebf31e951cd2420a8a9729fba985bc06 X 13f2c3f6275d4759a49ea58e03c50ef8--ebf31e951cd2420a8a9729fba985bc06 ebf31e951cd2420a8a9729fba985bc06--8f6a6e5d3d204203881e5578ff73505c 19eb69fa7fc74a0c8dbb5976f4722711 ebf31e951cd2420a8a9729fba985bc06--19eb69fa7fc74a0c8dbb5976f4722711 fc00c1debeee4b26a20ee57180b54dc8 19eb69fa7fc74a0c8dbb5976f4722711--fc00c1debeee4b26a20ee57180b54dc8 40c45ff8fdc64851b2c34203ece0c79b fc00c1debeee4b26a20ee57180b54dc8--40c45ff8fdc64851b2c34203ece0c79b 2e60ae6e881644b6a4ab3bb381564eb2 40c45ff8fdc64851b2c34203ece0c79b--2e60ae6e881644b6a4ab3bb381564eb2 b165cca88b5c4464b476959ca664a6d9 2e60ae6e881644b6a4ab3bb381564eb2--b165cca88b5c4464b476959ca664a6d9 10c9b6e304ce4851989d64a9a9b087d8 b165cca88b5c4464b476959ca664a6d9--10c9b6e304ce4851989d64a9a9b087d8 7729b155675148b18f028d1b723f3360 10c9b6e304ce4851989d64a9a9b087d8--7729b155675148b18f028d1b723f3360 a0524caf15334fbda7a20f1ad7d2c6ee 7729b155675148b18f028d1b723f3360--a0524caf15334fbda7a20f1ad7d2c6ee 2e4a93a3b28f4e3e8e315a399ca17522 a0524caf15334fbda7a20f1ad7d2c6ee--2e4a93a3b28f4e3e8e315a399ca17522 4041b61102a04f13b73024d300932c74 2e4a93a3b28f4e3e8e315a399ca17522--4041b61102a04f13b73024d300932c74 cad680e8bc4e41bdaa14cb057c3d6846 4041b61102a04f13b73024d300932c74--cad680e8bc4e41bdaa14cb057c3d6846 002c256a9f7e475da04d2167e7ab5ea3 cad680e8bc4e41bdaa14cb057c3d6846--002c256a9f7e475da04d2167e7ab5ea3 e01def9b4de44608b859ce7df0ef6ed2 X 002c256a9f7e475da04d2167e7ab5ea3--e01def9b4de44608b859ce7df0ef6ed2 e01def9b4de44608b859ce7df0ef6ed2--759b146dd3b149eb8970df6998c8ee42 7a3c82dc3ee1408ea2df45ac9c640d03 RZ(-1.0*g1) e01def9b4de44608b859ce7df0ef6ed2--7a3c82dc3ee1408ea2df45ac9c640d03 e492aacb1d5e407ea63b9c1c780f4912 X 7a3c82dc3ee1408ea2df45ac9c640d03--e492aacb1d5e407ea63b9c1c780f4912 e492aacb1d5e407ea63b9c1c780f4912--b1c236747bb74190b86e34b3a6092960 f2a8086dd05d4d2dab3ca1f00f7bbcfa e492aacb1d5e407ea63b9c1c780f4912--f2a8086dd05d4d2dab3ca1f00f7bbcfa 6e24b087a6f842d09c20060ed4946e6b f2a8086dd05d4d2dab3ca1f00f7bbcfa--6e24b087a6f842d09c20060ed4946e6b aa9c7851d428404a8169098848db3234 6e24b087a6f842d09c20060ed4946e6b--aa9c7851d428404a8169098848db3234 2e44834a7b04464c88631b99dbb80144 aa9c7851d428404a8169098848db3234--2e44834a7b04464c88631b99dbb80144 25172a7330c7421da5e9867077a433e8 X 2e44834a7b04464c88631b99dbb80144--25172a7330c7421da5e9867077a433e8 25172a7330c7421da5e9867077a433e8--cc134f7feb5b41038274d766ae7688d6 ffa8c0c88d1548a99d93ab6ba926a522 25172a7330c7421da5e9867077a433e8--ffa8c0c88d1548a99d93ab6ba926a522 46d8239c864a4a619c9b26382ea35a6a ffa8c0c88d1548a99d93ab6ba926a522--46d8239c864a4a619c9b26382ea35a6a 4003c4366de1427eb72866066bfac010 46d8239c864a4a619c9b26382ea35a6a--4003c4366de1427eb72866066bfac010 e172b372a765404c84b106b4a89a3848 X 4003c4366de1427eb72866066bfac010--e172b372a765404c84b106b4a89a3848 e172b372a765404c84b106b4a89a3848--035bdd1a18934a21ac4b07a389fd0b43 142a4afc3ae94172a567efe0879bf63c e172b372a765404c84b106b4a89a3848--142a4afc3ae94172a567efe0879bf63c b23ff34930894e11b82e8a3e389cc769 142a4afc3ae94172a567efe0879bf63c--b23ff34930894e11b82e8a3e389cc769 fde0f45841f54869a5a422147845d8de b23ff34930894e11b82e8a3e389cc769--fde0f45841f54869a5a422147845d8de 71f45143c78e474f8361a3fe7310e718 fde0f45841f54869a5a422147845d8de--71f45143c78e474f8361a3fe7310e718 151b6d2f5f244387b7e6f96118af8009 X 71f45143c78e474f8361a3fe7310e718--151b6d2f5f244387b7e6f96118af8009 151b6d2f5f244387b7e6f96118af8009--1ba05d3f519a4062ac89366ff0253151 e5e3323ce26e47349bcb34544d93923e 151b6d2f5f244387b7e6f96118af8009--e5e3323ce26e47349bcb34544d93923e 4650b284f45a4f2b84337fe99340de3c e5e3323ce26e47349bcb34544d93923e--4650b284f45a4f2b84337fe99340de3c 128b4912e2f5466c9cb17927cc0539a6 4650b284f45a4f2b84337fe99340de3c--128b4912e2f5466c9cb17927cc0539a6 44ba79d4c76d4539b636d88e6f00b6a8 128b4912e2f5466c9cb17927cc0539a6--44ba79d4c76d4539b636d88e6f00b6a8 f959ac48969d4b7c9ddf31c7df05ddc0 44ba79d4c76d4539b636d88e6f00b6a8--f959ac48969d4b7c9ddf31c7df05ddc0 4a937b8c1bac4143b95f0e4f1825e4c8 f959ac48969d4b7c9ddf31c7df05ddc0--4a937b8c1bac4143b95f0e4f1825e4c8 7e4bd917b55a464da7fd2c26314d8d16 4a937b8c1bac4143b95f0e4f1825e4c8--7e4bd917b55a464da7fd2c26314d8d16 fad86bc27d51476f85875a90691d4a78 X 7e4bd917b55a464da7fd2c26314d8d16--fad86bc27d51476f85875a90691d4a78 fad86bc27d51476f85875a90691d4a78--27b8f76c74ef4859a98af30466376326 2416baedd0c543e3aa496fff35475b77 fad86bc27d51476f85875a90691d4a78--2416baedd0c543e3aa496fff35475b77 1dde416becdf4eda84a2796de0fe6a74 2416baedd0c543e3aa496fff35475b77--1dde416becdf4eda84a2796de0fe6a74 39974eac16164b548b40f38da97ca139 1dde416becdf4eda84a2796de0fe6a74--39974eac16164b548b40f38da97ca139 28250cd00e794b8baa7187da3747e870 X 39974eac16164b548b40f38da97ca139--28250cd00e794b8baa7187da3747e870 28250cd00e794b8baa7187da3747e870--6e73a307ea9a4b338f74162b6f43f48a d814eafe463e485ea604c2d9e5470f53 28250cd00e794b8baa7187da3747e870--d814eafe463e485ea604c2d9e5470f53 d5130e98db40446e9ff38cb4eb574241 d814eafe463e485ea604c2d9e5470f53--d5130e98db40446e9ff38cb4eb574241 19b6feade84a4a92ad38b8b03abf3a1f d5130e98db40446e9ff38cb4eb574241--19b6feade84a4a92ad38b8b03abf3a1f 6a579e7b9956420ca5c360aa791de63d X 19b6feade84a4a92ad38b8b03abf3a1f--6a579e7b9956420ca5c360aa791de63d 6a579e7b9956420ca5c360aa791de63d--fb728d82bc8a4031892d200431ce471d 26ecb32c6da44e63b81a00c0aa314d5d 6a579e7b9956420ca5c360aa791de63d--26ecb32c6da44e63b81a00c0aa314d5d b68edb58fbdc494db69b7c9da503ab0d 26ecb32c6da44e63b81a00c0aa314d5d--b68edb58fbdc494db69b7c9da503ab0d 8f549bcd6cad4b51b26386b3d8e98dec X b68edb58fbdc494db69b7c9da503ab0d--8f549bcd6cad4b51b26386b3d8e98dec 8f549bcd6cad4b51b26386b3d8e98dec--5ef8c6f4e44b40d182056c3ecbbf24dc 6b754f764c4e495bbcf04f1c52cde762 8f549bcd6cad4b51b26386b3d8e98dec--6b754f764c4e495bbcf04f1c52cde762 1b81275c7a274aed9e30510c07c3d27c 6b754f764c4e495bbcf04f1c52cde762--1b81275c7a274aed9e30510c07c3d27c 0a0cbfd16b8946739efce90bb792020b 1b81275c7a274aed9e30510c07c3d27c--0a0cbfd16b8946739efce90bb792020b d0866056020343d0ac55348c0e70404d 0a0cbfd16b8946739efce90bb792020b--d0866056020343d0ac55348c0e70404d 273066db57f14a44a42e0855d4ab23f2 d0866056020343d0ac55348c0e70404d--273066db57f14a44a42e0855d4ab23f2 ae05b8acf4b243b78461d1901056fd6f X 273066db57f14a44a42e0855d4ab23f2--ae05b8acf4b243b78461d1901056fd6f ae05b8acf4b243b78461d1901056fd6f--e071fc92fd3045d3b1b81ed1118055b1 9e18aeb6bef84e238a161dd8192b446a ae05b8acf4b243b78461d1901056fd6f--9e18aeb6bef84e238a161dd8192b446a f662d92f18074a399ca88d717d8d9f9e 9e18aeb6bef84e238a161dd8192b446a--f662d92f18074a399ca88d717d8d9f9e 25562c91e0ab4a5a8cadb2c7dcb5563b X f662d92f18074a399ca88d717d8d9f9e--25562c91e0ab4a5a8cadb2c7dcb5563b 25562c91e0ab4a5a8cadb2c7dcb5563b--1dd60793ef1b45038b025ad9d1b7e3fd 1f980e6c47c241c08b1fa61ea4c255e9 25562c91e0ab4a5a8cadb2c7dcb5563b--1f980e6c47c241c08b1fa61ea4c255e9 0ca868941a6241599613850eb0f2ae9c 1f980e6c47c241c08b1fa61ea4c255e9--0ca868941a6241599613850eb0f2ae9c 2e8ba99b6c394222a9e65d397d1acddc 0ca868941a6241599613850eb0f2ae9c--2e8ba99b6c394222a9e65d397d1acddc 8fff04e2f42b4cbf9999f8562767a8e9 2e8ba99b6c394222a9e65d397d1acddc--8fff04e2f42b4cbf9999f8562767a8e9 169d971aa12e4990b8e83651ec776408 8fff04e2f42b4cbf9999f8562767a8e9--169d971aa12e4990b8e83651ec776408 546f2feda3514bd19590faebe683f044 169d971aa12e4990b8e83651ec776408--546f2feda3514bd19590faebe683f044 7eb77aac7be14fb58f2b8d705daf257d 546f2feda3514bd19590faebe683f044--7eb77aac7be14fb58f2b8d705daf257d f9ea77c00863402a81c840424f721ebc X 7eb77aac7be14fb58f2b8d705daf257d--f9ea77c00863402a81c840424f721ebc f9ea77c00863402a81c840424f721ebc--da25b865044c4bc79ea68fbb729305af 62fc6a7c833a4297b10308d5f47c64ed f9ea77c00863402a81c840424f721ebc--62fc6a7c833a4297b10308d5f47c64ed f380f90517674c198ed29dfef4583766 62fc6a7c833a4297b10308d5f47c64ed--f380f90517674c198ed29dfef4583766 055f7c3923144868b441330976ca5099 X f380f90517674c198ed29dfef4583766--055f7c3923144868b441330976ca5099 055f7c3923144868b441330976ca5099--693eee487426499e9a3b3bb7ed947da2 3ac703739ca948fdbb72fe5b66434749 055f7c3923144868b441330976ca5099--3ac703739ca948fdbb72fe5b66434749 a9c3839d0475461f999e0ff10025fbbf 3ac703739ca948fdbb72fe5b66434749--a9c3839d0475461f999e0ff10025fbbf 72f30bd03b4048a792793fc2478147c7 a9c3839d0475461f999e0ff10025fbbf--72f30bd03b4048a792793fc2478147c7 820cfd7d5518479aa089bc995f7a2a01 72f30bd03b4048a792793fc2478147c7--820cfd7d5518479aa089bc995f7a2a01 6c73b8c4ea8c4e8f861ce1396035b47d 820cfd7d5518479aa089bc995f7a2a01--6c73b8c4ea8c4e8f861ce1396035b47d a4c4dbbcd817495ca9d155a64eef07f8 6c73b8c4ea8c4e8f861ce1396035b47d--a4c4dbbcd817495ca9d155a64eef07f8 e1eee320e9b245ac9d1532705302788b a4c4dbbcd817495ca9d155a64eef07f8--e1eee320e9b245ac9d1532705302788b e86c68009bd14de58ccb929126173a59 e1eee320e9b245ac9d1532705302788b--e86c68009bd14de58ccb929126173a59 a3f516affc934e9b90203bfb7d12dc09 e86c68009bd14de58ccb929126173a59--a3f516affc934e9b90203bfb7d12dc09 811243d3f43c4c46bd48ff1981ef4ca8 X a3f516affc934e9b90203bfb7d12dc09--811243d3f43c4c46bd48ff1981ef4ca8 811243d3f43c4c46bd48ff1981ef4ca8--0ee6aa8749f248c09ffe37dd05b15021 f1b1da63244e4668b54f7d7a8220c126 811243d3f43c4c46bd48ff1981ef4ca8--f1b1da63244e4668b54f7d7a8220c126 5a4643b073be49b48ba8381bcbbeae4c X f1b1da63244e4668b54f7d7a8220c126--5a4643b073be49b48ba8381bcbbeae4c 5a4643b073be49b48ba8381bcbbeae4c--ebfa906792834be9b5164d43ba66af85 72a198e4f8d745c8bf87290d8468ecbd RZ(-1.0*g1) 5a4643b073be49b48ba8381bcbbeae4c--72a198e4f8d745c8bf87290d8468ecbd d946d51ac5794b5bb7f87b13334fe47d X 72a198e4f8d745c8bf87290d8468ecbd--d946d51ac5794b5bb7f87b13334fe47d d946d51ac5794b5bb7f87b13334fe47d--760e4ec328df4c90b969ecf9d838cb2b acbd372c135d45f4b10400af9748cd71 X d946d51ac5794b5bb7f87b13334fe47d--acbd372c135d45f4b10400af9748cd71 acbd372c135d45f4b10400af9748cd71--0482d923f4084a13982dc98bc0ea2040 e2e49170762243a48f49ab2896f576f7 acbd372c135d45f4b10400af9748cd71--e2e49170762243a48f49ab2896f576f7 1998d7f34bbc48c0bf9bd64ebe89bd7b e2e49170762243a48f49ab2896f576f7--1998d7f34bbc48c0bf9bd64ebe89bd7b 57ea1d61b56d4610b78327d626ac8b6e 1998d7f34bbc48c0bf9bd64ebe89bd7b--57ea1d61b56d4610b78327d626ac8b6e de4047d4b79f49e3a3ac6843c4e37f5a 57ea1d61b56d4610b78327d626ac8b6e--de4047d4b79f49e3a3ac6843c4e37f5a 165f50d9b3354a5a8f53406838bd0724 de4047d4b79f49e3a3ac6843c4e37f5a--165f50d9b3354a5a8f53406838bd0724 2ef086e7e80d4814ad186fb6e8306e7c 165f50d9b3354a5a8f53406838bd0724--2ef086e7e80d4814ad186fb6e8306e7c 31c8e46ce412420082560aec2b2f89b9 2ef086e7e80d4814ad186fb6e8306e7c--31c8e46ce412420082560aec2b2f89b9 75e63666901747dfa69ff5364e0e8335 X 31c8e46ce412420082560aec2b2f89b9--75e63666901747dfa69ff5364e0e8335 75e63666901747dfa69ff5364e0e8335--33e0e9ed48394ddda077bff99ee00c01 94104de3e34847b9be9142d3232e7a2d 75e63666901747dfa69ff5364e0e8335--94104de3e34847b9be9142d3232e7a2d 320487620f2147b59e3b7ccbdf427bc1 94104de3e34847b9be9142d3232e7a2d--320487620f2147b59e3b7ccbdf427bc1 ddcb0e59e3eb434e981e18626a6ab60a 320487620f2147b59e3b7ccbdf427bc1--ddcb0e59e3eb434e981e18626a6ab60a 2e472bae587f4836ab048edfa21ecf9c ddcb0e59e3eb434e981e18626a6ab60a--2e472bae587f4836ab048edfa21ecf9c 386ee72bc7f34bd5a21a8d0bb2a4df54 2e472bae587f4836ab048edfa21ecf9c--386ee72bc7f34bd5a21a8d0bb2a4df54 699728140f704459ba3a4af10c7cfc86 386ee72bc7f34bd5a21a8d0bb2a4df54--699728140f704459ba3a4af10c7cfc86 856cd201e87d40f6b9b122cdea5befc4 699728140f704459ba3a4af10c7cfc86--856cd201e87d40f6b9b122cdea5befc4 5ba4380b584246a191a6a26bf4d1f175 856cd201e87d40f6b9b122cdea5befc4--5ba4380b584246a191a6a26bf4d1f175 dbd7b2a441de451f9457d791aee10b89 5ba4380b584246a191a6a26bf4d1f175--dbd7b2a441de451f9457d791aee10b89 49c58f0af9e94eedbdb06608578f9ab7 dbd7b2a441de451f9457d791aee10b89--49c58f0af9e94eedbdb06608578f9ab7 4a49b59c15e34fd883722bfcbbad3fe0 49c58f0af9e94eedbdb06608578f9ab7--4a49b59c15e34fd883722bfcbbad3fe0 87f6b77968af45919eb885823c5d8140 4a49b59c15e34fd883722bfcbbad3fe0--87f6b77968af45919eb885823c5d8140 a87bf99896834e7fa1154ed3b1a06185 87f6b77968af45919eb885823c5d8140--a87bf99896834e7fa1154ed3b1a06185 a4c9675b2f294212ae5af6e998fec1dd a87bf99896834e7fa1154ed3b1a06185--a4c9675b2f294212ae5af6e998fec1dd 54e74f6e1ef74098b0f548bdb42a552b a4c9675b2f294212ae5af6e998fec1dd--54e74f6e1ef74098b0f548bdb42a552b b663c457d0b843c2bcbb287d904ef03b 54e74f6e1ef74098b0f548bdb42a552b--b663c457d0b843c2bcbb287d904ef03b bf42c086f6ae4730bc9cb3579b7bbe9a b663c457d0b843c2bcbb287d904ef03b--bf42c086f6ae4730bc9cb3579b7bbe9a 959449be885c46cab9590fd87648562a bf42c086f6ae4730bc9cb3579b7bbe9a--959449be885c46cab9590fd87648562a d30afc6a26a540b0827f68376310b140 959449be885c46cab9590fd87648562a--d30afc6a26a540b0827f68376310b140 c53cfcd5d6294b8f8fdc247d7159577c RX(b13) d30afc6a26a540b0827f68376310b140--c53cfcd5d6294b8f8fdc247d7159577c c53cfcd5d6294b8f8fdc247d7159577c--b5f76321495046598c4e036572d814c9 1f62b431dd7040f9a9f539d91f7f76fc 55311b7d69764a729f0173799cc99e55 f5ec58c878af489192b2c666836d7c9f--55311b7d69764a729f0173799cc99e55 1df49b1af96c41fdb7081c3b9afd4d65 5 4c406f59bc104eada7153fdb61998e12 55311b7d69764a729f0173799cc99e55--4c406f59bc104eada7153fdb61998e12 8aaad9e0882d40fda2be71cc1e99bf0a 4c406f59bc104eada7153fdb61998e12--8aaad9e0882d40fda2be71cc1e99bf0a d7761bf2058b4c3180cc5adbb81b3548 X 8aaad9e0882d40fda2be71cc1e99bf0a--d7761bf2058b4c3180cc5adbb81b3548 d7761bf2058b4c3180cc5adbb81b3548--d65f5f72e596497bb8aef46bbb3e4a37 a46bb0e2ddee46d1af4243bd30455679 d7761bf2058b4c3180cc5adbb81b3548--a46bb0e2ddee46d1af4243bd30455679 b2e1fbab2d0f4c6ea23563f9ff11d8b2 a46bb0e2ddee46d1af4243bd30455679--b2e1fbab2d0f4c6ea23563f9ff11d8b2 d506f838f4af4bff91b4730aa1a2feda b2e1fbab2d0f4c6ea23563f9ff11d8b2--d506f838f4af4bff91b4730aa1a2feda 46f50443ff83417488c390aae87d6e50 d506f838f4af4bff91b4730aa1a2feda--46f50443ff83417488c390aae87d6e50 25cd8c3c6b374c72b95d5f17d8642904 46f50443ff83417488c390aae87d6e50--25cd8c3c6b374c72b95d5f17d8642904 412502c3fcab481fb8251a836cf520d0 25cd8c3c6b374c72b95d5f17d8642904--412502c3fcab481fb8251a836cf520d0 88994450491a41afaac054a6fcb4e682 412502c3fcab481fb8251a836cf520d0--88994450491a41afaac054a6fcb4e682 c6feb47b59cf4d36a38d51c1954d990d X 88994450491a41afaac054a6fcb4e682--c6feb47b59cf4d36a38d51c1954d990d c6feb47b59cf4d36a38d51c1954d990d--abcfd2bacd154f0bb7840c39eabbbfef 3878c4b96371485abd5fa9e0d4d4cada c6feb47b59cf4d36a38d51c1954d990d--3878c4b96371485abd5fa9e0d4d4cada a3ddbf5211184306b98f8b97525903a1 3878c4b96371485abd5fa9e0d4d4cada--a3ddbf5211184306b98f8b97525903a1 74307a6960c34f8098cb304c46996cfe a3ddbf5211184306b98f8b97525903a1--74307a6960c34f8098cb304c46996cfe 00d499003a534eab99257e1b22cccccd 74307a6960c34f8098cb304c46996cfe--00d499003a534eab99257e1b22cccccd a01275248955443994910551cd44fa5c 00d499003a534eab99257e1b22cccccd--a01275248955443994910551cd44fa5c a48d3b7d273149f7be75daff84bc260f a01275248955443994910551cd44fa5c--a48d3b7d273149f7be75daff84bc260f 1f0228043d4b4be3bddadd7179072e0b a48d3b7d273149f7be75daff84bc260f--1f0228043d4b4be3bddadd7179072e0b 54ec81dd21b24d75953b9ca4b1d8adc4 1f0228043d4b4be3bddadd7179072e0b--54ec81dd21b24d75953b9ca4b1d8adc4 0d90d020540e49bc831381285d41c2ff 54ec81dd21b24d75953b9ca4b1d8adc4--0d90d020540e49bc831381285d41c2ff 679cc80786c9400b84ee7c3bf97e6560 0d90d020540e49bc831381285d41c2ff--679cc80786c9400b84ee7c3bf97e6560 549b0de19df44f889455497560f1968c 679cc80786c9400b84ee7c3bf97e6560--549b0de19df44f889455497560f1968c a2044bfdb5034644a851593b55391624 549b0de19df44f889455497560f1968c--a2044bfdb5034644a851593b55391624 f36ef6726b274a2eb4905a7de1236ee9 a2044bfdb5034644a851593b55391624--f36ef6726b274a2eb4905a7de1236ee9 5616f3e9eeba490f9f7326a778d71437 f36ef6726b274a2eb4905a7de1236ee9--5616f3e9eeba490f9f7326a778d71437 d075ffa481d84b87b3a2d575525d4f5d 5616f3e9eeba490f9f7326a778d71437--d075ffa481d84b87b3a2d575525d4f5d 355b05a36ffd4495ac086381f0f3b287 d075ffa481d84b87b3a2d575525d4f5d--355b05a36ffd4495ac086381f0f3b287 ff0e7ca126704828b3a31f1440abce17 355b05a36ffd4495ac086381f0f3b287--ff0e7ca126704828b3a31f1440abce17 cd3dea88988c4a399dd450243dc50396 ff0e7ca126704828b3a31f1440abce17--cd3dea88988c4a399dd450243dc50396 9e2d994a571e4f1c921abfb82bd21331 cd3dea88988c4a399dd450243dc50396--9e2d994a571e4f1c921abfb82bd21331 fdf77be72b2b48e89086c4423294e229 9e2d994a571e4f1c921abfb82bd21331--fdf77be72b2b48e89086c4423294e229 aa505b825e9144babc87a6950caa537a fdf77be72b2b48e89086c4423294e229--aa505b825e9144babc87a6950caa537a 2a7fe2d4616f4abb927db3dd32aed4b8 X aa505b825e9144babc87a6950caa537a--2a7fe2d4616f4abb927db3dd32aed4b8 2a7fe2d4616f4abb927db3dd32aed4b8--04a89f95fbb3470a9b3c2c41596d37d9 32733ea9f62a42c5a99c1b33ae03a184 RZ(-1.0*g0) 2a7fe2d4616f4abb927db3dd32aed4b8--32733ea9f62a42c5a99c1b33ae03a184 c5f32fc571004007b4a59b3d680a7a6c X 32733ea9f62a42c5a99c1b33ae03a184--c5f32fc571004007b4a59b3d680a7a6c c5f32fc571004007b4a59b3d680a7a6c--6d03c3dcfbdb44cda6d33b9a03548a21 4e5fb9320dd042ffbc81c3c73618caed c5f32fc571004007b4a59b3d680a7a6c--4e5fb9320dd042ffbc81c3c73618caed 0eacc571461648809132fc745d3fd9fa 4e5fb9320dd042ffbc81c3c73618caed--0eacc571461648809132fc745d3fd9fa fdc673a3877844cf97371ed71337f2fe 0eacc571461648809132fc745d3fd9fa--fdc673a3877844cf97371ed71337f2fe b84766856ee347c582a4cd275837d632 fdc673a3877844cf97371ed71337f2fe--b84766856ee347c582a4cd275837d632 8eb1aa3b087f4f7faef5b4a407121e91 b84766856ee347c582a4cd275837d632--8eb1aa3b087f4f7faef5b4a407121e91 729733e2cfdf43a8bad6435edd1da40e 8eb1aa3b087f4f7faef5b4a407121e91--729733e2cfdf43a8bad6435edd1da40e 81c370a03e2d4a58be2a8f49ba678084 X 729733e2cfdf43a8bad6435edd1da40e--81c370a03e2d4a58be2a8f49ba678084 81c370a03e2d4a58be2a8f49ba678084--8e929ce1b94a4ceea1daae53bf8aa56f 98fecff9a9e8406d896217a3840a7b4b 81c370a03e2d4a58be2a8f49ba678084--98fecff9a9e8406d896217a3840a7b4b 159e6bc4041e4ad88e6717dcecb814e4 98fecff9a9e8406d896217a3840a7b4b--159e6bc4041e4ad88e6717dcecb814e4 88a6b5a5640542448713034ccebf6f33 159e6bc4041e4ad88e6717dcecb814e4--88a6b5a5640542448713034ccebf6f33 747d19540b184b5eabafb762bb63da04 88a6b5a5640542448713034ccebf6f33--747d19540b184b5eabafb762bb63da04 af9b5b6e97ff486f945e54c2624bb408 747d19540b184b5eabafb762bb63da04--af9b5b6e97ff486f945e54c2624bb408 bd6ba72bb1994230a5269a52ac7ec4bd X af9b5b6e97ff486f945e54c2624bb408--bd6ba72bb1994230a5269a52ac7ec4bd bd6ba72bb1994230a5269a52ac7ec4bd--c6e8a316a8b64e99a662b7eb0647f624 78840c7975b04bd58b45d9abac51de61 bd6ba72bb1994230a5269a52ac7ec4bd--78840c7975b04bd58b45d9abac51de61 ec280ae55c2a45b6b4966e135fafdc93 78840c7975b04bd58b45d9abac51de61--ec280ae55c2a45b6b4966e135fafdc93 0f0769ab3a4a4374b3bcf17c7056d16a ec280ae55c2a45b6b4966e135fafdc93--0f0769ab3a4a4374b3bcf17c7056d16a debf302e96fd4f47abafa747cbad2fa2 0f0769ab3a4a4374b3bcf17c7056d16a--debf302e96fd4f47abafa747cbad2fa2 12afd63c718641c7a8f4e33e5ad86db6 debf302e96fd4f47abafa747cbad2fa2--12afd63c718641c7a8f4e33e5ad86db6 cba0bed3bf1b45a6aada5e7643e2753f X 12afd63c718641c7a8f4e33e5ad86db6--cba0bed3bf1b45a6aada5e7643e2753f cba0bed3bf1b45a6aada5e7643e2753f--5a2b96c93eb144a7b12f7058c2f3a2a0 50a461c9c0a44c32bd3774ad765b6e50 RZ(-1.0*g0) cba0bed3bf1b45a6aada5e7643e2753f--50a461c9c0a44c32bd3774ad765b6e50 bb1541bc34fb42959df790516af57ae1 X 50a461c9c0a44c32bd3774ad765b6e50--bb1541bc34fb42959df790516af57ae1 bb1541bc34fb42959df790516af57ae1--98146cdcf1ba492abc1ce7fb56ee3f46 3443ce7ba93143358cb5b44ee3b97e4e bb1541bc34fb42959df790516af57ae1--3443ce7ba93143358cb5b44ee3b97e4e 3953e5ab45084bf5be08f077c1e067d2 3443ce7ba93143358cb5b44ee3b97e4e--3953e5ab45084bf5be08f077c1e067d2 90c81ce90be54ef39b0589be7690fb34 3953e5ab45084bf5be08f077c1e067d2--90c81ce90be54ef39b0589be7690fb34 0227b220674c4ded8a1e987cd5e6005f 90c81ce90be54ef39b0589be7690fb34--0227b220674c4ded8a1e987cd5e6005f 134bbd112b944b31a1cff4509eaab14b X 0227b220674c4ded8a1e987cd5e6005f--134bbd112b944b31a1cff4509eaab14b 134bbd112b944b31a1cff4509eaab14b--b626f22e98e546948a3631b359bba090 2cf77830feec4e92bf500687aba6a966 134bbd112b944b31a1cff4509eaab14b--2cf77830feec4e92bf500687aba6a966 43bc8a65d829430cb8ebb33aac57055a 2cf77830feec4e92bf500687aba6a966--43bc8a65d829430cb8ebb33aac57055a f38f64d8eced4386b090dda1050d84f7 43bc8a65d829430cb8ebb33aac57055a--f38f64d8eced4386b090dda1050d84f7 1de169cf4da24d4f9515b61988a9c605 X f38f64d8eced4386b090dda1050d84f7--1de169cf4da24d4f9515b61988a9c605 1de169cf4da24d4f9515b61988a9c605--f0522071a1ee4a77940a673c6139be6c 099290c2dae04f4ea4ac4341341dde4b 1de169cf4da24d4f9515b61988a9c605--099290c2dae04f4ea4ac4341341dde4b e52f602fb72146a286142345e6cd88e9 099290c2dae04f4ea4ac4341341dde4b--e52f602fb72146a286142345e6cd88e9 8347eff170164ca392565a8b4f4ee5cd e52f602fb72146a286142345e6cd88e9--8347eff170164ca392565a8b4f4ee5cd 7fae6fdd0a3f4f5d91d6b51da696b920 8347eff170164ca392565a8b4f4ee5cd--7fae6fdd0a3f4f5d91d6b51da696b920 2b6f2d45e23c4a43a4359a9e04117c32 X 7fae6fdd0a3f4f5d91d6b51da696b920--2b6f2d45e23c4a43a4359a9e04117c32 2b6f2d45e23c4a43a4359a9e04117c32--ca4ec57453594f4e8b50706592c6d19c 97d9773aa0b54da2ba3e9d7577370caa 2b6f2d45e23c4a43a4359a9e04117c32--97d9773aa0b54da2ba3e9d7577370caa 9983d458d8ee4e1f8716d7db1ed45831 97d9773aa0b54da2ba3e9d7577370caa--9983d458d8ee4e1f8716d7db1ed45831 7f13af86fb6840229f0fda78441e7933 9983d458d8ee4e1f8716d7db1ed45831--7f13af86fb6840229f0fda78441e7933 c8bbb8b6b59745fba86776e1831b4382 7f13af86fb6840229f0fda78441e7933--c8bbb8b6b59745fba86776e1831b4382 171db9336ad84e49b705fd33cc1afc45 c8bbb8b6b59745fba86776e1831b4382--171db9336ad84e49b705fd33cc1afc45 64fa1dead10645c09e627a763917e289 X 171db9336ad84e49b705fd33cc1afc45--64fa1dead10645c09e627a763917e289 64fa1dead10645c09e627a763917e289--040b6d3681fa45d8ad017ddb8002a72d 5c54e48fc602467396cb1f6f9b49453e 64fa1dead10645c09e627a763917e289--5c54e48fc602467396cb1f6f9b49453e 2a45079ab3e94dbeb38f319a7e2a7131 5c54e48fc602467396cb1f6f9b49453e--2a45079ab3e94dbeb38f319a7e2a7131 78c765334f4646f0beb08f9fee83debc 2a45079ab3e94dbeb38f319a7e2a7131--78c765334f4646f0beb08f9fee83debc 618fce83441c4a989be07793d4a16121 78c765334f4646f0beb08f9fee83debc--618fce83441c4a989be07793d4a16121 d2c0047b143f4999a6e2963a37626c63 X 618fce83441c4a989be07793d4a16121--d2c0047b143f4999a6e2963a37626c63 d2c0047b143f4999a6e2963a37626c63--e535be7194924df8a34a74120b262315 0bde421443284283ac8c1ed2badf6eb7 d2c0047b143f4999a6e2963a37626c63--0bde421443284283ac8c1ed2badf6eb7 3fa8cef9deb742f6a3b42ac6edb7413d 0bde421443284283ac8c1ed2badf6eb7--3fa8cef9deb742f6a3b42ac6edb7413d ecd83549bd374eafb93e3bda5d4a1c69 3fa8cef9deb742f6a3b42ac6edb7413d--ecd83549bd374eafb93e3bda5d4a1c69 fa024b3df68243dbac9f07edb63b77fb ecd83549bd374eafb93e3bda5d4a1c69--fa024b3df68243dbac9f07edb63b77fb d216c88d20a548a5b9b8a18eca8cf333 fa024b3df68243dbac9f07edb63b77fb--d216c88d20a548a5b9b8a18eca8cf333 3fc79db6505d422099cc719d5c80aca6 d216c88d20a548a5b9b8a18eca8cf333--3fc79db6505d422099cc719d5c80aca6 14f0c7f2a8ad45d68cc5256dd60a9bdb 3fc79db6505d422099cc719d5c80aca6--14f0c7f2a8ad45d68cc5256dd60a9bdb db614398b2d14ec8bf703203c793d229 X 14f0c7f2a8ad45d68cc5256dd60a9bdb--db614398b2d14ec8bf703203c793d229 db614398b2d14ec8bf703203c793d229--782f46a9e75f4afd822034164607b1a1 d4024fe7e6a9449f8b68b0e3386d04ce db614398b2d14ec8bf703203c793d229--d4024fe7e6a9449f8b68b0e3386d04ce 7dff6a1eb00b4de18fb8304c59d8496c d4024fe7e6a9449f8b68b0e3386d04ce--7dff6a1eb00b4de18fb8304c59d8496c ca924d43e7ef435d8812a02ea35d747b 7dff6a1eb00b4de18fb8304c59d8496c--ca924d43e7ef435d8812a02ea35d747b aac8d68579be40caa56b7e21a617b66f ca924d43e7ef435d8812a02ea35d747b--aac8d68579be40caa56b7e21a617b66f f555416909024557832092eef4f84b91 aac8d68579be40caa56b7e21a617b66f--f555416909024557832092eef4f84b91 39589b5b841841df82c49201e6dab5ba f555416909024557832092eef4f84b91--39589b5b841841df82c49201e6dab5ba 593c9b60f24943e88c6a878013542adb X 39589b5b841841df82c49201e6dab5ba--593c9b60f24943e88c6a878013542adb 593c9b60f24943e88c6a878013542adb--03a9ecc7ffea4b6ea877e730feefa4bf a167c9d0cb314301b466d40840039561 593c9b60f24943e88c6a878013542adb--a167c9d0cb314301b466d40840039561 f6fa03f0747b4d508b0498ad7bdc4771 a167c9d0cb314301b466d40840039561--f6fa03f0747b4d508b0498ad7bdc4771 03bdabac32364eb3abe6f803f3419b87 f6fa03f0747b4d508b0498ad7bdc4771--03bdabac32364eb3abe6f803f3419b87 d1397498da15487cb71dec962cdce249 03bdabac32364eb3abe6f803f3419b87--d1397498da15487cb71dec962cdce249 dc136d25f8ca4fce8d67c6722a9d8c0f d1397498da15487cb71dec962cdce249--dc136d25f8ca4fce8d67c6722a9d8c0f a2a2ed30308844529aaf0b05bbb65046 X dc136d25f8ca4fce8d67c6722a9d8c0f--a2a2ed30308844529aaf0b05bbb65046 a2a2ed30308844529aaf0b05bbb65046--2cafa14693cc4b129eb1f9cf7f9a115c 03a214ba989e4905acf0597a6286861f a2a2ed30308844529aaf0b05bbb65046--03a214ba989e4905acf0597a6286861f b8691f7e3dbc484eb4befebfbb3881fb X 03a214ba989e4905acf0597a6286861f--b8691f7e3dbc484eb4befebfbb3881fb b8691f7e3dbc484eb4befebfbb3881fb--31eaec6ed2e4445591253a216b866661 226e421272c54eb19ccb97f5385b553f RZ(-1.0*g0) b8691f7e3dbc484eb4befebfbb3881fb--226e421272c54eb19ccb97f5385b553f f74d23d43f0847f9b1c59270b609a592 X 226e421272c54eb19ccb97f5385b553f--f74d23d43f0847f9b1c59270b609a592 f74d23d43f0847f9b1c59270b609a592--3dc51389b0be4fc6a7f68a06adc66643 3fef9f02aec14d0386611d671b408ff8 X f74d23d43f0847f9b1c59270b609a592--3fef9f02aec14d0386611d671b408ff8 3fef9f02aec14d0386611d671b408ff8--14d75e226fb1444bb0dd51ccc1f70e1e 0e03810436a74476bc5f6b87f95529fa 3fef9f02aec14d0386611d671b408ff8--0e03810436a74476bc5f6b87f95529fa 1f21bfe379df445c87fcdc89280134fa 0e03810436a74476bc5f6b87f95529fa--1f21bfe379df445c87fcdc89280134fa c2ece6e2f06b477fa888946c5b2b1741 1f21bfe379df445c87fcdc89280134fa--c2ece6e2f06b477fa888946c5b2b1741 90534cf2dbee40c1b0b84f0b43a73214 X c2ece6e2f06b477fa888946c5b2b1741--90534cf2dbee40c1b0b84f0b43a73214 90534cf2dbee40c1b0b84f0b43a73214--7da0037eb0a2466da3cc33d25bf3faef 4f583920b4fc4908923373cc489f31c1 90534cf2dbee40c1b0b84f0b43a73214--4f583920b4fc4908923373cc489f31c1 14e2f5dacfb247a88c87cb06086c400f 4f583920b4fc4908923373cc489f31c1--14e2f5dacfb247a88c87cb06086c400f 260f385f44e44b3b89a4c2613e020314 14e2f5dacfb247a88c87cb06086c400f--260f385f44e44b3b89a4c2613e020314 46d95b20b2c44c7a9b891dde057d3dfb 260f385f44e44b3b89a4c2613e020314--46d95b20b2c44c7a9b891dde057d3dfb aa4769bd1ef0469bb52f04196d7276bd 46d95b20b2c44c7a9b891dde057d3dfb--aa4769bd1ef0469bb52f04196d7276bd 46e15b26d9184e15a11acdd70e3a7841 aa4769bd1ef0469bb52f04196d7276bd--46e15b26d9184e15a11acdd70e3a7841 bec8300a7802456cabcb32555095e80d 46e15b26d9184e15a11acdd70e3a7841--bec8300a7802456cabcb32555095e80d 69147a68027e4ed3b94a212ebd8df28b bec8300a7802456cabcb32555095e80d--69147a68027e4ed3b94a212ebd8df28b 736b0e6634b3419088a67883151468d9 69147a68027e4ed3b94a212ebd8df28b--736b0e6634b3419088a67883151468d9 e2098b8532a64de5aeef735f08f374c8 736b0e6634b3419088a67883151468d9--e2098b8532a64de5aeef735f08f374c8 9d1b859a0ed348f0a732a2986a00499d e2098b8532a64de5aeef735f08f374c8--9d1b859a0ed348f0a732a2986a00499d 0fdb20b3b491462298b50d9e3fb3caf3 RX(b04) 9d1b859a0ed348f0a732a2986a00499d--0fdb20b3b491462298b50d9e3fb3caf3 023afe78c7a241ca849a5c57613bfc8a 0fdb20b3b491462298b50d9e3fb3caf3--023afe78c7a241ca849a5c57613bfc8a 4b30362e2c5646d8a95b2c1934a50f1a 023afe78c7a241ca849a5c57613bfc8a--4b30362e2c5646d8a95b2c1934a50f1a 9b90247760ab47438a2946f574d1c2fa 4b30362e2c5646d8a95b2c1934a50f1a--9b90247760ab47438a2946f574d1c2fa 3e05a7cf664247deb7696bfd4e61e04f X 9b90247760ab47438a2946f574d1c2fa--3e05a7cf664247deb7696bfd4e61e04f 3e05a7cf664247deb7696bfd4e61e04f--abae29d175454ba2bd021c04169efd28 15a821ed1bba4ecc954eed85193cc2c2 3e05a7cf664247deb7696bfd4e61e04f--15a821ed1bba4ecc954eed85193cc2c2 bc0b502343164c6d816bcb89560fd80a 15a821ed1bba4ecc954eed85193cc2c2--bc0b502343164c6d816bcb89560fd80a 2922a70a443e4cdfaf60741923d334b2 bc0b502343164c6d816bcb89560fd80a--2922a70a443e4cdfaf60741923d334b2 1b62a197c577478fa98483fb6e1b898a 2922a70a443e4cdfaf60741923d334b2--1b62a197c577478fa98483fb6e1b898a 38c310022e884307b25cf88697a50874 1b62a197c577478fa98483fb6e1b898a--38c310022e884307b25cf88697a50874 fb63208f02d244abbb27a94d361f79bf 38c310022e884307b25cf88697a50874--fb63208f02d244abbb27a94d361f79bf 0ae390cc4791445ba1e6c6993adcfc1e fb63208f02d244abbb27a94d361f79bf--0ae390cc4791445ba1e6c6993adcfc1e a272ea88f4ff4e53ad93d5b0a371ef41 X 0ae390cc4791445ba1e6c6993adcfc1e--a272ea88f4ff4e53ad93d5b0a371ef41 a272ea88f4ff4e53ad93d5b0a371ef41--13f2c3f6275d4759a49ea58e03c50ef8 69e3aea7c9014de7a39526063bce3be5 a272ea88f4ff4e53ad93d5b0a371ef41--69e3aea7c9014de7a39526063bce3be5 cdeafffd57b044ad9407e74aaeec45cf 69e3aea7c9014de7a39526063bce3be5--cdeafffd57b044ad9407e74aaeec45cf 18ee3a4f2ab6499d973cc99dd4d0b5be cdeafffd57b044ad9407e74aaeec45cf--18ee3a4f2ab6499d973cc99dd4d0b5be 20170220547642579ff9c8e67c5ee4e1 18ee3a4f2ab6499d973cc99dd4d0b5be--20170220547642579ff9c8e67c5ee4e1 e11e80a4fd8f4fb0bba173625776dde1 20170220547642579ff9c8e67c5ee4e1--e11e80a4fd8f4fb0bba173625776dde1 7f518839a2cd43e181be5aa203632763 e11e80a4fd8f4fb0bba173625776dde1--7f518839a2cd43e181be5aa203632763 c66ae50ff6d747b8a884746835633480 7f518839a2cd43e181be5aa203632763--c66ae50ff6d747b8a884746835633480 18e7cc5064b1480db81dd7c3cff802d1 c66ae50ff6d747b8a884746835633480--18e7cc5064b1480db81dd7c3cff802d1 d14e9ac9bad6496081ba7cdb34205c54 18e7cc5064b1480db81dd7c3cff802d1--d14e9ac9bad6496081ba7cdb34205c54 4efae88d1c2f4056a0e2cb8841b46ae7 d14e9ac9bad6496081ba7cdb34205c54--4efae88d1c2f4056a0e2cb8841b46ae7 27a1249a1b4a4aec9d949a0b611446f5 4efae88d1c2f4056a0e2cb8841b46ae7--27a1249a1b4a4aec9d949a0b611446f5 2d628286d89e419489760ea65319d8a9 27a1249a1b4a4aec9d949a0b611446f5--2d628286d89e419489760ea65319d8a9 52eb987c47404e9799e37ea4ef29e198 2d628286d89e419489760ea65319d8a9--52eb987c47404e9799e37ea4ef29e198 3cd9faa2836743b5bed8645926028f19 52eb987c47404e9799e37ea4ef29e198--3cd9faa2836743b5bed8645926028f19 822f405138394299ab7b0a4261a158ea 3cd9faa2836743b5bed8645926028f19--822f405138394299ab7b0a4261a158ea 768a9990a5774b43bb26ce313c7ed781 822f405138394299ab7b0a4261a158ea--768a9990a5774b43bb26ce313c7ed781 e5fea683150947c284b8cace56661419 768a9990a5774b43bb26ce313c7ed781--e5fea683150947c284b8cace56661419 6f9257ee905d443cb60f50ade4dca436 e5fea683150947c284b8cace56661419--6f9257ee905d443cb60f50ade4dca436 d4b71fcb4fd34ef19b76b753ea3a5206 6f9257ee905d443cb60f50ade4dca436--d4b71fcb4fd34ef19b76b753ea3a5206 f9dcacf2fc954a2eb844539b176a5a9d d4b71fcb4fd34ef19b76b753ea3a5206--f9dcacf2fc954a2eb844539b176a5a9d 00619d6327e9418aa51399ba9afa0121 f9dcacf2fc954a2eb844539b176a5a9d--00619d6327e9418aa51399ba9afa0121 75e7d69dd5754d2098c3ba911e106fa0 X 00619d6327e9418aa51399ba9afa0121--75e7d69dd5754d2098c3ba911e106fa0 75e7d69dd5754d2098c3ba911e106fa0--ffa8c0c88d1548a99d93ab6ba926a522 4fc3a0d836f349659be8b0efebc15a3d RZ(-1.0*g1) 75e7d69dd5754d2098c3ba911e106fa0--4fc3a0d836f349659be8b0efebc15a3d e86d8ae2c63d4f9cb8e810880503cd69 X 4fc3a0d836f349659be8b0efebc15a3d--e86d8ae2c63d4f9cb8e810880503cd69 e86d8ae2c63d4f9cb8e810880503cd69--4003c4366de1427eb72866066bfac010 151cb098841940cb9689e24184c2caab e86d8ae2c63d4f9cb8e810880503cd69--151cb098841940cb9689e24184c2caab 0f09ae3eeafa4c14b37dda1882da64d8 151cb098841940cb9689e24184c2caab--0f09ae3eeafa4c14b37dda1882da64d8 11ccf614a43d4ca4b2c2c393dd35c0c0 0f09ae3eeafa4c14b37dda1882da64d8--11ccf614a43d4ca4b2c2c393dd35c0c0 0ce67144de324d8594a547891c8d09b3 11ccf614a43d4ca4b2c2c393dd35c0c0--0ce67144de324d8594a547891c8d09b3 b2b4f7e1c90c4ef2bde1c1ebfefc7f5d 0ce67144de324d8594a547891c8d09b3--b2b4f7e1c90c4ef2bde1c1ebfefc7f5d e93b998ce511497b98d905e4bd2c9bf0 b2b4f7e1c90c4ef2bde1c1ebfefc7f5d--e93b998ce511497b98d905e4bd2c9bf0 3b0ec7cb8701458384ec9108bb5a387c X e93b998ce511497b98d905e4bd2c9bf0--3b0ec7cb8701458384ec9108bb5a387c 3b0ec7cb8701458384ec9108bb5a387c--e5e3323ce26e47349bcb34544d93923e 676a8a4b726646f09409c3c97b2fef37 3b0ec7cb8701458384ec9108bb5a387c--676a8a4b726646f09409c3c97b2fef37 e4d83ec221224a53b830d503a6b8215d 676a8a4b726646f09409c3c97b2fef37--e4d83ec221224a53b830d503a6b8215d e0a8fdee29e54c3dab5ded0313b1521d e4d83ec221224a53b830d503a6b8215d--e0a8fdee29e54c3dab5ded0313b1521d 2317a52d666a4e209bac8a0e2787aef0 e0a8fdee29e54c3dab5ded0313b1521d--2317a52d666a4e209bac8a0e2787aef0 44e2ac2aec914af080fc74e2a2e89135 2317a52d666a4e209bac8a0e2787aef0--44e2ac2aec914af080fc74e2a2e89135 eab85a93c9b1415ea6dfbd2fb11ec12c X 44e2ac2aec914af080fc74e2a2e89135--eab85a93c9b1415ea6dfbd2fb11ec12c eab85a93c9b1415ea6dfbd2fb11ec12c--7e4bd917b55a464da7fd2c26314d8d16 fabdcbaab0604f33a49b82e41d8828c2 eab85a93c9b1415ea6dfbd2fb11ec12c--fabdcbaab0604f33a49b82e41d8828c2 00300ecb346a41cab53d854933246594 fabdcbaab0604f33a49b82e41d8828c2--00300ecb346a41cab53d854933246594 fcbc495fcad647f38f9d9887d92cd45b 00300ecb346a41cab53d854933246594--fcbc495fcad647f38f9d9887d92cd45b e6a008d691cb4596897dde0aa8b72bd7 fcbc495fcad647f38f9d9887d92cd45b--e6a008d691cb4596897dde0aa8b72bd7 944f9df372ae480bb0abca6b1afaeb82 e6a008d691cb4596897dde0aa8b72bd7--944f9df372ae480bb0abca6b1afaeb82 1e748f9375cd452282bffa3825c564cf X 944f9df372ae480bb0abca6b1afaeb82--1e748f9375cd452282bffa3825c564cf 1e748f9375cd452282bffa3825c564cf--d814eafe463e485ea604c2d9e5470f53 2cbddb3b01394e9bb8a71833ed01ff51 RZ(-1.0*g1) 1e748f9375cd452282bffa3825c564cf--2cbddb3b01394e9bb8a71833ed01ff51 3eaf85059ff44115ae586bb353cf28bf X 2cbddb3b01394e9bb8a71833ed01ff51--3eaf85059ff44115ae586bb353cf28bf 3eaf85059ff44115ae586bb353cf28bf--19b6feade84a4a92ad38b8b03abf3a1f d2eba23a80084329b7795e0c37867715 3eaf85059ff44115ae586bb353cf28bf--d2eba23a80084329b7795e0c37867715 e4192a0931364bd68b5174c79a99865a d2eba23a80084329b7795e0c37867715--e4192a0931364bd68b5174c79a99865a b5a60c9e363a40b1ab54e5dad821de3f e4192a0931364bd68b5174c79a99865a--b5a60c9e363a40b1ab54e5dad821de3f bff37bb4feee4c038f53b3e4c496d095 b5a60c9e363a40b1ab54e5dad821de3f--bff37bb4feee4c038f53b3e4c496d095 67a05934298547a398af8da6532188e7 X bff37bb4feee4c038f53b3e4c496d095--67a05934298547a398af8da6532188e7 67a05934298547a398af8da6532188e7--6b754f764c4e495bbcf04f1c52cde762 8f3da28a94914725be900602ea7e35ad 67a05934298547a398af8da6532188e7--8f3da28a94914725be900602ea7e35ad 0f8cb980d09c499eb59027da36abae81 8f3da28a94914725be900602ea7e35ad--0f8cb980d09c499eb59027da36abae81 bab020e2e3e149d39cb28e97d2344511 0f8cb980d09c499eb59027da36abae81--bab020e2e3e149d39cb28e97d2344511 7472f5cb24b441cba9547e913d4a2872 X bab020e2e3e149d39cb28e97d2344511--7472f5cb24b441cba9547e913d4a2872 7472f5cb24b441cba9547e913d4a2872--273066db57f14a44a42e0855d4ab23f2 ccdaea0a874c41a0baee238d336fc349 7472f5cb24b441cba9547e913d4a2872--ccdaea0a874c41a0baee238d336fc349 f6dcb5803f6948558eec536005fdf898 ccdaea0a874c41a0baee238d336fc349--f6dcb5803f6948558eec536005fdf898 30094c0da14c4a9ab702c38fb0de0cd2 f6dcb5803f6948558eec536005fdf898--30094c0da14c4a9ab702c38fb0de0cd2 30df0e31c5f847448b4af6a6582d8a85 30094c0da14c4a9ab702c38fb0de0cd2--30df0e31c5f847448b4af6a6582d8a85 2777859b1f6640f28d9da65954553b1d X 30df0e31c5f847448b4af6a6582d8a85--2777859b1f6640f28d9da65954553b1d 2777859b1f6640f28d9da65954553b1d--1f980e6c47c241c08b1fa61ea4c255e9 a75be92b3c5a48cf9e22a05b45ac9c82 2777859b1f6640f28d9da65954553b1d--a75be92b3c5a48cf9e22a05b45ac9c82 07569519310f4f6ebe1a659543c468a3 a75be92b3c5a48cf9e22a05b45ac9c82--07569519310f4f6ebe1a659543c468a3 aa466f71f19741149e49a3695ad34ee7 07569519310f4f6ebe1a659543c468a3--aa466f71f19741149e49a3695ad34ee7 01c0c36f16074b1f8de67942afdd9ec2 aa466f71f19741149e49a3695ad34ee7--01c0c36f16074b1f8de67942afdd9ec2 1e94ea6037c341dcadc19118b1ae2e63 01c0c36f16074b1f8de67942afdd9ec2--1e94ea6037c341dcadc19118b1ae2e63 40f57395782947d3bad58da883873df4 X 1e94ea6037c341dcadc19118b1ae2e63--40f57395782947d3bad58da883873df4 40f57395782947d3bad58da883873df4--7eb77aac7be14fb58f2b8d705daf257d 496779bf263246a69e377619b1a45e78 40f57395782947d3bad58da883873df4--496779bf263246a69e377619b1a45e78 f66d112ece7e41809d59134cbc6bff01 496779bf263246a69e377619b1a45e78--f66d112ece7e41809d59134cbc6bff01 4e66b5b401224deeb79db35912d571db f66d112ece7e41809d59134cbc6bff01--4e66b5b401224deeb79db35912d571db 1297bfdc21e84d4cb4c0ec963b60daa7 4e66b5b401224deeb79db35912d571db--1297bfdc21e84d4cb4c0ec963b60daa7 3166eb1a5e684dda9deece5a2b8d4231 X 1297bfdc21e84d4cb4c0ec963b60daa7--3166eb1a5e684dda9deece5a2b8d4231 3166eb1a5e684dda9deece5a2b8d4231--3ac703739ca948fdbb72fe5b66434749 f4f9ba73d6ce4ad4a77610a8a48676c2 3166eb1a5e684dda9deece5a2b8d4231--f4f9ba73d6ce4ad4a77610a8a48676c2 e565676e8e71462cb82bc83f111d6f66 f4f9ba73d6ce4ad4a77610a8a48676c2--e565676e8e71462cb82bc83f111d6f66 4861d11c73d04b72a8256fb5866031b6 e565676e8e71462cb82bc83f111d6f66--4861d11c73d04b72a8256fb5866031b6 f1af7a2a89c94d5081a5ce881062f11e 4861d11c73d04b72a8256fb5866031b6--f1af7a2a89c94d5081a5ce881062f11e 0fc5a8befe8a46c0a9cfa665a668c8f4 f1af7a2a89c94d5081a5ce881062f11e--0fc5a8befe8a46c0a9cfa665a668c8f4 63b84d2807c646749b6480e06d2ad29b 0fc5a8befe8a46c0a9cfa665a668c8f4--63b84d2807c646749b6480e06d2ad29b e2c1c73d60044ade9c5fcde1fcf00748 63b84d2807c646749b6480e06d2ad29b--e2c1c73d60044ade9c5fcde1fcf00748 bf942eec9064466ca8090ff83b964812 X e2c1c73d60044ade9c5fcde1fcf00748--bf942eec9064466ca8090ff83b964812 bf942eec9064466ca8090ff83b964812--a3f516affc934e9b90203bfb7d12dc09 fbee614d7674406d98ef554225310cde bf942eec9064466ca8090ff83b964812--fbee614d7674406d98ef554225310cde 17528182502542b58da809f9736b59db fbee614d7674406d98ef554225310cde--17528182502542b58da809f9736b59db 109f0e03ab414176927efd048d061ee9 17528182502542b58da809f9736b59db--109f0e03ab414176927efd048d061ee9 b974b386627746d780755581b937a47d 109f0e03ab414176927efd048d061ee9--b974b386627746d780755581b937a47d 71b66f712be64630a57cd3a7bf1cc68e b974b386627746d780755581b937a47d--71b66f712be64630a57cd3a7bf1cc68e 60ebd91c76d6499a8484fce948a2d193 71b66f712be64630a57cd3a7bf1cc68e--60ebd91c76d6499a8484fce948a2d193 24b692a033214039b48dae52b60009d7 X 60ebd91c76d6499a8484fce948a2d193--24b692a033214039b48dae52b60009d7 24b692a033214039b48dae52b60009d7--e2e49170762243a48f49ab2896f576f7 32599956ef8d47fb894a612276ff9efb 24b692a033214039b48dae52b60009d7--32599956ef8d47fb894a612276ff9efb eb9ee5dcf46b4b4fa00acab585ed6aaf 32599956ef8d47fb894a612276ff9efb--eb9ee5dcf46b4b4fa00acab585ed6aaf d0a448f05ff54ad9bd7d83d2ffd38004 eb9ee5dcf46b4b4fa00acab585ed6aaf--d0a448f05ff54ad9bd7d83d2ffd38004 69595a1ae21e41dc99ea9fa743d8b2e1 d0a448f05ff54ad9bd7d83d2ffd38004--69595a1ae21e41dc99ea9fa743d8b2e1 5dbd0a52645a481db8e42ab8980eacad 69595a1ae21e41dc99ea9fa743d8b2e1--5dbd0a52645a481db8e42ab8980eacad 3670af791f734d14b7bd9a7a34bdef0d X 5dbd0a52645a481db8e42ab8980eacad--3670af791f734d14b7bd9a7a34bdef0d 3670af791f734d14b7bd9a7a34bdef0d--31c8e46ce412420082560aec2b2f89b9 16f033f1c20445d19f082e3dff8b90ff 3670af791f734d14b7bd9a7a34bdef0d--16f033f1c20445d19f082e3dff8b90ff 6b7dc26d27cf453c9bb43229b6d39b7d X 16f033f1c20445d19f082e3dff8b90ff--6b7dc26d27cf453c9bb43229b6d39b7d 6b7dc26d27cf453c9bb43229b6d39b7d--94104de3e34847b9be9142d3232e7a2d 60b0f77a564b49d8a7f4369d30d088a5 RZ(-1.0*g1) 6b7dc26d27cf453c9bb43229b6d39b7d--60b0f77a564b49d8a7f4369d30d088a5 3f4da438902b4d7d9dd3fe918fcf0cd5 X 60b0f77a564b49d8a7f4369d30d088a5--3f4da438902b4d7d9dd3fe918fcf0cd5 3f4da438902b4d7d9dd3fe918fcf0cd5--ddcb0e59e3eb434e981e18626a6ab60a c692771e1f1143968c5fbbaa8ae23904 X 3f4da438902b4d7d9dd3fe918fcf0cd5--c692771e1f1143968c5fbbaa8ae23904 c692771e1f1143968c5fbbaa8ae23904--2e472bae587f4836ab048edfa21ecf9c b8b0ca8535a94af7b65e4b0ef1cc4903 c692771e1f1143968c5fbbaa8ae23904--b8b0ca8535a94af7b65e4b0ef1cc4903 a8c79b97e1144b4aacd0e688c575e5d4 b8b0ca8535a94af7b65e4b0ef1cc4903--a8c79b97e1144b4aacd0e688c575e5d4 09fed3e37c1441f7a32105da2a45f06e a8c79b97e1144b4aacd0e688c575e5d4--09fed3e37c1441f7a32105da2a45f06e 18696d83cde9455dbb51e8e4b7a52975 X 09fed3e37c1441f7a32105da2a45f06e--18696d83cde9455dbb51e8e4b7a52975 18696d83cde9455dbb51e8e4b7a52975--5ba4380b584246a191a6a26bf4d1f175 a1d08c95b3034ed9bc2b77fce7353f46 18696d83cde9455dbb51e8e4b7a52975--a1d08c95b3034ed9bc2b77fce7353f46 d0540900e5ec4bea982c3f20b765dc7d a1d08c95b3034ed9bc2b77fce7353f46--d0540900e5ec4bea982c3f20b765dc7d 2c32b2a022e14cfc9c210eb90db9a50a d0540900e5ec4bea982c3f20b765dc7d--2c32b2a022e14cfc9c210eb90db9a50a b344030ce316488fbe8157eb6fecdcec 2c32b2a022e14cfc9c210eb90db9a50a--b344030ce316488fbe8157eb6fecdcec a8ee0e0778ca474f8e350934161274fe b344030ce316488fbe8157eb6fecdcec--a8ee0e0778ca474f8e350934161274fe 93a84e90c74c46cca13747f5d1bb6570 a8ee0e0778ca474f8e350934161274fe--93a84e90c74c46cca13747f5d1bb6570 77176363664844b6bc40755b5cb4345b 93a84e90c74c46cca13747f5d1bb6570--77176363664844b6bc40755b5cb4345b 6de4367e06254d3ea9d3eb0f63069a4c 77176363664844b6bc40755b5cb4345b--6de4367e06254d3ea9d3eb0f63069a4c f7cd427d49364f709131ca9e7c4a7a14 6de4367e06254d3ea9d3eb0f63069a4c--f7cd427d49364f709131ca9e7c4a7a14 4a3e6c004ad64bac884b2110322970bc f7cd427d49364f709131ca9e7c4a7a14--4a3e6c004ad64bac884b2110322970bc 8396113cdd1f4e819eaf5c4ce508b645 4a3e6c004ad64bac884b2110322970bc--8396113cdd1f4e819eaf5c4ce508b645 cd9b7300b8a24be493788e066a5573b0 RX(b14) 8396113cdd1f4e819eaf5c4ce508b645--cd9b7300b8a24be493788e066a5573b0 cd9b7300b8a24be493788e066a5573b0--1f62b431dd7040f9a9f539d91f7f76fc 4d456b50d8a74ba8b1c28b86e32ad019 123c52e80b5546c1a92de9802722ef76 1df49b1af96c41fdb7081c3b9afd4d65--123c52e80b5546c1a92de9802722ef76 3ff4536c95d0497f9b925f1cb60be8f1 6 0d3e9e2a5ae349a293be0af0068c152d 123c52e80b5546c1a92de9802722ef76--0d3e9e2a5ae349a293be0af0068c152d 5a977274bc3444959aeb0f5e25be21ee 0d3e9e2a5ae349a293be0af0068c152d--5a977274bc3444959aeb0f5e25be21ee b99e628db3a04b4fa1b316c47bf0a07a 5a977274bc3444959aeb0f5e25be21ee--b99e628db3a04b4fa1b316c47bf0a07a 9423fba9e06c4687875f4b2190f4ebe0 X b99e628db3a04b4fa1b316c47bf0a07a--9423fba9e06c4687875f4b2190f4ebe0 9423fba9e06c4687875f4b2190f4ebe0--a46bb0e2ddee46d1af4243bd30455679 1dfbf772f26b4fe4b20624e8fb18437b 9423fba9e06c4687875f4b2190f4ebe0--1dfbf772f26b4fe4b20624e8fb18437b 23b1abeaa2ff4a949d5a6c85cd94c976 1dfbf772f26b4fe4b20624e8fb18437b--23b1abeaa2ff4a949d5a6c85cd94c976 7e5c28867a4348349812e691eb801c04 23b1abeaa2ff4a949d5a6c85cd94c976--7e5c28867a4348349812e691eb801c04 6bbff17f695b40cb816939e94b2050d5 7e5c28867a4348349812e691eb801c04--6bbff17f695b40cb816939e94b2050d5 5f6f68d7ab014180b3233356237a82c4 6bbff17f695b40cb816939e94b2050d5--5f6f68d7ab014180b3233356237a82c4 22561c07cbd0450b9fd9fb1501afe8fc X 5f6f68d7ab014180b3233356237a82c4--22561c07cbd0450b9fd9fb1501afe8fc 22561c07cbd0450b9fd9fb1501afe8fc--88994450491a41afaac054a6fcb4e682 d75be31d8ca24fb7be8ebf507d818502 22561c07cbd0450b9fd9fb1501afe8fc--d75be31d8ca24fb7be8ebf507d818502 7138263d94b549a99cc621a5f3b0f6fa d75be31d8ca24fb7be8ebf507d818502--7138263d94b549a99cc621a5f3b0f6fa 21f13a75d82a4926b5314026ca93a71d 7138263d94b549a99cc621a5f3b0f6fa--21f13a75d82a4926b5314026ca93a71d fc624fea8db84fe9aa231e6ea25a8143 21f13a75d82a4926b5314026ca93a71d--fc624fea8db84fe9aa231e6ea25a8143 501f9efaea084c828e8e52fae230671a fc624fea8db84fe9aa231e6ea25a8143--501f9efaea084c828e8e52fae230671a 5e14e214b54043de875f3c09682798da 501f9efaea084c828e8e52fae230671a--5e14e214b54043de875f3c09682798da 914c95887f714585b749927481673a6e 5e14e214b54043de875f3c09682798da--914c95887f714585b749927481673a6e 9cc7ad315bc34402a696d55a52712787 914c95887f714585b749927481673a6e--9cc7ad315bc34402a696d55a52712787 f4ff461bdf5c4ce6829990a8d5ff182c 9cc7ad315bc34402a696d55a52712787--f4ff461bdf5c4ce6829990a8d5ff182c 9e78a0f5104d4baea13c1aa29e6a5be1 f4ff461bdf5c4ce6829990a8d5ff182c--9e78a0f5104d4baea13c1aa29e6a5be1 853e949a2e41405fa7808ba986787ec1 9e78a0f5104d4baea13c1aa29e6a5be1--853e949a2e41405fa7808ba986787ec1 9631c1b1ee24418e84312e855ba627fb 853e949a2e41405fa7808ba986787ec1--9631c1b1ee24418e84312e855ba627fb 36d2b74321c0494ebb5072d5bb77a4d2 9631c1b1ee24418e84312e855ba627fb--36d2b74321c0494ebb5072d5bb77a4d2 091833a793f54b68839920b85d8fad05 36d2b74321c0494ebb5072d5bb77a4d2--091833a793f54b68839920b85d8fad05 c45ced6f644d4c50a82ab7d871d5c0ac 091833a793f54b68839920b85d8fad05--c45ced6f644d4c50a82ab7d871d5c0ac 52d13ee641a647898510351b2a3bacd0 c45ced6f644d4c50a82ab7d871d5c0ac--52d13ee641a647898510351b2a3bacd0 857d8d1e8018456bab97f724d00e05e3 52d13ee641a647898510351b2a3bacd0--857d8d1e8018456bab97f724d00e05e3 359f8c602bbc44228c12db5c756e94d2 857d8d1e8018456bab97f724d00e05e3--359f8c602bbc44228c12db5c756e94d2 a6246d603afd4c1f9321e9e02608bcc7 359f8c602bbc44228c12db5c756e94d2--a6246d603afd4c1f9321e9e02608bcc7 5b60cb11f7e34a1eaf9b03bfc81b5b39 a6246d603afd4c1f9321e9e02608bcc7--5b60cb11f7e34a1eaf9b03bfc81b5b39 41ab853e7fb44138b6de3c1d6f919e32 5b60cb11f7e34a1eaf9b03bfc81b5b39--41ab853e7fb44138b6de3c1d6f919e32 441eaf42a186448e881bad9c9c2c89c5 41ab853e7fb44138b6de3c1d6f919e32--441eaf42a186448e881bad9c9c2c89c5 0e86134f548d442fbdf5775c6c1fcd19 441eaf42a186448e881bad9c9c2c89c5--0e86134f548d442fbdf5775c6c1fcd19 caffb3d8fd4d40bb961b72412654c411 0e86134f548d442fbdf5775c6c1fcd19--caffb3d8fd4d40bb961b72412654c411 5425b3b0e306456f9873472100adee9f caffb3d8fd4d40bb961b72412654c411--5425b3b0e306456f9873472100adee9f b410ab63aa9a4702aa110cbd456b6dda 5425b3b0e306456f9873472100adee9f--b410ab63aa9a4702aa110cbd456b6dda 93b75340271b4db686c4bad2647ac064 b410ab63aa9a4702aa110cbd456b6dda--93b75340271b4db686c4bad2647ac064 afdec258240d4a9cb3b25cbb521fa160 93b75340271b4db686c4bad2647ac064--afdec258240d4a9cb3b25cbb521fa160 b291ee10ed4440d08248cd6319113926 afdec258240d4a9cb3b25cbb521fa160--b291ee10ed4440d08248cd6319113926 ad024806781e4babbff9f2f55caa22ad b291ee10ed4440d08248cd6319113926--ad024806781e4babbff9f2f55caa22ad 4aa1ffcb936f45309203236130ef7a84 ad024806781e4babbff9f2f55caa22ad--4aa1ffcb936f45309203236130ef7a84 0a5510ccdf1a4a8db9ff5f2541181411 4aa1ffcb936f45309203236130ef7a84--0a5510ccdf1a4a8db9ff5f2541181411 64623cc62b904ac0ad55896158cfa98e X 0a5510ccdf1a4a8db9ff5f2541181411--64623cc62b904ac0ad55896158cfa98e 64623cc62b904ac0ad55896158cfa98e--98fecff9a9e8406d896217a3840a7b4b 79958165801d40fabd87ca6ed0166f2e 64623cc62b904ac0ad55896158cfa98e--79958165801d40fabd87ca6ed0166f2e 0cfadf4e0e2841a8baa19530721b3a35 79958165801d40fabd87ca6ed0166f2e--0cfadf4e0e2841a8baa19530721b3a35 c7c100572d984ad595ba7cbd71ad189d 0cfadf4e0e2841a8baa19530721b3a35--c7c100572d984ad595ba7cbd71ad189d 506e6aa5ec7b4af9b5297572394ed1ce X c7c100572d984ad595ba7cbd71ad189d--506e6aa5ec7b4af9b5297572394ed1ce 506e6aa5ec7b4af9b5297572394ed1ce--af9b5b6e97ff486f945e54c2624bb408 39cbb3d55d0344898babcb42827f6a89 506e6aa5ec7b4af9b5297572394ed1ce--39cbb3d55d0344898babcb42827f6a89 dabac6efde7b4f30bf87fcbe6d5c5e15 39cbb3d55d0344898babcb42827f6a89--dabac6efde7b4f30bf87fcbe6d5c5e15 03b2b9019b2d451aae035644b7460328 dabac6efde7b4f30bf87fcbe6d5c5e15--03b2b9019b2d451aae035644b7460328 4058177177214b9b8c5d964c7b26edbf 03b2b9019b2d451aae035644b7460328--4058177177214b9b8c5d964c7b26edbf 42c140b51f5b4d44b5a484056e48b9e8 4058177177214b9b8c5d964c7b26edbf--42c140b51f5b4d44b5a484056e48b9e8 1bb62849e57b4432919a6fe40f920c53 42c140b51f5b4d44b5a484056e48b9e8--1bb62849e57b4432919a6fe40f920c53 ceb32ebd8bd94afaa29be60da5eef97b 1bb62849e57b4432919a6fe40f920c53--ceb32ebd8bd94afaa29be60da5eef97b 48e612e9a67a4ea1b4878439feddaa7c ceb32ebd8bd94afaa29be60da5eef97b--48e612e9a67a4ea1b4878439feddaa7c 3d076fe90d584a91ac9e9e3d06ac84f6 48e612e9a67a4ea1b4878439feddaa7c--3d076fe90d584a91ac9e9e3d06ac84f6 da7820ff1b00407e95682a9890e4eedd 3d076fe90d584a91ac9e9e3d06ac84f6--da7820ff1b00407e95682a9890e4eedd a7c8e0e1eadb44a0b546b1b11e6c35ea da7820ff1b00407e95682a9890e4eedd--a7c8e0e1eadb44a0b546b1b11e6c35ea a1c4c1765bcf414699a9be8fe2558149 a7c8e0e1eadb44a0b546b1b11e6c35ea--a1c4c1765bcf414699a9be8fe2558149 8abc1199417242efbba26635f13ac755 a1c4c1765bcf414699a9be8fe2558149--8abc1199417242efbba26635f13ac755 1928c929272a4c8e985b8781e9af1075 8abc1199417242efbba26635f13ac755--1928c929272a4c8e985b8781e9af1075 c6d9331c61a74da99a8fdaae27597126 X 1928c929272a4c8e985b8781e9af1075--c6d9331c61a74da99a8fdaae27597126 c6d9331c61a74da99a8fdaae27597126--2cf77830feec4e92bf500687aba6a966 2cd4828b474a48efa0572af1e5a10617 RZ(-1.0*g0) c6d9331c61a74da99a8fdaae27597126--2cd4828b474a48efa0572af1e5a10617 94a19c5e06df42e58ddf15966de92425 X 2cd4828b474a48efa0572af1e5a10617--94a19c5e06df42e58ddf15966de92425 94a19c5e06df42e58ddf15966de92425--f38f64d8eced4386b090dda1050d84f7 c55096e75d4c4f6db3a790decbeb09c6 94a19c5e06df42e58ddf15966de92425--c55096e75d4c4f6db3a790decbeb09c6 662f78605122433eafe14ca5698cf4d9 c55096e75d4c4f6db3a790decbeb09c6--662f78605122433eafe14ca5698cf4d9 41da4ff805b5430f97a6fe20f4e58b4a 662f78605122433eafe14ca5698cf4d9--41da4ff805b5430f97a6fe20f4e58b4a dd31190d6b174e7c8cbb46b269902b27 41da4ff805b5430f97a6fe20f4e58b4a--dd31190d6b174e7c8cbb46b269902b27 ddd9fb810f4b4380bb609782dfe2acaf dd31190d6b174e7c8cbb46b269902b27--ddd9fb810f4b4380bb609782dfe2acaf d73b24705adb4d47ad0419048de1275c ddd9fb810f4b4380bb609782dfe2acaf--d73b24705adb4d47ad0419048de1275c c28a58eabe054687aa5459cbcef13214 X d73b24705adb4d47ad0419048de1275c--c28a58eabe054687aa5459cbcef13214 c28a58eabe054687aa5459cbcef13214--97d9773aa0b54da2ba3e9d7577370caa 1350b2aeb3124f5398a2ffbf2dec6b46 c28a58eabe054687aa5459cbcef13214--1350b2aeb3124f5398a2ffbf2dec6b46 25af8b644fa04e938e1c39c363fe429f 1350b2aeb3124f5398a2ffbf2dec6b46--25af8b644fa04e938e1c39c363fe429f 2c686a7fc66447d8804aace55c0ce617 25af8b644fa04e938e1c39c363fe429f--2c686a7fc66447d8804aace55c0ce617 21d85723ea38471ca9c6f6fcd4ee7089 X 2c686a7fc66447d8804aace55c0ce617--21d85723ea38471ca9c6f6fcd4ee7089 21d85723ea38471ca9c6f6fcd4ee7089--171db9336ad84e49b705fd33cc1afc45 4893b0d18feb4881a36bcd1a479d82e4 21d85723ea38471ca9c6f6fcd4ee7089--4893b0d18feb4881a36bcd1a479d82e4 187f518eba40492fa926c58f9eaf0fc0 4893b0d18feb4881a36bcd1a479d82e4--187f518eba40492fa926c58f9eaf0fc0 11429dac7821440da1fcdd0a7f251d60 187f518eba40492fa926c58f9eaf0fc0--11429dac7821440da1fcdd0a7f251d60 903e9f88f33a414d827f4c045501615d 11429dac7821440da1fcdd0a7f251d60--903e9f88f33a414d827f4c045501615d 7e4b60ab04b44a939da38e399dcfd69c 903e9f88f33a414d827f4c045501615d--7e4b60ab04b44a939da38e399dcfd69c e0bf83be637d426492c58f6289570ef2 7e4b60ab04b44a939da38e399dcfd69c--e0bf83be637d426492c58f6289570ef2 bac5199d8a70496f8dc23002e499b850 X e0bf83be637d426492c58f6289570ef2--bac5199d8a70496f8dc23002e499b850 bac5199d8a70496f8dc23002e499b850--0bde421443284283ac8c1ed2badf6eb7 6fb149fad5854d4c96413fb3d0d524a7 bac5199d8a70496f8dc23002e499b850--6fb149fad5854d4c96413fb3d0d524a7 f76ba00320114d86912b19560b51e578 6fb149fad5854d4c96413fb3d0d524a7--f76ba00320114d86912b19560b51e578 3c6f1ab07bc042d1b62dbcb7615c1685 f76ba00320114d86912b19560b51e578--3c6f1ab07bc042d1b62dbcb7615c1685 1974ccdb7c9e479abe768a17130f117b 3c6f1ab07bc042d1b62dbcb7615c1685--1974ccdb7c9e479abe768a17130f117b f8aa18ac992b4a74a223843cc990130b 1974ccdb7c9e479abe768a17130f117b--f8aa18ac992b4a74a223843cc990130b 96c1383bfb2848a49ab0396b95ac527c X f8aa18ac992b4a74a223843cc990130b--96c1383bfb2848a49ab0396b95ac527c 96c1383bfb2848a49ab0396b95ac527c--14f0c7f2a8ad45d68cc5256dd60a9bdb b2ecda8af1e34d92a97886ae690a3d03 96c1383bfb2848a49ab0396b95ac527c--b2ecda8af1e34d92a97886ae690a3d03 cb3dc31ccc6247adb10c1255ddc613e4 b2ecda8af1e34d92a97886ae690a3d03--cb3dc31ccc6247adb10c1255ddc613e4 5cd24d5608474eff8c321eca0838b53b cb3dc31ccc6247adb10c1255ddc613e4--5cd24d5608474eff8c321eca0838b53b 568b8e9e3ff64f23a5ef7c28294e8b16 5cd24d5608474eff8c321eca0838b53b--568b8e9e3ff64f23a5ef7c28294e8b16 4e81d040aea94f5e95331abe86b1b548 568b8e9e3ff64f23a5ef7c28294e8b16--4e81d040aea94f5e95331abe86b1b548 15077a427e0b4170b357ac2b8c14c5d3 4e81d040aea94f5e95331abe86b1b548--15077a427e0b4170b357ac2b8c14c5d3 284a110da88e45a688f6d5620a2dd132 15077a427e0b4170b357ac2b8c14c5d3--284a110da88e45a688f6d5620a2dd132 6450b4a346754153a9d1feaa4ddf9a65 284a110da88e45a688f6d5620a2dd132--6450b4a346754153a9d1feaa4ddf9a65 d0b6a2ba48534c4db565b29b4b7406fa X 6450b4a346754153a9d1feaa4ddf9a65--d0b6a2ba48534c4db565b29b4b7406fa d0b6a2ba48534c4db565b29b4b7406fa--a167c9d0cb314301b466d40840039561 4642c3ea65bf47c5a34f20ceb4785084 d0b6a2ba48534c4db565b29b4b7406fa--4642c3ea65bf47c5a34f20ceb4785084 49a3fbe92f044fbc8c670d61ba6a586b 4642c3ea65bf47c5a34f20ceb4785084--49a3fbe92f044fbc8c670d61ba6a586b f3c6605cb23240628f162bc33c8f7cef 49a3fbe92f044fbc8c670d61ba6a586b--f3c6605cb23240628f162bc33c8f7cef fed92f1ca35f4f9fb4bc28aca776442d X f3c6605cb23240628f162bc33c8f7cef--fed92f1ca35f4f9fb4bc28aca776442d fed92f1ca35f4f9fb4bc28aca776442d--dc136d25f8ca4fce8d67c6722a9d8c0f ad9607702e2947e0930d3eaa37d26802 fed92f1ca35f4f9fb4bc28aca776442d--ad9607702e2947e0930d3eaa37d26802 822e1381ed284043bdbe73891b6efac8 ad9607702e2947e0930d3eaa37d26802--822e1381ed284043bdbe73891b6efac8 81e94101a2944f02b554d3c253e22d2a 822e1381ed284043bdbe73891b6efac8--81e94101a2944f02b554d3c253e22d2a 713932d371ea4a43b19db6c2ecbb5c54 81e94101a2944f02b554d3c253e22d2a--713932d371ea4a43b19db6c2ecbb5c54 3751b5e827f940b9b13d4b9ea7cd154e 713932d371ea4a43b19db6c2ecbb5c54--3751b5e827f940b9b13d4b9ea7cd154e 123756b096294e58aab5322182d2846d 3751b5e827f940b9b13d4b9ea7cd154e--123756b096294e58aab5322182d2846d 34b26fb187514ff6aeb8ccd074c49ad5 X 123756b096294e58aab5322182d2846d--34b26fb187514ff6aeb8ccd074c49ad5 34b26fb187514ff6aeb8ccd074c49ad5--0e03810436a74476bc5f6b87f95529fa 47cb8f0a36fd4690888ec55b8a9f9c90 RZ(-1.0*g0) 34b26fb187514ff6aeb8ccd074c49ad5--47cb8f0a36fd4690888ec55b8a9f9c90 33fdbbc1b2d9425ea3227878567a0c3d X 47cb8f0a36fd4690888ec55b8a9f9c90--33fdbbc1b2d9425ea3227878567a0c3d 33fdbbc1b2d9425ea3227878567a0c3d--c2ece6e2f06b477fa888946c5b2b1741 91ab740655ee4fe7a8d60b8fe2bdc182 33fdbbc1b2d9425ea3227878567a0c3d--91ab740655ee4fe7a8d60b8fe2bdc182 e269339501164e12be59d4c6c3b6e735 X 91ab740655ee4fe7a8d60b8fe2bdc182--e269339501164e12be59d4c6c3b6e735 e269339501164e12be59d4c6c3b6e735--4f583920b4fc4908923373cc489f31c1 dc15562f59d448b5a4c16a625fb8c114 RZ(-1.0*g0) e269339501164e12be59d4c6c3b6e735--dc15562f59d448b5a4c16a625fb8c114 1fe60e17cc7e4bf19d540b1d7a96fafb X dc15562f59d448b5a4c16a625fb8c114--1fe60e17cc7e4bf19d540b1d7a96fafb 1fe60e17cc7e4bf19d540b1d7a96fafb--260f385f44e44b3b89a4c2613e020314 4d15745f99354b949c04f1b088701d51 1fe60e17cc7e4bf19d540b1d7a96fafb--4d15745f99354b949c04f1b088701d51 f129e2c66c6545b69dcacf4911f48b2d 4d15745f99354b949c04f1b088701d51--f129e2c66c6545b69dcacf4911f48b2d a9ee4b3729f94ab2be69575c7c9de143 f129e2c66c6545b69dcacf4911f48b2d--a9ee4b3729f94ab2be69575c7c9de143 d1eac3999b014afcb5138658929fbd97 a9ee4b3729f94ab2be69575c7c9de143--d1eac3999b014afcb5138658929fbd97 019e641913bb4406a414054f6a9065dc d1eac3999b014afcb5138658929fbd97--019e641913bb4406a414054f6a9065dc c5f723385f9244c2a72d356898feb57f 019e641913bb4406a414054f6a9065dc--c5f723385f9244c2a72d356898feb57f 932e640830ab4607a913789b171cc490 c5f723385f9244c2a72d356898feb57f--932e640830ab4607a913789b171cc490 a878a3e627444379a420423be75ed2c2 932e640830ab4607a913789b171cc490--a878a3e627444379a420423be75ed2c2 3302d55a11044c14acb951c79bbb42ad RX(b05) a878a3e627444379a420423be75ed2c2--3302d55a11044c14acb951c79bbb42ad 9a3258e47193481ea88052265cea44bb 3302d55a11044c14acb951c79bbb42ad--9a3258e47193481ea88052265cea44bb 1254e2c93ede4f16ab17402da0b2e879 9a3258e47193481ea88052265cea44bb--1254e2c93ede4f16ab17402da0b2e879 9b4c5560f3a748b4b3ebdfce728d50d3 1254e2c93ede4f16ab17402da0b2e879--9b4c5560f3a748b4b3ebdfce728d50d3 5d2b89297ed14c4c9eab474decbe8766 9b4c5560f3a748b4b3ebdfce728d50d3--5d2b89297ed14c4c9eab474decbe8766 a09706363a7a4c8eb6d87b007405ec2b X 5d2b89297ed14c4c9eab474decbe8766--a09706363a7a4c8eb6d87b007405ec2b a09706363a7a4c8eb6d87b007405ec2b--15a821ed1bba4ecc954eed85193cc2c2 85f264520b3d439a8fe148347eb4e597 a09706363a7a4c8eb6d87b007405ec2b--85f264520b3d439a8fe148347eb4e597 a09c8980b5f5444d9c5b3e5744fa318a 85f264520b3d439a8fe148347eb4e597--a09c8980b5f5444d9c5b3e5744fa318a 5e8caaedb2d34e6b84843fb51becb374 a09c8980b5f5444d9c5b3e5744fa318a--5e8caaedb2d34e6b84843fb51becb374 d58f34b93b6a4ba7bb9e4905d1e2d692 5e8caaedb2d34e6b84843fb51becb374--d58f34b93b6a4ba7bb9e4905d1e2d692 d3dee5c9d3624074b6e40cf910a59712 d58f34b93b6a4ba7bb9e4905d1e2d692--d3dee5c9d3624074b6e40cf910a59712 bfef7ad753f244fbbca0be9991b8513e X d3dee5c9d3624074b6e40cf910a59712--bfef7ad753f244fbbca0be9991b8513e bfef7ad753f244fbbca0be9991b8513e--0ae390cc4791445ba1e6c6993adcfc1e d093ee604c8a44309bfb2c51cd261918 bfef7ad753f244fbbca0be9991b8513e--d093ee604c8a44309bfb2c51cd261918 1c6668107c714f84b4ee033d6dd40d01 d093ee604c8a44309bfb2c51cd261918--1c6668107c714f84b4ee033d6dd40d01 c8e18949f47a4ee48fd1c5ae0342bfff 1c6668107c714f84b4ee033d6dd40d01--c8e18949f47a4ee48fd1c5ae0342bfff b22e2be22e584030840d09213edeabc3 c8e18949f47a4ee48fd1c5ae0342bfff--b22e2be22e584030840d09213edeabc3 e7cf668ae4eb4c6f855177d8c823884c b22e2be22e584030840d09213edeabc3--e7cf668ae4eb4c6f855177d8c823884c f2075e6184764cffa0ee23d5a0e84def e7cf668ae4eb4c6f855177d8c823884c--f2075e6184764cffa0ee23d5a0e84def ccd908d232a04ac989b022f9239550f7 f2075e6184764cffa0ee23d5a0e84def--ccd908d232a04ac989b022f9239550f7 30f13b9fbdba4786a2d0bd4f85d3e73c ccd908d232a04ac989b022f9239550f7--30f13b9fbdba4786a2d0bd4f85d3e73c d43d1be51cc1436e85be7e689133199a 30f13b9fbdba4786a2d0bd4f85d3e73c--d43d1be51cc1436e85be7e689133199a a639981d614545c990a3dc9efb82a99b d43d1be51cc1436e85be7e689133199a--a639981d614545c990a3dc9efb82a99b 0de5dec4e30c430f873023abc3ee372f a639981d614545c990a3dc9efb82a99b--0de5dec4e30c430f873023abc3ee372f 497a2fa52bb9406e9c8028513b0684c6 0de5dec4e30c430f873023abc3ee372f--497a2fa52bb9406e9c8028513b0684c6 e3e474076e9a4a4fa33757458a1a4649 497a2fa52bb9406e9c8028513b0684c6--e3e474076e9a4a4fa33757458a1a4649 c00736cdd774459581562d3707522fbe e3e474076e9a4a4fa33757458a1a4649--c00736cdd774459581562d3707522fbe ccaec428b84045de9e76bc24b0c637f5 c00736cdd774459581562d3707522fbe--ccaec428b84045de9e76bc24b0c637f5 c7492ad349f740d6b783482bbf5bfe21 ccaec428b84045de9e76bc24b0c637f5--c7492ad349f740d6b783482bbf5bfe21 57efc573f7254de3a63e8e1aa75ce279 c7492ad349f740d6b783482bbf5bfe21--57efc573f7254de3a63e8e1aa75ce279 848b4c7f732a46438658571f6bc3e841 57efc573f7254de3a63e8e1aa75ce279--848b4c7f732a46438658571f6bc3e841 4b3c38864cb14d51bf4ba482e662685d 848b4c7f732a46438658571f6bc3e841--4b3c38864cb14d51bf4ba482e662685d 8b2e0a04432842e2bb7fcb14b5cce314 4b3c38864cb14d51bf4ba482e662685d--8b2e0a04432842e2bb7fcb14b5cce314 ed72a0b51b8f46ecbbf93eec3aa41cdb 8b2e0a04432842e2bb7fcb14b5cce314--ed72a0b51b8f46ecbbf93eec3aa41cdb 85e01ef4708e4b03977f66c4f1670f47 ed72a0b51b8f46ecbbf93eec3aa41cdb--85e01ef4708e4b03977f66c4f1670f47 3160b2de1e0e4490a7a3cc9a3889f2af 85e01ef4708e4b03977f66c4f1670f47--3160b2de1e0e4490a7a3cc9a3889f2af fad0667d297a414e90cbb7b34680396a 3160b2de1e0e4490a7a3cc9a3889f2af--fad0667d297a414e90cbb7b34680396a 3da527520b4842cca3b7ac1eb57f6cf4 fad0667d297a414e90cbb7b34680396a--3da527520b4842cca3b7ac1eb57f6cf4 ce05b6e6f3d74289a1a8b55728da91d8 3da527520b4842cca3b7ac1eb57f6cf4--ce05b6e6f3d74289a1a8b55728da91d8 c855160c83d241e3a6d962b1e345e61e ce05b6e6f3d74289a1a8b55728da91d8--c855160c83d241e3a6d962b1e345e61e 76688e12f28542b3bfb60aee5b2d3110 c855160c83d241e3a6d962b1e345e61e--76688e12f28542b3bfb60aee5b2d3110 b71a9f3e29684d55b5ded5ff74c98ed9 76688e12f28542b3bfb60aee5b2d3110--b71a9f3e29684d55b5ded5ff74c98ed9 a96c0d201a3a4228990c3d5042c68d53 b71a9f3e29684d55b5ded5ff74c98ed9--a96c0d201a3a4228990c3d5042c68d53 923e2b911f6045628af8da05151217f9 a96c0d201a3a4228990c3d5042c68d53--923e2b911f6045628af8da05151217f9 950712e2dd5b4032b6f7389088c2472b 923e2b911f6045628af8da05151217f9--950712e2dd5b4032b6f7389088c2472b 2a37b9b75e984b8faa547527f69d1079 X 950712e2dd5b4032b6f7389088c2472b--2a37b9b75e984b8faa547527f69d1079 2a37b9b75e984b8faa547527f69d1079--676a8a4b726646f09409c3c97b2fef37 ec9b99b30679495f9d56a9069f3c42cb 2a37b9b75e984b8faa547527f69d1079--ec9b99b30679495f9d56a9069f3c42cb c6d7e3d372184a4bb1f82294f8362c0c ec9b99b30679495f9d56a9069f3c42cb--c6d7e3d372184a4bb1f82294f8362c0c 73de7cdadae24e02acd17d077714488b c6d7e3d372184a4bb1f82294f8362c0c--73de7cdadae24e02acd17d077714488b be6e03438f51498d960dcdaa417dbacb X 73de7cdadae24e02acd17d077714488b--be6e03438f51498d960dcdaa417dbacb be6e03438f51498d960dcdaa417dbacb--44e2ac2aec914af080fc74e2a2e89135 33f3ac68a1b4449989c0a304de8c3411 be6e03438f51498d960dcdaa417dbacb--33f3ac68a1b4449989c0a304de8c3411 b6d4dc4e390547408d0960f1a022ff50 33f3ac68a1b4449989c0a304de8c3411--b6d4dc4e390547408d0960f1a022ff50 d740353154ee4b78866d24afe8284a6a b6d4dc4e390547408d0960f1a022ff50--d740353154ee4b78866d24afe8284a6a 8ff767bf2d844fbda9bd88c1b3fe543a d740353154ee4b78866d24afe8284a6a--8ff767bf2d844fbda9bd88c1b3fe543a d9b7c30ba25a49df8f9b5c20485de60c 8ff767bf2d844fbda9bd88c1b3fe543a--d9b7c30ba25a49df8f9b5c20485de60c a526f400ac48435ea5c6298d11625d41 d9b7c30ba25a49df8f9b5c20485de60c--a526f400ac48435ea5c6298d11625d41 7c99610bcb4d4113abafdd4887b9e3aa a526f400ac48435ea5c6298d11625d41--7c99610bcb4d4113abafdd4887b9e3aa 9367be1b83444f0bbe002b384ddf84b3 7c99610bcb4d4113abafdd4887b9e3aa--9367be1b83444f0bbe002b384ddf84b3 636142cad57c44f5bcf22e67d847f6d6 9367be1b83444f0bbe002b384ddf84b3--636142cad57c44f5bcf22e67d847f6d6 08377093da0a46b1b38ac68cfaac664b 636142cad57c44f5bcf22e67d847f6d6--08377093da0a46b1b38ac68cfaac664b 333152e199ab45e19aafc25183ab52cb 08377093da0a46b1b38ac68cfaac664b--333152e199ab45e19aafc25183ab52cb c8094874b20f409a9d0833ce4bd4d1cf 333152e199ab45e19aafc25183ab52cb--c8094874b20f409a9d0833ce4bd4d1cf 358d1feb131d4508a7dcc47136cdd57e c8094874b20f409a9d0833ce4bd4d1cf--358d1feb131d4508a7dcc47136cdd57e 16e1f1a3594040b082d58008058b43ac 358d1feb131d4508a7dcc47136cdd57e--16e1f1a3594040b082d58008058b43ac 469a19645a7249bda37699866dccfd55 X 16e1f1a3594040b082d58008058b43ac--469a19645a7249bda37699866dccfd55 469a19645a7249bda37699866dccfd55--8f3da28a94914725be900602ea7e35ad 141382e070bd42b59ec26217f150901c RZ(-1.0*g1) 469a19645a7249bda37699866dccfd55--141382e070bd42b59ec26217f150901c 0393af2bd76142f8abdf802f7804537e X 141382e070bd42b59ec26217f150901c--0393af2bd76142f8abdf802f7804537e 0393af2bd76142f8abdf802f7804537e--bab020e2e3e149d39cb28e97d2344511 60ad16a8ea034f28bf86732386ea0116 0393af2bd76142f8abdf802f7804537e--60ad16a8ea034f28bf86732386ea0116 542f7db815054e2596a05ae75b714cf0 60ad16a8ea034f28bf86732386ea0116--542f7db815054e2596a05ae75b714cf0 3aea1f7441d74a60b66d04add5c31c1f 542f7db815054e2596a05ae75b714cf0--3aea1f7441d74a60b66d04add5c31c1f e3cc1d2084ed4ca2bc9017a51e716459 3aea1f7441d74a60b66d04add5c31c1f--e3cc1d2084ed4ca2bc9017a51e716459 f8eb82b1a8a24de4819ccd318e6626f5 e3cc1d2084ed4ca2bc9017a51e716459--f8eb82b1a8a24de4819ccd318e6626f5 29e48db7419c47c28f9da116afe26fec f8eb82b1a8a24de4819ccd318e6626f5--29e48db7419c47c28f9da116afe26fec 36086a72bc6048cfb797abc7c927fba7 X 29e48db7419c47c28f9da116afe26fec--36086a72bc6048cfb797abc7c927fba7 36086a72bc6048cfb797abc7c927fba7--a75be92b3c5a48cf9e22a05b45ac9c82 1e3d99d70e394c28ac1bed812a005244 36086a72bc6048cfb797abc7c927fba7--1e3d99d70e394c28ac1bed812a005244 4b040253966042b1ae13b53e2e772a46 1e3d99d70e394c28ac1bed812a005244--4b040253966042b1ae13b53e2e772a46 2f8a602d58354f358ea34dfc859e67ba 4b040253966042b1ae13b53e2e772a46--2f8a602d58354f358ea34dfc859e67ba 61a414a062454841b3cfc08cf690f38c X 2f8a602d58354f358ea34dfc859e67ba--61a414a062454841b3cfc08cf690f38c 61a414a062454841b3cfc08cf690f38c--1e94ea6037c341dcadc19118b1ae2e63 ec065002155a41d1a982a28d7bb8b966 61a414a062454841b3cfc08cf690f38c--ec065002155a41d1a982a28d7bb8b966 19a9315833c6471bbcad7b4b825b7609 ec065002155a41d1a982a28d7bb8b966--19a9315833c6471bbcad7b4b825b7609 89dd617d69a146e180eb97e33e90e71e 19a9315833c6471bbcad7b4b825b7609--89dd617d69a146e180eb97e33e90e71e e93dd61e74ec4640b81e6901da6b1813 89dd617d69a146e180eb97e33e90e71e--e93dd61e74ec4640b81e6901da6b1813 d2cf58fc778140f5b8ce76fa9c548e9a e93dd61e74ec4640b81e6901da6b1813--d2cf58fc778140f5b8ce76fa9c548e9a 45fe6c685acc4f5980c7340488e04977 d2cf58fc778140f5b8ce76fa9c548e9a--45fe6c685acc4f5980c7340488e04977 8ca401398c71403489a3c31d0ed10a0c X 45fe6c685acc4f5980c7340488e04977--8ca401398c71403489a3c31d0ed10a0c 8ca401398c71403489a3c31d0ed10a0c--f4f9ba73d6ce4ad4a77610a8a48676c2 f1eabaf8fc5c44038cef6f8fc857a047 8ca401398c71403489a3c31d0ed10a0c--f1eabaf8fc5c44038cef6f8fc857a047 7e3686c1200f45b1a74702c3524d064c f1eabaf8fc5c44038cef6f8fc857a047--7e3686c1200f45b1a74702c3524d064c 5f0d874fd8744eadb6cac84165f7233c 7e3686c1200f45b1a74702c3524d064c--5f0d874fd8744eadb6cac84165f7233c 10fd990587b847f188706075bfece48a 5f0d874fd8744eadb6cac84165f7233c--10fd990587b847f188706075bfece48a c52a5ec72d964476a19b7c0f3634ee76 10fd990587b847f188706075bfece48a--c52a5ec72d964476a19b7c0f3634ee76 c2b2ee0940ae48fea9dd9d1858446265 X c52a5ec72d964476a19b7c0f3634ee76--c2b2ee0940ae48fea9dd9d1858446265 c2b2ee0940ae48fea9dd9d1858446265--e2c1c73d60044ade9c5fcde1fcf00748 00b3a0e9780d4075a223adf63e18d0c7 c2b2ee0940ae48fea9dd9d1858446265--00b3a0e9780d4075a223adf63e18d0c7 85a8d44493984e6ea8ffcfb7247521ed 00b3a0e9780d4075a223adf63e18d0c7--85a8d44493984e6ea8ffcfb7247521ed 94ea751e2d754671b117e34310cb3032 85a8d44493984e6ea8ffcfb7247521ed--94ea751e2d754671b117e34310cb3032 758f18750dc64d8d82abff1e56eee11b 94ea751e2d754671b117e34310cb3032--758f18750dc64d8d82abff1e56eee11b 0e0735528298466188e01e66676abf4e 758f18750dc64d8d82abff1e56eee11b--0e0735528298466188e01e66676abf4e fbc87c92c92e45b7b2e68f991b0569a9 0e0735528298466188e01e66676abf4e--fbc87c92c92e45b7b2e68f991b0569a9 40c0ca771d944e1da9b78d82ddbdf41e fbc87c92c92e45b7b2e68f991b0569a9--40c0ca771d944e1da9b78d82ddbdf41e 8b3a8b24351549e7a928b9aaf5113ebe 40c0ca771d944e1da9b78d82ddbdf41e--8b3a8b24351549e7a928b9aaf5113ebe 04287d45ab4348ef8b917c09471730a3 X 8b3a8b24351549e7a928b9aaf5113ebe--04287d45ab4348ef8b917c09471730a3 04287d45ab4348ef8b917c09471730a3--32599956ef8d47fb894a612276ff9efb f2c0ee495fd9418b8f943403183066c4 04287d45ab4348ef8b917c09471730a3--f2c0ee495fd9418b8f943403183066c4 8a04810a4d294a59973025e3f02591c2 f2c0ee495fd9418b8f943403183066c4--8a04810a4d294a59973025e3f02591c2 c1d86d092d0649bf854fe29e2b3544c1 8a04810a4d294a59973025e3f02591c2--c1d86d092d0649bf854fe29e2b3544c1 c5233ea812524be99bc4259494938d85 X c1d86d092d0649bf854fe29e2b3544c1--c5233ea812524be99bc4259494938d85 c5233ea812524be99bc4259494938d85--5dbd0a52645a481db8e42ab8980eacad f8e33bdc48a6453197ce14975159677d c5233ea812524be99bc4259494938d85--f8e33bdc48a6453197ce14975159677d 6196a8c27e6d4694b8646dfa6a99f588 f8e33bdc48a6453197ce14975159677d--6196a8c27e6d4694b8646dfa6a99f588 27e996f390c841feac70dd74ccb6696a 6196a8c27e6d4694b8646dfa6a99f588--27e996f390c841feac70dd74ccb6696a 930d86456cf740bb94ffcc027f941157 27e996f390c841feac70dd74ccb6696a--930d86456cf740bb94ffcc027f941157 955f6d11a1f34beab80ee9d1583680d3 930d86456cf740bb94ffcc027f941157--955f6d11a1f34beab80ee9d1583680d3 56910b99bcf34861a7610ab40739a70a 955f6d11a1f34beab80ee9d1583680d3--56910b99bcf34861a7610ab40739a70a 531c1e98fbb64676bf435cec644719fd X 56910b99bcf34861a7610ab40739a70a--531c1e98fbb64676bf435cec644719fd 531c1e98fbb64676bf435cec644719fd--b8b0ca8535a94af7b65e4b0ef1cc4903 4d05a381f3684af1a39d0d053c77535a RZ(-1.0*g1) 531c1e98fbb64676bf435cec644719fd--4d05a381f3684af1a39d0d053c77535a 53229afc8b964e00a19b95b852495ab9 X 4d05a381f3684af1a39d0d053c77535a--53229afc8b964e00a19b95b852495ab9 53229afc8b964e00a19b95b852495ab9--09fed3e37c1441f7a32105da2a45f06e 7fbb6b2f7d3149d4bcb238ad70af8af3 53229afc8b964e00a19b95b852495ab9--7fbb6b2f7d3149d4bcb238ad70af8af3 0f37d4548d384321a5e3fcc027ac6dba X 7fbb6b2f7d3149d4bcb238ad70af8af3--0f37d4548d384321a5e3fcc027ac6dba 0f37d4548d384321a5e3fcc027ac6dba--a1d08c95b3034ed9bc2b77fce7353f46 4076078202c54a21aa3d51e948289d4c RZ(-1.0*g1) 0f37d4548d384321a5e3fcc027ac6dba--4076078202c54a21aa3d51e948289d4c 4657242c700244c6a46d89fc1111ca09 X 4076078202c54a21aa3d51e948289d4c--4657242c700244c6a46d89fc1111ca09 4657242c700244c6a46d89fc1111ca09--2c32b2a022e14cfc9c210eb90db9a50a 6e1e48e77e4c4d7ab60a2b8128a64ac2 4657242c700244c6a46d89fc1111ca09--6e1e48e77e4c4d7ab60a2b8128a64ac2 2bebc6437cbc413596b9270658f5cae3 6e1e48e77e4c4d7ab60a2b8128a64ac2--2bebc6437cbc413596b9270658f5cae3 eb9c06e219e048289d37b3b7ffb75066 2bebc6437cbc413596b9270658f5cae3--eb9c06e219e048289d37b3b7ffb75066 da5428eb2a81457fa4cb5b6c8b2be739 eb9c06e219e048289d37b3b7ffb75066--da5428eb2a81457fa4cb5b6c8b2be739 ee2e5a3008874d0891f06a676e46e696 da5428eb2a81457fa4cb5b6c8b2be739--ee2e5a3008874d0891f06a676e46e696 34caa2a2e03e43378dec6fed49590a43 ee2e5a3008874d0891f06a676e46e696--34caa2a2e03e43378dec6fed49590a43 b5dee1aca4d942d5bae827818cd5deb5 34caa2a2e03e43378dec6fed49590a43--b5dee1aca4d942d5bae827818cd5deb5 e367a52c3a894d549c4d1c5a4d8a6551 b5dee1aca4d942d5bae827818cd5deb5--e367a52c3a894d549c4d1c5a4d8a6551 bf27781f72a2455f98ff909380e43b6f RX(b15) e367a52c3a894d549c4d1c5a4d8a6551--bf27781f72a2455f98ff909380e43b6f bf27781f72a2455f98ff909380e43b6f--4d456b50d8a74ba8b1c28b86e32ad019 92a5686377d0465fbd8e32a378edeb1a 47d8e5d75a8f4b6cbaa8ba63b6acd9ef 3ff4536c95d0497f9b925f1cb60be8f1--47d8e5d75a8f4b6cbaa8ba63b6acd9ef f4d36354a9514cba90d97d785dd99805 7 f0e4482969794d46add8faaed3e3c11b 47d8e5d75a8f4b6cbaa8ba63b6acd9ef--f0e4482969794d46add8faaed3e3c11b 1a48f0d127fe46c28891fc5d28a91748 f0e4482969794d46add8faaed3e3c11b--1a48f0d127fe46c28891fc5d28a91748 524a0f5059244ab5a6d5825d629b7cec 1a48f0d127fe46c28891fc5d28a91748--524a0f5059244ab5a6d5825d629b7cec 6be43b9c1ff0492abb49e1996b0d91e7 524a0f5059244ab5a6d5825d629b7cec--6be43b9c1ff0492abb49e1996b0d91e7 e758db6e6d1a4a78b3902617b3f3f8d3 X 6be43b9c1ff0492abb49e1996b0d91e7--e758db6e6d1a4a78b3902617b3f3f8d3 e758db6e6d1a4a78b3902617b3f3f8d3--1dfbf772f26b4fe4b20624e8fb18437b ebae10c85f55402c9ba6c892a4f968cf e758db6e6d1a4a78b3902617b3f3f8d3--ebae10c85f55402c9ba6c892a4f968cf 48b67249e46645af965c273650f231a2 ebae10c85f55402c9ba6c892a4f968cf--48b67249e46645af965c273650f231a2 2419f9b5926d4884a22c86d155a142db 48b67249e46645af965c273650f231a2--2419f9b5926d4884a22c86d155a142db 5806747acf1c47cd9418ddf2f96978f7 X 2419f9b5926d4884a22c86d155a142db--5806747acf1c47cd9418ddf2f96978f7 5806747acf1c47cd9418ddf2f96978f7--5f6f68d7ab014180b3233356237a82c4 23c1ae47d58942908bdfdeeb57583102 5806747acf1c47cd9418ddf2f96978f7--23c1ae47d58942908bdfdeeb57583102 770e840264f1431aa6e5c4fffbd18174 23c1ae47d58942908bdfdeeb57583102--770e840264f1431aa6e5c4fffbd18174 b657b8013bd34f23be1783d3df718b7d 770e840264f1431aa6e5c4fffbd18174--b657b8013bd34f23be1783d3df718b7d a6be162e3d854a7db66afa3ccf98ac2f b657b8013bd34f23be1783d3df718b7d--a6be162e3d854a7db66afa3ccf98ac2f f2fda88520b547a59a124e78c7f2a88a a6be162e3d854a7db66afa3ccf98ac2f--f2fda88520b547a59a124e78c7f2a88a d83ac49890a04070aaadb0808ec988c4 f2fda88520b547a59a124e78c7f2a88a--d83ac49890a04070aaadb0808ec988c4 fa288f63c1c347cb9402e6791f12e642 d83ac49890a04070aaadb0808ec988c4--fa288f63c1c347cb9402e6791f12e642 28d5962bf2b44faca3619fac5b137f1b fa288f63c1c347cb9402e6791f12e642--28d5962bf2b44faca3619fac5b137f1b 7a7ec6630b65452e970089fde86d89de 28d5962bf2b44faca3619fac5b137f1b--7a7ec6630b65452e970089fde86d89de f13c94726aea4277b00918795261d7da 7a7ec6630b65452e970089fde86d89de--f13c94726aea4277b00918795261d7da 77ea4fad632f4791a68befc5adc28513 f13c94726aea4277b00918795261d7da--77ea4fad632f4791a68befc5adc28513 3d671c3804c04ca08e1ffcd1b278dfb0 77ea4fad632f4791a68befc5adc28513--3d671c3804c04ca08e1ffcd1b278dfb0 260457ff7a0340a786c708c79bedf0f8 3d671c3804c04ca08e1ffcd1b278dfb0--260457ff7a0340a786c708c79bedf0f8 2e482d73d1f2414192816e975041cd13 260457ff7a0340a786c708c79bedf0f8--2e482d73d1f2414192816e975041cd13 bd238d4ef46b4605a8985f38427dbbed 2e482d73d1f2414192816e975041cd13--bd238d4ef46b4605a8985f38427dbbed 867fd6848cfa4e9d80eeba361d5a6246 bd238d4ef46b4605a8985f38427dbbed--867fd6848cfa4e9d80eeba361d5a6246 b6e5cd4552684cfb93486a18f6f61f6b 867fd6848cfa4e9d80eeba361d5a6246--b6e5cd4552684cfb93486a18f6f61f6b b0361a6b9f2c4ff99099ad716d06ef42 b6e5cd4552684cfb93486a18f6f61f6b--b0361a6b9f2c4ff99099ad716d06ef42 3944884ae02240c9bdbeaf46d0f7944f b0361a6b9f2c4ff99099ad716d06ef42--3944884ae02240c9bdbeaf46d0f7944f 28613c8331264ea8a442a001a81904fa 3944884ae02240c9bdbeaf46d0f7944f--28613c8331264ea8a442a001a81904fa 94fb2c38bb61452c9294afd5eae43ffb 28613c8331264ea8a442a001a81904fa--94fb2c38bb61452c9294afd5eae43ffb f05fde1a20ba48a4861dacdacb7be110 94fb2c38bb61452c9294afd5eae43ffb--f05fde1a20ba48a4861dacdacb7be110 fabfec431fcd4262aea33c1034fcea98 f05fde1a20ba48a4861dacdacb7be110--fabfec431fcd4262aea33c1034fcea98 ba183a4d63d542f78bb4d4a4f89eda88 fabfec431fcd4262aea33c1034fcea98--ba183a4d63d542f78bb4d4a4f89eda88 ded53138793348719c53f40abcca22e9 ba183a4d63d542f78bb4d4a4f89eda88--ded53138793348719c53f40abcca22e9 5ff1e3df7283433c829969d394a0b174 ded53138793348719c53f40abcca22e9--5ff1e3df7283433c829969d394a0b174 09adadad75d8435284e37677ad32c912 5ff1e3df7283433c829969d394a0b174--09adadad75d8435284e37677ad32c912 ba7af89946fe4293b1b2fab1d81ac3b5 09adadad75d8435284e37677ad32c912--ba7af89946fe4293b1b2fab1d81ac3b5 4430367f84bf48d99db43c584a0440ad ba7af89946fe4293b1b2fab1d81ac3b5--4430367f84bf48d99db43c584a0440ad a6f9ad3ddcd345d2903c2d712147bca9 4430367f84bf48d99db43c584a0440ad--a6f9ad3ddcd345d2903c2d712147bca9 bf3615d8421e4af18840f429ec2d6166 a6f9ad3ddcd345d2903c2d712147bca9--bf3615d8421e4af18840f429ec2d6166 f112021d10a64210aa47ccbb8c05c4af bf3615d8421e4af18840f429ec2d6166--f112021d10a64210aa47ccbb8c05c4af 3089b28235534deaaf23ba729e827aa9 f112021d10a64210aa47ccbb8c05c4af--3089b28235534deaaf23ba729e827aa9 ca0b5e567813401b8c36a969018713b1 3089b28235534deaaf23ba729e827aa9--ca0b5e567813401b8c36a969018713b1 8f13b8cf94224585bdefa4972bcbc4cd X ca0b5e567813401b8c36a969018713b1--8f13b8cf94224585bdefa4972bcbc4cd 8f13b8cf94224585bdefa4972bcbc4cd--79958165801d40fabd87ca6ed0166f2e e4d1035fe2d34cf4921ca4917a24555b RZ(-1.0*g0) 8f13b8cf94224585bdefa4972bcbc4cd--e4d1035fe2d34cf4921ca4917a24555b 575acddf16e44ae4ad2bb0827f80f9ea X e4d1035fe2d34cf4921ca4917a24555b--575acddf16e44ae4ad2bb0827f80f9ea 575acddf16e44ae4ad2bb0827f80f9ea--c7c100572d984ad595ba7cbd71ad189d c1e90fd5d4ff4671ada14d6fc93fcfbd 575acddf16e44ae4ad2bb0827f80f9ea--c1e90fd5d4ff4671ada14d6fc93fcfbd 12f1aa0de9ff44219272152ccff321b9 c1e90fd5d4ff4671ada14d6fc93fcfbd--12f1aa0de9ff44219272152ccff321b9 afc6f75af7484a7085606d71f356dee3 12f1aa0de9ff44219272152ccff321b9--afc6f75af7484a7085606d71f356dee3 d998ff2cd6194ab9b4592443ffd9d5fe afc6f75af7484a7085606d71f356dee3--d998ff2cd6194ab9b4592443ffd9d5fe 1524720855ea4d9299f675a434903434 d998ff2cd6194ab9b4592443ffd9d5fe--1524720855ea4d9299f675a434903434 ec8c538193c640f7a33f49819a56f372 1524720855ea4d9299f675a434903434--ec8c538193c640f7a33f49819a56f372 337dc2cc174f4883a2fddf3120b02b2f ec8c538193c640f7a33f49819a56f372--337dc2cc174f4883a2fddf3120b02b2f a9ffdc325e914b68b182eb0751eee350 337dc2cc174f4883a2fddf3120b02b2f--a9ffdc325e914b68b182eb0751eee350 25fc62a7819741409e070ad8f7211be4 a9ffdc325e914b68b182eb0751eee350--25fc62a7819741409e070ad8f7211be4 12ab398e9e544dce86dd2d87c13d4876 25fc62a7819741409e070ad8f7211be4--12ab398e9e544dce86dd2d87c13d4876 211e3128db58477fb1821481860c01d2 12ab398e9e544dce86dd2d87c13d4876--211e3128db58477fb1821481860c01d2 75125a358e0a45e1bdf45d526016da3b 211e3128db58477fb1821481860c01d2--75125a358e0a45e1bdf45d526016da3b 3c3e0643ebb64588ac1e77640132c24e 75125a358e0a45e1bdf45d526016da3b--3c3e0643ebb64588ac1e77640132c24e efe6a06eb426481494790fc5297662d4 3c3e0643ebb64588ac1e77640132c24e--efe6a06eb426481494790fc5297662d4 dc1aa0c464d043508c7b3a48c67b349c efe6a06eb426481494790fc5297662d4--dc1aa0c464d043508c7b3a48c67b349c a343d43516b84e3489c0e7820e4076fc dc1aa0c464d043508c7b3a48c67b349c--a343d43516b84e3489c0e7820e4076fc 0e60ace98a5748b9a5f76f37d17c8b24 a343d43516b84e3489c0e7820e4076fc--0e60ace98a5748b9a5f76f37d17c8b24 06fa52327e4e4c2cb779ed4381338d8d 0e60ace98a5748b9a5f76f37d17c8b24--06fa52327e4e4c2cb779ed4381338d8d 1ac9e5d0a12a482380cb17ff1e6dc13b 06fa52327e4e4c2cb779ed4381338d8d--1ac9e5d0a12a482380cb17ff1e6dc13b bcdf6a7445db46729d7c046b62d0bae8 1ac9e5d0a12a482380cb17ff1e6dc13b--bcdf6a7445db46729d7c046b62d0bae8 4d0f4b225f834382984ff5c71109bf1a bcdf6a7445db46729d7c046b62d0bae8--4d0f4b225f834382984ff5c71109bf1a 6302b3f1ea5142498b7e8c69322cfdc0 4d0f4b225f834382984ff5c71109bf1a--6302b3f1ea5142498b7e8c69322cfdc0 e9c66a2dbf59421eb079d828ca0b4f98 6302b3f1ea5142498b7e8c69322cfdc0--e9c66a2dbf59421eb079d828ca0b4f98 65fb9599c7024f959c3b84e2d4c5958b e9c66a2dbf59421eb079d828ca0b4f98--65fb9599c7024f959c3b84e2d4c5958b 20a7681cb835494dad990daab23a01f4 65fb9599c7024f959c3b84e2d4c5958b--20a7681cb835494dad990daab23a01f4 3e097c1c92af44ed8d0aecdd5fd3d7db X 20a7681cb835494dad990daab23a01f4--3e097c1c92af44ed8d0aecdd5fd3d7db 3e097c1c92af44ed8d0aecdd5fd3d7db--1350b2aeb3124f5398a2ffbf2dec6b46 b6734b9cb38f4b4fb6b14302d9045d0c RZ(-1.0*g0) 3e097c1c92af44ed8d0aecdd5fd3d7db--b6734b9cb38f4b4fb6b14302d9045d0c 7e8cb8fc29894542ace9117e3676c426 X b6734b9cb38f4b4fb6b14302d9045d0c--7e8cb8fc29894542ace9117e3676c426 7e8cb8fc29894542ace9117e3676c426--2c686a7fc66447d8804aace55c0ce617 6c0d9aeb94294f5b878697e2bed8918b 7e8cb8fc29894542ace9117e3676c426--6c0d9aeb94294f5b878697e2bed8918b bc1eb8508e574ac1b16ad2bf15e3bce2 6c0d9aeb94294f5b878697e2bed8918b--bc1eb8508e574ac1b16ad2bf15e3bce2 bf37c58889a34588951f0d6deda14ca9 bc1eb8508e574ac1b16ad2bf15e3bce2--bf37c58889a34588951f0d6deda14ca9 bce326be6c02426e95e9a98d401f8e11 bf37c58889a34588951f0d6deda14ca9--bce326be6c02426e95e9a98d401f8e11 04f5bc775a924a9ab7066a7c4d6a686a bce326be6c02426e95e9a98d401f8e11--04f5bc775a924a9ab7066a7c4d6a686a 0f731747ed0140559db09a1d995b46b0 04f5bc775a924a9ab7066a7c4d6a686a--0f731747ed0140559db09a1d995b46b0 fdc440ab63dc4981b2eee4cd66f4aacd 0f731747ed0140559db09a1d995b46b0--fdc440ab63dc4981b2eee4cd66f4aacd 10880cf9f3174ffda6115115190ae769 fdc440ab63dc4981b2eee4cd66f4aacd--10880cf9f3174ffda6115115190ae769 1e6ba7aeba4b4979a183dc53ebfd0ee8 X 10880cf9f3174ffda6115115190ae769--1e6ba7aeba4b4979a183dc53ebfd0ee8 1e6ba7aeba4b4979a183dc53ebfd0ee8--6fb149fad5854d4c96413fb3d0d524a7 d3019775e6a6465b85ff579e247bf090 1e6ba7aeba4b4979a183dc53ebfd0ee8--d3019775e6a6465b85ff579e247bf090 fe4cbabc7a78422d8a5f0b0dd3d2c9cc d3019775e6a6465b85ff579e247bf090--fe4cbabc7a78422d8a5f0b0dd3d2c9cc 7b60e82076f04629b64945414c75599f fe4cbabc7a78422d8a5f0b0dd3d2c9cc--7b60e82076f04629b64945414c75599f 0acb1063edd34999af2edf5c2ed628d2 X 7b60e82076f04629b64945414c75599f--0acb1063edd34999af2edf5c2ed628d2 0acb1063edd34999af2edf5c2ed628d2--f8aa18ac992b4a74a223843cc990130b 20baf81ac68e46ca9c587394c6abca52 0acb1063edd34999af2edf5c2ed628d2--20baf81ac68e46ca9c587394c6abca52 5eafc2bee7d841a0869676211670d4d5 20baf81ac68e46ca9c587394c6abca52--5eafc2bee7d841a0869676211670d4d5 0bad10db89ab488a93e2a3be2522e379 5eafc2bee7d841a0869676211670d4d5--0bad10db89ab488a93e2a3be2522e379 96219417dec6426186b95a99e3672f39 0bad10db89ab488a93e2a3be2522e379--96219417dec6426186b95a99e3672f39 6279c1a606674975a457d081391a5f89 96219417dec6426186b95a99e3672f39--6279c1a606674975a457d081391a5f89 b7752cc916e54166abe11303af2f7653 6279c1a606674975a457d081391a5f89--b7752cc916e54166abe11303af2f7653 f9446b42e693423c8ad4894f9526b6ae b7752cc916e54166abe11303af2f7653--f9446b42e693423c8ad4894f9526b6ae 7c92cafcd2ed4387845248b5ebea790f f9446b42e693423c8ad4894f9526b6ae--7c92cafcd2ed4387845248b5ebea790f e7bed98223b24bdf9d50c6e35d5b4ea8 7c92cafcd2ed4387845248b5ebea790f--e7bed98223b24bdf9d50c6e35d5b4ea8 ea7f757bd66e4a50b1f6f3a38371f19c e7bed98223b24bdf9d50c6e35d5b4ea8--ea7f757bd66e4a50b1f6f3a38371f19c b9f718b13755443083e1a8bd9d7aecd4 X ea7f757bd66e4a50b1f6f3a38371f19c--b9f718b13755443083e1a8bd9d7aecd4 b9f718b13755443083e1a8bd9d7aecd4--4642c3ea65bf47c5a34f20ceb4785084 01ca4626567642cd945c138d8d966a86 RZ(-1.0*g0) b9f718b13755443083e1a8bd9d7aecd4--01ca4626567642cd945c138d8d966a86 e9d70bf8865b48e987ffa57130423d2b X 01ca4626567642cd945c138d8d966a86--e9d70bf8865b48e987ffa57130423d2b e9d70bf8865b48e987ffa57130423d2b--f3c6605cb23240628f162bc33c8f7cef 60e37729d25344efb571919239ac7499 e9d70bf8865b48e987ffa57130423d2b--60e37729d25344efb571919239ac7499 ae07e8410b0d4a6380492c07c3e2e5b5 60e37729d25344efb571919239ac7499--ae07e8410b0d4a6380492c07c3e2e5b5 8c4f251a77fe4f969acfe044abdd801c ae07e8410b0d4a6380492c07c3e2e5b5--8c4f251a77fe4f969acfe044abdd801c 07b17de59f8f4fd0bf5c48faa4d02932 8c4f251a77fe4f969acfe044abdd801c--07b17de59f8f4fd0bf5c48faa4d02932 43d10ee32c28472d92ce57eb05f194f9 07b17de59f8f4fd0bf5c48faa4d02932--43d10ee32c28472d92ce57eb05f194f9 74f3d9ff903d44fc8d44b94121483392 43d10ee32c28472d92ce57eb05f194f9--74f3d9ff903d44fc8d44b94121483392 4adc6c8c92b3440d9c2ee3f3427b68cb 74f3d9ff903d44fc8d44b94121483392--4adc6c8c92b3440d9c2ee3f3427b68cb 2635a549334c4a25a85f8a37d4465a1c 4adc6c8c92b3440d9c2ee3f3427b68cb--2635a549334c4a25a85f8a37d4465a1c d34ee83bcd1c4eb2b27538da334c8169 2635a549334c4a25a85f8a37d4465a1c--d34ee83bcd1c4eb2b27538da334c8169 915b84c125f54382a6c03af0a65ab135 d34ee83bcd1c4eb2b27538da334c8169--915b84c125f54382a6c03af0a65ab135 834c747a732c4f29a34eef8fe06428b8 915b84c125f54382a6c03af0a65ab135--834c747a732c4f29a34eef8fe06428b8 d33b49560a33414a81b3dd5260fff054 834c747a732c4f29a34eef8fe06428b8--d33b49560a33414a81b3dd5260fff054 fe4ae1214a4b42659053b71c74e7113e d33b49560a33414a81b3dd5260fff054--fe4ae1214a4b42659053b71c74e7113e 912e48e1f212481786f979eff0f556db fe4ae1214a4b42659053b71c74e7113e--912e48e1f212481786f979eff0f556db ef15db753e9347f2be32287f38464a2a X 912e48e1f212481786f979eff0f556db--ef15db753e9347f2be32287f38464a2a ef15db753e9347f2be32287f38464a2a--4d15745f99354b949c04f1b088701d51 2c0e8a7edfde4ca5aa4442c178861e4e RZ(-1.0*g0) ef15db753e9347f2be32287f38464a2a--2c0e8a7edfde4ca5aa4442c178861e4e 0f50374eec43461cb76a1dec475abb9e X 2c0e8a7edfde4ca5aa4442c178861e4e--0f50374eec43461cb76a1dec475abb9e 0f50374eec43461cb76a1dec475abb9e--a9ee4b3729f94ab2be69575c7c9de143 cbebb97c3fbe4ca4b41e26d8490e7180 X 0f50374eec43461cb76a1dec475abb9e--cbebb97c3fbe4ca4b41e26d8490e7180 cbebb97c3fbe4ca4b41e26d8490e7180--d1eac3999b014afcb5138658929fbd97 0fbce08dcddf4c99abdf3a0e51c43250 cbebb97c3fbe4ca4b41e26d8490e7180--0fbce08dcddf4c99abdf3a0e51c43250 c9bfa372b9e64e42864d831065da6e61 0fbce08dcddf4c99abdf3a0e51c43250--c9bfa372b9e64e42864d831065da6e61 0a08d1facc2d4b50861ce265cf1de7d6 c9bfa372b9e64e42864d831065da6e61--0a08d1facc2d4b50861ce265cf1de7d6 e73e96bea0004c0aaa0722a4ac0f8649 X 0a08d1facc2d4b50861ce265cf1de7d6--e73e96bea0004c0aaa0722a4ac0f8649 e73e96bea0004c0aaa0722a4ac0f8649--a878a3e627444379a420423be75ed2c2 1bc4b540be1849058a29667a392972ce RX(b06) e73e96bea0004c0aaa0722a4ac0f8649--1bc4b540be1849058a29667a392972ce f042f5d8598945f182f499417513a2f3 1bc4b540be1849058a29667a392972ce--f042f5d8598945f182f499417513a2f3 b89ef3e6d1744dcaba486a464239c7a6 f042f5d8598945f182f499417513a2f3--b89ef3e6d1744dcaba486a464239c7a6 cde84fc27de44e2e989e06bb36bec951 b89ef3e6d1744dcaba486a464239c7a6--cde84fc27de44e2e989e06bb36bec951 2d1e0c7dfca2462eb8b0071966eb62d7 cde84fc27de44e2e989e06bb36bec951--2d1e0c7dfca2462eb8b0071966eb62d7 5d837b8eb0e6475b9db9a2bf028f638e 2d1e0c7dfca2462eb8b0071966eb62d7--5d837b8eb0e6475b9db9a2bf028f638e 6f6fdbc7bfbc40048473b6bca2603874 X 5d837b8eb0e6475b9db9a2bf028f638e--6f6fdbc7bfbc40048473b6bca2603874 6f6fdbc7bfbc40048473b6bca2603874--85f264520b3d439a8fe148347eb4e597 6742332198d14887a164b2e8323c03c1 6f6fdbc7bfbc40048473b6bca2603874--6742332198d14887a164b2e8323c03c1 716fc7454ab74f428a82954b8791e1d9 6742332198d14887a164b2e8323c03c1--716fc7454ab74f428a82954b8791e1d9 9fc91433e82c4ad8b24e01ca9b4578ac 716fc7454ab74f428a82954b8791e1d9--9fc91433e82c4ad8b24e01ca9b4578ac 4efc6b7b5f024b8a853393a2012f9e00 X 9fc91433e82c4ad8b24e01ca9b4578ac--4efc6b7b5f024b8a853393a2012f9e00 4efc6b7b5f024b8a853393a2012f9e00--d3dee5c9d3624074b6e40cf910a59712 0aca0ebe30014252a22a0bdf29eab75b 4efc6b7b5f024b8a853393a2012f9e00--0aca0ebe30014252a22a0bdf29eab75b 078e2ea72d074f29b12c53fbe4fa1e5c 0aca0ebe30014252a22a0bdf29eab75b--078e2ea72d074f29b12c53fbe4fa1e5c 596a1968fd154834b04044fbe3339467 078e2ea72d074f29b12c53fbe4fa1e5c--596a1968fd154834b04044fbe3339467 40abb24cf1e04cbe82f73ed70aeb07be 596a1968fd154834b04044fbe3339467--40abb24cf1e04cbe82f73ed70aeb07be eefb76d5c73b44d78131306ee4990852 40abb24cf1e04cbe82f73ed70aeb07be--eefb76d5c73b44d78131306ee4990852 a75c815489084c01a20a650a34235e4e eefb76d5c73b44d78131306ee4990852--a75c815489084c01a20a650a34235e4e d2aec98fa2a2410e80111446815b718f a75c815489084c01a20a650a34235e4e--d2aec98fa2a2410e80111446815b718f 3a7adf3bc9fc4bc7819c309fdf4a7937 d2aec98fa2a2410e80111446815b718f--3a7adf3bc9fc4bc7819c309fdf4a7937 4f9192ef3a824ca19097cee64e62f877 3a7adf3bc9fc4bc7819c309fdf4a7937--4f9192ef3a824ca19097cee64e62f877 1a231abbce7c48e7822361ea15201c8e 4f9192ef3a824ca19097cee64e62f877--1a231abbce7c48e7822361ea15201c8e 219bf3b811354c7088479b54aea05726 1a231abbce7c48e7822361ea15201c8e--219bf3b811354c7088479b54aea05726 fe3fd4a9ba6848569eb5b822a427e53b 219bf3b811354c7088479b54aea05726--fe3fd4a9ba6848569eb5b822a427e53b 567cee2f97324b0bb81652a059e54b60 fe3fd4a9ba6848569eb5b822a427e53b--567cee2f97324b0bb81652a059e54b60 e6ea0e908cbd4b1aa915ae2a3310ff0c 567cee2f97324b0bb81652a059e54b60--e6ea0e908cbd4b1aa915ae2a3310ff0c 7e67000defce4b3bb6ada8ab063c0fb1 e6ea0e908cbd4b1aa915ae2a3310ff0c--7e67000defce4b3bb6ada8ab063c0fb1 86fb54da605c474ea186a5fbb7c06fe9 7e67000defce4b3bb6ada8ab063c0fb1--86fb54da605c474ea186a5fbb7c06fe9 83afe405d388460bb25d0ec9d5a07e3e 86fb54da605c474ea186a5fbb7c06fe9--83afe405d388460bb25d0ec9d5a07e3e e58887aa4d5f49128262557ac2985e09 83afe405d388460bb25d0ec9d5a07e3e--e58887aa4d5f49128262557ac2985e09 d034085b6514448ea3455e7e12bb02cc e58887aa4d5f49128262557ac2985e09--d034085b6514448ea3455e7e12bb02cc 43cd442b9afb4dc0b5df246a7d4e391b d034085b6514448ea3455e7e12bb02cc--43cd442b9afb4dc0b5df246a7d4e391b 8fadda88d7de41d6b114df80861cf882 43cd442b9afb4dc0b5df246a7d4e391b--8fadda88d7de41d6b114df80861cf882 990239fa93914121a3760e2ee6070257 8fadda88d7de41d6b114df80861cf882--990239fa93914121a3760e2ee6070257 45b260152a9e4d078a3ced2ad0639afd 990239fa93914121a3760e2ee6070257--45b260152a9e4d078a3ced2ad0639afd bbc3887970a74086bf5c03461808c3d3 45b260152a9e4d078a3ced2ad0639afd--bbc3887970a74086bf5c03461808c3d3 65cf0ee3126e496dae04f09d0545e5ea bbc3887970a74086bf5c03461808c3d3--65cf0ee3126e496dae04f09d0545e5ea cc8399084c1e455d9f8274a2acb22fcc 65cf0ee3126e496dae04f09d0545e5ea--cc8399084c1e455d9f8274a2acb22fcc b82d0a34540c4033a7867e2d4e5603f4 cc8399084c1e455d9f8274a2acb22fcc--b82d0a34540c4033a7867e2d4e5603f4 8ee89c28a9dc47959b5163f51019bdf3 b82d0a34540c4033a7867e2d4e5603f4--8ee89c28a9dc47959b5163f51019bdf3 57ef8908413545779d0159ce70f5a954 8ee89c28a9dc47959b5163f51019bdf3--57ef8908413545779d0159ce70f5a954 1f1d27f4de8c4ca0a6c44ad001910a18 57ef8908413545779d0159ce70f5a954--1f1d27f4de8c4ca0a6c44ad001910a18 eba77f92faba4c978f8276a8883093a3 1f1d27f4de8c4ca0a6c44ad001910a18--eba77f92faba4c978f8276a8883093a3 12939a4069f64f7da35396b2fcd8029d eba77f92faba4c978f8276a8883093a3--12939a4069f64f7da35396b2fcd8029d 774214280cae4c56ac9c751c35ed38e3 12939a4069f64f7da35396b2fcd8029d--774214280cae4c56ac9c751c35ed38e3 d34d43bb1aae4e29a69ade9a2fa0522c 774214280cae4c56ac9c751c35ed38e3--d34d43bb1aae4e29a69ade9a2fa0522c c9141617eece484cbac310efe21587a9 X d34d43bb1aae4e29a69ade9a2fa0522c--c9141617eece484cbac310efe21587a9 c9141617eece484cbac310efe21587a9--ec9b99b30679495f9d56a9069f3c42cb e9346df7c30348aa81449a80adc48ed2 RZ(-1.0*g1) c9141617eece484cbac310efe21587a9--e9346df7c30348aa81449a80adc48ed2 c725db5875ec460998d10c772c4ba266 X e9346df7c30348aa81449a80adc48ed2--c725db5875ec460998d10c772c4ba266 c725db5875ec460998d10c772c4ba266--73de7cdadae24e02acd17d077714488b 5d9a935493794053a5f9d2b91c7b2c15 c725db5875ec460998d10c772c4ba266--5d9a935493794053a5f9d2b91c7b2c15 947af5f01cf24b59ad387ca7c9ecbcf2 5d9a935493794053a5f9d2b91c7b2c15--947af5f01cf24b59ad387ca7c9ecbcf2 33a3176287974244ae731842d07e0b26 947af5f01cf24b59ad387ca7c9ecbcf2--33a3176287974244ae731842d07e0b26 763898b00cb34c0b88858d7553f7e092 33a3176287974244ae731842d07e0b26--763898b00cb34c0b88858d7553f7e092 8402d2cd275a4aa997a76bea53cf045d 763898b00cb34c0b88858d7553f7e092--8402d2cd275a4aa997a76bea53cf045d 3b7dff8dbf08445d847ba2117a03cae8 8402d2cd275a4aa997a76bea53cf045d--3b7dff8dbf08445d847ba2117a03cae8 f0f1781df95d4602aa823a99ca681fea 3b7dff8dbf08445d847ba2117a03cae8--f0f1781df95d4602aa823a99ca681fea 03cb9e40104348e8aacda4e78f1f97fa f0f1781df95d4602aa823a99ca681fea--03cb9e40104348e8aacda4e78f1f97fa 8b1da6d0e9c3416290eb68f5cb702ef5 03cb9e40104348e8aacda4e78f1f97fa--8b1da6d0e9c3416290eb68f5cb702ef5 907ab8832ccc4d00a3810e59adebace6 8b1da6d0e9c3416290eb68f5cb702ef5--907ab8832ccc4d00a3810e59adebace6 2979017033d1477a8103cd38b21ca6f8 907ab8832ccc4d00a3810e59adebace6--2979017033d1477a8103cd38b21ca6f8 58cbbf3fe56f47d28d47360c2486f8cf 2979017033d1477a8103cd38b21ca6f8--58cbbf3fe56f47d28d47360c2486f8cf 4df62b01b511466b823c96c697356ea7 58cbbf3fe56f47d28d47360c2486f8cf--4df62b01b511466b823c96c697356ea7 56f9626714a2485c854ef7d2b01120c9 4df62b01b511466b823c96c697356ea7--56f9626714a2485c854ef7d2b01120c9 02ee0a4cfb814aaaad1907de6b81a671 56f9626714a2485c854ef7d2b01120c9--02ee0a4cfb814aaaad1907de6b81a671 8dcb184e00d74e33a3a828b42e185ac0 02ee0a4cfb814aaaad1907de6b81a671--8dcb184e00d74e33a3a828b42e185ac0 51964d6a760243c1bd01a55f7c2a1eeb 8dcb184e00d74e33a3a828b42e185ac0--51964d6a760243c1bd01a55f7c2a1eeb 916c2b35720d41429eb84118f4d2a554 51964d6a760243c1bd01a55f7c2a1eeb--916c2b35720d41429eb84118f4d2a554 097e0ebc69f5443697eb2c7cfd995432 916c2b35720d41429eb84118f4d2a554--097e0ebc69f5443697eb2c7cfd995432 76a978a1865640bfa48bd16870630ef3 097e0ebc69f5443697eb2c7cfd995432--76a978a1865640bfa48bd16870630ef3 f4bf2d05da544a0db896cad8b83526f1 76a978a1865640bfa48bd16870630ef3--f4bf2d05da544a0db896cad8b83526f1 1864bc50ead74cceb34e980bd2567de9 f4bf2d05da544a0db896cad8b83526f1--1864bc50ead74cceb34e980bd2567de9 cc88dea54e904cd0b181975812dc8a9d 1864bc50ead74cceb34e980bd2567de9--cc88dea54e904cd0b181975812dc8a9d d226fad6fb0a422d8d5041e776a519d0 cc88dea54e904cd0b181975812dc8a9d--d226fad6fb0a422d8d5041e776a519d0 b51236c5a0c34f978daa49f7425aabc6 d226fad6fb0a422d8d5041e776a519d0--b51236c5a0c34f978daa49f7425aabc6 7cff6b740403448eacb97ce2dd7baba2 X b51236c5a0c34f978daa49f7425aabc6--7cff6b740403448eacb97ce2dd7baba2 7cff6b740403448eacb97ce2dd7baba2--1e3d99d70e394c28ac1bed812a005244 de647869422941bf920f597a073b99ff RZ(-1.0*g1) 7cff6b740403448eacb97ce2dd7baba2--de647869422941bf920f597a073b99ff e33a2ab8147f47d8ba8eaf3c061b7177 X de647869422941bf920f597a073b99ff--e33a2ab8147f47d8ba8eaf3c061b7177 e33a2ab8147f47d8ba8eaf3c061b7177--2f8a602d58354f358ea34dfc859e67ba d315046b5ea84ac58f90da7a9eb1e247 e33a2ab8147f47d8ba8eaf3c061b7177--d315046b5ea84ac58f90da7a9eb1e247 fc5fb1f9f8854d2ebcc90b349ecf2a23 d315046b5ea84ac58f90da7a9eb1e247--fc5fb1f9f8854d2ebcc90b349ecf2a23 6cfcdf0eecdb47d68d7b7e2b6f330f2d fc5fb1f9f8854d2ebcc90b349ecf2a23--6cfcdf0eecdb47d68d7b7e2b6f330f2d d77fef22b9254418983970bf109cf87a 6cfcdf0eecdb47d68d7b7e2b6f330f2d--d77fef22b9254418983970bf109cf87a c7612809b0f349acbdee9099d1ba5ec2 d77fef22b9254418983970bf109cf87a--c7612809b0f349acbdee9099d1ba5ec2 405f068fae53441a82c5455a3f5aa097 c7612809b0f349acbdee9099d1ba5ec2--405f068fae53441a82c5455a3f5aa097 d4b9d650e3224c588ec15d77fab85aee 405f068fae53441a82c5455a3f5aa097--d4b9d650e3224c588ec15d77fab85aee 724dcedb2476469eb5ec0c6210e7bbd2 d4b9d650e3224c588ec15d77fab85aee--724dcedb2476469eb5ec0c6210e7bbd2 0e13d4a5040e4c87bb4f8b8676a2db77 X 724dcedb2476469eb5ec0c6210e7bbd2--0e13d4a5040e4c87bb4f8b8676a2db77 0e13d4a5040e4c87bb4f8b8676a2db77--f1eabaf8fc5c44038cef6f8fc857a047 fca3bf12584d4ee8a960d2cbcf0e9d2a 0e13d4a5040e4c87bb4f8b8676a2db77--fca3bf12584d4ee8a960d2cbcf0e9d2a 3fe7e45d95cb4927b3d39fd27e3388be fca3bf12584d4ee8a960d2cbcf0e9d2a--3fe7e45d95cb4927b3d39fd27e3388be 7f4e62597db14da2a2944796c81a7c60 3fe7e45d95cb4927b3d39fd27e3388be--7f4e62597db14da2a2944796c81a7c60 543bc08d4e164998954b34136c90ab72 X 7f4e62597db14da2a2944796c81a7c60--543bc08d4e164998954b34136c90ab72 543bc08d4e164998954b34136c90ab72--c52a5ec72d964476a19b7c0f3634ee76 5b59308e0af94a6ebd4d3af6d75043fd 543bc08d4e164998954b34136c90ab72--5b59308e0af94a6ebd4d3af6d75043fd 712f3ce3e639433db3d7fe8dd7ea9a06 5b59308e0af94a6ebd4d3af6d75043fd--712f3ce3e639433db3d7fe8dd7ea9a06 53914d4171dc4362b1f58b6981abb6e3 712f3ce3e639433db3d7fe8dd7ea9a06--53914d4171dc4362b1f58b6981abb6e3 94a218d6371b44ce8cf58faddaa773a3 53914d4171dc4362b1f58b6981abb6e3--94a218d6371b44ce8cf58faddaa773a3 b545484d8d0040d191f99d2662719a9b 94a218d6371b44ce8cf58faddaa773a3--b545484d8d0040d191f99d2662719a9b 7d344eef1c3949a0b4f4d7d0945e8c99 b545484d8d0040d191f99d2662719a9b--7d344eef1c3949a0b4f4d7d0945e8c99 15807dec749946c9958e8f41c5e99846 7d344eef1c3949a0b4f4d7d0945e8c99--15807dec749946c9958e8f41c5e99846 2c3c4953747445b1994156ddb8d5ae3f 15807dec749946c9958e8f41c5e99846--2c3c4953747445b1994156ddb8d5ae3f 3b761b5f17b946ce862f54e2cba7aff2 2c3c4953747445b1994156ddb8d5ae3f--3b761b5f17b946ce862f54e2cba7aff2 cb8a2a286580428db7eb0c38802d1cd1 3b761b5f17b946ce862f54e2cba7aff2--cb8a2a286580428db7eb0c38802d1cd1 4b6574b457744d6e8e30905763ef5ec8 X cb8a2a286580428db7eb0c38802d1cd1--4b6574b457744d6e8e30905763ef5ec8 4b6574b457744d6e8e30905763ef5ec8--f2c0ee495fd9418b8f943403183066c4 0a8cf5bc725e4b588005807ecc0c568f RZ(-1.0*g1) 4b6574b457744d6e8e30905763ef5ec8--0a8cf5bc725e4b588005807ecc0c568f fd9100353a314d5db619f65074a33828 X 0a8cf5bc725e4b588005807ecc0c568f--fd9100353a314d5db619f65074a33828 fd9100353a314d5db619f65074a33828--c1d86d092d0649bf854fe29e2b3544c1 2afc185cc87f45cfab2c00869b6a42dd fd9100353a314d5db619f65074a33828--2afc185cc87f45cfab2c00869b6a42dd 4ddb95302bfe427fa69457cc5d4e27da 2afc185cc87f45cfab2c00869b6a42dd--4ddb95302bfe427fa69457cc5d4e27da 89ce6f0f89bf4af8aa65d73faa9de986 4ddb95302bfe427fa69457cc5d4e27da--89ce6f0f89bf4af8aa65d73faa9de986 334f865c161145c39e54b656a4b7f433 89ce6f0f89bf4af8aa65d73faa9de986--334f865c161145c39e54b656a4b7f433 67bd08f5134741838e382431e819d821 334f865c161145c39e54b656a4b7f433--67bd08f5134741838e382431e819d821 9feb2fde5c3242a698c540376854799c 67bd08f5134741838e382431e819d821--9feb2fde5c3242a698c540376854799c 525bce54b1b147338795ad4725d5cb4b 9feb2fde5c3242a698c540376854799c--525bce54b1b147338795ad4725d5cb4b 49b0c50a47ba4c629df183f59f54f75f 525bce54b1b147338795ad4725d5cb4b--49b0c50a47ba4c629df183f59f54f75f bd47c144b47e40fe9b8a14b23b25f4e5 49b0c50a47ba4c629df183f59f54f75f--bd47c144b47e40fe9b8a14b23b25f4e5 f52df2daf61d4144b2d24cde131c48b3 bd47c144b47e40fe9b8a14b23b25f4e5--f52df2daf61d4144b2d24cde131c48b3 94cd113c8d3748e396bb5a3be911b39e f52df2daf61d4144b2d24cde131c48b3--94cd113c8d3748e396bb5a3be911b39e 4eab7aa1bcaa4c9390a3ef6fc1a4f53b 94cd113c8d3748e396bb5a3be911b39e--4eab7aa1bcaa4c9390a3ef6fc1a4f53b c94007ef49ca4088ab7469824d0e8be9 4eab7aa1bcaa4c9390a3ef6fc1a4f53b--c94007ef49ca4088ab7469824d0e8be9 48c715a1886c443aa725767abf0a5662 c94007ef49ca4088ab7469824d0e8be9--48c715a1886c443aa725767abf0a5662 99d454217f664343a5c725799cfeb660 X 48c715a1886c443aa725767abf0a5662--99d454217f664343a5c725799cfeb660 99d454217f664343a5c725799cfeb660--6e1e48e77e4c4d7ab60a2b8128a64ac2 aafef245c7de40df91ca857ebbac1f95 RZ(-1.0*g1) 99d454217f664343a5c725799cfeb660--aafef245c7de40df91ca857ebbac1f95 21f38cdbebdc4f3380d5bdd75cd63dd4 X aafef245c7de40df91ca857ebbac1f95--21f38cdbebdc4f3380d5bdd75cd63dd4 21f38cdbebdc4f3380d5bdd75cd63dd4--eb9c06e219e048289d37b3b7ffb75066 6c1ef53c03c147d88b3d6c24d8372227 X 21f38cdbebdc4f3380d5bdd75cd63dd4--6c1ef53c03c147d88b3d6c24d8372227 6c1ef53c03c147d88b3d6c24d8372227--da5428eb2a81457fa4cb5b6c8b2be739 ebc352a5c1784061970c1987f814f275 6c1ef53c03c147d88b3d6c24d8372227--ebc352a5c1784061970c1987f814f275 5e78a5484fac4537957210de790aba8d ebc352a5c1784061970c1987f814f275--5e78a5484fac4537957210de790aba8d 518e792715884fee9fa8aaaaabbcf145 5e78a5484fac4537957210de790aba8d--518e792715884fee9fa8aaaaabbcf145 337c4262339f40c2ab0caee6906d89b3 X 518e792715884fee9fa8aaaaabbcf145--337c4262339f40c2ab0caee6906d89b3 337c4262339f40c2ab0caee6906d89b3--e367a52c3a894d549c4d1c5a4d8a6551 b2701aad8c0045c6b83a459b1884acf2 RX(b16) 337c4262339f40c2ab0caee6906d89b3--b2701aad8c0045c6b83a459b1884acf2 b2701aad8c0045c6b83a459b1884acf2--92a5686377d0465fbd8e32a378edeb1a d7d4122e59be4b22bde15f3637d9da1e cd8fbdc6ce484b2485592184cc3b6928 f4d36354a9514cba90d97d785dd99805--cd8fbdc6ce484b2485592184cc3b6928 02ba60617d1749b583c1580c47ab9b94 cd8fbdc6ce484b2485592184cc3b6928--02ba60617d1749b583c1580c47ab9b94 764e61d21c574b6fae978cd3c910737c 02ba60617d1749b583c1580c47ab9b94--764e61d21c574b6fae978cd3c910737c 4d47f2969b4b4a07ac644fa8d72f8862 764e61d21c574b6fae978cd3c910737c--4d47f2969b4b4a07ac644fa8d72f8862 df5e2314f9704844a39ca1f501eca8f9 4d47f2969b4b4a07ac644fa8d72f8862--df5e2314f9704844a39ca1f501eca8f9 c43b9badebac4c57a5bcd556e0bf9c7d df5e2314f9704844a39ca1f501eca8f9--c43b9badebac4c57a5bcd556e0bf9c7d adba6d0ecd68420096903171d847bd24 X c43b9badebac4c57a5bcd556e0bf9c7d--adba6d0ecd68420096903171d847bd24 adba6d0ecd68420096903171d847bd24--ebae10c85f55402c9ba6c892a4f968cf 72018bfa6f8d4d14a5a1816e0cebf0c0 RZ(1.0*g0) adba6d0ecd68420096903171d847bd24--72018bfa6f8d4d14a5a1816e0cebf0c0 6c76358a34c94bf2987e292285f012fa X 72018bfa6f8d4d14a5a1816e0cebf0c0--6c76358a34c94bf2987e292285f012fa 6c76358a34c94bf2987e292285f012fa--2419f9b5926d4884a22c86d155a142db ac34f163ccad4111a8bbccf00a5c97a7 6c76358a34c94bf2987e292285f012fa--ac34f163ccad4111a8bbccf00a5c97a7 bd290dbe08b44f5bba67f9b43bc0b6d9 ac34f163ccad4111a8bbccf00a5c97a7--bd290dbe08b44f5bba67f9b43bc0b6d9 33bde518100a482787f28cc405ed7984 bd290dbe08b44f5bba67f9b43bc0b6d9--33bde518100a482787f28cc405ed7984 211424e32cab456785f308075a646420 33bde518100a482787f28cc405ed7984--211424e32cab456785f308075a646420 b5c6575522014c6387b478910414f208 211424e32cab456785f308075a646420--b5c6575522014c6387b478910414f208 3971fa1b4f1f40cfacb880557f6a294e b5c6575522014c6387b478910414f208--3971fa1b4f1f40cfacb880557f6a294e dd23e1e859464636af35c1ea791a3601 3971fa1b4f1f40cfacb880557f6a294e--dd23e1e859464636af35c1ea791a3601 c30bc95b02bf46bab00a5106c9503335 dd23e1e859464636af35c1ea791a3601--c30bc95b02bf46bab00a5106c9503335 80be7e783e484c42ac8de3d84a3c47e8 c30bc95b02bf46bab00a5106c9503335--80be7e783e484c42ac8de3d84a3c47e8 169d27d057d543cc9c6c8baba70f0095 80be7e783e484c42ac8de3d84a3c47e8--169d27d057d543cc9c6c8baba70f0095 41784ede1a6246009e67be4b762bd8bb 169d27d057d543cc9c6c8baba70f0095--41784ede1a6246009e67be4b762bd8bb 6e29c9d2022b413ea13d5dbcce254a1d 41784ede1a6246009e67be4b762bd8bb--6e29c9d2022b413ea13d5dbcce254a1d 474594af2be349aa80533e4886594039 6e29c9d2022b413ea13d5dbcce254a1d--474594af2be349aa80533e4886594039 41b50cb4f813473995d890eb98eacb9b 474594af2be349aa80533e4886594039--41b50cb4f813473995d890eb98eacb9b 2e6adcf743314ee3a11ccfbbf2ca39fa 41b50cb4f813473995d890eb98eacb9b--2e6adcf743314ee3a11ccfbbf2ca39fa 3026448996df427db83be57992c7ffc0 2e6adcf743314ee3a11ccfbbf2ca39fa--3026448996df427db83be57992c7ffc0 fdc2fa494db14616ac21dbdf5de398fb 3026448996df427db83be57992c7ffc0--fdc2fa494db14616ac21dbdf5de398fb 5c3527f8732641cdb56aa5f36c311855 fdc2fa494db14616ac21dbdf5de398fb--5c3527f8732641cdb56aa5f36c311855 d8e974a755f44c06a244538fa43d1f54 5c3527f8732641cdb56aa5f36c311855--d8e974a755f44c06a244538fa43d1f54 8ff00d505ed149759c0ca1282239ee62 d8e974a755f44c06a244538fa43d1f54--8ff00d505ed149759c0ca1282239ee62 5225c185b82f4a339b6efcb64e4681c1 8ff00d505ed149759c0ca1282239ee62--5225c185b82f4a339b6efcb64e4681c1 b0f2d2f6777d4e8aa1a8576f3e0a1061 5225c185b82f4a339b6efcb64e4681c1--b0f2d2f6777d4e8aa1a8576f3e0a1061 623d07769efa48c6a59119072920705c b0f2d2f6777d4e8aa1a8576f3e0a1061--623d07769efa48c6a59119072920705c e12ce7cf2f1c4fd3845a2c16356d321d 623d07769efa48c6a59119072920705c--e12ce7cf2f1c4fd3845a2c16356d321d 8fca68eb7b704846895f2f102494d33d e12ce7cf2f1c4fd3845a2c16356d321d--8fca68eb7b704846895f2f102494d33d f7c183d451d94b5aba97ff1e423af666 8fca68eb7b704846895f2f102494d33d--f7c183d451d94b5aba97ff1e423af666 aa53ce39f1834066ae2867883406aab5 f7c183d451d94b5aba97ff1e423af666--aa53ce39f1834066ae2867883406aab5 0a801b765991434c851ee08fdbcf0436 aa53ce39f1834066ae2867883406aab5--0a801b765991434c851ee08fdbcf0436 359df810ed7a47ddb57822b93a7d277e 0a801b765991434c851ee08fdbcf0436--359df810ed7a47ddb57822b93a7d277e df58f7bef5734afca54b392394b98eba 359df810ed7a47ddb57822b93a7d277e--df58f7bef5734afca54b392394b98eba fb9b710b651c4dea8494d26b64de1e41 df58f7bef5734afca54b392394b98eba--fb9b710b651c4dea8494d26b64de1e41 b283620e631e4242a52a4e4ebd5e52c4 fb9b710b651c4dea8494d26b64de1e41--b283620e631e4242a52a4e4ebd5e52c4 21787fdb01d64ac9bcd8425f2bb8c133 b283620e631e4242a52a4e4ebd5e52c4--21787fdb01d64ac9bcd8425f2bb8c133 0a9f9d11769747539c665560b4b7a246 21787fdb01d64ac9bcd8425f2bb8c133--0a9f9d11769747539c665560b4b7a246 2c05e908dad64ab0b85747ac27023349 0a9f9d11769747539c665560b4b7a246--2c05e908dad64ab0b85747ac27023349 cca80443cb08471d94ed611fa16d3476 2c05e908dad64ab0b85747ac27023349--cca80443cb08471d94ed611fa16d3476 16d5cc34cf5a4a279a2372a109a06bda cca80443cb08471d94ed611fa16d3476--16d5cc34cf5a4a279a2372a109a06bda 5e321cd341394629a7c3cb2eda1b5d62 16d5cc34cf5a4a279a2372a109a06bda--5e321cd341394629a7c3cb2eda1b5d62 3ffc0dbe978b45fc920ce76ad87b66e1 5e321cd341394629a7c3cb2eda1b5d62--3ffc0dbe978b45fc920ce76ad87b66e1 6214d3ae4ea54f7a81b24d7b42d32a7d 3ffc0dbe978b45fc920ce76ad87b66e1--6214d3ae4ea54f7a81b24d7b42d32a7d d3671b7047c441aaab2f6d60b1ab8536 6214d3ae4ea54f7a81b24d7b42d32a7d--d3671b7047c441aaab2f6d60b1ab8536 a391fc3b321e4e9fb9d208caa336d366 d3671b7047c441aaab2f6d60b1ab8536--a391fc3b321e4e9fb9d208caa336d366 0e5caf0a05684c589a852b33335806ba a391fc3b321e4e9fb9d208caa336d366--0e5caf0a05684c589a852b33335806ba e4995e56dcc74733a66a85a0e052d2fd 0e5caf0a05684c589a852b33335806ba--e4995e56dcc74733a66a85a0e052d2fd 543a1f061c5d4caebf2ea35a91c9b1a2 e4995e56dcc74733a66a85a0e052d2fd--543a1f061c5d4caebf2ea35a91c9b1a2 8094de20119a4e819148e16465764b34 543a1f061c5d4caebf2ea35a91c9b1a2--8094de20119a4e819148e16465764b34 7aa62489eb9a4432bee7d66702c254af 8094de20119a4e819148e16465764b34--7aa62489eb9a4432bee7d66702c254af 93f65b713a7c4e7987d16d9d738939fc 7aa62489eb9a4432bee7d66702c254af--93f65b713a7c4e7987d16d9d738939fc 93f11e116a594a7c9828bc8cab5503bb 93f65b713a7c4e7987d16d9d738939fc--93f11e116a594a7c9828bc8cab5503bb c277373747254d928ff25daee2e96a42 93f11e116a594a7c9828bc8cab5503bb--c277373747254d928ff25daee2e96a42 67a14ef3495e426e933aa6efbe88b03b c277373747254d928ff25daee2e96a42--67a14ef3495e426e933aa6efbe88b03b f5a81e744a284477a89d4b71804ec092 67a14ef3495e426e933aa6efbe88b03b--f5a81e744a284477a89d4b71804ec092 67fb1a6b64c7412196c216531a9cc7e5 f5a81e744a284477a89d4b71804ec092--67fb1a6b64c7412196c216531a9cc7e5 665796f6c089451199fb3a1f3d59b2f9 67fb1a6b64c7412196c216531a9cc7e5--665796f6c089451199fb3a1f3d59b2f9 a4c4f137df544d48b258401873aacefa 665796f6c089451199fb3a1f3d59b2f9--a4c4f137df544d48b258401873aacefa e058468b604d404daa8e16fce7399bd4 a4c4f137df544d48b258401873aacefa--e058468b604d404daa8e16fce7399bd4 3da0d7a7b0f24f3f941fe8f1f53fe99f e058468b604d404daa8e16fce7399bd4--3da0d7a7b0f24f3f941fe8f1f53fe99f c528b4a87a84499291ff261387917fbc 3da0d7a7b0f24f3f941fe8f1f53fe99f--c528b4a87a84499291ff261387917fbc 05c6a80b45a14d3dafa476316aeab74d c528b4a87a84499291ff261387917fbc--05c6a80b45a14d3dafa476316aeab74d fbf650c8f65f42af93f1241666d6f8e8 05c6a80b45a14d3dafa476316aeab74d--fbf650c8f65f42af93f1241666d6f8e8 d65b6a81e1a043ac8ffbe7d7ce18d1ef fbf650c8f65f42af93f1241666d6f8e8--d65b6a81e1a043ac8ffbe7d7ce18d1ef 4a57ffc9970646d68ebc5c6e985c85eb d65b6a81e1a043ac8ffbe7d7ce18d1ef--4a57ffc9970646d68ebc5c6e985c85eb 0332a23b982d441e8f4229b6e41d5b34 4a57ffc9970646d68ebc5c6e985c85eb--0332a23b982d441e8f4229b6e41d5b34 18f816e9a35c49a6a7dc482733f8f324 0332a23b982d441e8f4229b6e41d5b34--18f816e9a35c49a6a7dc482733f8f324 776102146327462f8bcc087b35b2c8f7 18f816e9a35c49a6a7dc482733f8f324--776102146327462f8bcc087b35b2c8f7 5c8e1407d0c247249a399e647704a55f 776102146327462f8bcc087b35b2c8f7--5c8e1407d0c247249a399e647704a55f f3314612ef3f4d488f8280bb01b51a74 5c8e1407d0c247249a399e647704a55f--f3314612ef3f4d488f8280bb01b51a74 c08dac0d90c84e799076904b854ee96b f3314612ef3f4d488f8280bb01b51a74--c08dac0d90c84e799076904b854ee96b 277a19e21b764686a437c00c805a676e c08dac0d90c84e799076904b854ee96b--277a19e21b764686a437c00c805a676e 004dd1df5726437bb13230ad23de22dc 277a19e21b764686a437c00c805a676e--004dd1df5726437bb13230ad23de22dc ec6ace95255b41559c09e836add5b782 004dd1df5726437bb13230ad23de22dc--ec6ace95255b41559c09e836add5b782 7ea6847896ee4e54993f372cbd81b27f ec6ace95255b41559c09e836add5b782--7ea6847896ee4e54993f372cbd81b27f 66d8df53a7ff4b76a5e629b85ea9a71a 7ea6847896ee4e54993f372cbd81b27f--66d8df53a7ff4b76a5e629b85ea9a71a baca8e410d504c9bbe52cd06a28068d4 66d8df53a7ff4b76a5e629b85ea9a71a--baca8e410d504c9bbe52cd06a28068d4 6193e400815c450bb1bbd041ac0f8bc8 baca8e410d504c9bbe52cd06a28068d4--6193e400815c450bb1bbd041ac0f8bc8 3dca07e5c7dd40b3a7cdb7af20dac90e X 6193e400815c450bb1bbd041ac0f8bc8--3dca07e5c7dd40b3a7cdb7af20dac90e 3dca07e5c7dd40b3a7cdb7af20dac90e--d3019775e6a6465b85ff579e247bf090 add30d6cd4b340959d1f26e0c3bb61df RZ(-1.0*g0) 3dca07e5c7dd40b3a7cdb7af20dac90e--add30d6cd4b340959d1f26e0c3bb61df 6bcc85a3b5d043ecb755e79061243a3d X add30d6cd4b340959d1f26e0c3bb61df--6bcc85a3b5d043ecb755e79061243a3d 6bcc85a3b5d043ecb755e79061243a3d--7b60e82076f04629b64945414c75599f 5b02890f9ec540bb97ba3f8ff7c667d9 6bcc85a3b5d043ecb755e79061243a3d--5b02890f9ec540bb97ba3f8ff7c667d9 90ba0effcb6d477da57513981da24b04 5b02890f9ec540bb97ba3f8ff7c667d9--90ba0effcb6d477da57513981da24b04 abfed411f39741f9bdc52445e9823a4f 90ba0effcb6d477da57513981da24b04--abfed411f39741f9bdc52445e9823a4f ca9a544ed219420f98ac52cc684edb25 abfed411f39741f9bdc52445e9823a4f--ca9a544ed219420f98ac52cc684edb25 fba4d291d37d4475977b27f6ab325d03 ca9a544ed219420f98ac52cc684edb25--fba4d291d37d4475977b27f6ab325d03 6aaf21f189bc48fba224520b8d497f53 fba4d291d37d4475977b27f6ab325d03--6aaf21f189bc48fba224520b8d497f53 6e291f9e2d7f4fc3849db0d22c57e881 6aaf21f189bc48fba224520b8d497f53--6e291f9e2d7f4fc3849db0d22c57e881 4958fac36668460db9cbc7a330e6026a 6e291f9e2d7f4fc3849db0d22c57e881--4958fac36668460db9cbc7a330e6026a b2cb8ca267434a5ca5cfe61c5528849e 4958fac36668460db9cbc7a330e6026a--b2cb8ca267434a5ca5cfe61c5528849e 94e360cad94c4671a2b4b7c6d9504c77 b2cb8ca267434a5ca5cfe61c5528849e--94e360cad94c4671a2b4b7c6d9504c77 71055a5cb3744598bcc233c1fe1ec9e0 94e360cad94c4671a2b4b7c6d9504c77--71055a5cb3744598bcc233c1fe1ec9e0 8023cea798e94e358cec723ffae076d5 71055a5cb3744598bcc233c1fe1ec9e0--8023cea798e94e358cec723ffae076d5 dfbab5ddb3654873af847c2ab56f5890 8023cea798e94e358cec723ffae076d5--dfbab5ddb3654873af847c2ab56f5890 97c07bf4d05743f1a358a7f59ca1366d dfbab5ddb3654873af847c2ab56f5890--97c07bf4d05743f1a358a7f59ca1366d 2bf0e0527bf8439e98923dc6a0263a58 97c07bf4d05743f1a358a7f59ca1366d--2bf0e0527bf8439e98923dc6a0263a58 300814231c4548658abcc756cb2fa226 2bf0e0527bf8439e98923dc6a0263a58--300814231c4548658abcc756cb2fa226 c9cbe9d1e7f04743b68139987fdd6cf6 300814231c4548658abcc756cb2fa226--c9cbe9d1e7f04743b68139987fdd6cf6 eb70dde494534001825d4f227f4cf751 c9cbe9d1e7f04743b68139987fdd6cf6--eb70dde494534001825d4f227f4cf751 a048c4d5aba747739bb969f5d0eaca68 eb70dde494534001825d4f227f4cf751--a048c4d5aba747739bb969f5d0eaca68 8c03c0aa57bd4135b5e3f8ebe349370c a048c4d5aba747739bb969f5d0eaca68--8c03c0aa57bd4135b5e3f8ebe349370c 41e1ccf4d424415aa9e83d6a8ff3b5f2 8c03c0aa57bd4135b5e3f8ebe349370c--41e1ccf4d424415aa9e83d6a8ff3b5f2 3a500c3e0b94463991b0639355b0f5c5 41e1ccf4d424415aa9e83d6a8ff3b5f2--3a500c3e0b94463991b0639355b0f5c5 c4a37e6ee55143c7929113316394176a 3a500c3e0b94463991b0639355b0f5c5--c4a37e6ee55143c7929113316394176a c72ef69268f6449db62fbc1c632fff75 c4a37e6ee55143c7929113316394176a--c72ef69268f6449db62fbc1c632fff75 f0dbd5372fe641f3ae546793b3b02a4b c72ef69268f6449db62fbc1c632fff75--f0dbd5372fe641f3ae546793b3b02a4b 17e4014cb3de429a94def1acec19c408 f0dbd5372fe641f3ae546793b3b02a4b--17e4014cb3de429a94def1acec19c408 9d34d4c88a124069bf609211047cf6fe 17e4014cb3de429a94def1acec19c408--9d34d4c88a124069bf609211047cf6fe 4215907a15b844aab5e1b0733e0f4bd9 9d34d4c88a124069bf609211047cf6fe--4215907a15b844aab5e1b0733e0f4bd9 4a2b688b038c4bb894f161887eaab75d 4215907a15b844aab5e1b0733e0f4bd9--4a2b688b038c4bb894f161887eaab75d 3c3433a905d148ab8f33f5159ffc184a 4a2b688b038c4bb894f161887eaab75d--3c3433a905d148ab8f33f5159ffc184a 2a5428ad87d0472b835f232ce45279bc 3c3433a905d148ab8f33f5159ffc184a--2a5428ad87d0472b835f232ce45279bc 143b10db937f4e969b0dfe43d5518e5e 2a5428ad87d0472b835f232ce45279bc--143b10db937f4e969b0dfe43d5518e5e 4f170c5863d64f74a08b5c6b248f074a X 143b10db937f4e969b0dfe43d5518e5e--4f170c5863d64f74a08b5c6b248f074a 4f170c5863d64f74a08b5c6b248f074a--0fbce08dcddf4c99abdf3a0e51c43250 97216973134547568964d0f7ac07d36b RZ(-1.0*g0) 4f170c5863d64f74a08b5c6b248f074a--97216973134547568964d0f7ac07d36b 5215b5d4df76422185e9489a59e6c6a0 X 97216973134547568964d0f7ac07d36b--5215b5d4df76422185e9489a59e6c6a0 5215b5d4df76422185e9489a59e6c6a0--0a08d1facc2d4b50861ce265cf1de7d6 dd2527c9fbcf4310a684812699b094a9 5215b5d4df76422185e9489a59e6c6a0--dd2527c9fbcf4310a684812699b094a9 b1f170dfa4dc43ea9dd7317908e6907a RX(b07) dd2527c9fbcf4310a684812699b094a9--b1f170dfa4dc43ea9dd7317908e6907a 9aaa3e3cbd2441089fa81b765f7c89fa b1f170dfa4dc43ea9dd7317908e6907a--9aaa3e3cbd2441089fa81b765f7c89fa 9ba50c89e9e5486c9031c5f10a69571a 9aaa3e3cbd2441089fa81b765f7c89fa--9ba50c89e9e5486c9031c5f10a69571a a1bce68c15a2403faafa46666ccc6a1e 9ba50c89e9e5486c9031c5f10a69571a--a1bce68c15a2403faafa46666ccc6a1e f980b3c55c4341deb1ffefd0a416bd1e a1bce68c15a2403faafa46666ccc6a1e--f980b3c55c4341deb1ffefd0a416bd1e 57e89349ae4a46f0a520c13fbce29930 f980b3c55c4341deb1ffefd0a416bd1e--57e89349ae4a46f0a520c13fbce29930 ee979b0bbf2e4757a70797be9b9026f2 57e89349ae4a46f0a520c13fbce29930--ee979b0bbf2e4757a70797be9b9026f2 d67cc63ff9334432a1e8a5abce9236a8 X ee979b0bbf2e4757a70797be9b9026f2--d67cc63ff9334432a1e8a5abce9236a8 d67cc63ff9334432a1e8a5abce9236a8--6742332198d14887a164b2e8323c03c1 83d23435f5b142e19dd41e698e898571 RZ(1.0*g1) d67cc63ff9334432a1e8a5abce9236a8--83d23435f5b142e19dd41e698e898571 c1671e9ed2dc4baf95e0e86fb9716b48 X 83d23435f5b142e19dd41e698e898571--c1671e9ed2dc4baf95e0e86fb9716b48 c1671e9ed2dc4baf95e0e86fb9716b48--9fc91433e82c4ad8b24e01ca9b4578ac 2a1ed11647884bab9b4d794220512de6 c1671e9ed2dc4baf95e0e86fb9716b48--2a1ed11647884bab9b4d794220512de6 3f77cd0fc79b4dabb5675a31475d703a 2a1ed11647884bab9b4d794220512de6--3f77cd0fc79b4dabb5675a31475d703a 5ed02e7f97034c5ca87c426e484e5855 3f77cd0fc79b4dabb5675a31475d703a--5ed02e7f97034c5ca87c426e484e5855 bd371bc65dae465b8aae740b205347b6 5ed02e7f97034c5ca87c426e484e5855--bd371bc65dae465b8aae740b205347b6 92725ead502f4e5e925adb5c91bd1dd3 bd371bc65dae465b8aae740b205347b6--92725ead502f4e5e925adb5c91bd1dd3 49464db3857e41bf8bce2a5c6cb4675b 92725ead502f4e5e925adb5c91bd1dd3--49464db3857e41bf8bce2a5c6cb4675b 602c65c47b854900aba5bef8a4f25f02 49464db3857e41bf8bce2a5c6cb4675b--602c65c47b854900aba5bef8a4f25f02 b2eef80b53bc4f8996254973e3755c05 602c65c47b854900aba5bef8a4f25f02--b2eef80b53bc4f8996254973e3755c05 e9855f57ecdf4c029960e8a19b9e9fb0 b2eef80b53bc4f8996254973e3755c05--e9855f57ecdf4c029960e8a19b9e9fb0 b72a9229aff04cfaa081c4a6a9d8469d e9855f57ecdf4c029960e8a19b9e9fb0--b72a9229aff04cfaa081c4a6a9d8469d 1693549fafef48fc8a3d456b5157a467 b72a9229aff04cfaa081c4a6a9d8469d--1693549fafef48fc8a3d456b5157a467 9d20eb3c2d234c8297df59a1e73d1591 1693549fafef48fc8a3d456b5157a467--9d20eb3c2d234c8297df59a1e73d1591 c22a99b9c71d497d9c85ed76a2004716 9d20eb3c2d234c8297df59a1e73d1591--c22a99b9c71d497d9c85ed76a2004716 6e45f0183a09461d85e4f952de60d40e c22a99b9c71d497d9c85ed76a2004716--6e45f0183a09461d85e4f952de60d40e f1b588f2a3ec431a9ea8e3f536729423 6e45f0183a09461d85e4f952de60d40e--f1b588f2a3ec431a9ea8e3f536729423 44266283ee8c49eca9efb214a23bfcda f1b588f2a3ec431a9ea8e3f536729423--44266283ee8c49eca9efb214a23bfcda ab60695dc10d44fab5886c87ca0051d4 44266283ee8c49eca9efb214a23bfcda--ab60695dc10d44fab5886c87ca0051d4 0504bd94b44b4341aa46d1c2494eecff ab60695dc10d44fab5886c87ca0051d4--0504bd94b44b4341aa46d1c2494eecff bf5f4c7327ed4172a8072835a373b319 0504bd94b44b4341aa46d1c2494eecff--bf5f4c7327ed4172a8072835a373b319 c9e1cfda8c984e188f4cac1aaf9f2a9b bf5f4c7327ed4172a8072835a373b319--c9e1cfda8c984e188f4cac1aaf9f2a9b f1ec45725f234e46b7d126e69ba2ea04 c9e1cfda8c984e188f4cac1aaf9f2a9b--f1ec45725f234e46b7d126e69ba2ea04 2e19c310f8cf4348891f24fcd58a911e f1ec45725f234e46b7d126e69ba2ea04--2e19c310f8cf4348891f24fcd58a911e 1cc852537fb14145a6e58e4eefbc2c3a 2e19c310f8cf4348891f24fcd58a911e--1cc852537fb14145a6e58e4eefbc2c3a 64db4f51c97d494da46a1e88a1de216a 1cc852537fb14145a6e58e4eefbc2c3a--64db4f51c97d494da46a1e88a1de216a 2016d1131cc84b78b22668c5ecf846d2 64db4f51c97d494da46a1e88a1de216a--2016d1131cc84b78b22668c5ecf846d2 a0cd86b9c3e14c3194386e472d5bc957 2016d1131cc84b78b22668c5ecf846d2--a0cd86b9c3e14c3194386e472d5bc957 bcfb32880ffd406a83fe31bd50c52a54 a0cd86b9c3e14c3194386e472d5bc957--bcfb32880ffd406a83fe31bd50c52a54 ee82eea697e248db8397612e6e4c21cb bcfb32880ffd406a83fe31bd50c52a54--ee82eea697e248db8397612e6e4c21cb f8c510dfe7ff4a878f62ac3a2fbaa377 ee82eea697e248db8397612e6e4c21cb--f8c510dfe7ff4a878f62ac3a2fbaa377 607d4e7900f8406a8d7aef0366989f05 f8c510dfe7ff4a878f62ac3a2fbaa377--607d4e7900f8406a8d7aef0366989f05 78061a3cc79342138b939d4b48ca10d6 607d4e7900f8406a8d7aef0366989f05--78061a3cc79342138b939d4b48ca10d6 6186caa57c794170b671b8ac0c5212cc 78061a3cc79342138b939d4b48ca10d6--6186caa57c794170b671b8ac0c5212cc dec44a1f6f2e469bab9ec10f25d9975d 6186caa57c794170b671b8ac0c5212cc--dec44a1f6f2e469bab9ec10f25d9975d 7c5a8dbb46784a05bcb7d6ff33d1e744 dec44a1f6f2e469bab9ec10f25d9975d--7c5a8dbb46784a05bcb7d6ff33d1e744 39a217ee8d0548c28f49a690c33dee15 7c5a8dbb46784a05bcb7d6ff33d1e744--39a217ee8d0548c28f49a690c33dee15 499937d0adfc4b00866ec3ef4adfa607 39a217ee8d0548c28f49a690c33dee15--499937d0adfc4b00866ec3ef4adfa607 2048c76b7f6f47d893acc7e4a548bd28 499937d0adfc4b00866ec3ef4adfa607--2048c76b7f6f47d893acc7e4a548bd28 8bc05edf6bc9412486cc64b784143283 2048c76b7f6f47d893acc7e4a548bd28--8bc05edf6bc9412486cc64b784143283 50ce3cc4a41542229d92b71c759ffc34 8bc05edf6bc9412486cc64b784143283--50ce3cc4a41542229d92b71c759ffc34 78bf3845b85646c1a1dfb5a5df92dff0 50ce3cc4a41542229d92b71c759ffc34--78bf3845b85646c1a1dfb5a5df92dff0 e03f44bd9c7f43faaef2e3c6ade6254c 78bf3845b85646c1a1dfb5a5df92dff0--e03f44bd9c7f43faaef2e3c6ade6254c 2188e798647b4a2ca1e90e530fc9318c e03f44bd9c7f43faaef2e3c6ade6254c--2188e798647b4a2ca1e90e530fc9318c 69da0031f702463eb38da9b60bed26f5 2188e798647b4a2ca1e90e530fc9318c--69da0031f702463eb38da9b60bed26f5 d13892834efb48d6bc6a3f7fb1ab3a6a 69da0031f702463eb38da9b60bed26f5--d13892834efb48d6bc6a3f7fb1ab3a6a 33b77d248cb14ea48e41741820a7b8f4 d13892834efb48d6bc6a3f7fb1ab3a6a--33b77d248cb14ea48e41741820a7b8f4 6caefd5e4bd24fc88b0d5c72e29e37dc 33b77d248cb14ea48e41741820a7b8f4--6caefd5e4bd24fc88b0d5c72e29e37dc bb2362d3635948f0bdaded209fd9aa24 6caefd5e4bd24fc88b0d5c72e29e37dc--bb2362d3635948f0bdaded209fd9aa24 a9d7407a46bb498688f0349dd0355d84 bb2362d3635948f0bdaded209fd9aa24--a9d7407a46bb498688f0349dd0355d84 8e2ab99314fb455abce75a273f9a7f2e a9d7407a46bb498688f0349dd0355d84--8e2ab99314fb455abce75a273f9a7f2e 345b242fc1e7400cb32270dcb3987624 8e2ab99314fb455abce75a273f9a7f2e--345b242fc1e7400cb32270dcb3987624 c922911c38cd4b22bcad14bb88226658 345b242fc1e7400cb32270dcb3987624--c922911c38cd4b22bcad14bb88226658 d63e0ce95b4c44dca1769b9bc9bf3443 c922911c38cd4b22bcad14bb88226658--d63e0ce95b4c44dca1769b9bc9bf3443 b1a6ee1ed95c420eadc6d21576a62902 d63e0ce95b4c44dca1769b9bc9bf3443--b1a6ee1ed95c420eadc6d21576a62902 cef71343589b4adba88b9030bdaa6565 b1a6ee1ed95c420eadc6d21576a62902--cef71343589b4adba88b9030bdaa6565 40ce1bf244f648eb812c689adb2cdf8e cef71343589b4adba88b9030bdaa6565--40ce1bf244f648eb812c689adb2cdf8e 8e61a6a893fb4c7ea6b58c6519c94d1e 40ce1bf244f648eb812c689adb2cdf8e--8e61a6a893fb4c7ea6b58c6519c94d1e 7ef76ee3592842f19e6da1c44d07611c 8e61a6a893fb4c7ea6b58c6519c94d1e--7ef76ee3592842f19e6da1c44d07611c 29cfb7da74ee4b2fb199d01289a8405f 7ef76ee3592842f19e6da1c44d07611c--29cfb7da74ee4b2fb199d01289a8405f 50edcf2a6839417e8f0d378ce9fd9c0d 29cfb7da74ee4b2fb199d01289a8405f--50edcf2a6839417e8f0d378ce9fd9c0d 44addeb082a94c359c01b752b8b73c66 50edcf2a6839417e8f0d378ce9fd9c0d--44addeb082a94c359c01b752b8b73c66 71514257e8e742ffaa43a76979dbbde4 44addeb082a94c359c01b752b8b73c66--71514257e8e742ffaa43a76979dbbde4 79be2d5305be4c0da47dbc18f3c002ee 71514257e8e742ffaa43a76979dbbde4--79be2d5305be4c0da47dbc18f3c002ee e992ea13122443b69081dbb610157934 79be2d5305be4c0da47dbc18f3c002ee--e992ea13122443b69081dbb610157934 e6fa0ecc516e439b8f8ea68671cc1875 e992ea13122443b69081dbb610157934--e6fa0ecc516e439b8f8ea68671cc1875 4f9ed218745b40a89c16b65d58f84dd9 e6fa0ecc516e439b8f8ea68671cc1875--4f9ed218745b40a89c16b65d58f84dd9 a5c69b37613f46a6b7569f80f97d25c4 4f9ed218745b40a89c16b65d58f84dd9--a5c69b37613f46a6b7569f80f97d25c4 8c24aa4d02414b35937f12c93a1e2b56 a5c69b37613f46a6b7569f80f97d25c4--8c24aa4d02414b35937f12c93a1e2b56 189758c65eb94957b09a23aeeafd66eb 8c24aa4d02414b35937f12c93a1e2b56--189758c65eb94957b09a23aeeafd66eb 36d518f601524dc69ff6e7e4b733b45f 189758c65eb94957b09a23aeeafd66eb--36d518f601524dc69ff6e7e4b733b45f 5bc3a4f824d6459db803e5395d94b537 36d518f601524dc69ff6e7e4b733b45f--5bc3a4f824d6459db803e5395d94b537 fcc9937c5bac4110b30b635485aa9232 5bc3a4f824d6459db803e5395d94b537--fcc9937c5bac4110b30b635485aa9232 3f896186bcc94e2da1da05b587163079 fcc9937c5bac4110b30b635485aa9232--3f896186bcc94e2da1da05b587163079 987764e42deb43ab8cd4107825afa326 3f896186bcc94e2da1da05b587163079--987764e42deb43ab8cd4107825afa326 b67ea2ef157640b59fa0b74b2153b732 987764e42deb43ab8cd4107825afa326--b67ea2ef157640b59fa0b74b2153b732 03263c68f0a249779890e0afa7197ca5 b67ea2ef157640b59fa0b74b2153b732--03263c68f0a249779890e0afa7197ca5 7468a87986db4ebd8e83da1d2a311f96 X 03263c68f0a249779890e0afa7197ca5--7468a87986db4ebd8e83da1d2a311f96 7468a87986db4ebd8e83da1d2a311f96--fca3bf12584d4ee8a960d2cbcf0e9d2a 6a471deddffe45aebc341ba754a218ea RZ(-1.0*g1) 7468a87986db4ebd8e83da1d2a311f96--6a471deddffe45aebc341ba754a218ea 7e08781c44d443748d9d4e90f3f9be19 X 6a471deddffe45aebc341ba754a218ea--7e08781c44d443748d9d4e90f3f9be19 7e08781c44d443748d9d4e90f3f9be19--7f4e62597db14da2a2944796c81a7c60 9e128e7c691c49eeb847d3ef6f585ee3 7e08781c44d443748d9d4e90f3f9be19--9e128e7c691c49eeb847d3ef6f585ee3 e9f65d591f9d4efab8ad3c72287fa125 9e128e7c691c49eeb847d3ef6f585ee3--e9f65d591f9d4efab8ad3c72287fa125 d2daf02cc5d749af939ab09a323cb1bf e9f65d591f9d4efab8ad3c72287fa125--d2daf02cc5d749af939ab09a323cb1bf 0a6cf503e26f467d97bd51b326a1936a d2daf02cc5d749af939ab09a323cb1bf--0a6cf503e26f467d97bd51b326a1936a 7b85318811964282ba780dfa9cbf996b 0a6cf503e26f467d97bd51b326a1936a--7b85318811964282ba780dfa9cbf996b b16f461eb2b64190acda99f1dd6e2a1a 7b85318811964282ba780dfa9cbf996b--b16f461eb2b64190acda99f1dd6e2a1a 253eae33df7e4ea4bb0ee643a12a3d47 b16f461eb2b64190acda99f1dd6e2a1a--253eae33df7e4ea4bb0ee643a12a3d47 d3474cba26844cec9bed8a51e6b68bc7 253eae33df7e4ea4bb0ee643a12a3d47--d3474cba26844cec9bed8a51e6b68bc7 93898a8cf99b4428a0fa37b8533408c7 d3474cba26844cec9bed8a51e6b68bc7--93898a8cf99b4428a0fa37b8533408c7 27e70f76fb09468cae1a42f62fa47ea2 93898a8cf99b4428a0fa37b8533408c7--27e70f76fb09468cae1a42f62fa47ea2 558c9527984a425db43b6246ed209a19 27e70f76fb09468cae1a42f62fa47ea2--558c9527984a425db43b6246ed209a19 45de1c9a5b474acd9f7ccb793965ffac 558c9527984a425db43b6246ed209a19--45de1c9a5b474acd9f7ccb793965ffac da28741ae5184935809dd30978008556 45de1c9a5b474acd9f7ccb793965ffac--da28741ae5184935809dd30978008556 d500e906bf204d448617fbe3c3890be3 da28741ae5184935809dd30978008556--d500e906bf204d448617fbe3c3890be3 bb694f9e06f749279900f502f5785b28 d500e906bf204d448617fbe3c3890be3--bb694f9e06f749279900f502f5785b28 2e97ee48e031453e9968addd275de7ae bb694f9e06f749279900f502f5785b28--2e97ee48e031453e9968addd275de7ae e88abaf1bcb34db9b84d0d352de6b383 2e97ee48e031453e9968addd275de7ae--e88abaf1bcb34db9b84d0d352de6b383 6bdec323add240d98ca6ca5c550d5bdc e88abaf1bcb34db9b84d0d352de6b383--6bdec323add240d98ca6ca5c550d5bdc d90fe2b528214814833c2e5ab8f4342e 6bdec323add240d98ca6ca5c550d5bdc--d90fe2b528214814833c2e5ab8f4342e 0153ce4cba3648f4b2c568f12ffedfb5 d90fe2b528214814833c2e5ab8f4342e--0153ce4cba3648f4b2c568f12ffedfb5 bc78fdbadd5f470393af3d780d66ca89 0153ce4cba3648f4b2c568f12ffedfb5--bc78fdbadd5f470393af3d780d66ca89 82f315db46554eff8418884a0ab9b266 bc78fdbadd5f470393af3d780d66ca89--82f315db46554eff8418884a0ab9b266 e2cc56dbc99f4e87bdb273ecb29b70fb 82f315db46554eff8418884a0ab9b266--e2cc56dbc99f4e87bdb273ecb29b70fb 65935e82d17c41fea7216dbc3e878ee0 e2cc56dbc99f4e87bdb273ecb29b70fb--65935e82d17c41fea7216dbc3e878ee0 b976e95676584d94b07c28cd82a58dec 65935e82d17c41fea7216dbc3e878ee0--b976e95676584d94b07c28cd82a58dec 7e32010b7a4945f2802eee16e40ffc4b b976e95676584d94b07c28cd82a58dec--7e32010b7a4945f2802eee16e40ffc4b 727b029f1d0e47aba989bdc953d9e964 7e32010b7a4945f2802eee16e40ffc4b--727b029f1d0e47aba989bdc953d9e964 669af5afc6284bb4bc1e83b7c21414bc 727b029f1d0e47aba989bdc953d9e964--669af5afc6284bb4bc1e83b7c21414bc 84521c9625b3481aa814eda8347d55e5 669af5afc6284bb4bc1e83b7c21414bc--84521c9625b3481aa814eda8347d55e5 af2d90ff57aa4268bfdae500fd521198 84521c9625b3481aa814eda8347d55e5--af2d90ff57aa4268bfdae500fd521198 8bea73df63ee488db0c92b99a45efbb2 af2d90ff57aa4268bfdae500fd521198--8bea73df63ee488db0c92b99a45efbb2 7d98932d14524524ae03a63bfc5c2799 8bea73df63ee488db0c92b99a45efbb2--7d98932d14524524ae03a63bfc5c2799 396375cad31d4a2b959654a426d55a8d X 7d98932d14524524ae03a63bfc5c2799--396375cad31d4a2b959654a426d55a8d 396375cad31d4a2b959654a426d55a8d--ebc352a5c1784061970c1987f814f275 efa57bdd8e1848599ba0e052e5d5a3fa RZ(-1.0*g1) 396375cad31d4a2b959654a426d55a8d--efa57bdd8e1848599ba0e052e5d5a3fa dfa013e644924b1f92c62ce8e403dfef X efa57bdd8e1848599ba0e052e5d5a3fa--dfa013e644924b1f92c62ce8e403dfef dfa013e644924b1f92c62ce8e403dfef--518e792715884fee9fa8aaaaabbcf145 fa0a519e05b04f44ae822042f175fad6 dfa013e644924b1f92c62ce8e403dfef--fa0a519e05b04f44ae822042f175fad6 a83caec3216e479d81d0e6a47fefc235 RX(b17) fa0a519e05b04f44ae822042f175fad6--a83caec3216e479d81d0e6a47fefc235 a83caec3216e479d81d0e6a47fefc235--d7d4122e59be4b22bde15f3637d9da1e"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -5.343060635441905\nMaxCut cost at iteration 10: 11.082247910452297\nMaxCut cost at iteration 20: 11.994065455470624\nMaxCut cost at iteration 30: 11.999830322854741\nMaxCut cost at iteration 40: 11.999985981739908\nMaxCut cost at iteration 50: 11.999998784164173\nMaxCut cost at iteration 60: 11.999999894200029\nMaxCut cost at iteration 70: 11.99999999079089\nMaxCut cost at iteration 80: 11.999999999198383\nMaxCut cost at iteration 90: 11.999999999930228\nMaxCut cost at iteration 100: 11.999999999993921\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 00011011  2023-12-11T15:41:35.523432 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-12-11T15:41:39.971552 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_79906ed7de6744a698323e84aacd60d3 Constant Chebyshev FM cluster_89fbdbb0395143ef88c4ef476b04fd03 Constant Fourier FM f3116987e9f84e57b21d43f05d68a5df 0 916454c0ccb3434f809d3deae50115c6 RX(phi) f3116987e9f84e57b21d43f05d68a5df--916454c0ccb3434f809d3deae50115c6 09995121c8de458ca5a89fb7caae9a80 1 67e8e477bd9948da8084ccc280f17b6c RX(acos(phi)) 916454c0ccb3434f809d3deae50115c6--67e8e477bd9948da8084ccc280f17b6c f2d7fa8d182542ecaddb8ecc12818df6 67e8e477bd9948da8084ccc280f17b6c--f2d7fa8d182542ecaddb8ecc12818df6 833a21ee7a6542c78a5e5f8e3ec3d1ec 6a1515ff35514537b5f919c511e92a96 RX(phi) 09995121c8de458ca5a89fb7caae9a80--6a1515ff35514537b5f919c511e92a96 f7f0ac7383cc4032bbec282ca729fa9e 2 faf7aa040d4146acba64846fa9481711 RX(acos(phi)) 6a1515ff35514537b5f919c511e92a96--faf7aa040d4146acba64846fa9481711 faf7aa040d4146acba64846fa9481711--833a21ee7a6542c78a5e5f8e3ec3d1ec e5f15a71505b459d9910e78ab87a818b 9cd064db5260438c9c07eb5c44c9679d RX(phi) f7f0ac7383cc4032bbec282ca729fa9e--9cd064db5260438c9c07eb5c44c9679d 8564c13fdc0842d7ac91062d86c562cc RX(acos(phi)) 9cd064db5260438c9c07eb5c44c9679d--8564c13fdc0842d7ac91062d86c562cc 8564c13fdc0842d7ac91062d86c562cc--e5f15a71505b459d9910e78ab87a818b <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom sub-class of Function\nclass custom_func(Function):\n    @classmethod\n    def eval(cls, x):\n        return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_func)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_c7bf43b35c704cf5b03d16488a05471d Constant custom_func FM cluster_d1ee2091932240919c4d4d29c9f09a2f Constant asin FM 582c31c7b87d45ba94cc8929ced3a4d6 0 45434dd7eb57426b897e1f86896d640b RX(asin(phi)) 582c31c7b87d45ba94cc8929ced3a4d6--45434dd7eb57426b897e1f86896d640b 6f3b26700903477d8858acb0ac332c43 1 d854ef9e045044ca8b2efae967bf1f59 RX(phi**2 + asin(phi)) 45434dd7eb57426b897e1f86896d640b--d854ef9e045044ca8b2efae967bf1f59 e1ed9c041206446a813893177c2c0170 d854ef9e045044ca8b2efae967bf1f59--e1ed9c041206446a813893177c2c0170 ee4adf8554794798b0327c48ef29201f f91390d61bd342ada994d02df4489438 RX(asin(phi)) 6f3b26700903477d8858acb0ac332c43--f91390d61bd342ada994d02df4489438 cbca022f34cc425393345aa2db42782c 2 3eaeda1cfc7e4c509b9c47a1954b7edd RX(phi**2 + asin(phi)) f91390d61bd342ada994d02df4489438--3eaeda1cfc7e4c509b9c47a1954b7edd 3eaeda1cfc7e4c509b9c47a1954b7edd--ee4adf8554794798b0327c48ef29201f a8f23d94b7a44530ac1bfc97f50d47fa aba2b5c717bb4b55973edfc898882c89 RX(asin(phi)) cbca022f34cc425393345aa2db42782c--aba2b5c717bb4b55973edfc898882c89 79ffea66804340e4905ae5db460f4f75 RX(phi**2 + asin(phi)) aba2b5c717bb4b55973edfc898882c89--79ffea66804340e4905ae5db460f4f75 79ffea66804340e4905ae5db460f4f75--a8f23d94b7a44530ac1bfc97f50d47fa <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_a8921b15ac734fb297903bc0e3a3a903 Exponential Fourier FM cluster_8550f18038a34c738dce37952c66afc6 Constant Fourier FM cluster_341670b8260645f5be84c1fd2ff01721 Tower Fourier FM e0182d53bab34fd6bc6ccbb99b3afcd6 0 c1c9ddfe574444efa1272b2211074b95 RX(phi) e0182d53bab34fd6bc6ccbb99b3afcd6--c1c9ddfe574444efa1272b2211074b95 a14f4398d7e84c599732fc254431be68 1 b932ff12a5bb4eb6aea647759da63cc7 RX(1.0*phi) c1c9ddfe574444efa1272b2211074b95--b932ff12a5bb4eb6aea647759da63cc7 d29c1543efe2465eaf5a84ed077eb9b3 RX(1.0*phi) b932ff12a5bb4eb6aea647759da63cc7--d29c1543efe2465eaf5a84ed077eb9b3 162281a7e4d64da4882fc8c071554102 d29c1543efe2465eaf5a84ed077eb9b3--162281a7e4d64da4882fc8c071554102 85fe181cd223410c936f48ae08a8ade9 d94f532c79d744508589391b1b3a160b RX(phi) a14f4398d7e84c599732fc254431be68--d94f532c79d744508589391b1b3a160b 6b0ef50ac2d044cea59c4e1a2691886b 2 00556cb4c47c4e928fd3ded1bea70680 RX(2.0*phi) d94f532c79d744508589391b1b3a160b--00556cb4c47c4e928fd3ded1bea70680 07162e3055f44df99e5cf43c33bd4711 RX(2.0*phi) 00556cb4c47c4e928fd3ded1bea70680--07162e3055f44df99e5cf43c33bd4711 07162e3055f44df99e5cf43c33bd4711--85fe181cd223410c936f48ae08a8ade9 908e7e929e70454d8876eb650d4dfbe1 71862618e3084fb9a70aa5475b385cdf RX(phi) 6b0ef50ac2d044cea59c4e1a2691886b--71862618e3084fb9a70aa5475b385cdf 89c1c76a691344ad80db234055e82591 3 3006f0b96a694c7ba95c47d82a1cb057 RX(3.0*phi) 71862618e3084fb9a70aa5475b385cdf--3006f0b96a694c7ba95c47d82a1cb057 aa9070b67f1c48e3a2d9232aaea5a6a4 RX(4.0*phi) 3006f0b96a694c7ba95c47d82a1cb057--aa9070b67f1c48e3a2d9232aaea5a6a4 aa9070b67f1c48e3a2d9232aaea5a6a4--908e7e929e70454d8876eb650d4dfbe1 708066544b6a48b0a4d7364789cd9207 1116b846b40f4662bfce2dbf6f008576 RX(phi) 89c1c76a691344ad80db234055e82591--1116b846b40f4662bfce2dbf6f008576 3c479d5d3b8b450d8c3ba27bfc4bdc2f 4 67c47f4c8a394cdba1313f981c50c2c6 RX(4.0*phi) 1116b846b40f4662bfce2dbf6f008576--67c47f4c8a394cdba1313f981c50c2c6 3e4d8cc1c3354a78995593ad246918ae RX(8.0*phi) 67c47f4c8a394cdba1313f981c50c2c6--3e4d8cc1c3354a78995593ad246918ae 3e4d8cc1c3354a78995593ad246918ae--708066544b6a48b0a4d7364789cd9207 3697326590804b0c84284a94cf8eb15e e37bf5f535d74edb99291b39eafa8eef RX(phi) 3c479d5d3b8b450d8c3ba27bfc4bdc2f--e37bf5f535d74edb99291b39eafa8eef 6cd7fb284f244394b8ae8c4d3c7bc86f RX(5.0*phi) e37bf5f535d74edb99291b39eafa8eef--6cd7fb284f244394b8ae8c4d3c7bc86f 058b71323fed42f2b78ec49a3bdbcadc RX(16.0*phi) 6cd7fb284f244394b8ae8c4d3c7bc86f--058b71323fed42f2b78ec49a3bdbcadc 058b71323fed42f2b78ec49a3bdbcadc--3697326590804b0c84284a94cf8eb15e <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 be1259e7a6e74333b2e960a191f2e098 0 de161b0cfca14a2c810c2fc4c211e135 RX(1.0*acos(phi)) be1259e7a6e74333b2e960a191f2e098--de161b0cfca14a2c810c2fc4c211e135 0bf79bb9e5114efda67afcffd1865a54 1 fa65808dac3a46a4a8161557729e2838 de161b0cfca14a2c810c2fc4c211e135--fa65808dac3a46a4a8161557729e2838 571b7ca132f14f3fae061fa5f24a30d7 680740a3400d4fa48352284fd99c7271 RX(1.414*acos(phi)) 0bf79bb9e5114efda67afcffd1865a54--680740a3400d4fa48352284fd99c7271 58704383116a4a36a656cccb43fb7ec2 2 680740a3400d4fa48352284fd99c7271--571b7ca132f14f3fae061fa5f24a30d7 677e9ea9e5574b96999e825083a2c431 c15be965343d43f2a2b59dcade325d03 RX(1.732*acos(phi)) 58704383116a4a36a656cccb43fb7ec2--c15be965343d43f2a2b59dcade325d03 7dd40c58bb7e4a8888347b7f9ec41fff 3 c15be965343d43f2a2b59dcade325d03--677e9ea9e5574b96999e825083a2c431 b1202f0ffbbf4b788cb788ff8dc89923 ff8f87b23a174158a652389288ff33c8 RX(2.0*acos(phi)) 7dd40c58bb7e4a8888347b7f9ec41fff--ff8f87b23a174158a652389288ff33c8 680cf8dd500945a8ba865699e7a5f23a 4 ff8f87b23a174158a652389288ff33c8--b1202f0ffbbf4b788cb788ff8dc89923 fc1df1b29f13423681f3d2397e861b83 9b417b2505f84d9ebe52457c2339756f RX(2.236*acos(phi)) 680cf8dd500945a8ba865699e7a5f23a--9b417b2505f84d9ebe52457c2339756f 9b417b2505f84d9ebe52457c2339756f--fc1df1b29f13423681f3d2397e861b83 <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0 # Extra multiplier, which can also be a Parameter\n)\n</code></pre> %3 c970f7bfb64b41f497130cc45a50574b 0 a2666c71b0614bbaa146d659e3dcf441 RY(80.0*acos(0.667*x + 1.667)) c970f7bfb64b41f497130cc45a50574b--a2666c71b0614bbaa146d659e3dcf441 1cc7a85e408a4932b028fc7b79d519cf 1 9f1ab67959eb495aae5e5d1e21d600c3 a2666c71b0614bbaa146d659e3dcf441--9f1ab67959eb495aae5e5d1e21d600c3 05379acf43b74a38aaab9696181b415a 112b5885518a4019a0ab0e713aad583f RY(40.0*acos(0.667*x + 1.667)) 1cc7a85e408a4932b028fc7b79d519cf--112b5885518a4019a0ab0e713aad583f 6cad895f4466456cad33498d34451b4b 2 112b5885518a4019a0ab0e713aad583f--05379acf43b74a38aaab9696181b415a d12dd72752624942bbaac7f32a9ccf42 eaa1391b2b5d4bb78e04f87696525084 RY(20.0*acos(0.667*x + 1.667)) 6cad895f4466456cad33498d34451b4b--eaa1391b2b5d4bb78e04f87696525084 7c3b1c9657bd4e0297f9eeb08ddcafc6 3 eaa1391b2b5d4bb78e04f87696525084--d12dd72752624942bbaac7f32a9ccf42 12420ee9688f4ec684d70e296c4e2c12 65eea6f1dcc8406e8328dc820f618be3 RY(10.0*acos(0.667*x + 1.667)) 7c3b1c9657bd4e0297f9eeb08ddcafc6--65eea6f1dcc8406e8328dc820f618be3 71a7c956d8454b119389d2a4049bf75e 4 65eea6f1dcc8406e8328dc820f618be3--12420ee9688f4ec684d70e296c4e2c12 8af2f973157841aeb2308c168b620226 a1bf251f3d72482c9593b5ee6fd023ec RY(5.0*acos(0.667*x + 1.667)) 71a7c956d8454b119389d2a4049bf75e--a1bf251f3d72482c9593b5ee6fd023ec a1bf251f3d72482c9593b5ee6fd023ec--8af2f973157841aeb2308c168b620226"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 ec072ccb805c412aa06c276362c3e8b5 0 12c1258a662d497081c1fb776701ed52 RX(theta\u2080) ec072ccb805c412aa06c276362c3e8b5--12c1258a662d497081c1fb776701ed52 b1fae1d44a694aa7b6bef651d6656c9d 1 95a6014ab816427e8719e9f3d2d71629 RY(theta\u2083) 12c1258a662d497081c1fb776701ed52--95a6014ab816427e8719e9f3d2d71629 214aafc8dcba45de88b3605069293549 RX(theta\u2086) 95a6014ab816427e8719e9f3d2d71629--214aafc8dcba45de88b3605069293549 7e0fd3fee2684a4e87b44077b0d70ece 214aafc8dcba45de88b3605069293549--7e0fd3fee2684a4e87b44077b0d70ece cc0ed36337c74456a2f81896d8f2a62a 7e0fd3fee2684a4e87b44077b0d70ece--cc0ed36337c74456a2f81896d8f2a62a 5829b609cb004519a14625031696b512 RX(theta\u2089) cc0ed36337c74456a2f81896d8f2a62a--5829b609cb004519a14625031696b512 7445a5dbe08a47c0bc2ae133e8221c76 RY(theta\u2081\u2082) 5829b609cb004519a14625031696b512--7445a5dbe08a47c0bc2ae133e8221c76 0fd93d68ce964e7fabee269c153d1a22 RX(theta\u2081\u2085) 7445a5dbe08a47c0bc2ae133e8221c76--0fd93d68ce964e7fabee269c153d1a22 5bee2f892632459c8b7ae85e9977d345 0fd93d68ce964e7fabee269c153d1a22--5bee2f892632459c8b7ae85e9977d345 9bf95f9825964060b53d10240cc9fa2a 5bee2f892632459c8b7ae85e9977d345--9bf95f9825964060b53d10240cc9fa2a 23966fd53ed44fb887b94dd229d1fde3 9bf95f9825964060b53d10240cc9fa2a--23966fd53ed44fb887b94dd229d1fde3 d260b0e07fb44327a037e14734d921b3 18285a3361de4c59b1d536e353164b8e RX(theta\u2081) b1fae1d44a694aa7b6bef651d6656c9d--18285a3361de4c59b1d536e353164b8e 477318915b8e4ae9990d6be62cc39500 2 acb34a8839a84827865aa43590ae2f72 RY(theta\u2084) 18285a3361de4c59b1d536e353164b8e--acb34a8839a84827865aa43590ae2f72 3d1cb43a76b04ab8bcda04f893351064 RX(theta\u2087) acb34a8839a84827865aa43590ae2f72--3d1cb43a76b04ab8bcda04f893351064 a2b56bfccb2e455897856431666a700a X 3d1cb43a76b04ab8bcda04f893351064--a2b56bfccb2e455897856431666a700a a2b56bfccb2e455897856431666a700a--7e0fd3fee2684a4e87b44077b0d70ece 554e186e9a00476aa9e502fbd12e4d8a a2b56bfccb2e455897856431666a700a--554e186e9a00476aa9e502fbd12e4d8a 58520bff52034950900c3a2a6a9cbbf1 RX(theta\u2081\u2080) 554e186e9a00476aa9e502fbd12e4d8a--58520bff52034950900c3a2a6a9cbbf1 2c9c233a21d84b05ab7b9135e816408f RY(theta\u2081\u2083) 58520bff52034950900c3a2a6a9cbbf1--2c9c233a21d84b05ab7b9135e816408f c9d7446a64194d1db82b865432027a6e RX(theta\u2081\u2086) 2c9c233a21d84b05ab7b9135e816408f--c9d7446a64194d1db82b865432027a6e d3542850f31c4ea580bce08dc02d27d7 X c9d7446a64194d1db82b865432027a6e--d3542850f31c4ea580bce08dc02d27d7 d3542850f31c4ea580bce08dc02d27d7--5bee2f892632459c8b7ae85e9977d345 0ae8fd57508f4160a460c60c24235423 d3542850f31c4ea580bce08dc02d27d7--0ae8fd57508f4160a460c60c24235423 0ae8fd57508f4160a460c60c24235423--d260b0e07fb44327a037e14734d921b3 bc9d4a84ca3f415bb9918dd71aa75aca bda0f549d6294992abf90eeefef9b0c7 RX(theta\u2082) 477318915b8e4ae9990d6be62cc39500--bda0f549d6294992abf90eeefef9b0c7 6022651f6bee4ec08b2a54705a60da1f RY(theta\u2085) bda0f549d6294992abf90eeefef9b0c7--6022651f6bee4ec08b2a54705a60da1f e8f2447533ff4a899b4f906d0ef867cd RX(theta\u2088) 6022651f6bee4ec08b2a54705a60da1f--e8f2447533ff4a899b4f906d0ef867cd cda02c84f63e411c99f7eb6dbbcf2f00 e8f2447533ff4a899b4f906d0ef867cd--cda02c84f63e411c99f7eb6dbbcf2f00 0df6e921e23849879f91f5f238ef4eb1 X cda02c84f63e411c99f7eb6dbbcf2f00--0df6e921e23849879f91f5f238ef4eb1 0df6e921e23849879f91f5f238ef4eb1--554e186e9a00476aa9e502fbd12e4d8a ac8d8448db124b35a9f3f8ac6173c6d1 RX(theta\u2081\u2081) 0df6e921e23849879f91f5f238ef4eb1--ac8d8448db124b35a9f3f8ac6173c6d1 2ab664cabfdc442d87ca7c4423a9ddc3 RY(theta\u2081\u2084) ac8d8448db124b35a9f3f8ac6173c6d1--2ab664cabfdc442d87ca7c4423a9ddc3 ea256605cec3453c9a982306ec545b2f RX(theta\u2081\u2087) 2ab664cabfdc442d87ca7c4423a9ddc3--ea256605cec3453c9a982306ec545b2f 19aa45713c3e4e32b44f89ae47ebc8bb ea256605cec3453c9a982306ec545b2f--19aa45713c3e4e32b44f89ae47ebc8bb 2e760188ca0e413ea30cadb05d5b8e34 X 19aa45713c3e4e32b44f89ae47ebc8bb--2e760188ca0e413ea30cadb05d5b8e34 2e760188ca0e413ea30cadb05d5b8e34--0ae8fd57508f4160a460c60c24235423 2e760188ca0e413ea30cadb05d5b8e34--bc9d4a84ca3f415bb9918dd71aa75aca <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 08b5c609177546a181a5c84346b30472 0 e50a87dbafee44f1be00e569e48d2f59 RX(phi\u2080) 08b5c609177546a181a5c84346b30472--e50a87dbafee44f1be00e569e48d2f59 d40b47f0797a43458dde5a6b5b30c423 1 e789613d4ef744b49b776a4b32123954 RY(phi\u2083) e50a87dbafee44f1be00e569e48d2f59--e789613d4ef744b49b776a4b32123954 d0de133b06da4b0f9143dc5fac5a4820 RX(phi\u2086) e789613d4ef744b49b776a4b32123954--d0de133b06da4b0f9143dc5fac5a4820 1305c3f96164414cb6a36f8a8ea41783 d0de133b06da4b0f9143dc5fac5a4820--1305c3f96164414cb6a36f8a8ea41783 d5839a1ba31942319fce790c2f5929e9 1305c3f96164414cb6a36f8a8ea41783--d5839a1ba31942319fce790c2f5929e9 21c0cd71af4c450c89b192142fc6e888 RX(phi\u2089) d5839a1ba31942319fce790c2f5929e9--21c0cd71af4c450c89b192142fc6e888 62fe2de504bf48b89e5d718c8513a30b RY(phi\u2081\u2082) 21c0cd71af4c450c89b192142fc6e888--62fe2de504bf48b89e5d718c8513a30b f79bd67de97143479949e42af6c3fe8d RX(phi\u2081\u2085) 62fe2de504bf48b89e5d718c8513a30b--f79bd67de97143479949e42af6c3fe8d c5d1c4b5b9fc4aa4bdfa78fe64530c9f f79bd67de97143479949e42af6c3fe8d--c5d1c4b5b9fc4aa4bdfa78fe64530c9f 7997f2d97e0c4e348c9b66e3598fc789 c5d1c4b5b9fc4aa4bdfa78fe64530c9f--7997f2d97e0c4e348c9b66e3598fc789 fa60b696ac424e2ca0cbb35e1cd7dee1 7997f2d97e0c4e348c9b66e3598fc789--fa60b696ac424e2ca0cbb35e1cd7dee1 a220f87e87874ae39c6632db724a8679 0d073df96a804f24a93f53ea05fd13a8 RX(phi\u2081) d40b47f0797a43458dde5a6b5b30c423--0d073df96a804f24a93f53ea05fd13a8 5f0d13e0ca3e4dba8ba705c9e0f77971 2 adf412e62eab4a0285eee00155c58436 RY(phi\u2084) 0d073df96a804f24a93f53ea05fd13a8--adf412e62eab4a0285eee00155c58436 8678f4dcdfa14d3884182de76e5882bd RX(phi\u2087) adf412e62eab4a0285eee00155c58436--8678f4dcdfa14d3884182de76e5882bd d0079a9d5b024609b9e5bc6855381857 PHASE(phi_ent\u2080) 8678f4dcdfa14d3884182de76e5882bd--d0079a9d5b024609b9e5bc6855381857 d0079a9d5b024609b9e5bc6855381857--1305c3f96164414cb6a36f8a8ea41783 0a0bbd20578341c8b824b95f37feb59d d0079a9d5b024609b9e5bc6855381857--0a0bbd20578341c8b824b95f37feb59d 14d5779a601f4ea58cf976348978d5c4 RX(phi\u2081\u2080) 0a0bbd20578341c8b824b95f37feb59d--14d5779a601f4ea58cf976348978d5c4 a5c29162f630454fae6352ce57b2882d RY(phi\u2081\u2083) 14d5779a601f4ea58cf976348978d5c4--a5c29162f630454fae6352ce57b2882d c236add756914444a7f9fea352128a4b RX(phi\u2081\u2086) a5c29162f630454fae6352ce57b2882d--c236add756914444a7f9fea352128a4b f60cc1bd03b04fcf88fd28a7bca35bd7 PHASE(phi_ent\u2082) c236add756914444a7f9fea352128a4b--f60cc1bd03b04fcf88fd28a7bca35bd7 f60cc1bd03b04fcf88fd28a7bca35bd7--c5d1c4b5b9fc4aa4bdfa78fe64530c9f 24ab642634e54d45b108d8ab7618dc45 f60cc1bd03b04fcf88fd28a7bca35bd7--24ab642634e54d45b108d8ab7618dc45 24ab642634e54d45b108d8ab7618dc45--a220f87e87874ae39c6632db724a8679 e396498762554ca980074e153de3c1ab 576e2b7660994182a58092c8b6be21f2 RX(phi\u2082) 5f0d13e0ca3e4dba8ba705c9e0f77971--576e2b7660994182a58092c8b6be21f2 82e0107cd1f74ce59eef80612ffa9e26 RY(phi\u2085) 576e2b7660994182a58092c8b6be21f2--82e0107cd1f74ce59eef80612ffa9e26 89dc992c4a5f44be9031bed30360a45d RX(phi\u2088) 82e0107cd1f74ce59eef80612ffa9e26--89dc992c4a5f44be9031bed30360a45d 8d349443572e4fe5bb2fc246a845c6a2 89dc992c4a5f44be9031bed30360a45d--8d349443572e4fe5bb2fc246a845c6a2 a351c3f11fba447eac699152f711b664 PHASE(phi_ent\u2081) 8d349443572e4fe5bb2fc246a845c6a2--a351c3f11fba447eac699152f711b664 a351c3f11fba447eac699152f711b664--0a0bbd20578341c8b824b95f37feb59d ffdf6bdb884145a595e2cb4f5a14cedf RX(phi\u2081\u2081) a351c3f11fba447eac699152f711b664--ffdf6bdb884145a595e2cb4f5a14cedf 089724321dbe4ae3a7d3ed9f80dd7f3f RY(phi\u2081\u2084) ffdf6bdb884145a595e2cb4f5a14cedf--089724321dbe4ae3a7d3ed9f80dd7f3f 2871b3b9c11e4d25b5401e08bb3dba9c RX(phi\u2081\u2087) 089724321dbe4ae3a7d3ed9f80dd7f3f--2871b3b9c11e4d25b5401e08bb3dba9c 38e8f539cec64681aff8790f896009c8 2871b3b9c11e4d25b5401e08bb3dba9c--38e8f539cec64681aff8790f896009c8 917c1b4361944dd486727dff473c49f9 PHASE(phi_ent\u2083) 38e8f539cec64681aff8790f896009c8--917c1b4361944dd486727dff473c49f9 917c1b4361944dd486727dff473c49f9--24ab642634e54d45b108d8ab7618dc45 917c1b4361944dd486727dff473c49f9--e396498762554ca980074e153de3c1ab <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_bebde9e8ca3a444181a7bcbbc5179632 cluster_0099bdee33484b68826b496b472848eb 39278aa568524a1a9fef924c2146127d 0 00453656671546dbb539ec726f5f2a35 RX(theta\u2080) 39278aa568524a1a9fef924c2146127d--00453656671546dbb539ec726f5f2a35 a679c7baeb5e40dd8948c8a86da5a3c6 1 6317503ca44643609b45273a810d7e02 RY(theta\u2083) 00453656671546dbb539ec726f5f2a35--6317503ca44643609b45273a810d7e02 aac28d90877c4249bff750fcd4450a32 RX(theta\u2086) 6317503ca44643609b45273a810d7e02--aac28d90877c4249bff750fcd4450a32 055a1414b75e4835989650a26ff9af68 HamEvo aac28d90877c4249bff750fcd4450a32--055a1414b75e4835989650a26ff9af68 854507f50fa6425e9016f58cc7523d3d RX(theta\u2089) 055a1414b75e4835989650a26ff9af68--854507f50fa6425e9016f58cc7523d3d c17b8ccdf8dd4f808370f9e8adde65ae RY(theta\u2081\u2082) 854507f50fa6425e9016f58cc7523d3d--c17b8ccdf8dd4f808370f9e8adde65ae 7fba0c6932db4931ae3305fef0922807 RX(theta\u2081\u2085) c17b8ccdf8dd4f808370f9e8adde65ae--7fba0c6932db4931ae3305fef0922807 a60c81e6132e47bf89a8eb914b3643c6 HamEvo 7fba0c6932db4931ae3305fef0922807--a60c81e6132e47bf89a8eb914b3643c6 373e4cbd569e48338c1a52a2d7a93748 a60c81e6132e47bf89a8eb914b3643c6--373e4cbd569e48338c1a52a2d7a93748 d0632c3ac6364a00b6b30547279df6b7 afa3c951ba3941d5a7b541ca60e9a06c RX(theta\u2081) a679c7baeb5e40dd8948c8a86da5a3c6--afa3c951ba3941d5a7b541ca60e9a06c 8cd677dac4004cbc987dd19f3ad41722 2 5f3fcffe32ea4cb2bb7b5873417b6d5b RY(theta\u2084) afa3c951ba3941d5a7b541ca60e9a06c--5f3fcffe32ea4cb2bb7b5873417b6d5b c348e47dc9f940c78f3f9222f1ebb5f8 RX(theta\u2087) 5f3fcffe32ea4cb2bb7b5873417b6d5b--c348e47dc9f940c78f3f9222f1ebb5f8 c19499ec3c1a46aabbe9ff9dd1f549e8 t = theta_t\u2080 c348e47dc9f940c78f3f9222f1ebb5f8--c19499ec3c1a46aabbe9ff9dd1f549e8 a92ab00a7f5146468faa2e4b299603e8 RX(theta\u2081\u2080) c19499ec3c1a46aabbe9ff9dd1f549e8--a92ab00a7f5146468faa2e4b299603e8 6b01be133bf14fe489bd105ba539ff25 RY(theta\u2081\u2083) a92ab00a7f5146468faa2e4b299603e8--6b01be133bf14fe489bd105ba539ff25 7fb8fb8412c44562b1831ec233e1cc33 RX(theta\u2081\u2086) 6b01be133bf14fe489bd105ba539ff25--7fb8fb8412c44562b1831ec233e1cc33 80ed51b773454c7abfba3298b5e9a64f t = theta_t\u2081 7fb8fb8412c44562b1831ec233e1cc33--80ed51b773454c7abfba3298b5e9a64f 80ed51b773454c7abfba3298b5e9a64f--d0632c3ac6364a00b6b30547279df6b7 1680e2149bac4c68b38803377e1a9c07 923db6a0ca5f4266ac7b04822101bc87 RX(theta\u2082) 8cd677dac4004cbc987dd19f3ad41722--923db6a0ca5f4266ac7b04822101bc87 f8a94ac7d99d4508abc3bd5d5f65318e RY(theta\u2085) 923db6a0ca5f4266ac7b04822101bc87--f8a94ac7d99d4508abc3bd5d5f65318e cfd07deb5c52457b94c9aaf4b59bbf64 RX(theta\u2088) f8a94ac7d99d4508abc3bd5d5f65318e--cfd07deb5c52457b94c9aaf4b59bbf64 cb1d5dc2bbf0421389ed8aa68ae8357c cfd07deb5c52457b94c9aaf4b59bbf64--cb1d5dc2bbf0421389ed8aa68ae8357c 92fd5d2f1a3440e69d91b1c057b0cb8b RX(theta\u2081\u2081) cb1d5dc2bbf0421389ed8aa68ae8357c--92fd5d2f1a3440e69d91b1c057b0cb8b 48b61b5597804692bbc2465c101e9899 RY(theta\u2081\u2084) 92fd5d2f1a3440e69d91b1c057b0cb8b--48b61b5597804692bbc2465c101e9899 1b3320199d7741569e06b881544c7cd7 RX(theta\u2081\u2087) 48b61b5597804692bbc2465c101e9899--1b3320199d7741569e06b881544c7cd7 7e0ea96dbd294876a2d43110a03dc4b9 1b3320199d7741569e06b881544c7cd7--7e0ea96dbd294876a2d43110a03dc4b9 7e0ea96dbd294876a2d43110a03dc4b9--1680e2149bac4c68b38803377e1a9c07 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_477d7d15a2de4376919de5145f909322 cluster_dbd7453a22b8437796ef1120152b0040 1786c46a77bf41579ce5771654441dda 0 dd03e45ba56d40e9be0b7ece7f54548a RX(theta\u2080) 1786c46a77bf41579ce5771654441dda--dd03e45ba56d40e9be0b7ece7f54548a b3b94e5be9854528a49ae50377869fab 1 dfbfaaf3a8994cf28005fe4bc91e8bc4 RY(theta\u2086) dd03e45ba56d40e9be0b7ece7f54548a--dfbfaaf3a8994cf28005fe4bc91e8bc4 283544c33c8e4aaa945f104c3be6117d RX(theta\u2081\u2082) dfbfaaf3a8994cf28005fe4bc91e8bc4--283544c33c8e4aaa945f104c3be6117d 8923fae16ff6402e81fc40d394091b2e 283544c33c8e4aaa945f104c3be6117d--8923fae16ff6402e81fc40d394091b2e 46cbbedf690f4856a8750f3ccbde14ac RX(theta\u2081\u2088) 8923fae16ff6402e81fc40d394091b2e--46cbbedf690f4856a8750f3ccbde14ac b56a039f385d40b39b856fb47061f17c RY(theta\u2082\u2084) 46cbbedf690f4856a8750f3ccbde14ac--b56a039f385d40b39b856fb47061f17c 5ae55b165bf244d1907edcb141723fd4 RX(theta\u2083\u2080) b56a039f385d40b39b856fb47061f17c--5ae55b165bf244d1907edcb141723fd4 6a75ffa7d1c446819dd3f6e91b922f3b 5ae55b165bf244d1907edcb141723fd4--6a75ffa7d1c446819dd3f6e91b922f3b d4d7f3aea6a9455ab2cb3c25dc17c014 6a75ffa7d1c446819dd3f6e91b922f3b--d4d7f3aea6a9455ab2cb3c25dc17c014 4fa85b3cd8684f5a9d00f066fc95ca80 99d50297b06b40d98157b8d33b91e683 RX(theta\u2081) b3b94e5be9854528a49ae50377869fab--99d50297b06b40d98157b8d33b91e683 215fe06c8753446a9beb0477997f3832 2 27b018cff46948179a7998c278c54d5e RY(theta\u2087) 99d50297b06b40d98157b8d33b91e683--27b018cff46948179a7998c278c54d5e 4c72769199e04a1ea5cdbfac0b1d0ad1 RX(theta\u2081\u2083) 27b018cff46948179a7998c278c54d5e--4c72769199e04a1ea5cdbfac0b1d0ad1 a022959e4e39488ea5f686ac1e64d1eb 4c72769199e04a1ea5cdbfac0b1d0ad1--a022959e4e39488ea5f686ac1e64d1eb 2876a2d00b54428f9e705a8861cddd9d RX(theta\u2081\u2089) a022959e4e39488ea5f686ac1e64d1eb--2876a2d00b54428f9e705a8861cddd9d 10dce09f3b8541d3ac330111b3ab6089 RY(theta\u2082\u2085) 2876a2d00b54428f9e705a8861cddd9d--10dce09f3b8541d3ac330111b3ab6089 41e6144a47344d03aa29ab59202e0e16 RX(theta\u2083\u2081) 10dce09f3b8541d3ac330111b3ab6089--41e6144a47344d03aa29ab59202e0e16 0843047bd3144bd3b473832ffcea3c49 41e6144a47344d03aa29ab59202e0e16--0843047bd3144bd3b473832ffcea3c49 0843047bd3144bd3b473832ffcea3c49--4fa85b3cd8684f5a9d00f066fc95ca80 09be13b7b8064dde83c865a92cd600b3 e904a79e9be84bf3beae16bf01ad58c9 RX(theta\u2082) 215fe06c8753446a9beb0477997f3832--e904a79e9be84bf3beae16bf01ad58c9 c18ae2cbd7c54caaa81d99039112345f 3 acdb05b33e4748d99599faee1ed32712 RY(theta\u2088) e904a79e9be84bf3beae16bf01ad58c9--acdb05b33e4748d99599faee1ed32712 c0927dc51e2d47a88692f22d9c867454 RX(theta\u2081\u2084) acdb05b33e4748d99599faee1ed32712--c0927dc51e2d47a88692f22d9c867454 3dbc06952a48403c9db67894728443f0 HamEvo c0927dc51e2d47a88692f22d9c867454--3dbc06952a48403c9db67894728443f0 85ceafce47c1429188e898ab159fd505 RX(theta\u2082\u2080) 3dbc06952a48403c9db67894728443f0--85ceafce47c1429188e898ab159fd505 dd02cff082914d7bb58bb55fbb1b1206 RY(theta\u2082\u2086) 85ceafce47c1429188e898ab159fd505--dd02cff082914d7bb58bb55fbb1b1206 2e4d1bfd3d994fe6b83d2f8be317f874 RX(theta\u2083\u2082) dd02cff082914d7bb58bb55fbb1b1206--2e4d1bfd3d994fe6b83d2f8be317f874 51c9ae0352c247fbb8ffd2311785b29e HamEvo 2e4d1bfd3d994fe6b83d2f8be317f874--51c9ae0352c247fbb8ffd2311785b29e 51c9ae0352c247fbb8ffd2311785b29e--09be13b7b8064dde83c865a92cd600b3 101f0ab9611647a1b71c6405a2cabfd8 91bf72a8a94a45c7bd1cb094b1c52ae6 RX(theta\u2083) c18ae2cbd7c54caaa81d99039112345f--91bf72a8a94a45c7bd1cb094b1c52ae6 be369985b0b54624be1a1bd3b42c93cb 4 f01faef473ec45b389d951186a22c3b1 RY(theta\u2089) 91bf72a8a94a45c7bd1cb094b1c52ae6--f01faef473ec45b389d951186a22c3b1 e06c883746394f74827d7518bd9acb09 RX(theta\u2081\u2085) f01faef473ec45b389d951186a22c3b1--e06c883746394f74827d7518bd9acb09 f47929e7b74341499f9f6917cc150e84 t = theta_t\u2080 e06c883746394f74827d7518bd9acb09--f47929e7b74341499f9f6917cc150e84 3124968ddd45461f96dc8e297bc4d740 RX(theta\u2082\u2081) f47929e7b74341499f9f6917cc150e84--3124968ddd45461f96dc8e297bc4d740 a8095bfca6dd46369e2465a57e99f186 RY(theta\u2082\u2087) 3124968ddd45461f96dc8e297bc4d740--a8095bfca6dd46369e2465a57e99f186 68f7b1f8679b430e8eca40ae54dda055 RX(theta\u2083\u2083) a8095bfca6dd46369e2465a57e99f186--68f7b1f8679b430e8eca40ae54dda055 daad61ad13704dbfac085d313017957b t = theta_t\u2081 68f7b1f8679b430e8eca40ae54dda055--daad61ad13704dbfac085d313017957b daad61ad13704dbfac085d313017957b--101f0ab9611647a1b71c6405a2cabfd8 979a9181ab5545cb94b1bd434dfd3ebc a8b221f3b9224b0f8f7dab30382b2028 RX(theta\u2084) be369985b0b54624be1a1bd3b42c93cb--a8b221f3b9224b0f8f7dab30382b2028 f0369c33a03e4342a76dae3d2a43c0ce 5 2172c550fe7049358d91c23eebc8852c RY(theta\u2081\u2080) a8b221f3b9224b0f8f7dab30382b2028--2172c550fe7049358d91c23eebc8852c 71205036301145e2b6913607bbfe1a2b RX(theta\u2081\u2086) 2172c550fe7049358d91c23eebc8852c--71205036301145e2b6913607bbfe1a2b 389e1ac04c024f3cbcae5726f235613a 71205036301145e2b6913607bbfe1a2b--389e1ac04c024f3cbcae5726f235613a f135196ce8204349a3391d4b2c8f2113 RX(theta\u2082\u2082) 389e1ac04c024f3cbcae5726f235613a--f135196ce8204349a3391d4b2c8f2113 ab17d11dfc504e45ba305fddf5735399 RY(theta\u2082\u2088) f135196ce8204349a3391d4b2c8f2113--ab17d11dfc504e45ba305fddf5735399 53d64708194146d8a82c7d65910b5624 RX(theta\u2083\u2084) ab17d11dfc504e45ba305fddf5735399--53d64708194146d8a82c7d65910b5624 9a2c16a371254056a79a1a900720c95e 53d64708194146d8a82c7d65910b5624--9a2c16a371254056a79a1a900720c95e 9a2c16a371254056a79a1a900720c95e--979a9181ab5545cb94b1bd434dfd3ebc 5b05de597e964438a02d5eafdfc5e2b7 ea501439382046e68c7c7f525c4d6248 RX(theta\u2085) f0369c33a03e4342a76dae3d2a43c0ce--ea501439382046e68c7c7f525c4d6248 c4e5c245f189439f921da4fb11b2ca37 RY(theta\u2081\u2081) ea501439382046e68c7c7f525c4d6248--c4e5c245f189439f921da4fb11b2ca37 506e5af1f9b44423844acccb92957f23 RX(theta\u2081\u2087) c4e5c245f189439f921da4fb11b2ca37--506e5af1f9b44423844acccb92957f23 e91fcda5ae794541980116967f39b5a8 506e5af1f9b44423844acccb92957f23--e91fcda5ae794541980116967f39b5a8 773894ff24c84a479097778017fab57b RX(theta\u2082\u2083) e91fcda5ae794541980116967f39b5a8--773894ff24c84a479097778017fab57b a4ccc9ae47d44026be344288a7353916 RY(theta\u2082\u2089) 773894ff24c84a479097778017fab57b--a4ccc9ae47d44026be344288a7353916 8ad59a6a148740ccb8e05b8068c4207c RX(theta\u2083\u2085) a4ccc9ae47d44026be344288a7353916--8ad59a6a148740ccb8e05b8068c4207c 568823137b27465c8dc9413002c8563b 8ad59a6a148740ccb8e05b8068c4207c--568823137b27465c8dc9413002c8563b 568823137b27465c8dc9413002c8563b--5b05de597e964438a02d5eafdfc5e2b7"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_8bf870e58fc34075be9f9fa170d253ed BPMA-1 cluster_af6e482fc88543889310825eb7337ea7 BPMA-0 c7aeda706d6a4646875eac93f2ff6504 0 2957fcd101964768af92518283306d22 RX(alpha\u2080\u2080) c7aeda706d6a4646875eac93f2ff6504--2957fcd101964768af92518283306d22 8c6bff22adb24894be1a52b665510bdc 1 76c33994b4004c6a93329681ae4cd4f9 RY(alpha\u2080\u2083) 2957fcd101964768af92518283306d22--76c33994b4004c6a93329681ae4cd4f9 a2257006462247bf9f481b1c4fdb997f 76c33994b4004c6a93329681ae4cd4f9--a2257006462247bf9f481b1c4fdb997f 38ce5c039c2845988429780443644860 a2257006462247bf9f481b1c4fdb997f--38ce5c039c2845988429780443644860 38e1e13a8fd4437ebe1bb6b05c7197cd RX(gamma\u2080\u2080) 38ce5c039c2845988429780443644860--38e1e13a8fd4437ebe1bb6b05c7197cd 14779a23b852420ab1f8818672ed6213 38e1e13a8fd4437ebe1bb6b05c7197cd--14779a23b852420ab1f8818672ed6213 fc56824c02be4a03b23df067b8011719 14779a23b852420ab1f8818672ed6213--fc56824c02be4a03b23df067b8011719 170a8d47f2ec44b793be7b3f9d523b18 RY(beta\u2080\u2083) fc56824c02be4a03b23df067b8011719--170a8d47f2ec44b793be7b3f9d523b18 c606bb24573a481e920d594f8e3375ef RX(beta\u2080\u2080) 170a8d47f2ec44b793be7b3f9d523b18--c606bb24573a481e920d594f8e3375ef 758ada43347e4a66b279957a5b6a847f RX(alpha\u2081\u2080) c606bb24573a481e920d594f8e3375ef--758ada43347e4a66b279957a5b6a847f 29145c6635c04209a1270cea6788bd59 RY(alpha\u2081\u2083) 758ada43347e4a66b279957a5b6a847f--29145c6635c04209a1270cea6788bd59 0a17e58833044221902e210f52dd5e90 29145c6635c04209a1270cea6788bd59--0a17e58833044221902e210f52dd5e90 9e91728cddac4084aeacdb27d3cdac73 0a17e58833044221902e210f52dd5e90--9e91728cddac4084aeacdb27d3cdac73 178c4b8ee1f1437685ceeafbff1cd667 RX(gamma\u2081\u2080) 9e91728cddac4084aeacdb27d3cdac73--178c4b8ee1f1437685ceeafbff1cd667 c376834d34b743079d6fe32da55c999a 178c4b8ee1f1437685ceeafbff1cd667--c376834d34b743079d6fe32da55c999a 288a3976ed7442668efeadee590e0418 c376834d34b743079d6fe32da55c999a--288a3976ed7442668efeadee590e0418 d09d0f72be9e48beac5c3c9f72caf9f8 RY(beta\u2081\u2083) 288a3976ed7442668efeadee590e0418--d09d0f72be9e48beac5c3c9f72caf9f8 7988fb0f69a54ed2b81f26f66fb2eb41 RX(beta\u2081\u2080) d09d0f72be9e48beac5c3c9f72caf9f8--7988fb0f69a54ed2b81f26f66fb2eb41 ef206564722a4182ad17ac3b35fca201 7988fb0f69a54ed2b81f26f66fb2eb41--ef206564722a4182ad17ac3b35fca201 e47d1681c2f74a50aacff070a3e0d34c 6cbd5a17218c45f1969322592193b20c RX(alpha\u2080\u2081) 8c6bff22adb24894be1a52b665510bdc--6cbd5a17218c45f1969322592193b20c b622ab1f46e34dd28d4cf695d3189de5 2 4e91bf645860414193bd3c7df33f8b36 RY(alpha\u2080\u2084) 6cbd5a17218c45f1969322592193b20c--4e91bf645860414193bd3c7df33f8b36 474cf1b0aa9748818b0f0c88f9567480 X 4e91bf645860414193bd3c7df33f8b36--474cf1b0aa9748818b0f0c88f9567480 474cf1b0aa9748818b0f0c88f9567480--a2257006462247bf9f481b1c4fdb997f 287e5828f0f04569946ed3300d51c428 474cf1b0aa9748818b0f0c88f9567480--287e5828f0f04569946ed3300d51c428 1a087640dcc74eec94ba8cc3ea762f93 RX(gamma\u2080\u2081) 287e5828f0f04569946ed3300d51c428--1a087640dcc74eec94ba8cc3ea762f93 0ae9bf67c9b2422f9ffe3e1fa65e7cbc 1a087640dcc74eec94ba8cc3ea762f93--0ae9bf67c9b2422f9ffe3e1fa65e7cbc f44347ca5cfa428fa014f94eaa970ac2 X 0ae9bf67c9b2422f9ffe3e1fa65e7cbc--f44347ca5cfa428fa014f94eaa970ac2 f44347ca5cfa428fa014f94eaa970ac2--fc56824c02be4a03b23df067b8011719 27b958b5331146ab9863c2335ae185f8 RY(beta\u2080\u2084) f44347ca5cfa428fa014f94eaa970ac2--27b958b5331146ab9863c2335ae185f8 f64def36091e44b495e4c0fead4b1b20 RX(beta\u2080\u2081) 27b958b5331146ab9863c2335ae185f8--f64def36091e44b495e4c0fead4b1b20 ec465d8878e049e2ba291edcdafc6902 RX(alpha\u2081\u2081) f64def36091e44b495e4c0fead4b1b20--ec465d8878e049e2ba291edcdafc6902 91901be5f06446f78451440825229e1c RY(alpha\u2081\u2084) ec465d8878e049e2ba291edcdafc6902--91901be5f06446f78451440825229e1c f8188208000249fbbdc466ebeaa07f06 X 91901be5f06446f78451440825229e1c--f8188208000249fbbdc466ebeaa07f06 f8188208000249fbbdc466ebeaa07f06--0a17e58833044221902e210f52dd5e90 5f84ab5727ca4433856573e526d07212 f8188208000249fbbdc466ebeaa07f06--5f84ab5727ca4433856573e526d07212 e5f252126dd24bda8e6f63ae6a59ea79 RX(gamma\u2081\u2081) 5f84ab5727ca4433856573e526d07212--e5f252126dd24bda8e6f63ae6a59ea79 12e4f23ac8d241bc98462374f2487c23 e5f252126dd24bda8e6f63ae6a59ea79--12e4f23ac8d241bc98462374f2487c23 9d996d4d94c146b3b1f497b9bf298e4c X 12e4f23ac8d241bc98462374f2487c23--9d996d4d94c146b3b1f497b9bf298e4c 9d996d4d94c146b3b1f497b9bf298e4c--288a3976ed7442668efeadee590e0418 4e36f52fdd5e4ab788522a13d6be47cc RY(beta\u2081\u2084) 9d996d4d94c146b3b1f497b9bf298e4c--4e36f52fdd5e4ab788522a13d6be47cc eadef049ad6042bebe40755bcb32e5d8 RX(beta\u2081\u2081) 4e36f52fdd5e4ab788522a13d6be47cc--eadef049ad6042bebe40755bcb32e5d8 eadef049ad6042bebe40755bcb32e5d8--e47d1681c2f74a50aacff070a3e0d34c 7c7c7a0edcbe418aa686283e7ec4ec86 7a2853970f894445abc4326891f1231f RX(alpha\u2080\u2082) b622ab1f46e34dd28d4cf695d3189de5--7a2853970f894445abc4326891f1231f 27e8c7eaf1b74fba9f34262a03147baa RY(alpha\u2080\u2085) 7a2853970f894445abc4326891f1231f--27e8c7eaf1b74fba9f34262a03147baa 492453db82ad4d3988de43d0f0557f50 27e8c7eaf1b74fba9f34262a03147baa--492453db82ad4d3988de43d0f0557f50 61ce7fd6345c4874a204a1ab4c29b45e X 492453db82ad4d3988de43d0f0557f50--61ce7fd6345c4874a204a1ab4c29b45e 61ce7fd6345c4874a204a1ab4c29b45e--287e5828f0f04569946ed3300d51c428 4e763424ca0c4dfb96cbed152b5f1b59 RX(gamma\u2080\u2082) 61ce7fd6345c4874a204a1ab4c29b45e--4e763424ca0c4dfb96cbed152b5f1b59 8e2e2be61b0a4365b40a44c40e4126ac X 4e763424ca0c4dfb96cbed152b5f1b59--8e2e2be61b0a4365b40a44c40e4126ac 8e2e2be61b0a4365b40a44c40e4126ac--0ae9bf67c9b2422f9ffe3e1fa65e7cbc 0da419ef7dd54fc1bf60856a27d15774 8e2e2be61b0a4365b40a44c40e4126ac--0da419ef7dd54fc1bf60856a27d15774 d545abb8597245698517a369242300de RY(beta\u2080\u2085) 0da419ef7dd54fc1bf60856a27d15774--d545abb8597245698517a369242300de 0efd1a9cd8664c8f9a3a8ae0d6dae1a3 RX(beta\u2080\u2082) d545abb8597245698517a369242300de--0efd1a9cd8664c8f9a3a8ae0d6dae1a3 6b48f359c24b468dbebe2bf9acc2ab8c RX(alpha\u2081\u2082) 0efd1a9cd8664c8f9a3a8ae0d6dae1a3--6b48f359c24b468dbebe2bf9acc2ab8c d7a8b92ca2d24923a7adb68dce560f0e RY(alpha\u2081\u2085) 6b48f359c24b468dbebe2bf9acc2ab8c--d7a8b92ca2d24923a7adb68dce560f0e 6e1ed847b8b84a2e82822e2d0f6f30b7 d7a8b92ca2d24923a7adb68dce560f0e--6e1ed847b8b84a2e82822e2d0f6f30b7 7780a505c5d248a6b3c78f7c108ae33f X 6e1ed847b8b84a2e82822e2d0f6f30b7--7780a505c5d248a6b3c78f7c108ae33f 7780a505c5d248a6b3c78f7c108ae33f--5f84ab5727ca4433856573e526d07212 04d6ff950b89476cb9ff9bed48823393 RX(gamma\u2081\u2082) 7780a505c5d248a6b3c78f7c108ae33f--04d6ff950b89476cb9ff9bed48823393 ed8097207b494989b38b0842ada81833 X 04d6ff950b89476cb9ff9bed48823393--ed8097207b494989b38b0842ada81833 ed8097207b494989b38b0842ada81833--12e4f23ac8d241bc98462374f2487c23 526d9ae809a742b2b438c913bc0d825f ed8097207b494989b38b0842ada81833--526d9ae809a742b2b438c913bc0d825f 07007d47e6194b3e8fa0d1bb0191d856 RY(beta\u2081\u2085) 526d9ae809a742b2b438c913bc0d825f--07007d47e6194b3e8fa0d1bb0191d856 7eb38c38865a43f3b44afdc6220ac6ea RX(beta\u2081\u2082) 07007d47e6194b3e8fa0d1bb0191d856--7eb38c38865a43f3b44afdc6220ac6ea 7eb38c38865a43f3b44afdc6220ac6ea--7c7c7a0edcbe418aa686283e7ec4ec86"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>This section introduces the various measurement protocols.</p>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>This section introduces mitigation protocols.</p>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'00': 50, '10': 50})]\nnoisy = [Counter({'00': 46, '10': 42, '01': 6, '11': 6})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[1.0026]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9704]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': ba7fd809-43b8-44e6-9321-b66d56a3ce19, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 4b968c47-c2d3-4455-b4c6-729d40651292, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 75f5d682-015a-4077-975d-a3cab06b1a33, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 61707e9b-ba42-40e5-a5da-d12d02c4fb26, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 34b385e6-d416-4e97-ba4c-6477173bb906, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': f121a854-3e51-48c8-8092-767af1fb50a2, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 5be64f94-b762-4b7d-a108-b7aac30c8a8d, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 4b1dab06-98cd-4409-b7cb-6fc2d1234a59, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 56cc2b9a-09b2-497a-b028-806078dea317, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 71d50a3c-7158-46f1-a057-5e2610e68d0c, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 7540bb40-cb34-4191-94e2-d7d5f71b29ca, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_2: tensor([0.8550], requires_grad=True)\n  theta_3: tensor([0.9275], requires_grad=True)\n  theta_0: tensor([0.1505], requires_grad=True)\n  theta_8: tensor([0.8725], requires_grad=True)\n  theta_6: tensor([0.7025], requires_grad=True)\n  theta_1: tensor([0.0848], requires_grad=True)\n  theta_5: tensor([0.1050], requires_grad=True)\n  theta_4: tensor([0.7986], requires_grad=True)\n  theta_7: tensor([0.9841], requires_grad=True)\n}\nembedded = {\n  ba7fd809-43b8-44e6-9321-b66d56a3ce19: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  4b968c47-c2d3-4455-b4c6-729d40651292: tensor([2., 2.])\n  75f5d682-015a-4077-975d-a3cab06b1a33: tensor([0.1505], grad_fn=&lt;ViewBackward0&gt;)\n  61707e9b-ba42-40e5-a5da-d12d02c4fb26: tensor([0.0848], grad_fn=&lt;ViewBackward0&gt;)\n  34b385e6-d416-4e97-ba4c-6477173bb906: tensor([0.8550], grad_fn=&lt;ViewBackward0&gt;)\n  f121a854-3e51-48c8-8092-767af1fb50a2: tensor([0.9275], grad_fn=&lt;ViewBackward0&gt;)\n  5be64f94-b762-4b7d-a108-b7aac30c8a8d: tensor([0.7986], grad_fn=&lt;ViewBackward0&gt;)\n  4b1dab06-98cd-4409-b7cb-6fc2d1234a59: tensor([0.1050], grad_fn=&lt;ViewBackward0&gt;)\n  56cc2b9a-09b2-497a-b028-806078dea317: tensor([0.7025], grad_fn=&lt;ViewBackward0&gt;)\n  71d50a3c-7158-46f1-a057-5e2610e68d0c: tensor([0.9841], grad_fn=&lt;ViewBackward0&gt;)\n  7540bb40-cb34-4191-94e2-d7d5f71b29ca: tensor([0.8725], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  theta_2: tensor([0.8550], grad_fn=&lt;ViewBackward0&gt;)\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  theta_3: tensor([0.9275], grad_fn=&lt;ViewBackward0&gt;)\n  theta_0: tensor([0.1505], grad_fn=&lt;ViewBackward0&gt;)\n  theta_8: tensor([0.8725], grad_fn=&lt;ViewBackward0&gt;)\n  y: tensor([2., 2.])\n  theta_6: tensor([0.7025], grad_fn=&lt;ViewBackward0&gt;)\n  theta_1: tensor([0.0848], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.1050], grad_fn=&lt;ViewBackward0&gt;)\n  theta_4: tensor([0.7986], grad_fn=&lt;ViewBackward0&gt;)\n  theta_7: tensor([0.9841], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.1347-0.2025j, -0.2260-0.1742j,  0.3257+0.0072j,  0.0132+0.2774j,\n         -0.2720-0.3532j, -0.4356+0.2895j,  0.3382+0.0606j, -0.0314+0.2912j],\n        [ 0.1347-0.2025j, -0.2260-0.1742j,  0.3257+0.0072j,  0.0132+0.2774j,\n         -0.2720-0.3532j, -0.4356+0.2895j,  0.3382+0.0606j, -0.0314+0.2912j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'001': 194, '000': 157, '110': 121, '010': 121, '101': 113, '011': 102, '100': 100, '111': 92})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(ba7fd809-43b8-44e6-9321-b66d56a3ce19)-C----------------------------------------Rx(75f5d682-015a-4077-975d-a3cab06b1a33)-Ry(f121a854-3e51-48c8-8092-767af1fb50a2)-Rx(56cc2b9a-09b2-497a-b028-806078dea317)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(4b968c47-c2d3-4455-b4c6-729d40651292)-X----------------------------------------Rx(61707e9b-ba42-40e5-a5da-d12d02c4fb26)-Ry(5be64f94-b762-4b7d-a108-b7aac30c8a8d)-Rx(71d50a3c-7158-46f1-a057-5e2610e68d0c)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(34b385e6-d416-4e97-ba4c-6477173bb906)-Ry(4b1dab06-98cd-4409-b7cb-6fc2d1234a59)-Rx(7540bb40-cb34-4191-94e2-d7d5f71b29ca)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [34b385e6-d416-4e97-ba4c-6477173bb906, 4b1dab06-98cd-4409-b7cb-6fc2d1234a59, 4b968c47-c2d3-4455-b4c6-729d40651292, 56cc2b9a-09b2-497a-b028-806078dea317, 5be64f94-b762-4b7d-a108-b7aac30c8a8d, 61707e9b-ba42-40e5-a5da-d12d02c4fb26, 71d50a3c-7158-46f1-a057-5e2610e68d0c, 7540bb40-cb34-4191-94e2-d7d5f71b29ca, 75f5d682-015a-4077-975d-a3cab06b1a33, ba7fd809-43b8-44e6-9321-b66d56a3ce19, f121a854-3e51-48c8-8092-767af1fb50a2].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(0.55)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.15)-DEPO(0.1)-Ry(0.93)-DEPO(0.1)-Rx(0.70)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.03)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.08)-DEPO(0.1)-Ry(0.80)-DEPO(0.1)-Rx(0.98)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.85)-DEPO(0.1)-Ry(0.10)-DEPO(0.1)-Rx(0.87)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 01be931260634f0fb244d058701a7ddf 0 d9dbf8ea134c461dbb7554876268f540 X 01be931260634f0fb244d058701a7ddf--d9dbf8ea134c461dbb7554876268f540 df8776bde9c041d684a9859beeabfd87 1 18b53b35f6c049ff9dc71f616d70a116 d9dbf8ea134c461dbb7554876268f540--18b53b35f6c049ff9dc71f616d70a116 c37d14b96864460d8e7bc76d3ed8af50 6e9016b8085d4f9b9f0802e29e8b33ce Y df8776bde9c041d684a9859beeabfd87--6e9016b8085d4f9b9f0802e29e8b33ce 6e9016b8085d4f9b9f0802e29e8b33ce--c37d14b96864460d8e7bc76d3ed8af50 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 9122aa2bd7b44e91a8a394e2f6ad7c33 0 75e44d38da7a4f8e946bd948bcb0e319 RX(0.5) 9122aa2bd7b44e91a8a394e2f6ad7c33--75e44d38da7a4f8e946bd948bcb0e319 f3c32eb342224e5e83ae2f2e68b713ca 75e44d38da7a4f8e946bd948bcb0e319--f3c32eb342224e5e83ae2f2e68b713ca <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 cc6e442889c04f348fa2f56a0c9623bb 0 1d19e97845d24d20ad3ba742e35b4a18 cc6e442889c04f348fa2f56a0c9623bb--1d19e97845d24d20ad3ba742e35b4a18 12d4e4f4f36f455b9c2433a082838776 1 041cfa71c2094b2c9d8a1675f37254d5 1d19e97845d24d20ad3ba742e35b4a18--041cfa71c2094b2c9d8a1675f37254d5 0b8d696559c6477b99432e2809e9705a f92ed35be2604479a2dbb1acc8f1b110 X 12d4e4f4f36f455b9c2433a082838776--f92ed35be2604479a2dbb1acc8f1b110 f92ed35be2604479a2dbb1acc8f1b110--1d19e97845d24d20ad3ba742e35b4a18 f92ed35be2604479a2dbb1acc8f1b110--0b8d696559c6477b99432e2809e9705a <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 48ce18a2158f47d190968ad0aebc5bb0 0 94ffd6741acb4febbbb50ab4fdc2b5ca X 48ce18a2158f47d190968ad0aebc5bb0--94ffd6741acb4febbbb50ab4fdc2b5ca de50931162c04431aebe2b5fcdbed80e X 94ffd6741acb4febbbb50ab4fdc2b5ca--de50931162c04431aebe2b5fcdbed80e 600d3f5c0b94430789c0fdcacac00c63 de50931162c04431aebe2b5fcdbed80e--600d3f5c0b94430789c0fdcacac00c63 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 2a25359034a64b8f82d38a25d93671af 0 b0fd816b88474f218b0887fed0a15321 X 2a25359034a64b8f82d38a25d93671af--b0fd816b88474f218b0887fed0a15321 d7c72a203c9246c583467a1c5f52c1e5 1 7cff2d734938452bbdae6de3cd5fa811 b0fd816b88474f218b0887fed0a15321--7cff2d734938452bbdae6de3cd5fa811 902b1d2cef6c418db05a67d57a6648f1 7cff2d734938452bbdae6de3cd5fa811--902b1d2cef6c418db05a67d57a6648f1 5b723f8fddb9469db441e3fd8c435935 11b276ab8d5246c49fc54a066e1042c9 d7c72a203c9246c583467a1c5f52c1e5--11b276ab8d5246c49fc54a066e1042c9 de8a30c023144ed5af50b15509e8659a X 11b276ab8d5246c49fc54a066e1042c9--de8a30c023144ed5af50b15509e8659a de8a30c023144ed5af50b15509e8659a--5b723f8fddb9469db441e3fd8c435935 </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 1aa0b04ebf154c2caa9774f953c7b53e 0 13ed3f85080442839e1c0ba878c3ace3 X 1aa0b04ebf154c2caa9774f953c7b53e--13ed3f85080442839e1c0ba878c3ace3 9f09bce1afa94576898fae994c16b6e8 1 99e71385e7cf4416b46fbd43678ae5d6 13ed3f85080442839e1c0ba878c3ace3--99e71385e7cf4416b46fbd43678ae5d6 9c4494579b754ad5aa411e168a6a8afb 965e8fd6395d47a1bb1eb2b0f34aa1bc X 9f09bce1afa94576898fae994c16b6e8--965e8fd6395d47a1bb1eb2b0f34aa1bc 965e8fd6395d47a1bb1eb2b0f34aa1bc--9c4494579b754ad5aa411e168a6a8afb <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_0bd8791b17594e86b618550f2358ad12 subblock cluster_60bfcd6f4c874ac19834b42c6e1356f8 subblock e34b6f4da4fb437c8fb76403cd11dc80 0 75de5610306349cab70af2e0fc8762de X e34b6f4da4fb437c8fb76403cd11dc80--75de5610306349cab70af2e0fc8762de 5dcdff1ae1604c319abfd090630a3448 1 e1c7b73ab48a4c9c86b68cc3ddbe341a X 75de5610306349cab70af2e0fc8762de--e1c7b73ab48a4c9c86b68cc3ddbe341a dd6bddb9d5fa4bf08f1dd08317fbe135 e1c7b73ab48a4c9c86b68cc3ddbe341a--dd6bddb9d5fa4bf08f1dd08317fbe135 fe183bab34b547c1a66bc53d490ebfa4 2ae0d8edf7e94bffab4815ea59c2335a Y 5dcdff1ae1604c319abfd090630a3448--2ae0d8edf7e94bffab4815ea59c2335a 35cc78e67a444e71a4e1475776dde79f 2 08da807797964e118e7dc77c68f078c4 Y 2ae0d8edf7e94bffab4815ea59c2335a--08da807797964e118e7dc77c68f078c4 08da807797964e118e7dc77c68f078c4--fe183bab34b547c1a66bc53d490ebfa4 705dd8643c4a4a048807fe939a4da3ca 865184cfb70e446687f5a42495e907ee 35cc78e67a444e71a4e1475776dde79f--865184cfb70e446687f5a42495e907ee 5840c41833594c1eb65e31bf9d6f4112 3 32bfae3c69ea4caba25bfcb9c0008fed 865184cfb70e446687f5a42495e907ee--32bfae3c69ea4caba25bfcb9c0008fed 32bfae3c69ea4caba25bfcb9c0008fed--705dd8643c4a4a048807fe939a4da3ca f4ba600569e649edb384c20e78b91de4 601382034d7e4689b94af25abc165eb7 5840c41833594c1eb65e31bf9d6f4112--601382034d7e4689b94af25abc165eb7 9ca3c91d6382434f8a63389293a8ea4a 4 4d7846c402274836a5bfa268314b9e8d 601382034d7e4689b94af25abc165eb7--4d7846c402274836a5bfa268314b9e8d 4d7846c402274836a5bfa268314b9e8d--f4ba600569e649edb384c20e78b91de4 98b8f1193b4040c6a75a554d34e3dd6f e6732f0a4e264d57bae3e74dae2bbf61 X 9ca3c91d6382434f8a63389293a8ea4a--e6732f0a4e264d57bae3e74dae2bbf61 e6732f0a4e264d57bae3e74dae2bbf61--601382034d7e4689b94af25abc165eb7 72ce3d3770e54b56a56521f6154e11cf X e6732f0a4e264d57bae3e74dae2bbf61--72ce3d3770e54b56a56521f6154e11cf 72ce3d3770e54b56a56521f6154e11cf--4d7846c402274836a5bfa268314b9e8d 72ce3d3770e54b56a56521f6154e11cf--98b8f1193b4040c6a75a554d34e3dd6f"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'11': 257, '10': 254, '00': 251, '01': 238})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'110': 30, '100': 28, '010': 22, '000': 20})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[ 0.2630, -0.0138],\n        [ 0.0106,  0.0010]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9754+0.0000j, 0.0000-0.2203j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.9058+0.0000j, 0.0000-0.4237j],\n        [0.9047+0.0000j, 0.0000-0.4260j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5444+0.0000j, 0.8070+0.0000j, 0.0000-0.1279j, 0.0000-0.1896j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_a39c867237f4410f8fb4f69736301413 [* 2] cluster_880527009ffa40fa8f9e035791c88f69 Rotations bb45549fb74e4441b7f14a9b36430664 0 8347f58efe4c493ea9d38f9ea0ddec91 RX(phi/theta) bb45549fb74e4441b7f14a9b36430664--8347f58efe4c493ea9d38f9ea0ddec91 f60704c17c6b457b8ec7b654420e1490 1 0a220245648f4c5e9c35856ec7e8da47 RX(phi) 8347f58efe4c493ea9d38f9ea0ddec91--0a220245648f4c5e9c35856ec7e8da47 01192982625245c29a33e6802a40da26 RX(phi) 0a220245648f4c5e9c35856ec7e8da47--01192982625245c29a33e6802a40da26 262939f8e6784098b9956d2f2832a244 RX(phi + theta) 01192982625245c29a33e6802a40da26--262939f8e6784098b9956d2f2832a244 5ef017d7694d48c8a6af55b05877c901 262939f8e6784098b9956d2f2832a244--5ef017d7694d48c8a6af55b05877c901 8141adbbf6694b3ba282fc6870458dc8 5ef017d7694d48c8a6af55b05877c901--8141adbbf6694b3ba282fc6870458dc8 676a2cf8e9134d2499074684d3864266 Z 8141adbbf6694b3ba282fc6870458dc8--676a2cf8e9134d2499074684d3864266 5bb1ea75f9e3443e9f07cdbaafff2190 676a2cf8e9134d2499074684d3864266--5bb1ea75f9e3443e9f07cdbaafff2190 e8d2758ec0af4a349a94d0d6cbb7e805 7102aef7295b4565b1e4abb4fe4101a9 RY(2*theta) f60704c17c6b457b8ec7b654420e1490--7102aef7295b4565b1e4abb4fe4101a9 93bf6f7e96654efb8e89c3c7a0edca93 2 7cc9b6186f8d4a7c8670d6dff0074438 RY(theta) 7102aef7295b4565b1e4abb4fe4101a9--7cc9b6186f8d4a7c8670d6dff0074438 c0fbe39e7d7e40f98625b6f371cd4d07 RY(theta) 7cc9b6186f8d4a7c8670d6dff0074438--c0fbe39e7d7e40f98625b6f371cd4d07 f213f0110cf046f89015cf52677af915 RY(theta**2) c0fbe39e7d7e40f98625b6f371cd4d07--f213f0110cf046f89015cf52677af915 2d7c196fe2c04463a23be69c9c61db2c X f213f0110cf046f89015cf52677af915--2d7c196fe2c04463a23be69c9c61db2c 2d7c196fe2c04463a23be69c9c61db2c--5ef017d7694d48c8a6af55b05877c901 c9c3aa02188946c2b27ef4671edfa616 2d7c196fe2c04463a23be69c9c61db2c--c9c3aa02188946c2b27ef4671edfa616 784610f65f074e2cad968bbaeefb483d Z c9c3aa02188946c2b27ef4671edfa616--784610f65f074e2cad968bbaeefb483d 784610f65f074e2cad968bbaeefb483d--e8d2758ec0af4a349a94d0d6cbb7e805 8d9ad7fafd0249f882243c49b4fc81ed 060c4cb78f534cec98f7dead3edaa18e RZ(cos(phi)) 93bf6f7e96654efb8e89c3c7a0edca93--060c4cb78f534cec98f7dead3edaa18e e87d9ec889544cb283ac63c908c29848 RZ(phi) 060c4cb78f534cec98f7dead3edaa18e--e87d9ec889544cb283ac63c908c29848 e42938b7a54e4980afd224060292e120 RZ(phi) e87d9ec889544cb283ac63c908c29848--e42938b7a54e4980afd224060292e120 e3049c23ad87448fb994f76a08924fea RZ(cos(phi)) e42938b7a54e4980afd224060292e120--e3049c23ad87448fb994f76a08924fea 4bf59aeb9f2d4d249d127e02d0274122 e3049c23ad87448fb994f76a08924fea--4bf59aeb9f2d4d249d127e02d0274122 9e23cca88afd46bab6023a044521e57a X 4bf59aeb9f2d4d249d127e02d0274122--9e23cca88afd46bab6023a044521e57a 9e23cca88afd46bab6023a044521e57a--c9c3aa02188946c2b27ef4671edfa616 1865b3ac7fe74520a9f05a4a7902b280 Z 9e23cca88afd46bab6023a044521e57a--1865b3ac7fe74520a9f05a4a7902b280 1865b3ac7fe74520a9f05a4a7902b280--8d9ad7fafd0249f882243c49b4fc81ed <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.3193]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.9192+0.0000j, 0.2725+0.0000j, 0.0000-0.2725j, 0.0000-0.0808j],\n        [0.7623+0.0000j, 0.4257+0.0000j, 0.0000-0.4257j, 0.0000-0.2377j],\n        [0.7010+0.0000j, 0.4578+0.0000j, 0.0000-0.4578j, 0.0000-0.2990j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 ba5022654aef474fa89c7d4b5c8cf1a7 0 f308d3cfc3de4faebe5620995f4778ec RX(theta\u2080) ba5022654aef474fa89c7d4b5c8cf1a7--f308d3cfc3de4faebe5620995f4778ec b32639bfc3fc4cbbbf81031b1599fc62 1 7b65878828f444029ff76082ae6326c0 RY(theta\u2084) f308d3cfc3de4faebe5620995f4778ec--7b65878828f444029ff76082ae6326c0 438e437afe3d4826af7942752622b05f RX(theta\u2088) 7b65878828f444029ff76082ae6326c0--438e437afe3d4826af7942752622b05f 81aaa99b1dc1469680caf150b07be04d 438e437afe3d4826af7942752622b05f--81aaa99b1dc1469680caf150b07be04d d82032b370434aafa39085f2082165d5 81aaa99b1dc1469680caf150b07be04d--d82032b370434aafa39085f2082165d5 a32f3be887ab462ebdfa982e5a328ab2 RX(theta\u2081\u2082) d82032b370434aafa39085f2082165d5--a32f3be887ab462ebdfa982e5a328ab2 3a3fb4579171494a8d246dd695c583d5 RY(theta\u2081\u2086) a32f3be887ab462ebdfa982e5a328ab2--3a3fb4579171494a8d246dd695c583d5 abbdf85857eb4017b66d13b6d361b1db RX(theta\u2082\u2080) 3a3fb4579171494a8d246dd695c583d5--abbdf85857eb4017b66d13b6d361b1db 7480eee4b0424d92b3cfa878d1d75e53 abbdf85857eb4017b66d13b6d361b1db--7480eee4b0424d92b3cfa878d1d75e53 afcdf11464eb4490b472ace19e9f4eb9 7480eee4b0424d92b3cfa878d1d75e53--afcdf11464eb4490b472ace19e9f4eb9 18b3e700d30f459e9d5ebc45944e7c8f afcdf11464eb4490b472ace19e9f4eb9--18b3e700d30f459e9d5ebc45944e7c8f 07fbbf4c4980410faeae1261fa634ba1 67b258c81e994db99b1800953a52671e RX(theta\u2081) b32639bfc3fc4cbbbf81031b1599fc62--67b258c81e994db99b1800953a52671e 6e494e11cbd34b588b0abefe1504ab15 2 2d5ea3a9b4db4d6ab4669a78ad82b2d1 RY(theta\u2085) 67b258c81e994db99b1800953a52671e--2d5ea3a9b4db4d6ab4669a78ad82b2d1 df8deab1526449e689deb784accbac4e RX(theta\u2089) 2d5ea3a9b4db4d6ab4669a78ad82b2d1--df8deab1526449e689deb784accbac4e d37e1b6c5afd453fb4ac3f8f8d7899e9 X df8deab1526449e689deb784accbac4e--d37e1b6c5afd453fb4ac3f8f8d7899e9 d37e1b6c5afd453fb4ac3f8f8d7899e9--81aaa99b1dc1469680caf150b07be04d 37ff174debff46d481be753d8df8e864 d37e1b6c5afd453fb4ac3f8f8d7899e9--37ff174debff46d481be753d8df8e864 085b8e83cbc24fe48e61992da8a30d79 RX(theta\u2081\u2083) 37ff174debff46d481be753d8df8e864--085b8e83cbc24fe48e61992da8a30d79 b32aa6f2b9a04840ab69f20890fd0b3d RY(theta\u2081\u2087) 085b8e83cbc24fe48e61992da8a30d79--b32aa6f2b9a04840ab69f20890fd0b3d 0e8cc7c036bb4e9680abd212ab173d0d RX(theta\u2082\u2081) b32aa6f2b9a04840ab69f20890fd0b3d--0e8cc7c036bb4e9680abd212ab173d0d 6bc025230f5a44e5bac229ccac64fed1 X 0e8cc7c036bb4e9680abd212ab173d0d--6bc025230f5a44e5bac229ccac64fed1 6bc025230f5a44e5bac229ccac64fed1--7480eee4b0424d92b3cfa878d1d75e53 cccc65affa934d6981b70e3299055f67 6bc025230f5a44e5bac229ccac64fed1--cccc65affa934d6981b70e3299055f67 cccc65affa934d6981b70e3299055f67--07fbbf4c4980410faeae1261fa634ba1 d05c3eeb05a849c4a5ee50b8b587c3cc 95a61e4a8cee439d88453392e0f49a52 RX(theta\u2082) 6e494e11cbd34b588b0abefe1504ab15--95a61e4a8cee439d88453392e0f49a52 f321d632d4f64b248e66312c09527a74 3 4dca3af6a59548f2a5dc5aa31dafc2ce RY(theta\u2086) 95a61e4a8cee439d88453392e0f49a52--4dca3af6a59548f2a5dc5aa31dafc2ce a5ddcb3ab4014636853cfb2b46bcc95c RX(theta\u2081\u2080) 4dca3af6a59548f2a5dc5aa31dafc2ce--a5ddcb3ab4014636853cfb2b46bcc95c bd6dfebb79dc46a4bf64edbc46e5a489 a5ddcb3ab4014636853cfb2b46bcc95c--bd6dfebb79dc46a4bf64edbc46e5a489 bf0c3781ac094c8e9579898bcafa872b X bd6dfebb79dc46a4bf64edbc46e5a489--bf0c3781ac094c8e9579898bcafa872b bf0c3781ac094c8e9579898bcafa872b--37ff174debff46d481be753d8df8e864 246a42180f0d408a9bea092650ec9a42 RX(theta\u2081\u2084) bf0c3781ac094c8e9579898bcafa872b--246a42180f0d408a9bea092650ec9a42 d7d8efc1e834490980ea9442ca50cbdf RY(theta\u2081\u2088) 246a42180f0d408a9bea092650ec9a42--d7d8efc1e834490980ea9442ca50cbdf 607b84ced91c4ec5882b1c4147f596ca RX(theta\u2082\u2082) d7d8efc1e834490980ea9442ca50cbdf--607b84ced91c4ec5882b1c4147f596ca 3086c147d27d418cbfdf2331fd643d60 607b84ced91c4ec5882b1c4147f596ca--3086c147d27d418cbfdf2331fd643d60 ee3d6c7c333f4dfc86f2af09f34045af X 3086c147d27d418cbfdf2331fd643d60--ee3d6c7c333f4dfc86f2af09f34045af ee3d6c7c333f4dfc86f2af09f34045af--cccc65affa934d6981b70e3299055f67 ee3d6c7c333f4dfc86f2af09f34045af--d05c3eeb05a849c4a5ee50b8b587c3cc 283e99ea5a6f439c8907cda609a31b73 d2764670a1b741eca55797f9c94cad77 RX(theta\u2083) f321d632d4f64b248e66312c09527a74--d2764670a1b741eca55797f9c94cad77 33090468fbe647a88d95484b8b1b5054 RY(theta\u2087) d2764670a1b741eca55797f9c94cad77--33090468fbe647a88d95484b8b1b5054 e4b72e5139a544b0875cb116d2c2fd4f RX(theta\u2081\u2081) 33090468fbe647a88d95484b8b1b5054--e4b72e5139a544b0875cb116d2c2fd4f d1aa37379dc34df4932ba718418f6ef7 X e4b72e5139a544b0875cb116d2c2fd4f--d1aa37379dc34df4932ba718418f6ef7 d1aa37379dc34df4932ba718418f6ef7--bd6dfebb79dc46a4bf64edbc46e5a489 aeac3a2307614e40b6698d2d019eed6c d1aa37379dc34df4932ba718418f6ef7--aeac3a2307614e40b6698d2d019eed6c b279936280c6430b99df463151d4fa9b RX(theta\u2081\u2085) aeac3a2307614e40b6698d2d019eed6c--b279936280c6430b99df463151d4fa9b 24fa765e3d854148bf6ca2d91472b2c0 RY(theta\u2081\u2089) b279936280c6430b99df463151d4fa9b--24fa765e3d854148bf6ca2d91472b2c0 24bf6495b4324dde9bddf47692be5f94 RX(theta\u2082\u2083) 24fa765e3d854148bf6ca2d91472b2c0--24bf6495b4324dde9bddf47692be5f94 7b8b3fb6d5944f5eb3e7cd81b81da1a0 X 24bf6495b4324dde9bddf47692be5f94--7b8b3fb6d5944f5eb3e7cd81b81da1a0 7b8b3fb6d5944f5eb3e7cd81b81da1a0--3086c147d27d418cbfdf2331fd643d60 ed06f335dcff4181b4e61abf06233e45 7b8b3fb6d5944f5eb3e7cd81b81da1a0--ed06f335dcff4181b4e61abf06233e45 ed06f335dcff4181b4e61abf06233e45--283e99ea5a6f439c8907cda609a31b73 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_6f539518b2c84487be1540ad57882102 HEA cluster_70cc803c9b3e4e8ca59661d755b512b3 HEA 2f8dcba216454c6a9e1805b66b62abab 0 d9212ae88e91494593faf4476fbd4d74 RX(theta\u2080) 2f8dcba216454c6a9e1805b66b62abab--d9212ae88e91494593faf4476fbd4d74 e3d7939ecfbf4647b09ff369ec76f090 1 14db1da304974201bbc698d21b0e2121 RY(theta\u2084) d9212ae88e91494593faf4476fbd4d74--14db1da304974201bbc698d21b0e2121 68b4275ad7e0443684cc13ebfda9ea6c RX(theta\u2088) 14db1da304974201bbc698d21b0e2121--68b4275ad7e0443684cc13ebfda9ea6c 4e1f82320a61407ca53c4ac06a44de98 68b4275ad7e0443684cc13ebfda9ea6c--4e1f82320a61407ca53c4ac06a44de98 b464bf8460844b028610ef0157f20eb0 4e1f82320a61407ca53c4ac06a44de98--b464bf8460844b028610ef0157f20eb0 04c7415c186949e29c754ea32a899e83 RX(theta\u2081\u2082) b464bf8460844b028610ef0157f20eb0--04c7415c186949e29c754ea32a899e83 47a8e43d153b4c7b8a57898a552e00af RY(theta\u2081\u2086) 04c7415c186949e29c754ea32a899e83--47a8e43d153b4c7b8a57898a552e00af fcc68830f8fa486284236eac2d39b3c0 RX(theta\u2082\u2080) 47a8e43d153b4c7b8a57898a552e00af--fcc68830f8fa486284236eac2d39b3c0 e71ab9fe456e493bb3e5fd997b74d447 fcc68830f8fa486284236eac2d39b3c0--e71ab9fe456e493bb3e5fd997b74d447 40200ab361a54fa4b7f6fd168ebbdc44 e71ab9fe456e493bb3e5fd997b74d447--40200ab361a54fa4b7f6fd168ebbdc44 d8dee128a89c4650994c5277ec0d8c3f RX(theta\u2080) 40200ab361a54fa4b7f6fd168ebbdc44--d8dee128a89c4650994c5277ec0d8c3f 4e473d66460b4e2a900cd8720560bb8b RY(theta\u2084) d8dee128a89c4650994c5277ec0d8c3f--4e473d66460b4e2a900cd8720560bb8b c581acf9319147cc89f342d6b149a95a RX(theta\u2088) 4e473d66460b4e2a900cd8720560bb8b--c581acf9319147cc89f342d6b149a95a 1e3ec6c4bd6b419abf4edcef9ef8b94f c581acf9319147cc89f342d6b149a95a--1e3ec6c4bd6b419abf4edcef9ef8b94f da875a59669c41148af553aee76b99e8 1e3ec6c4bd6b419abf4edcef9ef8b94f--da875a59669c41148af553aee76b99e8 7b5e9e5a0c7f414895ca42e90854cabc RX(theta\u2081\u2082) da875a59669c41148af553aee76b99e8--7b5e9e5a0c7f414895ca42e90854cabc 223995287c4a4448b4829beb91cf86ce RY(theta\u2081\u2086) 7b5e9e5a0c7f414895ca42e90854cabc--223995287c4a4448b4829beb91cf86ce d3c46010d8044d6baeb7363c63f4d45f RX(theta\u2082\u2080) 223995287c4a4448b4829beb91cf86ce--d3c46010d8044d6baeb7363c63f4d45f 5319fecd2a1d40f4b8d8354a4e2ffe3c d3c46010d8044d6baeb7363c63f4d45f--5319fecd2a1d40f4b8d8354a4e2ffe3c 50cd2aecc33d47639898582879d12721 5319fecd2a1d40f4b8d8354a4e2ffe3c--50cd2aecc33d47639898582879d12721 72751ce039d2456b9add2002d0cdfa1c 50cd2aecc33d47639898582879d12721--72751ce039d2456b9add2002d0cdfa1c 93c26031b31640db832ff779bdc4c1d3 595154b048ea4921af7881800762ddfb RX(theta\u2081) e3d7939ecfbf4647b09ff369ec76f090--595154b048ea4921af7881800762ddfb 058fa49a919c438796a8425cc06883ed 2 8bfa02af62f54d7493c2fa04ec05a14d RY(theta\u2085) 595154b048ea4921af7881800762ddfb--8bfa02af62f54d7493c2fa04ec05a14d 52cf04b5fa164dc893f915974c568bb6 RX(theta\u2089) 8bfa02af62f54d7493c2fa04ec05a14d--52cf04b5fa164dc893f915974c568bb6 f860ac0ea07c497ba075907992f92fbb X 52cf04b5fa164dc893f915974c568bb6--f860ac0ea07c497ba075907992f92fbb f860ac0ea07c497ba075907992f92fbb--4e1f82320a61407ca53c4ac06a44de98 7584a94161ef47f5883dfae2792c6c1a f860ac0ea07c497ba075907992f92fbb--7584a94161ef47f5883dfae2792c6c1a c5586bf5dd1243f2895571266ac876f3 RX(theta\u2081\u2083) 7584a94161ef47f5883dfae2792c6c1a--c5586bf5dd1243f2895571266ac876f3 9a6739434b414b579d9cb82a0e3e0d97 RY(theta\u2081\u2087) c5586bf5dd1243f2895571266ac876f3--9a6739434b414b579d9cb82a0e3e0d97 8687257f4a1f47a69686fd81cf0370fa RX(theta\u2082\u2081) 9a6739434b414b579d9cb82a0e3e0d97--8687257f4a1f47a69686fd81cf0370fa 0607a452941d44079569e98013d666ba X 8687257f4a1f47a69686fd81cf0370fa--0607a452941d44079569e98013d666ba 0607a452941d44079569e98013d666ba--e71ab9fe456e493bb3e5fd997b74d447 cfa18356c3f542178612115f07004fc4 0607a452941d44079569e98013d666ba--cfa18356c3f542178612115f07004fc4 5b624563c41c450b82ee21e13d93508a RX(theta\u2081) cfa18356c3f542178612115f07004fc4--5b624563c41c450b82ee21e13d93508a 3f4e3ea75a0442b7aecadd76dea8ec2b RY(theta\u2085) 5b624563c41c450b82ee21e13d93508a--3f4e3ea75a0442b7aecadd76dea8ec2b be42b1c81bcb4e7d98c48297235a85ca RX(theta\u2089) 3f4e3ea75a0442b7aecadd76dea8ec2b--be42b1c81bcb4e7d98c48297235a85ca 33a6e61bac2648a4a16fd4bcac3d339d X be42b1c81bcb4e7d98c48297235a85ca--33a6e61bac2648a4a16fd4bcac3d339d 33a6e61bac2648a4a16fd4bcac3d339d--1e3ec6c4bd6b419abf4edcef9ef8b94f e934e674e596420b912dae2fa01e6293 33a6e61bac2648a4a16fd4bcac3d339d--e934e674e596420b912dae2fa01e6293 2e2519f7701348e19ab43ab64dbdfae1 RX(theta\u2081\u2083) e934e674e596420b912dae2fa01e6293--2e2519f7701348e19ab43ab64dbdfae1 965547ad69db41b6b731612fcf9b91dc RY(theta\u2081\u2087) 2e2519f7701348e19ab43ab64dbdfae1--965547ad69db41b6b731612fcf9b91dc df59aec1f7ba4fc38357d9af661ea65d RX(theta\u2082\u2081) 965547ad69db41b6b731612fcf9b91dc--df59aec1f7ba4fc38357d9af661ea65d 2492bf49c3184684b5858a907255c3db X df59aec1f7ba4fc38357d9af661ea65d--2492bf49c3184684b5858a907255c3db 2492bf49c3184684b5858a907255c3db--5319fecd2a1d40f4b8d8354a4e2ffe3c a66beb3e763a4ee18c1a63e8fffbe576 2492bf49c3184684b5858a907255c3db--a66beb3e763a4ee18c1a63e8fffbe576 a66beb3e763a4ee18c1a63e8fffbe576--93c26031b31640db832ff779bdc4c1d3 66643f46d88e4317b128cb55ad145324 02b79a638c4846858a12784f510620e5 RX(theta\u2082) 058fa49a919c438796a8425cc06883ed--02b79a638c4846858a12784f510620e5 19f05295c5e1469e83f1165d87699454 3 7f99a76166f44265af6abbb033131e6d RY(theta\u2086) 02b79a638c4846858a12784f510620e5--7f99a76166f44265af6abbb033131e6d 02b9365a86bf4af8b3b3fe6a49d9623e RX(theta\u2081\u2080) 7f99a76166f44265af6abbb033131e6d--02b9365a86bf4af8b3b3fe6a49d9623e cdb1a6c583444d459a9f77d1e95d7cd0 02b9365a86bf4af8b3b3fe6a49d9623e--cdb1a6c583444d459a9f77d1e95d7cd0 aab42bc5b22945a2bf412526b2755391 X cdb1a6c583444d459a9f77d1e95d7cd0--aab42bc5b22945a2bf412526b2755391 aab42bc5b22945a2bf412526b2755391--7584a94161ef47f5883dfae2792c6c1a 47e0955ff3284b58b22467433b1f1d43 RX(theta\u2081\u2084) aab42bc5b22945a2bf412526b2755391--47e0955ff3284b58b22467433b1f1d43 262224ec9af842d883bdf069ba9e8e71 RY(theta\u2081\u2088) 47e0955ff3284b58b22467433b1f1d43--262224ec9af842d883bdf069ba9e8e71 996af01b4d4745918b0c5de302ba6a61 RX(theta\u2082\u2082) 262224ec9af842d883bdf069ba9e8e71--996af01b4d4745918b0c5de302ba6a61 9803c4bdc43949ecbf6632fca2dc9661 996af01b4d4745918b0c5de302ba6a61--9803c4bdc43949ecbf6632fca2dc9661 0bc8bac1be344ca2855988d9d627d279 X 9803c4bdc43949ecbf6632fca2dc9661--0bc8bac1be344ca2855988d9d627d279 0bc8bac1be344ca2855988d9d627d279--cfa18356c3f542178612115f07004fc4 1fc28e16adf14f19adf82ef26445a0d2 RX(theta\u2082) 0bc8bac1be344ca2855988d9d627d279--1fc28e16adf14f19adf82ef26445a0d2 e7f6cd4309574df3b3a4214e70b53a81 RY(theta\u2086) 1fc28e16adf14f19adf82ef26445a0d2--e7f6cd4309574df3b3a4214e70b53a81 64ff197f6961486790047747caf78e86 RX(theta\u2081\u2080) e7f6cd4309574df3b3a4214e70b53a81--64ff197f6961486790047747caf78e86 6f922fdb424242f2adab4d77ee9b393b 64ff197f6961486790047747caf78e86--6f922fdb424242f2adab4d77ee9b393b 008f9303bc4e4dabafb5aaf4c684cb6e X 6f922fdb424242f2adab4d77ee9b393b--008f9303bc4e4dabafb5aaf4c684cb6e 008f9303bc4e4dabafb5aaf4c684cb6e--e934e674e596420b912dae2fa01e6293 f6b31ce6883647be8f109f5ac8ccf2df RX(theta\u2081\u2084) 008f9303bc4e4dabafb5aaf4c684cb6e--f6b31ce6883647be8f109f5ac8ccf2df 8c99afd2f79146af9cc02f6a54ca37fc RY(theta\u2081\u2088) f6b31ce6883647be8f109f5ac8ccf2df--8c99afd2f79146af9cc02f6a54ca37fc 6debc978ab694bec8ce2bc5e2cea38be RX(theta\u2082\u2082) 8c99afd2f79146af9cc02f6a54ca37fc--6debc978ab694bec8ce2bc5e2cea38be 543e23d5bf86457982a715b6d94762bf 6debc978ab694bec8ce2bc5e2cea38be--543e23d5bf86457982a715b6d94762bf 6aa46321d5e74b4d906acc524c2fa2cb X 543e23d5bf86457982a715b6d94762bf--6aa46321d5e74b4d906acc524c2fa2cb 6aa46321d5e74b4d906acc524c2fa2cb--a66beb3e763a4ee18c1a63e8fffbe576 6aa46321d5e74b4d906acc524c2fa2cb--66643f46d88e4317b128cb55ad145324 4fcdbc9b58fb4dbc98cef719aa6dd2c5 56a3419263e94c4bb28a7eb1c2c2fcba RX(theta\u2083) 19f05295c5e1469e83f1165d87699454--56a3419263e94c4bb28a7eb1c2c2fcba 93ecd3deb0db47239ebe002a1ec7bbbc RY(theta\u2087) 56a3419263e94c4bb28a7eb1c2c2fcba--93ecd3deb0db47239ebe002a1ec7bbbc d12a406e0941424f98e48f89d41e9dfa RX(theta\u2081\u2081) 93ecd3deb0db47239ebe002a1ec7bbbc--d12a406e0941424f98e48f89d41e9dfa 1b9552101093400883866ea2ac971bd3 X d12a406e0941424f98e48f89d41e9dfa--1b9552101093400883866ea2ac971bd3 1b9552101093400883866ea2ac971bd3--cdb1a6c583444d459a9f77d1e95d7cd0 fdaba70985e347e8830fea6c2c4f5777 1b9552101093400883866ea2ac971bd3--fdaba70985e347e8830fea6c2c4f5777 a36176b170014d9e9fd95827f4c0db10 RX(theta\u2081\u2085) fdaba70985e347e8830fea6c2c4f5777--a36176b170014d9e9fd95827f4c0db10 be695c27b1b8432290739518bcf967f8 RY(theta\u2081\u2089) a36176b170014d9e9fd95827f4c0db10--be695c27b1b8432290739518bcf967f8 e79a8c3d04f14339af2069cbbc7de197 RX(theta\u2082\u2083) be695c27b1b8432290739518bcf967f8--e79a8c3d04f14339af2069cbbc7de197 015e207d2f2140d8ab6fef3bd38a9b4e X e79a8c3d04f14339af2069cbbc7de197--015e207d2f2140d8ab6fef3bd38a9b4e 015e207d2f2140d8ab6fef3bd38a9b4e--9803c4bdc43949ecbf6632fca2dc9661 b4d78506ab0c4efcb299ee9a38883252 015e207d2f2140d8ab6fef3bd38a9b4e--b4d78506ab0c4efcb299ee9a38883252 bf41dc6c39cf48d4ad9597b14c5167c2 RX(theta\u2083) b4d78506ab0c4efcb299ee9a38883252--bf41dc6c39cf48d4ad9597b14c5167c2 7337f210894c4ecd84a82601de9d39ec RY(theta\u2087) bf41dc6c39cf48d4ad9597b14c5167c2--7337f210894c4ecd84a82601de9d39ec 295671416b70412a8dbbc5bf3e555fbb RX(theta\u2081\u2081) 7337f210894c4ecd84a82601de9d39ec--295671416b70412a8dbbc5bf3e555fbb 5113c9c90a7446dc9d5ff0d8c885f815 X 295671416b70412a8dbbc5bf3e555fbb--5113c9c90a7446dc9d5ff0d8c885f815 5113c9c90a7446dc9d5ff0d8c885f815--6f922fdb424242f2adab4d77ee9b393b 9bf4a26dcf8240d781205c2b5a4aabf5 5113c9c90a7446dc9d5ff0d8c885f815--9bf4a26dcf8240d781205c2b5a4aabf5 9d81e3f2e2c241cfb43e344bc8f7195d RX(theta\u2081\u2085) 9bf4a26dcf8240d781205c2b5a4aabf5--9d81e3f2e2c241cfb43e344bc8f7195d 0d464c3f4b514f519ad8dc4621eeb9ad RY(theta\u2081\u2089) 9d81e3f2e2c241cfb43e344bc8f7195d--0d464c3f4b514f519ad8dc4621eeb9ad bebfa40134fd4da7976f55080bc68fc7 RX(theta\u2082\u2083) 0d464c3f4b514f519ad8dc4621eeb9ad--bebfa40134fd4da7976f55080bc68fc7 c2d2fb8dfda742deb51c3872da0cf242 X bebfa40134fd4da7976f55080bc68fc7--c2d2fb8dfda742deb51c3872da0cf242 c2d2fb8dfda742deb51c3872da0cf242--543e23d5bf86457982a715b6d94762bf 770fad8d87e540109c9d86e4d941e383 c2d2fb8dfda742deb51c3872da0cf242--770fad8d87e540109c9d86e4d941e383 770fad8d87e540109c9d86e4d941e383--4fcdbc9b58fb4dbc98cef719aa6dd2c5 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_9cd1fbaab3d8425d8283333d3fcd86b9 HEA cluster_dd75c95354fd4796a77c62e95e44b0dc HEA 3c5ed0d996ca4291b4c1b0e9d50d29f1 0 21195e057aa34f3bb98db204ad17a87e RX(p1\u2080) 3c5ed0d996ca4291b4c1b0e9d50d29f1--21195e057aa34f3bb98db204ad17a87e cbcdbe98954042d286e316ce9a77dba5 1 48f796215aaa40d693d7f702e9a89a1e RY(p1\u2084) 21195e057aa34f3bb98db204ad17a87e--48f796215aaa40d693d7f702e9a89a1e 168061ff343047e9b5564e0e8a7e1259 RX(p1\u2088) 48f796215aaa40d693d7f702e9a89a1e--168061ff343047e9b5564e0e8a7e1259 79c1b741c65343d799af7d95f1c2b375 168061ff343047e9b5564e0e8a7e1259--79c1b741c65343d799af7d95f1c2b375 f2855f6a56764cd9957bc2765f1baafd 79c1b741c65343d799af7d95f1c2b375--f2855f6a56764cd9957bc2765f1baafd 8a3a4769082d413995d3d6b14f1469d5 RX(p1\u2081\u2082) f2855f6a56764cd9957bc2765f1baafd--8a3a4769082d413995d3d6b14f1469d5 8aa9c91e315f433d93a45e548d0293c3 RY(p1\u2081\u2086) 8a3a4769082d413995d3d6b14f1469d5--8aa9c91e315f433d93a45e548d0293c3 e1da5ed8a6124c418a5cf877228c64e3 RX(p1\u2082\u2080) 8aa9c91e315f433d93a45e548d0293c3--e1da5ed8a6124c418a5cf877228c64e3 dbaeeb972f2a43059304765dcc787cdc e1da5ed8a6124c418a5cf877228c64e3--dbaeeb972f2a43059304765dcc787cdc 94c2f5be23924cf79358aa438576d2c0 dbaeeb972f2a43059304765dcc787cdc--94c2f5be23924cf79358aa438576d2c0 df385951ef684de0ac665648a293842e RX(p2\u2080) 94c2f5be23924cf79358aa438576d2c0--df385951ef684de0ac665648a293842e 5d5dec9e70f64b67b4659915774b2147 RY(p2\u2084) df385951ef684de0ac665648a293842e--5d5dec9e70f64b67b4659915774b2147 8ae7754c169747ef92119901da63ae46 RX(p2\u2088) 5d5dec9e70f64b67b4659915774b2147--8ae7754c169747ef92119901da63ae46 ed2969ea71984ba0b21fe002549d48a8 8ae7754c169747ef92119901da63ae46--ed2969ea71984ba0b21fe002549d48a8 534878a05499438bb9eb5e7e8bf10089 ed2969ea71984ba0b21fe002549d48a8--534878a05499438bb9eb5e7e8bf10089 75c7efa5907749069840710ebe62702c RX(p2\u2081\u2082) 534878a05499438bb9eb5e7e8bf10089--75c7efa5907749069840710ebe62702c d25b731baf53457a9bdd178ce26cf6c9 RY(p2\u2081\u2086) 75c7efa5907749069840710ebe62702c--d25b731baf53457a9bdd178ce26cf6c9 d896fc6622044b6e9976a8868c363495 RX(p2\u2082\u2080) d25b731baf53457a9bdd178ce26cf6c9--d896fc6622044b6e9976a8868c363495 a5a871b7ecc14ae8824eceeb87ee9dec d896fc6622044b6e9976a8868c363495--a5a871b7ecc14ae8824eceeb87ee9dec ad71c0543b9b407a9da340677131fd7d a5a871b7ecc14ae8824eceeb87ee9dec--ad71c0543b9b407a9da340677131fd7d 4cf1eeaaa30b4875895b6aa962b3208f ad71c0543b9b407a9da340677131fd7d--4cf1eeaaa30b4875895b6aa962b3208f b838cdcc3770453cbfa7e72ce90c2c06 e87b6bb5256042f99d1a636f6405aff9 RX(p1\u2081) cbcdbe98954042d286e316ce9a77dba5--e87b6bb5256042f99d1a636f6405aff9 0efc9fe5b9d14357aac443bd050ad8fd 2 2fd4de19c2864abd8da8b319ebd2f416 RY(p1\u2085) e87b6bb5256042f99d1a636f6405aff9--2fd4de19c2864abd8da8b319ebd2f416 80e62a30c33b46b6b638c6e908c6d73b RX(p1\u2089) 2fd4de19c2864abd8da8b319ebd2f416--80e62a30c33b46b6b638c6e908c6d73b 92a1b557377d4faa8212e0ee296c0fe5 X 80e62a30c33b46b6b638c6e908c6d73b--92a1b557377d4faa8212e0ee296c0fe5 92a1b557377d4faa8212e0ee296c0fe5--79c1b741c65343d799af7d95f1c2b375 1e74640b2e534b2aa67ec611c0d4d852 92a1b557377d4faa8212e0ee296c0fe5--1e74640b2e534b2aa67ec611c0d4d852 fe3046092b8d42c784d843be36e54974 RX(p1\u2081\u2083) 1e74640b2e534b2aa67ec611c0d4d852--fe3046092b8d42c784d843be36e54974 6f2c50b0c2ea401cb9ff4ab824320dcf RY(p1\u2081\u2087) fe3046092b8d42c784d843be36e54974--6f2c50b0c2ea401cb9ff4ab824320dcf e6bd86f6b1b948f8a4de9e7419028f56 RX(p1\u2082\u2081) 6f2c50b0c2ea401cb9ff4ab824320dcf--e6bd86f6b1b948f8a4de9e7419028f56 206a96a992d645ecb3540c8b53b95ef1 X e6bd86f6b1b948f8a4de9e7419028f56--206a96a992d645ecb3540c8b53b95ef1 206a96a992d645ecb3540c8b53b95ef1--dbaeeb972f2a43059304765dcc787cdc ce0161424347415885017bb11ef9fe3f 206a96a992d645ecb3540c8b53b95ef1--ce0161424347415885017bb11ef9fe3f f5aae61dd1474fca8667d92bf473d052 RX(p2\u2081) ce0161424347415885017bb11ef9fe3f--f5aae61dd1474fca8667d92bf473d052 a395547476d84076b2d44f8c3d1cdf8d RY(p2\u2085) f5aae61dd1474fca8667d92bf473d052--a395547476d84076b2d44f8c3d1cdf8d cbf19c041dcf4455b695667149ac229e RX(p2\u2089) a395547476d84076b2d44f8c3d1cdf8d--cbf19c041dcf4455b695667149ac229e 9a5b34cf09bf48b08e247ab9ef22d971 X cbf19c041dcf4455b695667149ac229e--9a5b34cf09bf48b08e247ab9ef22d971 9a5b34cf09bf48b08e247ab9ef22d971--ed2969ea71984ba0b21fe002549d48a8 f625752fe53444a1b3064b1e58eb4024 9a5b34cf09bf48b08e247ab9ef22d971--f625752fe53444a1b3064b1e58eb4024 cc5c448742b24a0ba701cab7eb809c26 RX(p2\u2081\u2083) f625752fe53444a1b3064b1e58eb4024--cc5c448742b24a0ba701cab7eb809c26 9d192dd5fcb04d18a7f822d6a6040716 RY(p2\u2081\u2087) cc5c448742b24a0ba701cab7eb809c26--9d192dd5fcb04d18a7f822d6a6040716 3131eff5117e434988607bbc5dc3bd9b RX(p2\u2082\u2081) 9d192dd5fcb04d18a7f822d6a6040716--3131eff5117e434988607bbc5dc3bd9b b7936b996aa64e4eb2cd80142e7bd383 X 3131eff5117e434988607bbc5dc3bd9b--b7936b996aa64e4eb2cd80142e7bd383 b7936b996aa64e4eb2cd80142e7bd383--a5a871b7ecc14ae8824eceeb87ee9dec 488f20e7226548f3a322c662bd421e07 b7936b996aa64e4eb2cd80142e7bd383--488f20e7226548f3a322c662bd421e07 488f20e7226548f3a322c662bd421e07--b838cdcc3770453cbfa7e72ce90c2c06 dd168719c9b842bcaecd8b35f77f17f8 585d66e894f34ed2a9c27138d3135859 RX(p1\u2082) 0efc9fe5b9d14357aac443bd050ad8fd--585d66e894f34ed2a9c27138d3135859 923e05400410432fb24e8a3cd247ff57 3 fb5b11f70c3641859748d5544648b610 RY(p1\u2086) 585d66e894f34ed2a9c27138d3135859--fb5b11f70c3641859748d5544648b610 e2c49702dde14518bd6ee750f7831da6 RX(p1\u2081\u2080) fb5b11f70c3641859748d5544648b610--e2c49702dde14518bd6ee750f7831da6 e12a6564f07c436489a6be309f663c0b e2c49702dde14518bd6ee750f7831da6--e12a6564f07c436489a6be309f663c0b b102d49fc73f4b8fa049d23050ff35c3 X e12a6564f07c436489a6be309f663c0b--b102d49fc73f4b8fa049d23050ff35c3 b102d49fc73f4b8fa049d23050ff35c3--1e74640b2e534b2aa67ec611c0d4d852 1d5dc6800e764b709293ec18820a4435 RX(p1\u2081\u2084) b102d49fc73f4b8fa049d23050ff35c3--1d5dc6800e764b709293ec18820a4435 1037b308b9e647ae8eee43b1a9450811 RY(p1\u2081\u2088) 1d5dc6800e764b709293ec18820a4435--1037b308b9e647ae8eee43b1a9450811 f5af8181f6784309a5912a557793980a RX(p1\u2082\u2082) 1037b308b9e647ae8eee43b1a9450811--f5af8181f6784309a5912a557793980a e63e77be399c47cda8f053fc98f50c4e f5af8181f6784309a5912a557793980a--e63e77be399c47cda8f053fc98f50c4e bf6f46c5afe64b94b63fee1fd5979912 X e63e77be399c47cda8f053fc98f50c4e--bf6f46c5afe64b94b63fee1fd5979912 bf6f46c5afe64b94b63fee1fd5979912--ce0161424347415885017bb11ef9fe3f 66935f41da4842eebe6d069a54dd67ce RX(p2\u2082) bf6f46c5afe64b94b63fee1fd5979912--66935f41da4842eebe6d069a54dd67ce f65ce27103e349b2a1b6cf78517c55e5 RY(p2\u2086) 66935f41da4842eebe6d069a54dd67ce--f65ce27103e349b2a1b6cf78517c55e5 414c54ffab0b411d954a3fec150c782b RX(p2\u2081\u2080) f65ce27103e349b2a1b6cf78517c55e5--414c54ffab0b411d954a3fec150c782b 905f3dcfe479488ca0e885d9693f4b04 414c54ffab0b411d954a3fec150c782b--905f3dcfe479488ca0e885d9693f4b04 76c06d5522844962a688157558d8ffd6 X 905f3dcfe479488ca0e885d9693f4b04--76c06d5522844962a688157558d8ffd6 76c06d5522844962a688157558d8ffd6--f625752fe53444a1b3064b1e58eb4024 49433a05952046bf8757bdfd5df0f08e RX(p2\u2081\u2084) 76c06d5522844962a688157558d8ffd6--49433a05952046bf8757bdfd5df0f08e 75956f07ba304a8a8a68a89813d6e31e RY(p2\u2081\u2088) 49433a05952046bf8757bdfd5df0f08e--75956f07ba304a8a8a68a89813d6e31e f4da5f9b230344188235442964b1b801 RX(p2\u2082\u2082) 75956f07ba304a8a8a68a89813d6e31e--f4da5f9b230344188235442964b1b801 dbdc8d15cba7480ea27fbc67beb39de0 f4da5f9b230344188235442964b1b801--dbdc8d15cba7480ea27fbc67beb39de0 32aeeb33666048368965e61680e2babf X dbdc8d15cba7480ea27fbc67beb39de0--32aeeb33666048368965e61680e2babf 32aeeb33666048368965e61680e2babf--488f20e7226548f3a322c662bd421e07 32aeeb33666048368965e61680e2babf--dd168719c9b842bcaecd8b35f77f17f8 ca30066c34434552b018d7e3ffbf154b 8681e946a2724541b77713b78af34072 RX(p1\u2083) 923e05400410432fb24e8a3cd247ff57--8681e946a2724541b77713b78af34072 0e98414718fa41efb05bce54a8f9de4d RY(p1\u2087) 8681e946a2724541b77713b78af34072--0e98414718fa41efb05bce54a8f9de4d 151a1f7d03a74784802a7cc544043863 RX(p1\u2081\u2081) 0e98414718fa41efb05bce54a8f9de4d--151a1f7d03a74784802a7cc544043863 2fc6a1ff61e44b399621d01ab93fea0e X 151a1f7d03a74784802a7cc544043863--2fc6a1ff61e44b399621d01ab93fea0e 2fc6a1ff61e44b399621d01ab93fea0e--e12a6564f07c436489a6be309f663c0b f901d158e9c94f2b93310fd5c7202876 2fc6a1ff61e44b399621d01ab93fea0e--f901d158e9c94f2b93310fd5c7202876 6e23d2cb335c4858ba2dec9eda6b548c RX(p1\u2081\u2085) f901d158e9c94f2b93310fd5c7202876--6e23d2cb335c4858ba2dec9eda6b548c a0e8c20a51ee4f9c985baf55b16c55e4 RY(p1\u2081\u2089) 6e23d2cb335c4858ba2dec9eda6b548c--a0e8c20a51ee4f9c985baf55b16c55e4 aef75b09db5549eda5424440a9a3a342 RX(p1\u2082\u2083) a0e8c20a51ee4f9c985baf55b16c55e4--aef75b09db5549eda5424440a9a3a342 cab50551d0af49ee92303e28ab7110f5 X aef75b09db5549eda5424440a9a3a342--cab50551d0af49ee92303e28ab7110f5 cab50551d0af49ee92303e28ab7110f5--e63e77be399c47cda8f053fc98f50c4e 68e67a0c1c2f48909e212f6d1106697d cab50551d0af49ee92303e28ab7110f5--68e67a0c1c2f48909e212f6d1106697d a654d0cb35a144e5952ef261a8e27564 RX(p2\u2083) 68e67a0c1c2f48909e212f6d1106697d--a654d0cb35a144e5952ef261a8e27564 c782c11a18374f69917f763f7be372fa RY(p2\u2087) a654d0cb35a144e5952ef261a8e27564--c782c11a18374f69917f763f7be372fa dee0ea47280a4705a83e6cc7144ae806 RX(p2\u2081\u2081) c782c11a18374f69917f763f7be372fa--dee0ea47280a4705a83e6cc7144ae806 4947f98c804c4d7f81efc4afde9ce468 X dee0ea47280a4705a83e6cc7144ae806--4947f98c804c4d7f81efc4afde9ce468 4947f98c804c4d7f81efc4afde9ce468--905f3dcfe479488ca0e885d9693f4b04 8f361623e2fa4d048a4382c4c9fa21ba 4947f98c804c4d7f81efc4afde9ce468--8f361623e2fa4d048a4382c4c9fa21ba 34a42884c2224b8d807bdfa6f757bd89 RX(p2\u2081\u2085) 8f361623e2fa4d048a4382c4c9fa21ba--34a42884c2224b8d807bdfa6f757bd89 fdd3f29c3e924a7b987a53d98c5157b7 RY(p2\u2081\u2089) 34a42884c2224b8d807bdfa6f757bd89--fdd3f29c3e924a7b987a53d98c5157b7 d68f2a8fada645de8f1900ce168888d4 RX(p2\u2082\u2083) fdd3f29c3e924a7b987a53d98c5157b7--d68f2a8fada645de8f1900ce168888d4 1dc37f9ac818433985c9def4827e1859 X d68f2a8fada645de8f1900ce168888d4--1dc37f9ac818433985c9def4827e1859 1dc37f9ac818433985c9def4827e1859--dbdc8d15cba7480ea27fbc67beb39de0 645560549e2845629ff84aaf9f92ff54 1dc37f9ac818433985c9def4827e1859--645560549e2845629ff84aaf9f92ff54 645560549e2845629ff84aaf9f92ff54--ca30066c34434552b018d7e3ffbf154b </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6723])), ('theta_0', tensor([0.1476])), ('theta_1', tensor([0.6309])), ('theta_10', tensor([0.8657])), ('theta_11', tensor([0.8418])), ('theta_12', tensor([0.1063])), ('theta_13', tensor([0.6077])), ('theta_14', tensor([0.8846])), ('theta_15', tensor([0.9668])), ('theta_16', tensor([0.2565])), ('theta_17', tensor([0.1043])), ('theta_18', tensor([0.9783])), ('theta_19', tensor([0.0618])), ('theta_2', tensor([0.1834])), ('theta_20', tensor([0.4442])), ('theta_21', tensor([0.6389])), ('theta_22', tensor([0.6250])), ('theta_23', tensor([0.5487])), ('theta_3', tensor([0.8038])), ('theta_4', tensor([0.9408])), ('theta_5', tensor([0.4441])), ('theta_6', tensor([0.6926])), ('theta_7', tensor([0.3457])), ('theta_8', tensor([0.6128])), ('theta_9', tensor([0.6174]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6713])), ('theta_0', tensor([0.1486])), ('theta_1', tensor([0.6319])), ('theta_10', tensor([0.8667])), ('theta_11', tensor([0.8428])), ('theta_12', tensor([0.1073])), ('theta_13', tensor([0.6067])), ('theta_14', tensor([0.8856])), ('theta_15', tensor([0.9678])), ('theta_16', tensor([0.2575])), ('theta_17', tensor([0.1033])), ('theta_18', tensor([0.9773])), ('theta_19', tensor([0.0608])), ('theta_2', tensor([0.1844])), ('theta_20', tensor([0.4452])), ('theta_21', tensor([0.6379])), ('theta_22', tensor([0.6260])), ('theta_23', tensor([0.5497])), ('theta_3', tensor([0.8048])), ('theta_4', tensor([0.9418])), ('theta_5', tensor([0.4451])), ('theta_6', tensor([0.6936])), ('theta_7', tensor([0.3467])), ('theta_8', tensor([0.6138])), ('theta_9', tensor([0.6184]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9986+0.0000j,  0.0000-0.0369j,  0.0000-0.0369j, -0.0014+0.0000j],\n        [ 0.9556+0.0000j,  0.0000-0.2059j,  0.0000-0.2059j, -0.0444+0.0000j],\n        [ 0.9810+0.0000j,  0.0000-0.1367j,  0.0000-0.1367j, -0.0190+0.0000j]])\nxs = [Counter({'00': 99, '10': 1}), Counter({'00': 86, '01': 8, '10': 6}), Counter({'00': 95, '01': 4, '10': 1})]\nex = tensor([[0.9973],\n        [0.9113],\n        [0.9619]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9973, 0.9973],\n        [0.9113, 0.9113],\n        [0.9619, 0.9619]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-12-11T15:41:42.234183 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2023-12-11T15:41:42.614563 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'01': 52, '00': 48})]\nSample in little endian = [Counter({'10': 52, '00': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'10': 52, '00': 48})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 88, '01': 12})]\nOn Braket = [Counter({'00': 87, '01': 13})]\nOn Pulser = [Counter({'00': 89, '01': 11})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [0.60466101+0.58392443j 0.        +0.j         0.37628597-0.3896488j\n 0.        +0.j        ]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_f54224870bd04f7f87572fcf5c078fa3 Circuit block cluster_9c1a63de8e9f47c0b1e73b710ed3f5ee Prep block d91c43f637b645af8e5d201857cb9444 0 84e34534809145479dc83a0c13e9c470 d91c43f637b645af8e5d201857cb9444--84e34534809145479dc83a0c13e9c470 e8ddd97055d84827a1a04531fb3fc6c4 1 e401cbe58a1642ac8b758ec224d315c8 RX(theta\u2080) 84e34534809145479dc83a0c13e9c470--e401cbe58a1642ac8b758ec224d315c8 97800fd73efc44b8a19c00dcdeb252bc RY(theta\u2084) e401cbe58a1642ac8b758ec224d315c8--97800fd73efc44b8a19c00dcdeb252bc 069dc93bbee542a9a83007726f9c9068 RX(theta\u2088) 97800fd73efc44b8a19c00dcdeb252bc--069dc93bbee542a9a83007726f9c9068 693edc30e3dd49b98644a97c1175eadb 069dc93bbee542a9a83007726f9c9068--693edc30e3dd49b98644a97c1175eadb 68989a7f628941e290c290659af58732 693edc30e3dd49b98644a97c1175eadb--68989a7f628941e290c290659af58732 c786c66871a242399ad52ff1c4b3a0ce RX(theta\u2081\u2082) 68989a7f628941e290c290659af58732--c786c66871a242399ad52ff1c4b3a0ce be52efadc13341a6bd9b5b133760ad42 RY(theta\u2081\u2086) c786c66871a242399ad52ff1c4b3a0ce--be52efadc13341a6bd9b5b133760ad42 a44494efaf554c9582fab7bf83ab6523 RX(theta\u2082\u2080) be52efadc13341a6bd9b5b133760ad42--a44494efaf554c9582fab7bf83ab6523 dbe4e4f26eb3442b96964bf934ce1009 a44494efaf554c9582fab7bf83ab6523--dbe4e4f26eb3442b96964bf934ce1009 f4fe0a8ad0c34e209be787a6f31aab9d dbe4e4f26eb3442b96964bf934ce1009--f4fe0a8ad0c34e209be787a6f31aab9d 2105a2dba9214f008a9390ae4030366e f4fe0a8ad0c34e209be787a6f31aab9d--2105a2dba9214f008a9390ae4030366e ef9ee374eeac41e293528da19a8fd39b f4888afd8b85453e925a4004767a98a1 e8ddd97055d84827a1a04531fb3fc6c4--f4888afd8b85453e925a4004767a98a1 922017bfc3a849fab1738893c8169596 2 7d4ecc189f93445799bb5670e6ea079d RX(theta\u2081) f4888afd8b85453e925a4004767a98a1--7d4ecc189f93445799bb5670e6ea079d d8193a4aa5d947b29b1230ffc991a387 RY(theta\u2085) 7d4ecc189f93445799bb5670e6ea079d--d8193a4aa5d947b29b1230ffc991a387 834c0299476241f9a99d40e181cfcc53 RX(theta\u2089) d8193a4aa5d947b29b1230ffc991a387--834c0299476241f9a99d40e181cfcc53 1e9521dfeb2c41a0b28023aa0d0a2bea X 834c0299476241f9a99d40e181cfcc53--1e9521dfeb2c41a0b28023aa0d0a2bea 1e9521dfeb2c41a0b28023aa0d0a2bea--693edc30e3dd49b98644a97c1175eadb 6f32e04c735747c5adf91c52e5d73f13 1e9521dfeb2c41a0b28023aa0d0a2bea--6f32e04c735747c5adf91c52e5d73f13 3f4c497a57084c81acf0cdffaee0c042 RX(theta\u2081\u2083) 6f32e04c735747c5adf91c52e5d73f13--3f4c497a57084c81acf0cdffaee0c042 fa73e4ff37224824a862928617c0db5b RY(theta\u2081\u2087) 3f4c497a57084c81acf0cdffaee0c042--fa73e4ff37224824a862928617c0db5b 7e6ec6eb3670488aa1d34a3ae61f7bec RX(theta\u2082\u2081) fa73e4ff37224824a862928617c0db5b--7e6ec6eb3670488aa1d34a3ae61f7bec 75ce104e7e434d4abc7d72cd1498c442 X 7e6ec6eb3670488aa1d34a3ae61f7bec--75ce104e7e434d4abc7d72cd1498c442 75ce104e7e434d4abc7d72cd1498c442--dbe4e4f26eb3442b96964bf934ce1009 29a9b1104a8f4265b5d613181b3c7206 75ce104e7e434d4abc7d72cd1498c442--29a9b1104a8f4265b5d613181b3c7206 29a9b1104a8f4265b5d613181b3c7206--ef9ee374eeac41e293528da19a8fd39b 29d1b959ed7b464986dcd0f68c7f83f2 4e525f2915124b73bb5b6a6778ba05b0 922017bfc3a849fab1738893c8169596--4e525f2915124b73bb5b6a6778ba05b0 3cf7b2c73cf54462acfbfd2521c5aa80 3 51ed73c2345c45c6a238b0e0b1ef2d3a RX(theta\u2082) 4e525f2915124b73bb5b6a6778ba05b0--51ed73c2345c45c6a238b0e0b1ef2d3a b34eb7cf3a4e484697829ae9b0877781 RY(theta\u2086) 51ed73c2345c45c6a238b0e0b1ef2d3a--b34eb7cf3a4e484697829ae9b0877781 5f65a54657834dafa3b7d1c2f96fb80d RX(theta\u2081\u2080) b34eb7cf3a4e484697829ae9b0877781--5f65a54657834dafa3b7d1c2f96fb80d 1dca8ecaecd243dc8c225d9266091169 5f65a54657834dafa3b7d1c2f96fb80d--1dca8ecaecd243dc8c225d9266091169 e310ab78af0f434384b6bbc15baa4d5b X 1dca8ecaecd243dc8c225d9266091169--e310ab78af0f434384b6bbc15baa4d5b e310ab78af0f434384b6bbc15baa4d5b--6f32e04c735747c5adf91c52e5d73f13 8fb8655b1b4d4555ae3b7e155151c684 RX(theta\u2081\u2084) e310ab78af0f434384b6bbc15baa4d5b--8fb8655b1b4d4555ae3b7e155151c684 af5ee18a03f641b99d12e777a00c2caf RY(theta\u2081\u2088) 8fb8655b1b4d4555ae3b7e155151c684--af5ee18a03f641b99d12e777a00c2caf 3982992647354d44b21b1dcf5cb73ea3 RX(theta\u2082\u2082) af5ee18a03f641b99d12e777a00c2caf--3982992647354d44b21b1dcf5cb73ea3 b91305b1b4494960afc6811432962f2c 3982992647354d44b21b1dcf5cb73ea3--b91305b1b4494960afc6811432962f2c e589b979ebef43f18e9957cbe659e2bc X b91305b1b4494960afc6811432962f2c--e589b979ebef43f18e9957cbe659e2bc e589b979ebef43f18e9957cbe659e2bc--29a9b1104a8f4265b5d613181b3c7206 e589b979ebef43f18e9957cbe659e2bc--29d1b959ed7b464986dcd0f68c7f83f2 58fcbc54229e427280c639cca1827244 33dbd89185e848f6972d4bfef948a3d5 X 3cf7b2c73cf54462acfbfd2521c5aa80--33dbd89185e848f6972d4bfef948a3d5 66f79e6a2c524ae6a8a92500566ff7d7 RX(theta\u2083) 33dbd89185e848f6972d4bfef948a3d5--66f79e6a2c524ae6a8a92500566ff7d7 8823849a2b07474ebac332d08d0114ce RY(theta\u2087) 66f79e6a2c524ae6a8a92500566ff7d7--8823849a2b07474ebac332d08d0114ce 2c28f7e81a46438d94f6a20db83dc1b0 RX(theta\u2081\u2081) 8823849a2b07474ebac332d08d0114ce--2c28f7e81a46438d94f6a20db83dc1b0 897b00eedaed4ee7b98cbb761cbee288 X 2c28f7e81a46438d94f6a20db83dc1b0--897b00eedaed4ee7b98cbb761cbee288 897b00eedaed4ee7b98cbb761cbee288--1dca8ecaecd243dc8c225d9266091169 3ba696b82c4740f9a20a5c8d650e2ec6 897b00eedaed4ee7b98cbb761cbee288--3ba696b82c4740f9a20a5c8d650e2ec6 12494a9cc02e49ff9f8e177fd998e30a RX(theta\u2081\u2085) 3ba696b82c4740f9a20a5c8d650e2ec6--12494a9cc02e49ff9f8e177fd998e30a efeb296cf7db42bfa09366b784063df7 RY(theta\u2081\u2089) 12494a9cc02e49ff9f8e177fd998e30a--efeb296cf7db42bfa09366b784063df7 893d9379973041c381e2d0021a6aefc4 RX(theta\u2082\u2083) efeb296cf7db42bfa09366b784063df7--893d9379973041c381e2d0021a6aefc4 0726e73ced9f432d85ecac2bed1bc20a X 893d9379973041c381e2d0021a6aefc4--0726e73ced9f432d85ecac2bed1bc20a 0726e73ced9f432d85ecac2bed1bc20a--b91305b1b4494960afc6811432962f2c 5156b2a222974b3b8465ae75f40f95ef 0726e73ced9f432d85ecac2bed1bc20a--5156b2a222974b3b8465ae75f40f95ef 5156b2a222974b3b8465ae75f40f95ef--58fcbc54229e427280c639cca1827244  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[ 0.2561-0.1032j,  0.0494+0.0587j,  0.3258+0.1880j,  0.2518-0.0606j,\n         -0.3047-0.3365j, -0.0829+0.4560j,  0.2562+0.1226j, -0.1817+0.4180j],\n        [ 0.3139+0.4935j, -0.2357+0.3002j,  0.4257+0.0696j,  0.0326+0.0448j,\n          0.1226-0.1125j, -0.2873+0.1443j, -0.1797-0.3972j, -0.0041-0.0452j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}