{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\nreturn 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n# Global analog RX block.\nblock = AnalogRX(pi)\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 36, '01': 32, '10': 32})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock | None = None,\nbackend: BackendName | str = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nmitigation: Mitigations | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize a generic QuantumModel instance.\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\nsuper().__init__()\nif not isinstance(circuit, QuantumCircuit):\nTypeError(\nf\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n)\nself.inputs = [p for p in circuit.unique_parameters if not p.trainable and not p.is_number]\nif diff_mode is None:\nraise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\nself.backend = backend_factory(\nbackend=backend, diff_mode=diff_mode, configuration=configuration\n)\nif isinstance(observable, list) or observable is None:\nobservable = observable\nelse:\nobservable = [observable]\nconv = self.backend.convert(circuit, observable)\nself.embedding_fn = conv.embedding_fn\nself._circuit = conv.circuit\nself._observable = conv.observable\nself._backend_name = backend\nself._diff_mode = diff_mode\nself._measurement = measurement\nself._noise = noise\nself._mitigation = mitigation\nself._params = nn.ParameterDict(\n{\nstr(key): nn.Parameter(val, requires_grad=val.requires_grad)\nfor key, val in conv.params.items()\n}\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n\"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\nparams = self.embedding_fn(self._params, values)\nreturn self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\nself,\nvalues: dict[str, Tensor] = {},\nobservable: list[ConvertedObservable] | ConvertedObservable | None = None,\nstate: Optional[Tensor] = None,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nmitigation: Mitigations | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute expectation using the given backend.\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\nif observable is None:\nif self._observable is None:\nraise ValueError(\n\"Provide an AbstractBlock as the observable to compute expectation.\"\n\"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n\"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n)\nobservable = self._observable\nparams = self.embedding_fn(self._params, values)\nif measurement is None:\nmeasurement = self._measurement\nif noise is None:\nnoise = self._noise\nif mitigation is None:\nmitigation = self._mitigation\nreturn self.backend.expectation(\ncircuit=self._circuit,\nobservable=observable,\nparam_values=params,\nstate=state,\nmeasurement=measurement,\nnoise=noise,\nmitigation=mitigation,\nendianness=endianness,\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n\"\"\"Reset all the variational parameters with a given list of values.\"\"\"\ncurrent_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\nassert (\nlen(values) == self.num_vparams\n), \"Pass an iterable with the values of all variational parameters\"\nfor i, k in enumerate(current_vparams.keys()):\ncurrent_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN\nfrom qadence import hea, feature_map, hamiltonian_factory, Z\n# create the circuit\nn_qubits, depth = 2, 4\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning = Z)\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n# initialize and use the model\nqnn = QNN(circuit, obs, diff_mode=\"ad\", backend=\"pyqtorch\")\ny = qnn.expectation({\"phi\": torch.rand(3)})\n</code></pre> <pre><code>tensor([[0.7110, 1.4221],\n[1.6172, 3.2344],\n[1.1616, 2.3231]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock,\ntransform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize the QNN.\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\nsuper().__init__(\ncircuit=circuit,\nobservable=observable,\nbackend=backend,\ndiff_mode=diff_mode,\nmeasurement=measurement,\nconfiguration=configuration,\nnoise=noise,\n)\nif self.out_features is None:\nraise ValueError(\"You need to provide at least one observable in the QNN constructor\")\nself.transform = transform if transform else lambda x: x\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\nself,\nvalues: dict[str, Tensor] | Tensor = None,\nstate: Tensor | None = None,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Forward pass of the model.\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n    Args:\n        values (dict[str, Tensor] | Tensor): the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\nif values is None:\nvalues = {}\nif not isinstance(values, dict):\nvalues = self._format_to_dict(values)\nif measurement is None:\nmeasurement = self._measurement\nif noise is None:\nnoise = self._noise\nreturn self.transform(\nself.expectation(\nvalues=values,\nstate=state,\nmeasurement=measurement,\nendianness=endianness,\nnoise=noise,\n)\n)\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\nclass CustomQuantumModel(QuantumModel):\ndef __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\nsuper().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\nself.n_qubits = circuit.n_qubits\n# define some additional parameters which will scale and shift (variationally) the\n# output of the QuantumModel\n# you can use all torch machinery for building those\nself.scale_out = torch.nn.Parameter(torch.ones(1))\nself.shift_out = torch.nn.Parameter(torch.ones(1))\n# override the forward pass of the model\n# the forward pass is the output of your QuantumModel and in this case\n# it's the (scaled) expectation value of the total magnetization with\n# a variable coefficient in front\ndef forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n# scale the observable\nres = self.expectation(values)\n# scale and shift the result before returning\nreturn self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\ndef quantum_circuit(n_qubits):\nx = Parameter(\"x\", trainable=False)\nfm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\nansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\nansatz = chain(ansatz, CNOT(0, n_qubits-1))\nblock = chain(fm, ansatz)\nblock.tag = \"circuit\"\nreturn QuantumCircuit(n_qubits, block)\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 1.0910],\n[-0.3106],\n[-0.0326],\n[-0.2145],\n[-0.1543],\n[-0.5374],\n[-0.5529],\n[-0.0691],\n[-0.0888],\n[-0.4947]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\ndef __init__(\nself,\ntrain_circuit: QuantumCircuit,\ntarget_circuit: QuantumCircuit,\nbackend=\"pyqtorch\",\n):\nsuper().__init__(circuit=train_circuit, backend=backend)\nself.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\ndef forward(self):\nreturn self.overlap_fn()\n# compute the wavefunction of the associated train circuit\ndef wavefunction(self):\nreturn model.overlap_fn.run({})\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\nmodel = LearnHadamard(train_circuit, target_circuit)\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.5337]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\nloss = criterion(torch.tensor([[1.0]]), model())\nreturn loss, {}\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\nmodel, None, optimizer, config, loss_fn=loss_fn\n)\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\nhamiltonian_factory, QuantumCircuit,\nQuantumModel, BackendName, DiffMode)\nimport torch\nn_qubits = 2\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.GPSR)\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\nexp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\nexp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\nexp_val_ad.detach().numpy(),\nlabel=\"f(x)\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_ad.detach().numpy(),\nlabel=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_gpsr.detach().numpy(),\ns=5,\nlabel=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-11-21T16:26:16.942301 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n\"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit and an optional observable to their native representation.\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nmitigation: Mitigations | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n\"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n    representation.\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run a circuit and return the resulting wave function.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\nself,\ncircuit: ConvertedCircuit,\nnoise: Noise,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run a circuit and return the resulting the density matrix.\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1000,\nstate: Tensor | None = None,\nnoise: Noise | None = None,\nmitigation: Mitigations | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bit strings.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n\"\"\"Return as a string the available fields with types of the configuration.\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\nconf_msg = \"\"\nfor _field in fields(self):\nif not _field.name.startswith(\"_\"):\nconf_msg += (\nf\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n)\nreturn conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n\"\"\"Return parameter names for the current backend.\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\nparam_ids: Tuple\n# FIXME: better type hiearchy?\ntypes = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\nif not isinstance(blk, types):\nraise TypeError(f\"Can not infer param name from {type(blk)}\")\nelse:\nif self._use_gate_params:\nparam_ids = tuple(blk.parameters.uuids())\nelse:\nparam_ids = tuple(map(stringify, blk.parameters.expressions()))\nreturn param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\nself, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n\"\"\"Assign numerical values to the circuit parameters.\"\"\"\nif param_values is None:\nreturn circuit.native()\nparams_copy = param_values.copy()\npnames = [p.name for p in circuit.native.parameters]\n# account for fixed parameters\nfor name in param_values.keys():\nif name not in pnames:\nparams_copy.pop(name)\n# make sure that all the parameters are single floats\n# otherwise it won't be accepted by Braket\nnative_params = promote_parameters(params_copy)\n# assign the parameters to the circuit\nassigned_circuit = circuit.native(**native_params)\nreturn assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return a wavefunction in form of a statevector.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Parameters of the circuit (after calling the embedding function on the user-facing parameters).</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The endianness of the wave function.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"\n    Execute the circuit and return a wavefunction in form of a statevector.\n    Arguments:\n        circuit: The circuit that is executed.\n        param_values: Parameters of the circuit (after calling the embedding\n            function on the user-facing parameters).\n        state: Initial state.\n        endianness: The endianness of the wave function.\n    \"\"\"\nif state is not None:\nraise NotImplementedError\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nresults = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\nfinal_circuit.state_vector()  # set simulation type\ntask = self._device.run(final_circuit, 0)\nresults.append(task.result().values[0])\nstates = torch.tensor(np.array(results))\nn_qubits = circuit.abstract.n_qubits\nif endianness != self.native_endianness and n_qubits &gt; 1:\nfrom qadence.transpile import invert_endianness\nstates = invert_endianness(states)\nreturn states\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1,\nstate: Tensor | None = None,\nnoise: Noise | None = None,\nmitigation: Mitigations | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\nif state is not None:\nraise NotImplementedError(\"Braket cannot handle a custom initial state.\")\nif n_shots &lt; 1:\nraise ValueError(\"You can only call sample with n_shots&gt;0.\")\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nsamples = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\ntask = self._device.run(final_circuit, n_shots)\nsamples.append(task.result().measurement_counts)\nif endianness != self.native_endianness:\nfrom qadence.transpile import invert_endianness\nsamples = invert_endianness(samples)\nif noise is not None:\nsamples = apply_noise(noise=noise, samples=samples)\nif mitigation is not None:\nassert noise\nsamples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\nreturn samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>Module</code></p> <p>A class to abstract the operations done by the autodiff engine.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def __init__(\nself,\nbackend: QuantumBackend,\ndiff_mode: DiffMode = DiffMode.AD,\n**psr_args: int | float | None,\n) -&gt; None:\nsuper().__init__()\nself.backend = backend\nself.diff_mode = diff_mode\nself.psr_args = psr_args\n# TODO: Add differentiable overlap calculation\nself._overlap: Callable = None  # type: ignore [assignment]\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of a given observable.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A backend native observable to compute the expectation value from.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>A dict of values for symbolic substitution.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>An initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>A shot-based measurement protocol.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the state.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of expectation values.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nmitigation: Mitigations | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of a given observable.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        observable: A backend native observable to compute the expectation value from.\n        param_values: A dict of values for symbolic substitution.\n        state: An initial state.\n        measurement: A shot-based measurement protocol.\n        endianness: Endianness of the state.\n    Returns:\n        A tensor of expectation values.\n    \"\"\"\nobservable = observable if isinstance(observable, list) else [observable]\ndifferentiable_expectation = DifferentiableExpectation(\nbackend=self.backend,\ncircuit=circuit,\nobservable=observable,\nparam_values=param_values,\nstate=state,\nmeasurement=measurement,\nnoise=noise,\nmitigation=mitigation,\nendianness=endianness,\n)\nif self.diff_mode == DiffMode.AD:\nexpectation = differentiable_expectation.ad\nelif self.diff_mode == DiffMode.ADJOINT:\nexpectation = differentiable_expectation.adjoint\nelse:\ntry:\nfns = get_gpsr_fns()\npsr_fn = fns[self.diff_mode]\nexcept KeyError:\nraise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\nexpectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\nreturn expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Run on the underlying backend.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run on the underlying backend.\"\"\"\nreturn self.backend.run(\ncircuit=circuit, param_values=param_values, state=state, endianness=endianness\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.sample","title":"<code>sample(circuit, param_values, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Sample bitstring from the registered circuit.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>The values of the parameters after embedding</p> <p> TYPE: <code>dict[str, Tensor]</code> </p> <code>n_shots</code> <p>The number of shots. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>A mitigation protocol to apply to noisy samples.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>An iterable with all the sampled bitstrings</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor],\nn_shots: int = 1,\nstate: Tensor | None = None,\nnoise: Noise | None = None,\nmitigation: Mitigations | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bitstring from the registered circuit.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        param_values: The values of the parameters after embedding\n        n_shots: The number of shots. Defaults to 1.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: A mitigation protocol to apply to noisy samples.\n        endianness: Endianness of the resulting bitstrings.\n    Returns:\n        An iterable with all the sampled bitstrings\n    \"\"\"\nwith torch.no_grad():\nreturn self.backend.sample(\ncircuit=circuit,\nparam_values=param_values,\nn_shots=n_shots,\nstate=state,\nnoise=noise,\nmitigation=mitigation,\nendianness=endianness,\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation","title":"<code>DifferentiableExpectation</code>  <code>dataclass</code>","text":"<p>A handler for differentiating expectation estimation using various engines.</p>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation.construct_rules","title":"<code>construct_rules(circuit, observable, psr_fn, **psr_args)</code>  <code>staticmethod</code>","text":"<p>Create a mapping between parameters and PSR functions.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>@staticmethod\ndef construct_rules(\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock],\npsr_fn: Callable,\n**psr_args: int | float | None,\n) -&gt; dict[str, Callable]:\n\"\"\"Create a mapping between parameters and PSR functions.\"\"\"\nuuid_to_eigs = uuid_to_eigen(circuit.block)\n# We currently rely on implicit ordering to match the PSR to the parameter,\n# because we want to cache PSRs.\nparam_to_psr = OrderedDict()\nfor param_id, eigenvalues in uuid_to_eigs.items():\nif eigenvalues is None:\nraise ValueError(\nf\"Eigenvalues are not defined for param_id {param_id}\\n\"\n# f\"of type {type(block)}.\\n\"\n\"PSR cannot be defined in that case.\"\n)\nparam_to_psr[param_id] = psr_fn(eigenvalues, **psr_args)\nfor obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\n# We need the embedded fixed params of the observable in the param_values dict\n# to be able to call expectation. Since torch backward requires\n# a list of param_ids and values of equal length, we need to pass them to PSR too.\n# Since they are constants their gradients are 0.\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\nreturn param_to_psr\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.PSRExpectation","title":"<code>PSRExpectation</code>","text":"<p>             Bases: <code>Function</code></p> <p>Overloads the PyTorch AD system to perform parameter shift rule on quantum circuits.</p>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n\"\"\"Convert Qadence Register to Pulser Register.\"\"\"\ncoords = np.array(list(register.coords.values()))\nreturn PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.IDEALIZED","title":"<code>IDEALIZED = IdealDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.REALISTIC","title":"<code>REALISTIC = RealisticDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit and an optional observable to their native representation.\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.interaction","title":"<code>interaction: Callable | Interaction | str = Interaction.NN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Digital-analog emulation interaction that is used for <code>AnalogBlock</code>s.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\nself,\nops: list[Module],\nqubits: Tuple[int, ...],\nn_qubits: int,\nconfig: Configuration = None,\n):\n\"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n    call to _apply_batch_gate.\n    \"\"\"\nsuper().__init__(n_qubits, ops)\nself.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\nself,\nqubit_support: Tuple[int, ...],\nn_qubits: int,\nblock: TimeEvolutionBlock,\nconfig: Configuration,\n):\nsuper().__init__()\nself.qubit_support = qubit_support\nself.n_qubits = n_qubits\nself.param_names = config.get_param_name(block)\nself.block = block\nif isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\nhmat = block_to_tensor(\nblock.generator,\nqubit_support=self.qubit_support,\nuse_full_support=False,\n)\nhmat = hmat.permute(1, 2, 0)\nself._hamiltonian = lambda x: hmat\nelif isinstance(block.generator, Tensor):\nm = block.generator.to(dtype=cdouble)\nhmat = block_to_tensor(\nMatrixBlock(m, qubit_support=block.qubit_support),\nqubit_support=self.qubit_support,\nuse_full_support=False,\n)\nhmat = hmat.permute(1, 2, 0)\nself._hamiltonian = lambda x: hmat\nelif isinstance(block.generator, sympy.Basic):\nself._hamiltonian = (\nlambda values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n)\n# FIXME Why are we squeezing\nelse:\ndef _hamiltonian(values: dict[str, Tensor]) -&gt; Tensor:\nhmat = _block_to_tensor_embedded(\nblock.generator,  # type: ignore[arg-type]\nvalues=values,\nqubit_support=self.qubit_support,\nuse_full_support=False,\n)\nreturn hmat.permute(1, 2, 0)\nself._hamiltonian = _hamiltonian\nself._time_evolution = lambda values: values[self.param_names[0]]\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n\"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\nreturn _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n\"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\nif len(self.param_names) &gt; 2:\nraise NotImplementedError(\n\"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n)\ndef _generator(val: Tensor) -&gt; Tensor:\nval_copy = values.copy()\nval_copy[self.param_names[1]] = val\nhmat = _block_to_tensor_embedded(\nself.block.generator,  # type: ignore[arg-type]\nvalues=val_copy,\nqubit_support=self.qubit_support,\nuse_full_support=False,\n)\nreturn hmat.permute(1, 2, 0)\nreturn finitediff(\nlambda v: self._unitary(\ntime_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n),\nvalues[self.param_names[1]],\n)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n\"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\nreturn finitediff(\nlambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(values)),\nvalues[self.param_names[0]],\n)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n\"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\nreturn self._unitary(self._hamiltonian(values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Currently, the only implemented differentiation engine is PyTorch but it is easy to add support to another one like Jax.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are implemented by extending the PyTorch autograd engine using custom <code>Function</code> objects. The implementation is based on this PyTorch guide.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\nclass CustomFunction(Function):\n# forward pass implementation giving the output of the module\n@staticmethod\ndef forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\nctx.save_for_backward(inputs, params)\n...\n# backward pass implementation giving the derivative of the module\n# with respect to the parameters. This must return the whole vector-jacobian\n# product to integrate within the autograd engine\n@staticmethod\ndef backward(ctx, grad_output: torch.Tensor):\ninputs, params = ctx.saved_tensors\n...\n</code></pre> <p>The class <code>PSRExpectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\nreturn PSRExpectation.apply(\nctx.expectation_fn,\nctx.param_psrs,\nparams.keys(),\n*params.values(),\n)\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\n</code></pre> %3 b445fe2c07cc4a51834082b1f60be937 0 35b62d591c2c499282e2e1a8169ea8d7 X b445fe2c07cc4a51834082b1f60be937--35b62d591c2c499282e2e1a8169ea8d7 4244785ea52a4eea9f0454f513a8c391 1 ac29e5b0c2d04802aec9d2496b3f8113 35b62d591c2c499282e2e1a8169ea8d7--ac29e5b0c2d04802aec9d2496b3f8113 601c9242d86941408f73c294ffdd62e7 1f0343e90dc3497ba7c00bf2b4fcfe77 Y 4244785ea52a4eea9f0454f513a8c391--1f0343e90dc3497ba7c00bf2b4fcfe77 1f0343e90dc3497ba7c00bf2b4fcfe77--601c9242d86941408f73c294ffdd62e7 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(0))\n</code></pre> %3 1070d66619b34457bee5c383b7d17dc8 0 2a7f29fac3074537b30f19cbb1cb37a8 X 1070d66619b34457bee5c383b7d17dc8--2a7f29fac3074537b30f19cbb1cb37a8 7371409b1d6a4a36ac36f6a17aa57d0f Y 2a7f29fac3074537b30f19cbb1cb37a8--7371409b1d6a4a36ac36f6a17aa57d0f 6306e4f0dfd0451aaf9133f6f0497e8e 7371409b1d6a4a36ac36f6a17aa57d0f--6306e4f0dfd0451aaf9133f6f0497e8e <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(1))\n</code></pre> %3 726fd2d7161342188e8d8a2a3e2ec766 0 6c48ba8c823c4f2ea3d83bb8321e07c7 X 726fd2d7161342188e8d8a2a3e2ec766--6c48ba8c823c4f2ea3d83bb8321e07c7 f573e6aa516b4492b3371f9262a97bf0 1 d7871a91f0b444d6886c2180ecc97b99 6c48ba8c823c4f2ea3d83bb8321e07c7--d7871a91f0b444d6886c2180ecc97b99 897f508dcf3047b99b405970a5cd9e2c d7871a91f0b444d6886c2180ecc97b99--897f508dcf3047b99b405970a5cd9e2c 136dba3e844e4a319282cea0a9deb664 0c2ce1ef270a4714810daa920663a843 f573e6aa516b4492b3371f9262a97bf0--0c2ce1ef270a4714810daa920663a843 76708741a3e94fa589a19d72cabfdc5e Y 0c2ce1ef270a4714810daa920663a843--76708741a3e94fa589a19d72cabfdc5e 76708741a3e94fa589a19d72cabfdc5e--136dba3e844e4a319282cea0a9deb664 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_19a4e2cde5564196aef7b157c501425e b34e0b0306c245168b1b9d628e6b08bb 0 e2594a447e1c42afb2e0dcb3e667d3dc b34e0b0306c245168b1b9d628e6b08bb--e2594a447e1c42afb2e0dcb3e667d3dc 5c4c28cefcbe43b9b817998fa4bbd331 1 5442b271a9e74d74b4fe5fa32fd584a5 e2594a447e1c42afb2e0dcb3e667d3dc--5442b271a9e74d74b4fe5fa32fd584a5 037142ad8a1645dab8e76122bd6e23a6 5e2e6306ac8f4a18a0eced95a69f0adf AddBlock 5c4c28cefcbe43b9b817998fa4bbd331--5e2e6306ac8f4a18a0eced95a69f0adf cf924e2b2e274f7c888cfd1e429cdba6 2 5e2e6306ac8f4a18a0eced95a69f0adf--037142ad8a1645dab8e76122bd6e23a6 b1ed139b3c844404a30b30eedb6b909a 0efbd8964ade46228c8766b78cb0f6f6 cf924e2b2e274f7c888cfd1e429cdba6--0efbd8964ade46228c8766b78cb0f6f6 0efbd8964ade46228c8766b78cb0f6f6--b1ed139b3c844404a30b30eedb6b909a <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n# `chain` puts things in sequence\nblock = chain(\nkron(X(0), Y(1), rx),\nCNOT(2,3),\nHamEvo(gen, 10)\n)\n</code></pre> %3 cluster_9f1069d06737490ab99fd4b81bd5dee1 cluster_0bf988f2ee794366aacc3d470e88652a rx c1a16247b6b64b839c1dbdddab8e88b1 0 7b9ce7b33d2949d8bf2f3c0f82cce7e0 X c1a16247b6b64b839c1dbdddab8e88b1--7b9ce7b33d2949d8bf2f3c0f82cce7e0 6f714eb16d104f7eb844fc6759da4e61 1 d42bb99d034542d9ba6a0e2890346e59 7b9ce7b33d2949d8bf2f3c0f82cce7e0--d42bb99d034542d9ba6a0e2890346e59 a5d67f7645cf4a4a838cda34abd9604e d42bb99d034542d9ba6a0e2890346e59--a5d67f7645cf4a4a838cda34abd9604e 4923e11a39ec48f794add4146173aedc a5d67f7645cf4a4a838cda34abd9604e--4923e11a39ec48f794add4146173aedc 4622e68d0bf2456ca4faa836151ccb15 2a8ac31158604b29b24bb65a230be519 Y 6f714eb16d104f7eb844fc6759da4e61--2a8ac31158604b29b24bb65a230be519 5a11d4dbbc3b4240a67520b062ef6688 2 b5b627b9acc54261b0bd857891ce8531 2a8ac31158604b29b24bb65a230be519--b5b627b9acc54261b0bd857891ce8531 09edde79f09b482c845e9d2e2d627200 HamEvo b5b627b9acc54261b0bd857891ce8531--09edde79f09b482c845e9d2e2d627200 09edde79f09b482c845e9d2e2d627200--4622e68d0bf2456ca4faa836151ccb15 1dd3b4b58bdd4369834fe3365080eea7 b55927b927e549508a621f2aa36d8561 RX(x) 5a11d4dbbc3b4240a67520b062ef6688--b55927b927e549508a621f2aa36d8561 798aea13fe2c4da283e9c46550c3be25 3 a0573f7fe2db4d1e9d805c0214711cda b55927b927e549508a621f2aa36d8561--a0573f7fe2db4d1e9d805c0214711cda 6f5c6be0def54302893746e422cf63b9 t = 10 a0573f7fe2db4d1e9d805c0214711cda--6f5c6be0def54302893746e422cf63b9 6f5c6be0def54302893746e422cf63b9--1dd3b4b58bdd4369834fe3365080eea7 c0dad84b777d4d279ba55f33d119da4c 8c8d2707af4041dfa67197a1d3d49bf4 RX(0.5) 798aea13fe2c4da283e9c46550c3be25--8c8d2707af4041dfa67197a1d3d49bf4 c31b2e29f5954d82adaa754ac71aab98 X 8c8d2707af4041dfa67197a1d3d49bf4--c31b2e29f5954d82adaa754ac71aab98 c31b2e29f5954d82adaa754ac71aab98--a0573f7fe2db4d1e9d805c0214711cda 0b5ec24b13514f58b1938719cf4173e1 c31b2e29f5954d82adaa754ac71aab98--0b5ec24b13514f58b1938719cf4173e1 0b5ec24b13514f58b1938719cf4173e1--c0dad84b777d4d279ba55f33d119da4c <pre><code>from qadence import feature_map, hea, chain\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_14340cfad8fd4b799a15a463820587b0 HEA cluster_8c0f4d004a0746c9bda0a4e943233d98 Tower Fourier FM 5696b2162ced4281a1e5537319462f7e 0 acbb2b7bba744dc6bb65fac1f1b35889 RX(1.0*phi) 5696b2162ced4281a1e5537319462f7e--acbb2b7bba744dc6bb65fac1f1b35889 5e702c2ec73245829bf473b05bfae01d 1 850a64202de440728ab0609fab0a7957 RX(theta\u2080) acbb2b7bba744dc6bb65fac1f1b35889--850a64202de440728ab0609fab0a7957 91666d92c36f4cc8a92c72148665a147 RY(theta\u2084) 850a64202de440728ab0609fab0a7957--91666d92c36f4cc8a92c72148665a147 718ccdbbdd0144f2a742f22f55ad3bc2 RX(theta\u2088) 91666d92c36f4cc8a92c72148665a147--718ccdbbdd0144f2a742f22f55ad3bc2 29e5e3d063474b2b93576f7d731d5520 718ccdbbdd0144f2a742f22f55ad3bc2--29e5e3d063474b2b93576f7d731d5520 bd8350b8a4f047cd8d5f76dab984682f 29e5e3d063474b2b93576f7d731d5520--bd8350b8a4f047cd8d5f76dab984682f 544a375887ca4ef6992c5d632ba1ba46 RX(theta\u2081\u2082) bd8350b8a4f047cd8d5f76dab984682f--544a375887ca4ef6992c5d632ba1ba46 f73eecbc12c04116a836b7225c6d7b17 RY(theta\u2081\u2086) 544a375887ca4ef6992c5d632ba1ba46--f73eecbc12c04116a836b7225c6d7b17 4d858e6cad4e4218aa172658e6b42207 RX(theta\u2082\u2080) f73eecbc12c04116a836b7225c6d7b17--4d858e6cad4e4218aa172658e6b42207 b472b6ebb0294701be96c19e47ee5699 4d858e6cad4e4218aa172658e6b42207--b472b6ebb0294701be96c19e47ee5699 69495ce31864439ba8a4cf4fa7016fe2 b472b6ebb0294701be96c19e47ee5699--69495ce31864439ba8a4cf4fa7016fe2 5c292b6420aa413a936503969df916cf 69495ce31864439ba8a4cf4fa7016fe2--5c292b6420aa413a936503969df916cf 540b6810804b4f8a85636a5971c26b33 5d4d314dcee94b8f8725181d1a1b6eba RX(2.0*phi) 5e702c2ec73245829bf473b05bfae01d--5d4d314dcee94b8f8725181d1a1b6eba bc2d57e771124758b2da2b23983e9167 2 d0da28f43397470aa94a0f4bcb31e299 RX(theta\u2081) 5d4d314dcee94b8f8725181d1a1b6eba--d0da28f43397470aa94a0f4bcb31e299 5e921878b32340fcac12e4b72a27b7df RY(theta\u2085) d0da28f43397470aa94a0f4bcb31e299--5e921878b32340fcac12e4b72a27b7df 9d6d450b3780412e9c86fdf6bcda1285 RX(theta\u2089) 5e921878b32340fcac12e4b72a27b7df--9d6d450b3780412e9c86fdf6bcda1285 f8cb94e91aee41f79b7c0efaebd39fac X 9d6d450b3780412e9c86fdf6bcda1285--f8cb94e91aee41f79b7c0efaebd39fac f8cb94e91aee41f79b7c0efaebd39fac--29e5e3d063474b2b93576f7d731d5520 e2478af016384ab8afd09637b20e712a f8cb94e91aee41f79b7c0efaebd39fac--e2478af016384ab8afd09637b20e712a 76b7858d8e4142b1b38db5dc73962f66 RX(theta\u2081\u2083) e2478af016384ab8afd09637b20e712a--76b7858d8e4142b1b38db5dc73962f66 602193fdc3e14773b1fc493e9e3811f8 RY(theta\u2081\u2087) 76b7858d8e4142b1b38db5dc73962f66--602193fdc3e14773b1fc493e9e3811f8 9b6b91a9f3d14296bcec9ecbeee45b0c RX(theta\u2082\u2081) 602193fdc3e14773b1fc493e9e3811f8--9b6b91a9f3d14296bcec9ecbeee45b0c aa878a1df49144c1944d3f1ee51c499b X 9b6b91a9f3d14296bcec9ecbeee45b0c--aa878a1df49144c1944d3f1ee51c499b aa878a1df49144c1944d3f1ee51c499b--b472b6ebb0294701be96c19e47ee5699 441049805cfb42d4a1ece1ec2b4c0b20 aa878a1df49144c1944d3f1ee51c499b--441049805cfb42d4a1ece1ec2b4c0b20 441049805cfb42d4a1ece1ec2b4c0b20--540b6810804b4f8a85636a5971c26b33 4340039b01994d2e8d4d57b84382a661 1d2c6a9b0d8c44d1b02fd34a63b4663e RX(3.0*phi) bc2d57e771124758b2da2b23983e9167--1d2c6a9b0d8c44d1b02fd34a63b4663e beb82e18fa9145b19ee9bcfb7dbe4125 3 e8b1b930be6349b5a1291ab49a2d2d16 RX(theta\u2082) 1d2c6a9b0d8c44d1b02fd34a63b4663e--e8b1b930be6349b5a1291ab49a2d2d16 9f9ec7166ccc4b9e8851b87eb5682c26 RY(theta\u2086) e8b1b930be6349b5a1291ab49a2d2d16--9f9ec7166ccc4b9e8851b87eb5682c26 a0cd7e66c53141a5bacf7580f058402e RX(theta\u2081\u2080) 9f9ec7166ccc4b9e8851b87eb5682c26--a0cd7e66c53141a5bacf7580f058402e b8ef476ef0274133bbf9a4cd8fbdd3f9 a0cd7e66c53141a5bacf7580f058402e--b8ef476ef0274133bbf9a4cd8fbdd3f9 a668e0c8d44541189a3f05b135162709 X b8ef476ef0274133bbf9a4cd8fbdd3f9--a668e0c8d44541189a3f05b135162709 a668e0c8d44541189a3f05b135162709--e2478af016384ab8afd09637b20e712a d44643ae310342f8828496d79c719fe1 RX(theta\u2081\u2084) a668e0c8d44541189a3f05b135162709--d44643ae310342f8828496d79c719fe1 fe119851797c43f8bb2da7255996a32f RY(theta\u2081\u2088) d44643ae310342f8828496d79c719fe1--fe119851797c43f8bb2da7255996a32f 0912a77fd61048b295acc6d2268849d9 RX(theta\u2082\u2082) fe119851797c43f8bb2da7255996a32f--0912a77fd61048b295acc6d2268849d9 b126fe3667f14ab0b8f3c92b8ec39b58 0912a77fd61048b295acc6d2268849d9--b126fe3667f14ab0b8f3c92b8ec39b58 bb066b7d92fb46b184674fa0539d9371 X b126fe3667f14ab0b8f3c92b8ec39b58--bb066b7d92fb46b184674fa0539d9371 bb066b7d92fb46b184674fa0539d9371--441049805cfb42d4a1ece1ec2b4c0b20 bb066b7d92fb46b184674fa0539d9371--4340039b01994d2e8d4d57b84382a661 d8e2f32438144fb0af9e5b0595728a68 f16930ca337349dfbaeddaca4fa65839 RX(4.0*phi) beb82e18fa9145b19ee9bcfb7dbe4125--f16930ca337349dfbaeddaca4fa65839 32c312bd11054850a52ad5dbdbe11e22 RX(theta\u2083) f16930ca337349dfbaeddaca4fa65839--32c312bd11054850a52ad5dbdbe11e22 ec901bb3bc9448eaa27c30d7e2479bea RY(theta\u2087) 32c312bd11054850a52ad5dbdbe11e22--ec901bb3bc9448eaa27c30d7e2479bea bb96b5944ce14551ab33b476e03c5f5a RX(theta\u2081\u2081) ec901bb3bc9448eaa27c30d7e2479bea--bb96b5944ce14551ab33b476e03c5f5a 543d375877c04711b5fb34913435023c X bb96b5944ce14551ab33b476e03c5f5a--543d375877c04711b5fb34913435023c 543d375877c04711b5fb34913435023c--b8ef476ef0274133bbf9a4cd8fbdd3f9 c9f6534c0de64f5fba7668aa47b0d516 543d375877c04711b5fb34913435023c--c9f6534c0de64f5fba7668aa47b0d516 65bd417211eb4169977ef34ed4eee9f6 RX(theta\u2081\u2085) c9f6534c0de64f5fba7668aa47b0d516--65bd417211eb4169977ef34ed4eee9f6 28d8abb49130454f98b2c32f20d56015 RY(theta\u2081\u2089) 65bd417211eb4169977ef34ed4eee9f6--28d8abb49130454f98b2c32f20d56015 1e1014650ae64f348478334480c37848 RX(theta\u2082\u2083) 28d8abb49130454f98b2c32f20d56015--1e1014650ae64f348478334480c37848 79062146212947749c02231e60f466e7 X 1e1014650ae64f348478334480c37848--79062146212947749c02231e60f466e7 79062146212947749c02231e60f466e7--b126fe3667f14ab0b8f3c92b8ec39b58 6d4199ebab614fac97fe51b47071c993 79062146212947749c02231e60f466e7--6d4199ebab614fac97fe51b47071c993 6d4199ebab614fac97fe51b47071c993--d8e2f32438144fb0af9e5b0595728a68 <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_e6090e7257004be582202914c63f21d2 Obs. cluster_623327e272fc40abbba5baa55f5737da cluster_0568175e17f2415793dcf700dc3f3b58 HEA e4d1ff163edc4580b7ab6ede70114083 0 85c74a807aed437a8886a8311909bece RX(theta\u2080) e4d1ff163edc4580b7ab6ede70114083--85c74a807aed437a8886a8311909bece 983238dcb20a480fbcf6cfc8e532f578 1 e9064aa0f8b34c8386797388fd2cd74e RY(theta\u2083) 85c74a807aed437a8886a8311909bece--e9064aa0f8b34c8386797388fd2cd74e 2b75220716074b7da7f3101b651d0e04 RX(theta\u2086) e9064aa0f8b34c8386797388fd2cd74e--2b75220716074b7da7f3101b651d0e04 49f3dfe1614d4a538cfc2012d1e2614b 2b75220716074b7da7f3101b651d0e04--49f3dfe1614d4a538cfc2012d1e2614b b37239b8f8af4653bc1d327fb2c32e5c 49f3dfe1614d4a538cfc2012d1e2614b--b37239b8f8af4653bc1d327fb2c32e5c cff74f965bab440181608729c9b5b57d RX(theta\u2089) b37239b8f8af4653bc1d327fb2c32e5c--cff74f965bab440181608729c9b5b57d dd012a54176a420c82abf51e46ffa491 RY(theta\u2081\u2082) cff74f965bab440181608729c9b5b57d--dd012a54176a420c82abf51e46ffa491 b086f134780f4ed88554a5d0cb3435d2 RX(theta\u2081\u2085) dd012a54176a420c82abf51e46ffa491--b086f134780f4ed88554a5d0cb3435d2 b092abcc06a74905a16ed557964dd531 b086f134780f4ed88554a5d0cb3435d2--b092abcc06a74905a16ed557964dd531 ff41fca00bd94004b79db151bc4e1dc6 b092abcc06a74905a16ed557964dd531--ff41fca00bd94004b79db151bc4e1dc6 c8bd1cb7162c4e839854fc62e2b5ef08 ff41fca00bd94004b79db151bc4e1dc6--c8bd1cb7162c4e839854fc62e2b5ef08 ecbb7c1fc3e649e5a75dbbfb390878ac c8bd1cb7162c4e839854fc62e2b5ef08--ecbb7c1fc3e649e5a75dbbfb390878ac 6709306417424d71ab5486c76ef47c96 3003dbe8255c451dbfe72ad5745be6b5 RX(theta\u2081) 983238dcb20a480fbcf6cfc8e532f578--3003dbe8255c451dbfe72ad5745be6b5 191b5c20ea864778bb8c555961a1781b 2 6d0dd480225a4bcf9ff3c7a6c32815b7 RY(theta\u2084) 3003dbe8255c451dbfe72ad5745be6b5--6d0dd480225a4bcf9ff3c7a6c32815b7 2e7cc1d414cd416c9708f7eac5d3caed RX(theta\u2087) 6d0dd480225a4bcf9ff3c7a6c32815b7--2e7cc1d414cd416c9708f7eac5d3caed 1ddb67ca2ea94e1d85a0becd31760b8f X 2e7cc1d414cd416c9708f7eac5d3caed--1ddb67ca2ea94e1d85a0becd31760b8f 1ddb67ca2ea94e1d85a0becd31760b8f--49f3dfe1614d4a538cfc2012d1e2614b d2403ea863ca469f8936567d5dcbf55d 1ddb67ca2ea94e1d85a0becd31760b8f--d2403ea863ca469f8936567d5dcbf55d f9351f6d900248e0afa00c9c97f3ce7c RX(theta\u2081\u2080) d2403ea863ca469f8936567d5dcbf55d--f9351f6d900248e0afa00c9c97f3ce7c 4cee25d3c6c14eb38dc28f618a3e8a4a RY(theta\u2081\u2083) f9351f6d900248e0afa00c9c97f3ce7c--4cee25d3c6c14eb38dc28f618a3e8a4a 4f647cd0faf947eab5e7563cbbeb0ab0 RX(theta\u2081\u2086) 4cee25d3c6c14eb38dc28f618a3e8a4a--4f647cd0faf947eab5e7563cbbeb0ab0 4a878c814d9548fcb57053f9570e3bab X 4f647cd0faf947eab5e7563cbbeb0ab0--4a878c814d9548fcb57053f9570e3bab 4a878c814d9548fcb57053f9570e3bab--b092abcc06a74905a16ed557964dd531 2401c4b066ec4ae08fad66c1ea4d565a 4a878c814d9548fcb57053f9570e3bab--2401c4b066ec4ae08fad66c1ea4d565a 48fcf48c5d1446618922dd4a8a68101f AddBlock 2401c4b066ec4ae08fad66c1ea4d565a--48fcf48c5d1446618922dd4a8a68101f 48fcf48c5d1446618922dd4a8a68101f--6709306417424d71ab5486c76ef47c96 360006705b24499bac2d355b78068fe8 c7a20b6029ad424ea228eb2f3ecf5939 RX(theta\u2082) 191b5c20ea864778bb8c555961a1781b--c7a20b6029ad424ea228eb2f3ecf5939 f98928fa7a8445bfbab080ad69da9db7 RY(theta\u2085) c7a20b6029ad424ea228eb2f3ecf5939--f98928fa7a8445bfbab080ad69da9db7 010ebc896b0b472d9ce8475f58b6b261 RX(theta\u2088) f98928fa7a8445bfbab080ad69da9db7--010ebc896b0b472d9ce8475f58b6b261 5ab4b638e4bc4172a0d18072993cffd6 010ebc896b0b472d9ce8475f58b6b261--5ab4b638e4bc4172a0d18072993cffd6 5ebb5b40381d47709ca392fc4f16639d X 5ab4b638e4bc4172a0d18072993cffd6--5ebb5b40381d47709ca392fc4f16639d 5ebb5b40381d47709ca392fc4f16639d--d2403ea863ca469f8936567d5dcbf55d 1a50152f1caa45afa6fe7692502a7bf3 RX(theta\u2081\u2081) 5ebb5b40381d47709ca392fc4f16639d--1a50152f1caa45afa6fe7692502a7bf3 86b5f4b4e82944e08c4a2166b45dfdce RY(theta\u2081\u2084) 1a50152f1caa45afa6fe7692502a7bf3--86b5f4b4e82944e08c4a2166b45dfdce c5334eb2d8ed494780406eea4c996c66 RX(theta\u2081\u2087) 86b5f4b4e82944e08c4a2166b45dfdce--c5334eb2d8ed494780406eea4c996c66 08b43f54fac04e008901fbeae8a5069b c5334eb2d8ed494780406eea4c996c66--08b43f54fac04e008901fbeae8a5069b ceaea6df7e6c46c69bf4318a5ca94f12 X 08b43f54fac04e008901fbeae8a5069b--ceaea6df7e6c46c69bf4318a5ca94f12 ceaea6df7e6c46c69bf4318a5ca94f12--2401c4b066ec4ae08fad66c1ea4d565a ae149535eeb04466926b8c1a17f44cd3 ceaea6df7e6c46c69bf4318a5ca94f12--ae149535eeb04466926b8c1a17f44cd3 ae149535eeb04466926b8c1a17f44cd3--360006705b24499bac2d355b78068fe8"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\ngraph_attr = {\n\"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n\"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n\"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n\"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\nnode_attr = {\n\"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n\"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n\"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\ndefault_cluster_attr = {\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n\"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\nhamevo_cluster_attr = {\n\"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Add start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\nhamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Define start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n# Define more nodes\nfor i in range(4):\nh.node(f\"b{i}\", group=f\"{i}\")\nfor i in range(4):\nh.edge(f's{i}', f'a{i}')\nh.edge(f'a{i}', f'b{i}')\nh.edge(f'b{i}', f'e{i}')\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and significant changes to the interface should be expected in the near-future. Nevertheless, the currest version serves as a prototype of the functionality, and any feedback is greatly appreciated.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states.</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. In this tutorial we do not use any information regarding the edges of the register graph, only the coordinates of each node that are used to compute the distance \\(r_{ij}\\) in the interaction term. Below, we create a line register of three qubits directly from the coordinates.</p> <pre><code>from qadence import Register\ndx = 8.0  # Atom spacing in \u03bcm\nreg = Register.from_coordinates([(0, 0), (dx, 0), (2*dx, 0)])\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from math import pi\nfrom qadence import AnalogRot\nrot_op = AnalogRot(\nduration = 500., # [ns]\nomega = pi, # [rad/\u03bcs]\ndelta = pi, # [rad/\u03bcs]\nphase = pi, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n-0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run\nfrom qadence.analog.utils import C6_DICT\nfrom math import pi, cos, sin\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n# Parameters used in the AnalogRot\nduration = 500.\nomega = pi\ndelta = pi\nphase = pi\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n# Building the interaction Hamiltonian\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\nh_int = c_6 * (\n1/(dx**6) * (N(0)@N(1)) +\n1/(dx**6) * (N(1)@N(2)) +\n1/((2*dx)**6) * (N(0)@N(2))\n)\nhamiltonian = h_x + h_y + h_n + h_int\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n-0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\nreg,\nrot_op,\nbackend = BackendName.PULSER,\n)\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n-0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run\nfrom math import pi\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0), (2*dx, 0)])\nn_qubits = 3\n# Rotation angle\ntheta = pi\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n# Some random initial state\ninit_state = random_state(n_qubits)\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\nreg,\nrot_analog,\nstate = init_state,\nbackend = BackendName.PYQTORCH\n)\nwf_digital_pyq = run(\nreg,\nrot_digital,\nstate = init_state,\nbackend = BackendName.PYQTORCH\n)\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\nreg,\nrot_analog,\nstate = init_state,\nbackend = BackendName.PULSER,\n)\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>wait</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, wait, run\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0), (2*dx, 0)])\nn_qubits = 3\nduration = 1000.\nop = wait(duration = duration)\ninit_state = random_state(n_qubits)\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#some-technical-details","title":"Some technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but are under revision for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all the Analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>wait</code> operation initializes a <code>WaitBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = \"global\"</code>. However, the blocks do support local qubit supports, with some constraints. The main constraint is that using <code>kron</code> on operators with different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\ntry:\nblock = kron(rot_0, rot_1)\nexcept ValueError as error:\nprint(\"Error:\", error)\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block:</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, wait\nfrom sympy import acos\n# Line register\nn_qubits = 2\ndx = 8.0  # Atom spacing in \u03bcm\ncoordinates = [(i*dx, 0) for i in range(n_qubits)]\nregister = Register.from_coordinates(coordinates)\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n# Feature map with a few global analog rotations\nfm = chain(\nAnalogRX(x),\nAnalogRY(2*x),\nAnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\nAnalogRX(\"tht_0\"),\nAnalogRY(\"tht_1\"),\nAnalogRZ(\"tht_2\"),\nwait(t_0),\nAnalogRX(\"tht_3\"),\nAnalogRY(\"tht_4\"),\nAnalogRZ(\"tht_5\"),\nwait(t_1),\nAnalogRX(\"tht_6\"),\nAnalogRY(\"tht_7\"),\nAnalogRZ(\"tht_8\"),\nwait(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\nmodel = QuantumModel(\ncircuit,\nobservable = observable,\nbackend = BackendName.PYQTORCH,\ndiff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n# Function to fit:\ndef f(x):\nreturn x**2\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(x_train, y_train):\nout = model.expectation({\"x\": x_train})\nloss = mse_loss(out.squeeze(), y_train)\nreturn loss\nn_epochs = 200\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_fn(x_train, y_train)\nloss.backward()\noptimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2023-11-21T16:26:20.702501 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>Warning</p> <p>Tutorial to be updated</p> <p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom pulser.devices import Chadoq2\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\ndef qubo_register_coords(Q):\n\"\"\"Compute coordinates for register.\"\"\"\nbitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\ncosts = []\n# this takes exponential time with the dimension of the QUBO\nfor b in bitstrings:\nz = np.array(list(b), dtype=int)\ncost = z.T @ Q @ z\ncosts.append(cost)\nzipped = zip(bitstrings, costs)\nsort_zipped = sorted(zipped, key=lambda x: x[1])\ndef evaluate_mapping(new_coords, *args):\n\"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\nQ, shape = args\nnew_coords = np.reshape(new_coords, shape)\nnew_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\nreturn np.linalg.norm(new_Q - Q)\nshape = (len(Q), 2)\ncosts = []\nnp.random.seed(0)\nx0 = np.random.random(shape).flatten()\nres = minimize(\nevaluate_mapping,\nx0,\nargs=(Q, shape),\nmethod=\"Nelder-Mead\",\ntol=1e-6,\noptions={\"maxiter\": 200000, \"maxfev\": None},\n)\nreturn [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom qadence import add_interaction, chain\nfrom qadence import QuantumModel, QuantumCircuit, AnalogRZ, AnalogRX, Register\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\nz = np.array(list(bitstring), dtype=int)\ncost = z.T @ Q @ z\nreturn cost\n# Cost function.\ndef cost_fn(counter, Q):\ncost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\nreturn cost / sum(counter.values())  # Divide by total samples\n# Weights.\nQ = np.array(\n[\n[-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n[19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n[19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n[5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n[5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n]\n)\n</code></pre> <p>Now, build a weighted register graph from the QUBO definition similarly to what is done in Pulser.</p> <pre><code>reg = Register.from_coordinates(qubo_register_coords(Q))\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70.</p> <pre><code>from qadence.analog.utils import ising_interaction\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\nemulated = add_interaction(\nreg, block, interaction=lambda r, ps: ising_interaction(r, ps, rydberg_level=70)\n)\n</code></pre> <pre><code>emulated = ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u2502   \u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430074584827*t0']]\n\u2502   \u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279670303258*s0']]\n\u2514\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430074584827*t1']]\n\u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279670303258*s1']]\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(QuantumCircuit(reg, emulated), backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 470, '01000': 89, '00100': 86, '10000': 76, '00001': 74, '00010': 72, '00101': 19, '11000': 18, '10010': 13, '01001': 12, '10100': 12, '00011': 11, '00110': 11, '01100': 8, '10001': 8, '01010': 7, '01101': 3, '10110': 3, '00111': 2, '10011': 2, '11010': 2, '01011': 1, '10101': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\nQ = args[0]\nparam = torch.tensor(param)\nmodel.reset_vparams(param)\nC = model.sample({}, n_shots=1000)[0]\nreturn cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\nres = minimize(\nloss,\nargs=Q,\nx0=np.random.uniform(1, 10, size=2 * layers),\nmethod=\"COBYLA\",\ntol=1e-8,\noptions={\"maxiter\": 20},\n)\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 243, '01011': 200, '00100': 103, '01000': 97, '01001': 82, '00110': 72, '00000': 61, '00001': 33, '00010': 25, '10000': 23, '01010': 16, '00101': 14, '10001': 7, '10011': 7, '01111': 5, '10010': 5, '01101': 4, '00011': 2, '01100': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-11-21T16:26:22.575454 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\nn_qubits = 2\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\nH(1),\ncphase_evo,\nH(1)\n)\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n# Interaction strength.\ng_int = 1.0\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\nfor j in range(i):\ninteraction_list.append(g_int * kron(N(i), N(j)))\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\nn_qubits=3,        # Total number of qubits in the transformation\ngen_target=h_int,  # The target Ising generator\nt_f=torch.pi,      # The target evolution time\ngen_build=h_sys,   # The building block Ising generator to be used\nstrategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\nignore_global_phases=False  # Global phases from mapping between Z and N\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_cd5a91b7052547b2a71a7e77bd275fbb cluster_f93db6c507164943a3532ab8f8add187 cluster_5a003eb3b2ce479f96f5841a851533cc cluster_8291819387e34195a63d800e9a5aaa8e cluster_db07f13187394db0ae31d5eeb3e8b3f0 cluster_5ed9571bdb8845ef8b4b7f98fcd436a3 cluster_1f7fbd3130ca4b65be4a62bfd88e355b 670577b461414242866dd723e3d9a0ec 0 d0109edef03b4dc4b3f8e6ae7ade1af6 HamEvo 670577b461414242866dd723e3d9a0ec--d0109edef03b4dc4b3f8e6ae7ade1af6 5644ef717cf34673890dd59ee4bd9d21 1 44699ef68fbf4ca3a7d7994e48ba84fa HamEvo d0109edef03b4dc4b3f8e6ae7ade1af6--44699ef68fbf4ca3a7d7994e48ba84fa cc6e0c4c43984dccaaa5b3dfaa1b3857 HamEvo 44699ef68fbf4ca3a7d7994e48ba84fa--cc6e0c4c43984dccaaa5b3dfaa1b3857 c6f4f6e0dbc04adcaf52a2d022c20040 X cc6e0c4c43984dccaaa5b3dfaa1b3857--c6f4f6e0dbc04adcaf52a2d022c20040 26a925fac1c3433bb1a4d73290ee7ed6 HamEvo c6f4f6e0dbc04adcaf52a2d022c20040--26a925fac1c3433bb1a4d73290ee7ed6 3633d33f9d194bd98dceffa2f34d04d8 HamEvo 26a925fac1c3433bb1a4d73290ee7ed6--3633d33f9d194bd98dceffa2f34d04d8 e2e587f9290a45639625a8967788987e X 3633d33f9d194bd98dceffa2f34d04d8--e2e587f9290a45639625a8967788987e ac8c4b4895e244d6b05c7b962164f0a5 e2e587f9290a45639625a8967788987e--ac8c4b4895e244d6b05c7b962164f0a5 9bd0dac3b5fe440e87b08e5535c66deb HamEvo ac8c4b4895e244d6b05c7b962164f0a5--9bd0dac3b5fe440e87b08e5535c66deb 87f9c863211142aeb77b4705369b84eb HamEvo 9bd0dac3b5fe440e87b08e5535c66deb--87f9c863211142aeb77b4705369b84eb 289d6e621b484cf6b7d1fa1e32915022 87f9c863211142aeb77b4705369b84eb--289d6e621b484cf6b7d1fa1e32915022 34bd6d7fafe14b689128ae982abf90a4 289d6e621b484cf6b7d1fa1e32915022--34bd6d7fafe14b689128ae982abf90a4 2d93b4edd83d4d81b3f3002b1ed2d9ca d9d0d19d2e2e42daadc90516256db87c t = -3.142 5644ef717cf34673890dd59ee4bd9d21--d9d0d19d2e2e42daadc90516256db87c 4dda412525104e169456b9a69d899883 2 61a71ce2e4cb4dee9e1ad3f6eceff493 t = 3.142 d9d0d19d2e2e42daadc90516256db87c--61a71ce2e4cb4dee9e1ad3f6eceff493 9a01abcb415d4fef805d3ffd07a41ca5 t = -3.142 61a71ce2e4cb4dee9e1ad3f6eceff493--9a01abcb415d4fef805d3ffd07a41ca5 335c2dfd383d410bb5310fc5cfdf4e7e 9a01abcb415d4fef805d3ffd07a41ca5--335c2dfd383d410bb5310fc5cfdf4e7e 8ade2ce9a02d4aa586f55f29d281b15a t = 1.571 335c2dfd383d410bb5310fc5cfdf4e7e--8ade2ce9a02d4aa586f55f29d281b15a 27bc75de34164f878728f5a87f6cf75c t = 1.571 8ade2ce9a02d4aa586f55f29d281b15a--27bc75de34164f878728f5a87f6cf75c 60cbce39edcd4da59d846daf0fff1009 27bc75de34164f878728f5a87f6cf75c--60cbce39edcd4da59d846daf0fff1009 ee589dd8e42d4db09faaf0cf6f0d1566 X 60cbce39edcd4da59d846daf0fff1009--ee589dd8e42d4db09faaf0cf6f0d1566 c5416ac2e0d24e5988235ab079bdc33f t = 1.571 ee589dd8e42d4db09faaf0cf6f0d1566--c5416ac2e0d24e5988235ab079bdc33f a89b0787ed7d40e096550452ffffd27b t = 1.571 c5416ac2e0d24e5988235ab079bdc33f--a89b0787ed7d40e096550452ffffd27b dfef32f4c7ec4aed93ab2f6fdbd72a0d X a89b0787ed7d40e096550452ffffd27b--dfef32f4c7ec4aed93ab2f6fdbd72a0d dfef32f4c7ec4aed93ab2f6fdbd72a0d--2d93b4edd83d4d81b3f3002b1ed2d9ca 106b383274ad45a6b88345520cfdd448 700a953ea3684b649b727fb169b7a73a 4dda412525104e169456b9a69d899883--700a953ea3684b649b727fb169b7a73a 9cf0734ef5114792bb836855436cce4a 700a953ea3684b649b727fb169b7a73a--9cf0734ef5114792bb836855436cce4a 3ed4da80fc1f4cf89a515b64f46d0f13 9cf0734ef5114792bb836855436cce4a--3ed4da80fc1f4cf89a515b64f46d0f13 e2f6e72488a0423aa52e45fa511a3439 X 3ed4da80fc1f4cf89a515b64f46d0f13--e2f6e72488a0423aa52e45fa511a3439 f02331dc7d1d4d18abf0573060e2c69f e2f6e72488a0423aa52e45fa511a3439--f02331dc7d1d4d18abf0573060e2c69f 25883870b53a413a929ccf86c671bdbc f02331dc7d1d4d18abf0573060e2c69f--25883870b53a413a929ccf86c671bdbc b7e75598e4fd4617a0f7bce72cfd0c97 X 25883870b53a413a929ccf86c671bdbc--b7e75598e4fd4617a0f7bce72cfd0c97 77897eb33c0042cc8f09135b18bbd8d5 X b7e75598e4fd4617a0f7bce72cfd0c97--77897eb33c0042cc8f09135b18bbd8d5 e85acc615f91422fb1d8673d6b62556e 77897eb33c0042cc8f09135b18bbd8d5--e85acc615f91422fb1d8673d6b62556e 643331d5939340caa481ea9b5f01cd0a e85acc615f91422fb1d8673d6b62556e--643331d5939340caa481ea9b5f01cd0a 0f887a178d6e455eb4dd387b1128bd75 X 643331d5939340caa481ea9b5f01cd0a--0f887a178d6e455eb4dd387b1128bd75 0f887a178d6e455eb4dd387b1128bd75--106b383274ad45a6b88345520cfdd448 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\ncnot_daqc = chain(\nH(j),\ntransformed_ising,\nH(j)\n)\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\nreturn g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=1.0),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_d9451a8bcba84e819f420b13fad2864e cluster_5f3e29d339f84a7bb54830783053c3ea b7714f79e388491cb1cecfd2312b41fe 0 e74a2801ddce4072a451df775a6130fa X b7714f79e388491cb1cecfd2312b41fe--e74a2801ddce4072a451df775a6130fa 5fcdefaf52da44098048039482659b06 1 7627bf045b3842d3a70aa3fa810a8611 HamEvo e74a2801ddce4072a451df775a6130fa--7627bf045b3842d3a70aa3fa810a8611 7f7620f7f70347649424468db9ca94c8 X 7627bf045b3842d3a70aa3fa810a8611--7f7620f7f70347649424468db9ca94c8 d7411749f1834ec28022bec5b81e8a42 7f7620f7f70347649424468db9ca94c8--d7411749f1834ec28022bec5b81e8a42 6ccba372ff474dc998f60ef0c8ce7f9d HamEvo d7411749f1834ec28022bec5b81e8a42--6ccba372ff474dc998f60ef0c8ce7f9d 8d39b4b6ad5e4fa68b8432f94343d99e 6ccba372ff474dc998f60ef0c8ce7f9d--8d39b4b6ad5e4fa68b8432f94343d99e 5ac2942800614c31a66d48a0350ebabb 8d39b4b6ad5e4fa68b8432f94343d99e--5ac2942800614c31a66d48a0350ebabb 8da78f9c4ccf4099adc1e2ddc5604c86 6b8f953f079c48d59f36feabd5e246a0 5fcdefaf52da44098048039482659b06--6b8f953f079c48d59f36feabd5e246a0 af692a8c11594f67a54c1b5e76e7dc99 2 0a654114634744e39f88cc6f9026d472 t = -0.500 6b8f953f079c48d59f36feabd5e246a0--0a654114634744e39f88cc6f9026d472 f7396331328646eca5de3e81a4c8d21d 0a654114634744e39f88cc6f9026d472--f7396331328646eca5de3e81a4c8d21d 93129dd647d242e3a4c0ae520028cd3f X f7396331328646eca5de3e81a4c8d21d--93129dd647d242e3a4c0ae520028cd3f 47989723642d4031bc7ef56e760922d1 t = -0.500 93129dd647d242e3a4c0ae520028cd3f--47989723642d4031bc7ef56e760922d1 5d358420201e4ed79b28b2fe2b2262fe X 47989723642d4031bc7ef56e760922d1--5d358420201e4ed79b28b2fe2b2262fe 5d358420201e4ed79b28b2fe2b2262fe--8da78f9c4ccf4099adc1e2ddc5604c86 d145faad2d084df59287716af877c28a 683935a0fa5741bd917d9094237f88f1 X af692a8c11594f67a54c1b5e76e7dc99--683935a0fa5741bd917d9094237f88f1 f4ac20c808714f088fb3dbdfc18011e3 683935a0fa5741bd917d9094237f88f1--f4ac20c808714f088fb3dbdfc18011e3 0e263847658e43b6b06ce49f2c404e65 X f4ac20c808714f088fb3dbdfc18011e3--0e263847658e43b6b06ce49f2c404e65 bd38e15a14cc4e1d9f9d0132963d04ad X 0e263847658e43b6b06ce49f2c404e65--bd38e15a14cc4e1d9f9d0132963d04ad 67499f152db04395a8dadc59976cdab2 bd38e15a14cc4e1d9f9d0132963d04ad--67499f152db04395a8dadc59976cdab2 9bb21266fefd4f10a029c67a038b7d72 X 67499f152db04395a8dadc59976cdab2--9bb21266fefd4f10a029c67a038b7d72 9bb21266fefd4f10a029c67a038b7d72--d145faad2d084df59287716af877c28a <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=0.001),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_e6ae668bfa4a4dce80ca55f8baca9d49 cluster_3f74fd4e17af43d586f49fea511164e1 46956a9de5d44d2fb0133b6be2515ffa 0 0ed30c3094134fe9abae18f285670e86 X 46956a9de5d44d2fb0133b6be2515ffa--0ed30c3094134fe9abae18f285670e86 b867fffda1634d9188bad022aadc099e 1 c7b7a0eb716648eb9e02c5bd9c7f9737 HamEvo 0ed30c3094134fe9abae18f285670e86--c7b7a0eb716648eb9e02c5bd9c7f9737 49cba16429f342449cdb5efac05a0dfb X c7b7a0eb716648eb9e02c5bd9c7f9737--49cba16429f342449cdb5efac05a0dfb 00f2bff416c74b1e9610d6dd1d2d9d1e 49cba16429f342449cdb5efac05a0dfb--00f2bff416c74b1e9610d6dd1d2d9d1e 336981ac02334aa9b42f4e07423f1215 HamEvo 00f2bff416c74b1e9610d6dd1d2d9d1e--336981ac02334aa9b42f4e07423f1215 40fbcf7705f84c919941e9db05b2112d 336981ac02334aa9b42f4e07423f1215--40fbcf7705f84c919941e9db05b2112d 0ceec60762ed4de681502eb163334683 40fbcf7705f84c919941e9db05b2112d--0ceec60762ed4de681502eb163334683 29c3738817914612ba13bf7f4a010af7 249e973a609a42bc9b6a5d09ef42e5f8 b867fffda1634d9188bad022aadc099e--249e973a609a42bc9b6a5d09ef42e5f8 60e409f3267f401499169baaa845c6a9 2 c12bda8e96004ea0a724bd4e8fb31f67 t = -500.000000000000 249e973a609a42bc9b6a5d09ef42e5f8--c12bda8e96004ea0a724bd4e8fb31f67 f394f64e8cfe4b9c92639d7635c97e36 c12bda8e96004ea0a724bd4e8fb31f67--f394f64e8cfe4b9c92639d7635c97e36 697e83f36d474c72aee7269bc1a56af0 X f394f64e8cfe4b9c92639d7635c97e36--697e83f36d474c72aee7269bc1a56af0 55c8fffb48e548b5938d928a4e02c1be t = -500.000000000000 697e83f36d474c72aee7269bc1a56af0--55c8fffb48e548b5938d928a4e02c1be cd8472b392b14692a5f4887a263a1d5e X 55c8fffb48e548b5938d928a4e02c1be--cd8472b392b14692a5f4887a263a1d5e cd8472b392b14692a5f4887a263a1d5e--29c3738817914612ba13bf7f4a010af7 49bd214bb30346b39b0832b4eae55a80 31f6331ea6284d28bb46ccd4f8568965 X 60e409f3267f401499169baaa845c6a9--31f6331ea6284d28bb46ccd4f8568965 b42bf4af45a04fe486c8c151fbbfa0d4 31f6331ea6284d28bb46ccd4f8568965--b42bf4af45a04fe486c8c151fbbfa0d4 69ec64711cb84fe69251304f37c0ddb8 X b42bf4af45a04fe486c8c151fbbfa0d4--69ec64711cb84fe69251304f37c0ddb8 9c90a0b3d9f24f9b81fcfd67ecd21cbe X 69ec64711cb84fe69251304f37c0ddb8--9c90a0b3d9f24f9b81fcfd67ecd21cbe 6ab2a989845c49c78b89938ba7960168 9c90a0b3d9f24f9b81fcfd67ecd21cbe--6ab2a989845c49c78b89938ba7960168 67b1dd37bf9a40c1bdd1cd5e8f7ad801 X 6ab2a989845c49c78b89938ba7960168--67b1dd37bf9a40c1bdd1cd5e8f7ad801 67b1dd37bf9a40c1bdd1cd5e8f7ad801--49bd214bb30346b39b0832b4eae55a80 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\ntransformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int = 0.0),\n)\nexcept ValueError as error:\nprint(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n\"cloud_configuration\": {\n\"username\": \"&lt;changeme&gt;\",\n\"password\": \"&lt;changeme&gt;\",\n\"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n\"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n}\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\nbell_state = chain(\nentangle(\"t\", qubit_support=(0,1)),\nRY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.4033156033573492, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\nparams = {\n\"t\": torch.tensor([1000]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Return the final state vector\nfinal_vector = model.run(params)\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 27, '11': 23})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-11-21T16:26:23.077229 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-11-21T16:26:23.169911 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence.backends.pulser.devices import Device\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, bell_state)\n# Choose a realistic device\nmodel = QuantumModel(\ncircuit,\nbackend=BackendName.PULSER,\ndiff_mode=DiffMode.GPSR,\nconfiguration={\"device_type\": Device.REALISTIC}\n)\nparams = {\n\"t\": torch.tensor([1000]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 23})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n# Custom entanglement operation.\ndef my_entanglement(duration):\nreturn chain(\nAnalogRY(-torch.pi / 2),\nwait(duration)\n)\nprotocol = chain(\nmy_entanglement(\"t\"),\nRY(0, \"y\"),\n)\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"t\": torch.tensor([500]),  # ns\n\"y\": torch.tensor([torch.pi / 2]),\n}\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-11-21T16:26:23.617944 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\nhea_one_layer = chain(\nkron(RY(0, \"th00\"), RY(1, \"th01\")),\nkron(RX(0, \"th10\"), RX(1, \"th11\")),\nkron(RY(0, \"th20\"), RY(1, \"th21\")),\nentangle(\"t\", qubit_support=(0,1)),\n)\nprotocol = chain(\nfourier_feature_map(1, param=\"x\"),\nhea_one_layer,\nAnalogRX(torch.pi/4)\n)\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"x\": torch.tensor([0.8]), # rad\n\"t\": torch.tensor([900]), # ns\n\"th00\":  torch.rand(1), # rad\n\"th01\":  torch.rand(1), # rad\n\"th10\":  torch.rand(1), # rad\n\"th11\":  torch.rand(1), # rad\n\"th20\":  torch.rand(1), # rad\n\"th21\":  torch.rand(1), # rad\n}\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-11-21T16:26:23.780248 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/rydberg-hea/","title":"Hardware efficient ansatz with restricted addressability","text":"<p>Qadence simplifies the execution of digital-analog workloads on neutral atom quantum computers where the local addressability is restricted.</p> <p>In this regime, which we will refer to as semi-local addressing, the full Hamiltonian of the qubit system realized with neutral atoms comprises the following terms:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\textrm{global}} + \\mathcal{H}_{\\textrm{int}} + \\mathcal{H}_{\\textrm{local}} \\] <p>The first two terms are the standard components of a neutral atom Hamiltonians and read as follows:</p> <p>$$     \\mathcal{H}{\\textrm{global}} = \\frac{\\Omega}{2}\\sum{i}^N \\left(         \\textrm{cos}(\\phi)\\sigma^x_i - \\textrm{sin}(\\phi)\\sigma^y_i \\right) -         \\delta \\sum_{i}^N \\hat{n}i \\     \\mathcal{H}{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j $$ where \\(\\Omega\\) is the Rabi frequency, \\(\\phi\\) the global phase, \\(\\delta\\) the detuning which can all be time-dependent (here omitted for simplicity). The operator \\(\\hat{n}_i = \\frac{1+\\sigma_i^z}{2}\\) is the occupation operator for the Rydberg state. \\(R_i\\) represents instead the spatial coordinates of the i-th qubit.</p> <p>The local addressability term reads instead:</p> \\[     \\mathcal{H}_{\\textrm{local}}(w^{drv}, w^{det}) = \\frac{\\tilde{\\Omega}}{2}\\sum_{i}^N         w_i^{drv}\\left(\\textrm{cos}(\\phi)\\sigma^x_i - \\textrm{sin}(\\phi)\\sigma^y_i \\right) -         \\Delta \\sum_{i}^N w_i^{det} \\hat{n}_i \\] <p>In this Hamiltonian, the local addressing pattern in both Rabi frequency and detuning is determined by the weights \\(w^{drv} = \\{w_i^{drv}\\}\\) and \\(w^{det} = \\{w_i^{det}\\}\\) respectively. These weights are assigned before starting the simulation and they should have a unit sum. Their action is to effectively modulate the amplitude of the local drive/detuning pulses given by \\(\\tilde{\\Omega}\\) and \\(\\Delta\\) which are here considered time-independent for simplicity.</p> <p>Qadence implements the Hamiltonian above in two different flavors of increasing complexity described below.</p>"},{"location":"digital_analog_qc/rydberg-hea/#circuit-constructor","title":"Circuit constructor","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\matchcal{H} = \\mathcal{H}_{\\textrm{local}}(w^{drv}, w^{det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{drv}, w_{j}^{det}) \\] <p>Notice that in real-device implementation, one layer only is usually possible.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\nregister,\nn_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\naddressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\naddressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\ntunable_phase=True, # make the phase \\phi as a variational parameter\n)\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\nansatz_layer = rydberg_hea_layer(\nregister,\ntevo_det,\ntevo_drive,\ntevo_int,\ndetunings=weights_det,\ndrives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as PyQTorch and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/rydberg-hea/#usage-with-digital-analog-emulation","title":"Usage with digital-analog emulation","text":"<p>A full integration with the emulated digital-analog framework for realistic simulations is coming soon.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n\"\"\"The number of qubits in the whole system.\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n\"\"\"The number of qubits the block is acting on.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n\"\"\"The indices of the qubit(s) the block is acting on.\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\nself.blocks = (target_block,)\n# using tuple expansion because some control operations could\n# have multiple targets, e.g. CSWAP\nsuper().__init__((*control, *target_block.qubit_support))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n\"\"\"The number of parameters required by the block.\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\nself.blocks = (target_block,)\nself.parameters = target_block.parameters\nsuper().__init__((*control, target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n\"\"\"Decomposition into purely digital gates.\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\nself.block = block\n# TODO: more meaningful name like `scale`?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nsuper().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n\"\"\"A chain of analog blocks.\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\nfor b in blocks:\nif not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\nraise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n\"\"\"Stack analog blocks vertically (i.e. in time).\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nself.blocks = blocks\nself.interaction = interaction\nqubit_support = QubitSupport()\nduration = blocks[0].duration\nfor b in blocks:\nif not isinstance(b, AnalogBlock):\nraise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\nif b.qubit_support == QubitSupport(\"global\"):\nraise ValueError(\"Blocks with global support cannot be kron'ed.\")\nif not qubit_support.is_disjoint(b.qubit_support):\nraise ValueError(\"Make sure blocks act on distinct qubits!\")\nif not np.isclose(evaluate(duration), evaluate(b.duration)):\nraise ValueError(\"Kron'ed blocks have to have same duration.\")\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>Can be used with <code>add_interaction</code>. WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p> <p>Can be used with <code>add_interaction</code>.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\nb = chain(X(0), Y(0))\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n\"\"\"Chain blocks sequentially.\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n    Returns:\n        ChainBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n    b = chain(X(0), Y(0))\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogChain` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_chain(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\nb = kron(X(0), Y(1))\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n\"\"\"Stack blocks vertically.\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n    Returns:\n        KronBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n    b = kron(X(0), Y(1))\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogKron` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_kron(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\nb = add(X(0), Y(0))\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n\"\"\"Sums blocks.\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n    Returns:\n        AddBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n    b = add(X(0), Y(0))\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\nreturn _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nqubit_support = QubitSupport()\nfor b in blocks:\nassert (\nQubitSupportType.GLOBAL,\n) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\nassert qubit_support.is_disjoint(\nb.qubit_support\n), \"Make sure blocks act on distinct qubits!\"\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\nblock = hea(2,2)\nprint(block_to_tensor(block))\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.1709+0.3017j, -0.4932-0.4932j, -0.4975-0.2831j, -0.1649-0.1961j],\n[-0.0164-0.4321j,  0.3352+0.2216j, -0.3870-0.4641j, -0.5347+0.0218j],\n[-0.2988-0.5635j, -0.2746-0.4115j,  0.3084+0.2571j, -0.3356-0.2731j],\n[-0.0645-0.5308j, -0.3275+0.0013j, -0.1177-0.3636j,  0.6365+0.2357j]]],\ngrad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n[0, 3]]),\nvalues=tensor([ 2.+0.j, -2.+0.j]),\nsize=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\nblock: AbstractBlock,\nvalues: dict[str, TNumber | torch.Tensor] = {},\nqubit_support: tuple | None = None,\nuse_full_support: bool = True,\ntensor_type: TensorType = TensorType.DENSE,\nendianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n\"\"\"\n    Convert a block into a torch tensor.\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n    block = hea(2,2)\n    print(block_to_tensor(block))\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n# FIXME: default use_full_support to False. In general, it would\n# be more efficient to do that, and make sure that computations such\n# as observables only do the matmul of the size of the qubit support.\nif tensor_type == TensorType.DENSE:\nfrom qadence.blocks import embedding\n(ps, embed) = embedding(block)\nreturn _block_to_tensor_embedded(\nblock, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n)\nelif tensor_type == TensorType.SPARSEDIAGONAL:\nt = block_to_diagonal(block, endianness=endianness)\nindices, values, size = torch.nonzero(t), t[t != 0], len(t)\nindices = torch.stack((indices.flatten(), indices.flatten()))\nreturn torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"x\",\nfeature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Exponential fourier feature map.\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\nif feature_range is None:\nfeature_range = (0.0, 2.0**n_qubits)\nsupport = tuple(range(n_qubits)) if support is None else support\nhlayer = kron(H(qubit) for qubit in support)\nrlayer = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=RZ,\nfm_type=BasisSet.FOURIER,\nreupload_scaling=ReuploadScaling.EXP,\nfeature_range=feature_range,\ntarget_range=(0.0, 2 * pi),\n)\nrlayer.tag = None\nreturn tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | type[Function] | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data is assumed to come from.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] | None = None,\nparam: Parameter | str = \"phi\",\nop: RotationTypes = RX,\nfm_type: BasisSet | type[Function] | str = BasisSet.FOURIER,\nreupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\nfeature_range: tuple[float, float] | None = None,\ntarget_range: tuple[float, float] | None = None,\nmultiplier: Parameter | TParameter | None = None,\n) -&gt; KronBlock:\n\"\"\"Construct a feature map of a given type.\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data is assumed to come from.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n# Process input\nif support is None:\nsupport = tuple(range(n_qubits))\nelif len(support) != n_qubits:\nraise ValueError(\"Wrong qubit support supplied\")\nif op not in ROTATIONS:\nraise ValueError(\nf\"Operation {op} not supported. \"\nf\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n)\n# Backwards compatibility\nif fm_type in (\"fourier\", \"chebyshev\", \"tower\"):\nlogger.warning(\n\"Selecting `fm_type` as 'fourier', 'chebyshev' or 'tower' is deprecated. \"\n\"Please use the respective enumerations: 'fm_type = BasisSet.FOURIER', \"\n\"'fm_type = BasisSet.CHEBYSHEV' or 'reupload_scaling = ReuploadScaling.TOWER'.\"\n)\nif fm_type == \"fourier\":\nfm_type = BasisSet.FOURIER\nelif fm_type == \"chebyshev\":\nfm_type = BasisSet.CHEBYSHEV\nelif fm_type == \"tower\":\nfm_type = BasisSet.CHEBYSHEV\nreupload_scaling = ReuploadScaling.TOWER\nif isinstance(param, Parameter):\nfparam = param\nfparam.trainable = False\nelse:\nfparam = FeatureParameter(param)\n# Set feature and target range\nfeature_range = _set_range(fm_type) if feature_range is None else feature_range\ntarget_range = _set_range(fm_type) if target_range is None else target_range\n# Rescale the feature parameter\nscaling = (max(target_range) - min(target_range)) / (max(feature_range) - min(feature_range))\nshift = min(target_range) - min(feature_range) * scaling\nif isclose(scaling, 1.0):\n# So we don't get 1.0 factor in visualization\nscaled_fparam = fparam + shift\nelse:\nscaled_fparam = scaling * fparam + shift\n# Transform feature parameter\nif fm_type == BasisSet.FOURIER:\ntransformed_feature = scaled_fparam\nelif fm_type == BasisSet.CHEBYSHEV:\ntransformed_feature = acos(scaled_fparam)\nelif inspect.isclass(fm_type) and issubclass(fm_type, Function):\ntransformed_feature = fm_type(scaled_fparam)\nelse:\nraise NotImplementedError(\nf\"Feature map type {fm_type} not implemented. Choose an item from the BasisSet \"\nf\"enum: {[bs.name for bs in BasisSet]}, or your own sympy.Function to wrap \"\n\"the given feature parameter with.\"\n)\nbasis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n# Set reupload scaling function\nif callable(reupload_scaling):\nrs_func = reupload_scaling\nrs_tag = \"Custom\"\nelse:\nrs_func = RS_FUNC_DICT.get(reupload_scaling, None)  # type: ignore [call-overload]\nif rs_func is None:\nraise NotImplementedError(\nf\"Reupload scaling {reupload_scaling} not implemented; choose an item from \"\nf\"the ReuploadScaling enum: {[rs.name for rs in ReuploadScaling]}, or your own \"\n\"python function with a single int arg as input and int or float output.\"\n)\nif isinstance(reupload_scaling, ReuploadScaling):\nrs_tag = reupload_scaling.value\nelse:\nrs_tag = reupload_scaling\n# Set overall multiplier\nmultiplier = 1 if multiplier is None else multiplier\n# Build feature map\nop_list = []\nfor i, qubit in enumerate(support):\nop_list.append(op(qubit, multiplier * rs_func(i) * transformed_feature))\nfm = kron(*op_list)\nfm.tag = rs_tag + \" \" + basis_tag + \" FM\"\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Fourier feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev tower feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\nFutureWarning,\n)\nfm = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=op,\nfm_type=BasisSet.CHEBYSHEV,\nreupload_scaling=ReuploadScaling.TOWER,\n)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\nn_qubits: int,\nn_features: int,\ndepth: int = None,\nansatz: Optional[AbstractBlock] = None,\nfm_pauli: Type[RY] = RY,\nspectrum: str = \"simple\",\nbasis: str = \"fourier\",\nfm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n\"\"\"Helper function to build a qadence QNN quantum circuit.\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\ndepth = n_qubits if depth is None else depth\nidx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\nif fm_strategy == \"parallel\":\n_fm = kron(*idx_fms)\nfm = tag(_fm, tag=\"FM\")\nelif fm_strategy == \"serial\":\nfm_components: list[AbstractBlock] = []\nfor j, fm_idx in enumerate(idx_fms[:-1]):\nfm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\nfm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\nfm_components.extend(fm_component)\nfm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\nfm = chain(*fm_components)  # type: ignore[assignment]\nansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\nreturn [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nstrategy=\"sDAQC\",\noperations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nsupport: tuple[int, ...] = None,\nstrategy: Strategy = Strategy.DIGITAL,\n**strategy_args: Any,\n) -&gt; AbstractBlock:\n\"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nhea_func_dict = {\nStrategy.DIGITAL: hea_digital,\nStrategy.SDAQC: hea_sDAQC,\nStrategy.BDAQC: hea_bDAQC,\nStrategy.ANALOG: hea_analog,\n}\ntry:\nhea_func = hea_func_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nhea_block: AbstractBlock = hea_func(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\n**strategy_args,\n)  # type: ignore\nreturn hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nperiodic: bool = False,\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\ntry:\nif entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\nraise ValueError(\n\"Please provide a valid two-qubit entangler operation for digital HEA.\"\n)\nexcept TypeError:\nraise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\nperiodic=periodic,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n    It uses step-wise digital-analog computation.\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n# TODO: Add qubit support\nif entangler is None:\nentangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif not block_is_qubit_hamiltonian(entangler):\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nexcept NotImplementedError:\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_analog(\ndepth=depth,\nparam_prefix=param_prefix,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, force_update=False, use_complete_graph=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_update</code> <p>force override register detuning and interaction strengths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_complete_graph</code> <p>computes an interaction for every edge in a complete graph, independent of the edges in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\nn_qubits = 3\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\nn_qubits,\ninteraction = Interaction.XY,\nrandom_strength = True,\n)\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\nregister,\ninteraction = Interaction.NN,\ninteraction_strength = \"theta\"\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\nregister: Register | int,\ninteraction: Interaction | None = None,\ndetuning: TDetuning | None = None,\ninteraction_strength: TArray | str | None = None,\ndetuning_strength: TArray | str | None = None,\nrandom_strength: bool = False,\nforce_update: bool = False,\nuse_complete_graph: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    General Hamiltonian creation function.\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        force_update: force override register detuning and interaction strengths.\n        use_complete_graph: computes an interaction for every edge in a complete graph,\n            independent of the edges in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n        n_qubits = 3\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\nif interaction is None and detuning is None:\nraise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n# If number of qubits is given, creates all-to-all register\nregister = Register(register) if isinstance(register, int) else register\n# Get interaction function\ntry:\nint_fn = INTERACTION_DICT[interaction]  # type: ignore [index]\nexcept (KeyError, ValueError) as error:\nif interaction is None:\npass\nelse:\nraise KeyError(f\"Interaction {interaction} not supported.\")\n# Check single-qubit detuning\nif (detuning is not None) and (detuning not in DETUNINGS):\nraise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n# Pre-process detuning and interaction strengths and update register\nhas_detuning_strength, detuning_strength = _preprocess_strengths(\nregister, detuning_strength, \"nodes\", force_update, random_strength\n)\nedge_str = \"all_edges\" if use_complete_graph else \"edges\"\nhas_interaction_strength, interaction_strength = _preprocess_strengths(\nregister, interaction_strength, edge_str, force_update, random_strength\n)\nif (not has_detuning_strength) or force_update:\nregister = _update_detuning_strength(register, detuning_strength)\nif (not has_interaction_strength) or force_update:\nregister = _update_interaction_strength(register, interaction_strength, use_complete_graph)\n# Create single-qubit detunings:\nsingle_qubit_terms: List[AbstractBlock] = []\nif detuning is not None:\nfor node in register.nodes:\nblock_sq = detuning(node)  # type: ignore [operator]\nstrength_sq = register.nodes[node][\"strength\"]\nsingle_qubit_terms.append(strength_sq * block_sq)\n# Create two-qubit interactions:\ntwo_qubit_terms: List[AbstractBlock] = []\nedge_data = register.all_edges if use_complete_graph else register.edges\nif interaction is not None:\nfor edge in edge_data:\nblock_tq = int_fn(*edge)  # type: ignore [operator]\nstrength_tq = edge_data[edge][\"strength\"]\ntwo_qubit_terms.append(strength_tq * block_tq)\nreturn add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising NN interaction.\"\"\"\nreturn N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"XY interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Heisenberg XYZ interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising ZZ interaction.\"\"\"\nreturn Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\nn_qubits = 3\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\ninverse: bool = False,\nreverse_in: bool = False,\nswaps_out: bool = False,\nstrategy: Strategy = Strategy.DIGITAL,\ngen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    The Quantum Fourier Transform.\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n        n_qubits = 3\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif reverse_in:\nsupport = support[::-1]\nqft_layer_dict = {\nStrategy.DIGITAL: _qft_layer_digital,\nStrategy.SDAQC: _qft_layer_sDAQC,\nStrategy.BDAQC: _qft_layer_bDAQC,\nStrategy.ANALOG: _qft_layer_analog,\n}\ntry:\nlayer_func = qft_layer_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nqft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\nqft_circ = chain(\nlayer_func(\nn_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n)  # type: ignore\nfor layer in qft_layers\n)\nif swaps_out:\nswap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\nqft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\nreturn tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\nregister: qd.Register,\nn_layers: int = 1,\naddressable_detuning: bool = True,\naddressable_drive: bool = False,\ntunable_phase: bool = False,\nadditional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n\"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\nn_qubits = register.n_qubits\nprefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\ndetunings = None\n# add a detuning pattern locally addressing the atoms\nif addressable_detuning:\ndetunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\ndrives = None\n# add a drive pattern locally addressing the atoms\nif addressable_drive:\ndrives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\nphase = None\nif tunable_phase:\nphase = qd.VariationalParameter(\"phase\")\nreturn chain(\nrydberg_hea_layer(\nregister,\nVariationalParameter(f\"At{prefix}_{layer}\"),\nVariationalParameter(f\"Omega{prefix}_{layer}\"),\nVariationalParameter(f\"wait{prefix}_{layer}\"),\ndetunings=detunings,\ndrives=drives,\nphase=phase,\n)\nfor layer in range(n_layers)\n)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\nregister: qd.Register,\ntevo_drive: Parameter | float,\ntevo_det: Parameter | float,\ntevo_wait: Parameter | float,\nphase: Parameter | float | None = None,\ndetunings: list[Parameter] | list[float] | None = None,\ndrives: list[Parameter] | list[float] | None = None,\ndrive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n\"\"\"A single layer of the Rydberg hardware efficient ansatz.\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\nn_qubits = register.n_qubits\ndrive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\ndrive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\ndetuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\ninteraction = hamiltonian_factory(register, qd.Interaction.NN)\n# drive and interaction are not commuting thus they need to be\n# added directly into the final Hamiltonian generator\nif phase is not None:\ngenerator = (\ndrive_scaling * sympy.cos(phase) * drive_x\n- drive_scaling * sympy.sin(phase) * drive_y\n+ interaction\n)\nelse:\ngenerator = drive_scaling * drive_x + interaction\nreturn chain(\nqd.HamEvo(generator, tevo_drive),\n# detuning and interaction are commuting, so they\n# can be ordered arbitrarily and treated separately\nqd.HamEvo(interaction, tevo_wait),\nqd.HamEvo(detuning, tevo_det),\n)\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\nn_qubits = 3\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\ngen_target = 0.1 * (Z(1)@Z(2))\nt_f = 2.0\ntransformed_circuit = daqc_transform(\nn_qubits = n_qubits,\ngen_target = gen_target,\nt_f = t_f,\ngen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\nn_qubits: int,\ngen_target: AbstractBlock,\nt_f: float,\ngen_build: AbstractBlock | None = None,\nzero_tol: float = 1e-08,\nstrategy: Strategy = Strategy.SDAQC,\nignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n    The result is another fixed 2-body Hamiltonian.\n    Reference for universality of 2-body Hamiltonians:\n    -- https://arxiv.org/abs/quant-ph/0106064\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n    -- https://arxiv.org/abs/1812.03637\n    The transform translates a target weighted generator of the type:\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n    To a circuit using analog evolutions with a fixed building block generator:\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n    where `op = Z` or `op = N`.\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n    Notes:\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n        n_qubits = 3\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n        gen_target = 0.1 * (Z(1)@Z(2))\n        t_f = 2.0\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n##################\n# Input controls #\n##################\nif strategy != Strategy.SDAQC:\nraise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\nif n_qubits == 4:\nraise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\nif gen_build is None:\ngen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif (not block_is_qubit_hamiltonian(gen_target)) or (\nnot block_is_qubit_hamiltonian(gen_build)\n):\nraise ValueError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\nexcept NotImplementedError:\n# Happens when block_is_qubit_hamiltonian is called on something that is not a block.\nraise TypeError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\n#####################\n# Generator parsing #\n#####################\ng_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\ng_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n# Get the global phase hamiltonian and single-qubit detuning hamiltonian\nif build_type == GenDAQC.NN:\nh_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\nif target_type == GenDAQC.NN:\nh_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n# Time re-scalings\nif build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\nt_star = t_f / 4.0\nelif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\nt_star = 4.0 * t_f\nelse:\nt_star = t_f\n# Check if target Hamiltonian can be mapped with the build Hamiltonian\nassert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n##################\n# DAQC Transform #\n##################\n# Section III A of https://arxiv.org/abs/1812.03637:\n# Matrix M for the linear system, exemplified in Table I:\nmatrix_M = _build_matrix_M(n_qubits)\n# Linear system mapping interaction ratios -&gt; evolution times.\nt_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n# ZZ-DAQC with ZZ or NN build Hamiltonian\ndaqc_slices = []\nfor m in range(2, n_qubits + 1):\nfor n in range(1, m):\nalpha = _ix_map(n_qubits, n, m)\nt = t_slices[alpha - 1]\nif abs(t) &gt; zero_tol:\nif abs(t) &gt; (1 / (zero_tol**0.5)):\nlogger.warning(\n\"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n)\nx_gates = kron(X(n - 1), X(m - 1))\nanalog_evo = HamEvo(gen_build, t)\n# TODO: Fix repeated X-gates\nif build_type == GenDAQC.NN:\n# Local detuning at each DAQC layer for NN build Hamiltonian\nsq_detuning_build = HamEvo(h_sq_build, t)\ndaqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\nelif build_type == GenDAQC.ZZ:\ndaqc_slices.append(chain(x_gates, analog_evo, x_gates))\ndaqc_circuit = chain(*daqc_slices)\n########################\n# Phases and Detunings #\n########################\nif target_type == GenDAQC.NN:\n# Local detuning given a NN target Hamiltonian\nsq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\ndaqc_circuit = chain(sq_detuning_target, daqc_circuit)\nif not ignore_global_phases:\nif build_type == GenDAQC.NN:\n# Constant global phase given a NN build Hamiltonian\nglobal_phase_build = HamEvo(h_phase_build, t_slices.sum())\ndaqc_circuit = chain(global_phase_build, daqc_circuit)\nif target_type == GenDAQC.NN:\n# Constant global phase and given a NN target Hamiltonian\nglobal_phase_target = HamEvo(h_phase_target, t_f).dagger()\ndaqc_circuit = chain(global_phase_target, daqc_circuit)\nreturn daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\nbasis: str,\nfm_pauli: Type[RY],\nfm_strategy: str,\nn_features: int,\nn_qubits: int,\nspectrum: str,\n) -&gt; list[KronBlock]:\n\"\"\"Builds the index feature maps based on the given parameters.\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\nidx_fms = []\nfor i in range(n_features):\ntarget_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\nparam = FeatureParameter(f\"x{i}\")\nblock = kron(\n*[\nfm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\nfor j, qubit in enumerate(target_qubits)\n]\n)\nidx_fm = block\nidx_fms.append(idx_fm)\nreturn idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n\"\"\"Converts a spectrum string, e.g. tower or exponential.\n    The result is the correct generator prefactor.\n    \"\"\"\nspectrum = spectrum.lower()\nconversion_dict: dict[str, float | int] = {\n\"simple\": 1,\n\"tower\": qubit_index + 1,\n\"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n}\nreturn conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n\"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n    Returns:\n        List[int]: The list of target qubits.\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\nif fm_strategy == \"parallel\":\nn_qubits_per_feature = int(n_qubits / n_features)\ntarget_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\nelif fm_strategy == \"serial\":\ntarget_qubits = range(0, n_qubits)\nelse:\nraise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\nreturn target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\nx: Any,\nqcd: QuantumCircuitDiagram | Cluster | None = None,\nlayout: str = \"LR\",\ntheme: str = \"light\",\nfill: bool = True,\n**kwargs: Any,\n) -&gt; Graph:\n\"\"\"Display a block, circuit, or quantum model.\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\nreturn make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\nmake_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\nobservable: Union[list[AbstractBlock], AbstractBlock],\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: Union[DiffMode, str, None] = None,\nnoise: Union[Noise, None] = None,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\nraise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.run` method.\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    \"\"\"\nraise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Union[Tensor, None] = None,\nn_shots: int = 100,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nnoise: Union[Noise, None] = None,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n\"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\nraise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f92e683ff40&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f92e683f370&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n\"\"\"Retrieve all trainable model parameters in a single vector.\n    Args:\n        model (Module): the input PyTorch model\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\nps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\nreturn torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n\"\"\"Return the total number of parameters of the given model.\"\"\"\nreturn len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n\"\"\"Set all trainable parameters of a model from a single vector.\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\nwith torch.no_grad():\nidx = 0\nfor ps in model.parameters():\nif ps.requires_grad:\nn = torch.numel(ps)\nif ps.ndim == 0:\nps[()] = theta[idx : idx + n]\nelse:\nps[:] = theta[idx : idx + n].reshape(ps.size())\nidx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\nmodel: Module,\noptimizer: Optimizer,\nloss_fn: Callable,\nxs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n\"\"\"Default Torch optimize step with closure.\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\nloss, metrics = None, {}\ndef closure() -&gt; Any:\n# NOTE: We need the nonlocal as we can't return a metric dict and\n# because e.g. LBFGS calls this closure multiple times but for some\n# reason the returned loss is always the first one...\nnonlocal metrics, loss\noptimizer.zero_grad()\nloss, metrics = loss_fn(model, xs)\nloss.backward(retain_graph=True)\nreturn loss.item()\noptimizer.step(closure)\n# return the loss/metrics that are being mutated inside the closure...\nreturn loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n## lets prepare the train routine\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: Union[None, DataLoader, DictDataLoader],\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\"\"\"Runs the training loop with gradient-based optimizer.\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n    ## lets prepare the train routine\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n## Training\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if dataloader is not None else None\n# outer epoch loop\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\ntry:\n# in case there is not data needed by the model\n# this is the case, for example, of quantum models\n# which do not have classical input data (e.g. chemistry)\nif dataloader is None:\nloss, metrics = optimize_step(model, optimizer, loss_fn, None)\nloss = loss.item()\nelif isinstance(dataloader, (DictDataLoader, DataLoader)):\ndata = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\nloss, metrics = optimize_step(model, optimizer, loss_fn, data)\nelse:\nraise NotImplementedError(\nf\"Unsupported dataloader type: {type(dataloader)}. \"\n\"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n)\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nexcept KeyboardInterrupt:\nprint(\"Terminating training gracefully after the current iteration.\")\nbreak\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | None,\noptimizer: NGOptimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n\"\"\"Runs the training loop with a gradient-free optimizer.\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\ndef _update_parameters(\ndata: Tensor | None, ng_params: ng.p.Array\n) -&gt; tuple[float, dict, ng.p.Array]:\nloss, metrics = loss_fn(model, data)  # type: ignore[misc]\noptimizer.tell(ng_params, float(loss))\nng_params = optimizer.ask()  # type: ignore [assignment]\nparams = promote_to_tensor(ng_params.value, requires_grad=False)\nset_parameters(model, params)\nreturn loss, metrics, ng_params\nassert loss_fn is not None, \"Provide a valid loss function\"\n# TODO: support also Scipy optimizers\nassert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n# set optimizer configuration and initial parameters\noptimizer.budget = config.max_iter\noptimizer.enable_pickling()\n# TODO: Make it GPU compatible if possible\nparams = get_parameters(model).detach().numpy()\nng_params = ng.p.Array(init=params)\n# serial training\n# TODO: Add a parallelization using the num_workers argument in Nevergrad\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if dataloader is not None else None\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\nif dataloader is None:\nloss, metrics, ng_params = _update_parameters(None, ng_params)\nelif isinstance(dataloader, (DictDataLoader, DataLoader)):\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nif iteration &gt;= init_iter + config.max_iter:\nbreak\n## Final writing and stuff\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.4065, 0.8547]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n\"\"\"Randomly sample points from the first dimension of the given tensors.\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\nself.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.5520, 0.5128, 0.8844, 0.3853, 0.1138]), tensor([0.7267, 0.4795, 0.8860, 0.1588, 0.1412]), tensor([0.4323, 0.2156, 0.6628, 0.0107, 0.0522])]\n[tensor([0.1679, 0.2914, 0.0584, 0.0124, 0.3985]), tensor([0.8215, 0.9256, 0.2762, 0.3432, 0.2289]), tensor([0.5735, 0.7052, 0.1925, 0.1755, 0.1534])]\n[tensor([0.5520, 0.5128, 0.8844, 0.3853, 0.1138]), tensor([0.7267, 0.4795, 0.8860, 0.1588, 0.1412]), tensor([0.4323, 0.2156, 0.6628, 0.0107, 0.0522])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n\"\"\"Convert torch tensors an (infinite) Dataloader.\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\nds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\nreturn DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\na11 = 0.5 * (Z(control) - I(control))\na22 = -0.5 * (Z(target) + I(target))\na12 = 0.5 * (chain(X(control), Z(control)) + X(control))\na21 = 0.5 * (chain(Z(target), X(target)) + X(target))\nself.generator = (\nkron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n)\nsuper().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nself.generator = kron((I(control) - Z(control)) * 0.5, X(target) - I(target))\nsuper().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nsuper().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n# TODO: should we give them more meaningful names? like 'angle'?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = X(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Y(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\nself.parameters = ParamMap(parameter=parameter)\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.1804-4.2794e-17j, -0.6272+2.2739e-17j],\n[ 1.0007-2.3573e-18j, -0.0385+9.0640e-20j]])\ntensor([[1.6181-0.0440j, 0.2614-0.1383j],\n[1.3914-0.0214j, 0.1634-0.0779j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ngenerator: Union[TGenerator, AbstractBlock],\nparameter: TParameter,\nqubit_support: tuple[int, ...] = None,\n):\ngen_exprs = {}\nif qubit_support is None and not isinstance(generator, AbstractBlock):\nraise ValueError(\"You have to supply a qubit support for non-block generators.\")\nsuper().__init__(qubit_support if qubit_support else generator.qubit_support)\nif isinstance(generator, AbstractBlock):\nqubit_support = generator.qubit_support\nif generator.is_parametric:\ngen_exprs = {str(e): e for e in expressions(generator)}\nelif isinstance(generator, torch.Tensor):\nmsg = \"Please provide a square generator.\"\nif len(generator.shape) == 2:\nassert generator.shape[0] == generator.shape[1], msg\nelif len(generator.shape) == 3:\nassert generator.shape[1] == generator.shape[2], msg\nassert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\nelse:\nraise TypeError(\n\"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n)\ngen_exprs = {str(generator.__hash__()): generator}\nelif isinstance(generator, (sympy.Basic, sympy.Array)):\ngen_exprs = {str(generator): generator}\nelse:\nraise TypeError(\nf\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n)\nps = {\"parameter\": Parameter(parameter), **gen_exprs}\nself.parameters = ParamMap(**ps)\nself.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n\"\"\"Decompose the Hamiltonian evolution into digital gates.\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n# psi(t) = exp(-i * H * t * psi0)\n# psi(t) = exp(-i * lambda * t * psi0)\n# H = sum(Paulin) + sum(Pauli1*Pauli2)\nlogger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\nblocks = []\n# how to change the type/dict to enum effectively\n# when there is a term including non-commuting matrices use st2 or st4\n# 1) should check that the given generator respects the constraints\n# single-qubit gates\nassert isinstance(\nself.generator, AbstractBlock\n), \"Only a generator represented as a block can be decomposed\"\nif block_is_qubit_hamiltonian(self.generator):\ntry:\nblock_is_commuting_hamiltonian(self.generator)\napproximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\nexcept TypeError:\nlogger.warning(\n\"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n)\nblocks.extend(\nlie_trotter_suzuki(\nblock=self.generator,\nparameter=self.parameters.parameter,\norder=LTSOrder[approximation],\n)\n)\n# 2) return an AbstractBlock instance with the set of gates\n# resulting from the decomposition\nreturn chain(*blocks)\nelse:\nraise NotImplementedError(\n\"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\nrydberg_ising_hamiltonian_generator = (\n4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(control)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(target)\n)\nsuper().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global')</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog X rotation.\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=0)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global')</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Y rotation.\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=-np.pi / 2)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global')</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nalpha = _cast(Parameter, angle)\ndelta = np.pi\nduration = alpha / delta * 1000\nps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=0.0)\nreturn ConstantAnalogRotation(qubit_support=q, parameters=ps)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global')</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\nduration: float | str | Parameter = 1000.0,\nomega: float | str | Parameter = 0,\ndelta: float | str | Parameter = 0,\nphase: float | str | Parameter = 0,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"General analog rotation operation.\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nif isinstance(duration, str):\nduration = Parameter(duration)\nalpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000  # type: ignore [operator]\nps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\nreturn ConstantAnalogRotation(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global')</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\nduration: TNumber | sympy.Basic,\nqubit_support: str | QubitSupport | tuple = \"global\",\n) -&gt; WaitBlock:\n\"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n    Returns:\n        a `WaitBlock`\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nps = ParamMap(duration=duration)\nreturn WaitBlock(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['bb82ab6d-2c3c-4242-90d8-cb136e8d380e', '7f3499e3-8fef-44b0-9b97-19fab8a08912'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\nself._name_dict: dict[str, tuple[str, Basic]] = {}\nself._uuid_dict: dict[str, str] = {}\nfor name, v in kwargs.items():\nparam = v if isinstance(v, sympy.Basic) else Parameter(v)\nuuid = str(uuid4())\nself._name_dict[name] = (uuid, param)\nself._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.7043476796040012\ntheta: trainable=True value=2.0\nexpr=x*y : {x, y}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\ncls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n\"\"\"\n    Arguments:\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\np: Parameter\nif isinstance(name, get_args(TNumber)):\nreturn sympify(name)\nelif isinstance(name, Tensor):\nif name.numel() == 1:\nreturn sympify(name)\nelse:\nreturn Array(name.detach().numpy())\nelif isinstance(name, Parameter):\np = super().__new__(cls, name.name, **assumptions)\np.name = name.name\np.trainable = name.trainable\np.value = name.value\nreturn p\nelif isinstance(name, (Basic, Expr)):\nif name.is_number:\nreturn sympify(evaluate(name))\nreturn name\nelif isinstance(name, str):\np = super().__new__(cls, name, **assumptions)\np.trainable = assumptions.get(\"trainable\", True)\np.value = assumptions.get(\"value\", None)\nif p.value is None:\np.value = rand(1).item()\nreturn p\nelse:\nraise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\nreturn Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\nreturn Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\nexpr = Parameter(\"x\") * Parameter(\"y\")\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.11942186246998064\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\nres: Basic\nres_value: TNumber | Tensor\nquery: dict[Parameter, TNumber | Tensor] = {}\nif isinstance(expr, Array):\nreturn Tensor(expr.tolist())\nelse:\nif not expr.is_number:\nfor s in expr.free_symbols:\nif s.name in values.keys():\nquery[s] = values[s.name]\nelif hasattr(s, \"value\"):\nquery[s] = s.value\nelse:\nraise ValueError(f\"No value provided for symbol {s.name}\")\nif as_torch:\nres_value = torchify(expr)(**{s.name: tensor(v) for s, v in query.items()})\nelse:\nres = expr.subs(query)\nres_value = sympy_to_numeric(res)\nreturn res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\nparam: Expr,\n) -&gt; TNumber | Tensor | Expr:\n\"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\nreturn param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.torchify","title":"<code>torchify(expr)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\n</code></pre> RETURNS DESCRIPTION <code>SymPyModule</code> <p>A torchified, differentiable Expression.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def torchify(expr: Expr) -&gt; SymPyModule:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n    Returns:\n        A torchified, differentiable Expression.\n    \"\"\"\nextra_funcs = {sympy.core.numbers.ImaginaryUnit: 1.0j}\nreturn SymPyModule(expressions=[sympy.N(expr)], extra_funcs=extra_funcs)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False)</code>","text":"<p>Construct embedding function.</p> <p>It maps user-facing parameters to either expression-level parameters or gate-level parameters. The construced embedding function has the signature:</p> <pre><code> embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\nblock: AbstractBlock, to_gate_params: bool = False\n) -&gt; tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict],]:\n\"\"\"Construct embedding function.\n    It maps user-facing parameters to either *expression-level*\n    parameters or *gate-level* parameters. The construced embedding function has the signature:\n         embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\nunique_expressions = unique(expressions(block))\nunique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\nunique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\nunique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n# NOTE\n# there are 3 kinds of parameters in qadence\n# - non-trainable which are considered as inputs for classical data\n# - trainable which are the variational parameters to be optimized\n# - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n#\n# both non-trainable and trainable parameters can have the same element applied\n# to different operations in the quantum circuit, e.g. assigning the same parameter\n# to multiple gates.\nnon_numeric_symbols = [p for p in unique_symbols if not p.is_number]\ntrainable_symbols = [p for p in non_numeric_symbols if p.trainable]\nconstant_expressions = [expr for expr in unique_expressions if expr.is_number]\n# we dont need to care about constant symbols if they are contained in an symbolic expression\n# we only care about gate params which are ONLY a constant\nembeddings: dict[sympy.Expr, sympytorch.SymPyModule] = {\nexpr: torchify(expr) for expr in unique_expressions if not expr.is_number\n}\nuuid_to_expr = uuid_to_expression(block)\ndef embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\nembedded_params: dict[sympy.Expr, Tensor] = {}\nfor expr, fn in embeddings.items():\nangle: Tensor\nvalues = {}\nfor symbol in expr.free_symbols:\nif symbol.name in inputs:\nvalue = inputs[symbol.name]\nelif symbol.name in params:\nvalue = params[symbol.name]\nelse:\nmsg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\nraise KeyError(\nf\"{msg_trainable} parameter '{symbol.name}' not found in the \"\nf\"inputs list: {list(inputs.keys())} nor the \"\nf\"params list: {list(params.keys())}.\"\n)\nvalues[symbol.name] = value\nangle = fn(**values)\n# do not reshape parameters which are multi-dimensional\n# tensors, such as for example generator matrices\nif not len(angle.squeeze().shape) &gt; 1:\nangle = angle.reshape(-1)\nembedded_params[expr] = angle\nfor e in constant_expressions + unique_const_matrices:\nembedded_params[e] = params[stringify(e)]\nif to_gate_params:\ngate_lvl_params: StrTensorDict = {}\nfor uuid, e in uuid_to_expr.items():\ngate_lvl_params[uuid] = embedded_params[e]\nreturn gate_lvl_params\nelse:\nreturn {stringify(k): v for k, v in embedded_params.items()}\nparams: StrTensorDict\nparams = {p.name: torch.tensor([p.value], requires_grad=True) for p in trainable_symbols}\nparams.update(\n{\nstringify(expr): torch.tensor([evaluate(expr)], requires_grad=False)\nfor expr in constant_expressions\n}\n)\nparams.update(\n{\nstringify(expr): torch.tensor(\nnp.array(expr.tolist(), dtype=np.cdouble), requires_grad=False\n)\nfor expr in unique_const_matrices\n}\n)\nreturn params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n\"\"\"\n    Arguments:\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\nself.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\nself.register = Register(support) if isinstance(support, int) else support\nglobal_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\nif not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\nraise ValueError(\nf\"Register with {self.register.n_qubits} qubits is too small for the \"\nf\"given block with {self.block.n_qubits} qubits\"\n)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n\"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\nreturn QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n\"\"\"Extract one or more blocks using the human-readable tag.\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n    Args:\n        tag (str): the tag to look for\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\ndef _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\nblocks = []\nif block.tag == tag:\nblocks += [block]\nif isinstance(block, CompositeBlock):\nblocks += flatten(*[_get_block(b) for b in block.blocks])\nreturn blocks\nreturn _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n\"\"\"Extract all parameters for primitive blocks in the circuit.\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\nreturn parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(self, support: nx.Graph | int, spacing: float | None = 1.0):\n\"\"\"A 2D register of qubits which includes their coordinates.\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\nself.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n# Auxiliary complete graph\nsupport = self.graph.nodes\nall_edges = list(filter(lambda x: x[0] &lt; x[1], product(support, support)))\nself.complete_graph = nx.Graph()\nself.complete_graph.add_nodes_from(support)\nself.complete_graph.add_edges_from(all_edges)\nif spacing is not None and self.min_distance != 0.0:\n_scale_node_positions(self.graph, self.min_distance, spacing)\npos_values = nx.get_node_attributes(self.graph, \"pos\")\nnx.set_node_attributes(self.complete_graph, pos_values, \"pos\")\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n\"\"\"Create graph representing linear lattice.\n    Args:\n        n_qubits (int): number of nodes in the graph\n    Returns:\n        graph instance\n    \"\"\"\ngraph = nx.Graph()\nfor i in range(n_qubits):\ngraph.add_node(i, pos=(i, 0.0))\nfor i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\ngraph.add_edge(i, j)\nreturn graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('cf5c6a5b-bce9-4a8c-93e3-3aa3e12327c3', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.789175520652516'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('1df5ec96-118b-4402-865a-644f037835f4', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.41066690020480434'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('79fc11e7-abc5-4c61-8b5a-0476937aaa17', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.7262773469971591'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('01279f6a-1e16-43f3-8bc0-938072a6a7e7', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.9592730319839947'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('c359e9ea-fb0d-423f-8b25-1515acf80067', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.29853362350562773'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('bfd124ee-7625-4b6b-bc9e-3feeff9f80f5', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.8358036266838368'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nobj: Any\nif d.get(\"expression\"):\nexpr = eval(d[\"expression\"])\nif hasattr(expr, \"free_symbols\"):\nfor symb in expr.free_symbols:\nsymb.value = float(d[\"symbols\"][symb.name][\"value\"])\nobj = expr\nelif d.get(\"QuantumModel\"):\nobj = QuantumModel._from_dict(d, as_torch)\nelif d.get(\"QNN\"):\nobj = QNN._from_dict(d, as_torch)\nelif d.get(\"TransformedModule\"):\nobj = TransformedModule._from_dict(d, as_torch)\nelif d.get(\"block\") and d.get(\"register\"):\nobj = QuantumCircuit._from_dict(d)\nelif d.get(\"graph\"):\nobj = Register._from_dict(d)\nelif d.get(\"type\"):\nif d[\"type\"] in ALL_BLOCK_NAMES:\nblock: AbstractBlock = (\ngetattr(operations, d[\"type\"])._from_dict(d)\nif hasattr(operations, d[\"type\"])\nelse getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n)\nif d[\"tag\"] is not None:\nblock = tag(block, d[\"tag\"])\nobj = block\nelse:\nimport warnings\nmsg = warnings.warn(\n\"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n)\ntry:\nmodule_name = list(d.keys())[0]\nobj = getattr(globals(), module_name)\nobj.load_state_dict(d[module_name])\nexcept Exception as e:\nlogger.error(\nTypeError(\nf\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n)\n)\nreturn obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nd = {}\nif isinstance(file_path, str):\nfile_path = Path(file_path)\nif not os.path.exists(file_path):\nlogger.error(f\"File {file_path} not found.\")\nraise FileNotFoundError\nFORMAT = file_extension(file_path)\n_, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\ntry:\nd = load_fn(file_path, map_location)\nlogger.debug(f\"Successfully loaded {d} from {file_path}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to load Object from {file_path} due to {e}\")\nreturn deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\nobj: SUPPORTED_TYPES,\nfolder: str | Path,\nfile_name: str = \"\",\nformat: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(f\"Serialization of object type {type(obj)} not supported.\")\nfolder = Path(folder)\nif not folder.is_dir():\nlogger.error(NotADirectoryError)\nif file_name == \"\":\nfile_name = type(obj).__name__\ntry:\nsuffix, save_fn, _, save_params = FORMAT_DICT[format]\nd = serialize(obj, save_params)\nfile_path = folder / Path(file_name + suffix)\nsave_fn(d, file_path)\nlogger.debug(f\"Successfully saved {obj} from to {folder}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('6e4eaaa0-7b95-42bc-86e9-c16d1b7c80f9', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.39070750051343706'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('6c888a13-8a5c-4c35-8f72-7ace2a9d156b', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.41850047742945184'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('58449cc4-8ef8-4f46-ba6f-4c3137fbf63e', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.9575646045718003'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('7e16a960-a627-4263-a582-3bbbd2be8d60', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.04088597391021753'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('b0b87284-6659-4827-a86c-a94136bdce91', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.8270642740051448'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('ef83de65-875e-4db6-8c6a-8c7995803c71', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.8746260993314904'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\nd: dict = {}\ntry:\nif isinstance(obj, Expr):\nsymb_dict = {}\nexpr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\nsymbs: set[Parameter | Basic] = obj.free_symbols\nif symbs:\nsymb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\nd = {**expr_dict, **symb_dict}\nelif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\nd = obj._to_dict(save_params)\nelif isinstance(obj, torch.nn.Module):\nd = {type(obj).__name__: obj.state_dict()}\nelse:\nd = obj._to_dict()\nexcept Exception as e:\nlogger.error(f\"Serialization of object {obj} failed due to {e}\")\nreturn d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n\"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A ChainBlock representing the GHZ state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\ncnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\nreturn chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a GHZ state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2))\nreturn norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n\"\"\"\n    Checks if a wave function is normalized.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n    Returns:\n        A bool.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nwf = wf.unsqueeze(0)\nsum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\nones = torch.ones_like(sum_probs)\nreturn torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n\"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum())\nelse:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the one state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"1\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n\"\"\"\n    Converts a wave function into a torch Distribution.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n    Returns:\n        A torch.distributions.Distribution.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\nreturn Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n\"\"\"\n    Creates an abstract product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\nreturn _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\nbitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n\"\"\"\n    Creates a product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\nreturn _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>11101101\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n\"\"\"\n    Creates a random bistring.\n    Arguments:\n        N (int): The length of the bitstring.\n    Returns:\n        A string.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\nreturn \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Creates a block representing a random abstract product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\nreturn product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a random product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nwf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\nrand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\nwf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\nreturn wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[-0.1316-0.2250j, -0.0565-0.1414j,  0.3979+0.3708j,  0.7759-0.1056j]])\ntensor([[0.8356-0.2161j, 0.0000+0.0000j, 0.1264+0.4890j, 0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\nn_qubits: int,\nbatch_size: int = 1,\nbackend: str = BackendName.PYQTORCH,\ntype: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n\"\"\"\n    Generates a random state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\nif type == StateGeneratorType.HAAR_MEASURE_FAST:\nstate = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.HAAR_MEASURE_SLOW:\nstate = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.RANDOM_ROTATIONS:\nstate = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\nassert all(list(map(is_normalized, state)))\nreturn state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the uniform state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\nreturn norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the zero state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"0\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n@blockfn_to_circfn\ndef fn(block):\n# un-decorated function accepts a block and returns a block\nreturn block * block\ntransp = transpile(\n# the decorated function accepts a circuit and returns a circuit\nfn,\n# already existing functions can also be decorated\nblockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n\"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n    Returns:\n        Composed function.\n    Examples:\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\nreturn lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\nif is_chain_of_primitivekrons(block):\ntry:\nreturn kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\nexcept Exception as e:\nlogger.debug(\nf\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n)\nreturn block\nelif isinstance(block, CompositeBlock):\nreturn _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 ChainBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n\"\"\"Push the scale all the way down into the leaves of the block tree.\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n    Examples:\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\nraise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\nblocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n\"\"\"Set the trainability of all parameters in a block to a given value.\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\nif isinstance(blocks, AbstractBlock):\nblocks = [blocks]\nif inplace:\nfor block in blocks:\nparams: list[sympy.Basic] = parameters(block)\nfor p in params:\nif not p.is_number:\np.trainable = value\nelse:\nraise NotImplementedError(\"Not inplace set_trainable is not yet available\")\nreturn blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n\u2514\u2500\u2500 ChainBlock(0)\n\u2514\u2500\u2500 put on (0)\n\u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n    Reassigns qubit locations appropriately.\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\nvblock: AbstractBlock\nfrom qadence.transpile import reassign\nif isinstance(block, ControlBlock):\nvblock = deepcopy(block)\nb: AbstractBlock\n(b,) = block.blocks\nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nb = validate(b)\nvblock.blocks = (b,)  # type: ignore[assignment]\nelif isinstance(block, CompositeBlock):\nblocks = []\nfor b in block.blocks:\nmi, ma = min(b.qubit_support), max(b.qubit_support)\nnb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nnb = validate(nb)\nnb = PutBlock(nb, tuple(range(mi, ma + 1)))\nblocks.append(nb)\ntry:\nvblock = _construct(type(block), tuple(blocks))\nexcept AssertionError as e:\nif str(e) == \"Make sure blocks act on distinct qubits!\":\nvblock = chain(*blocks)\nelse:\nraise e\nelif isinstance(block, PrimitiveBlock):\nvblock = deepcopy(block)\nelse:\nraise NotImplementedError\nvblock.tag = block.tag\nreturn vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>add_interaction</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Used when dumping enum fields in a schema.\"\"\"\nret: str = self.value\nreturn ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\nn_qubits = 4\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 69, '1000': 10, '0001': 9, '0100': 7, '0010': 2, '0011': 1, '1010': 1, '1100': 1})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\nmodel = qd.QNN(circuit, observable)\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: tensor([[0.4619],\n[0.2336],\n[0.3466],\n[0.3091],\n[0.3848],\n[0.5296],\n[0.1685],\n[0.2566],\n[0.3779],\n[0.2013]], grad_fn=&lt;CatBackward0&gt;)\nFirst-order derivative w.r.t. the feature parameter: tensor([-1.0731,  0.7376,  0.7347,  0.7483, -1.9705,  0.1689,  0.6896, -5.4024,\n0.7118,  0.7184], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: tensor([-1.0731,  0.7376,  0.7347,  0.7483, -1.9705,  0.1689,  0.6896, -5.4024,\n0.7118,  0.7184], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\nx = torch.linspace(0, 1, data_size).reshape(-1, 1)\ny = torch.sin(x)\nreturn to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\ndls = {}\nfor k in [\"y1\", \"y2\"]:\nx = torch.rand(data_size, 1)\ny = torch.sin(x)\ndls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\nreturn DictDataLoader(dls)\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\nprint(f\"Standard {x = }\")\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n(x, y) = next(dl)\nprint(f\"Infinite {x = }\")\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n[0.2000]])\nStandard x = tensor([[0.4000],\n[0.6000]])\nStandard x = tensor([[0.8000],\n[1.0000]])\nInfinite x = tensor([[0.0000],\n[0.2000]])\nInfinite x = tensor([[0.4000],\n[0.6000]])\nInfinite x = tensor([[0.8000],\n[1.0000]])\nInfinite x = tensor([[0.0000],\n[0.2000]])\nInfinite x = tensor([[0.4000],\n[0.6000]])\ndata = {'y1': [tensor([[0.2434],\n[0.3151],\n[0.1038],\n[0.4767],\n[0.1838]]), tensor([[0.2410],\n[0.3099],\n[0.1036],\n[0.4589],\n[0.1827]])], 'y2': [tensor([[0.9386],\n[0.6771],\n[0.9058],\n[0.5234],\n[0.6710]]), tensor([[0.8067],\n[0.6266],\n[0.7869],\n[0.4999],\n[0.6218]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\nbatch_size = 5\nn_epochs = 100\nconfig = TrainConfig(\nfolder=\"some_path/\",\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 50\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2023-11-21T16:26:26.590403 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\ntmp_path = Path(\"/tmp\")\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\nfor i in range(n_epochs):\nout = model(x)\nloss = criterion(out, y)\nloss.backward()\noptimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\ndef train(\nmodel: Module,\ndata: DataLoader,\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\ndl_iter = iter(dataloader)\n# outer epoch loop\nfor iteration in range(init_iter, init_iter + config.max_iter):\ndata = data_to_device(next(dl_iter), device)\nloss, metrics = optimize_step(model, optimizer, loss_fn, data)\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\nnx.draw(graph)\n</code></pre> 2023-11-21T16:26:27.129293 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\nn_qubits = graph.number_of_nodes()\nn_layers = 2\ncost_ham = Zero()\nfor op in zz_ops:\ncost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\nlayers = []\nfor layer in range(n_layers):\n# cost layer with digital decomposition\ncost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\ncost_layer = tag(cost_layer, \"cost\")\n# mixing layer with single qubit rotations\nmixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\nmixing_layer = tag(mixing_layer, \"mixing\")\n# putting all together in a single ChainBlock\nlayers.append(chain(cost_layer, mixing_layer))\nfinal_b = chain(*layers)\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_d5b333536c8a48239091cde188ecaff6 mixing cluster_49903ebc94024c2c8184236a03735fae cost cluster_955054a9fd214d57950eb138759c851b mixing cluster_f622f90b08e14acea2cf9c3dba9aa77a cost 4bf2978370fa44b4934d4df668d9e3d0 0 0f78d014664d4272a486fd4ec001cca7 4bf2978370fa44b4934d4df668d9e3d0--0f78d014664d4272a486fd4ec001cca7 2a725f96e813448899c1269405c471bd 1 40941c1446fc4a2191f8a5121467943c 0f78d014664d4272a486fd4ec001cca7--40941c1446fc4a2191f8a5121467943c 85d2cf90d21b4b96868758336966f71f 40941c1446fc4a2191f8a5121467943c--85d2cf90d21b4b96868758336966f71f aa368d3aa0b447cd9e04dbfda25bb07f 85d2cf90d21b4b96868758336966f71f--aa368d3aa0b447cd9e04dbfda25bb07f c1550f110975496d8fb47d3be5505a4b aa368d3aa0b447cd9e04dbfda25bb07f--c1550f110975496d8fb47d3be5505a4b 58d8dfc34a4a4e038af830b8d82ebdf2 c1550f110975496d8fb47d3be5505a4b--58d8dfc34a4a4e038af830b8d82ebdf2 d35efee7243449f696d05364d294f624 58d8dfc34a4a4e038af830b8d82ebdf2--d35efee7243449f696d05364d294f624 aff531fa06b74dd7b1a72a44cc580275 d35efee7243449f696d05364d294f624--aff531fa06b74dd7b1a72a44cc580275 768c8bd92f2d4b5284db088c2373601a aff531fa06b74dd7b1a72a44cc580275--768c8bd92f2d4b5284db088c2373601a e57b57566f0148448377486a34d2b6de 768c8bd92f2d4b5284db088c2373601a--e57b57566f0148448377486a34d2b6de c90cfe35efb6493abee7a43d7a4df989 e57b57566f0148448377486a34d2b6de--c90cfe35efb6493abee7a43d7a4df989 4aa9ac101dff49279656d9889d8facaa c90cfe35efb6493abee7a43d7a4df989--4aa9ac101dff49279656d9889d8facaa e34e08001b764526b0ca9c82b238c2d2 4aa9ac101dff49279656d9889d8facaa--e34e08001b764526b0ca9c82b238c2d2 f273a29e4e7445f58d4ff8c4538ec547 e34e08001b764526b0ca9c82b238c2d2--f273a29e4e7445f58d4ff8c4538ec547 a07f2c9fd82e419f9a157c2c57ea07d5 f273a29e4e7445f58d4ff8c4538ec547--a07f2c9fd82e419f9a157c2c57ea07d5 a64b298098824e41b09da0ac86d468d2 a07f2c9fd82e419f9a157c2c57ea07d5--a64b298098824e41b09da0ac86d468d2 0e8e968190b64d84a68fb4759d590139 a64b298098824e41b09da0ac86d468d2--0e8e968190b64d84a68fb4759d590139 6801f83fe5b3475590dd3707ff150cf2 0e8e968190b64d84a68fb4759d590139--6801f83fe5b3475590dd3707ff150cf2 7fdf84a8fe2841518f97059fb4189694 6801f83fe5b3475590dd3707ff150cf2--7fdf84a8fe2841518f97059fb4189694 3f6bdee69a78412da1b30cf03f1288e2 7fdf84a8fe2841518f97059fb4189694--3f6bdee69a78412da1b30cf03f1288e2 0e8a05a64a8d46ee9a04a896dd49a68d 3f6bdee69a78412da1b30cf03f1288e2--0e8a05a64a8d46ee9a04a896dd49a68d 0401911687a949ca87d97ec722b3780b 0e8a05a64a8d46ee9a04a896dd49a68d--0401911687a949ca87d97ec722b3780b 751f722e61e449b6bc95921a778cf2f2 0401911687a949ca87d97ec722b3780b--751f722e61e449b6bc95921a778cf2f2 8d60d759252f44cca5bd160a98487d9b 751f722e61e449b6bc95921a778cf2f2--8d60d759252f44cca5bd160a98487d9b b261d6e769ca4d70a9d1e278cfa24a9e 8d60d759252f44cca5bd160a98487d9b--b261d6e769ca4d70a9d1e278cfa24a9e 479ef513fbfc4891bc2de98485e50261 b261d6e769ca4d70a9d1e278cfa24a9e--479ef513fbfc4891bc2de98485e50261 d3eed70fe106440e9dfe4aae8fabc390 479ef513fbfc4891bc2de98485e50261--d3eed70fe106440e9dfe4aae8fabc390 9d9387abc55141afb2c01b6beda7a727 d3eed70fe106440e9dfe4aae8fabc390--9d9387abc55141afb2c01b6beda7a727 f92528859c7b454eb76650995f85dc92 9d9387abc55141afb2c01b6beda7a727--f92528859c7b454eb76650995f85dc92 7c74bf26ca3d4c5da0f44dfed1ea312c f92528859c7b454eb76650995f85dc92--7c74bf26ca3d4c5da0f44dfed1ea312c 0508cad9d2b041c4b5ac798f3817b549 7c74bf26ca3d4c5da0f44dfed1ea312c--0508cad9d2b041c4b5ac798f3817b549 2a0dbf748f2a465b8b5a02268858660c 0508cad9d2b041c4b5ac798f3817b549--2a0dbf748f2a465b8b5a02268858660c 327ccc4aea164959a5390b0eb2d9904f 2a0dbf748f2a465b8b5a02268858660c--327ccc4aea164959a5390b0eb2d9904f f3c06a1c71874b0a90b86315c0f16dcc 327ccc4aea164959a5390b0eb2d9904f--f3c06a1c71874b0a90b86315c0f16dcc 18800c4114714fd193266418172c02ea f3c06a1c71874b0a90b86315c0f16dcc--18800c4114714fd193266418172c02ea 0ca42f0a0821423fabb4868e259edd54 18800c4114714fd193266418172c02ea--0ca42f0a0821423fabb4868e259edd54 ea06f12eb8934661921d28db450e82f4 0ca42f0a0821423fabb4868e259edd54--ea06f12eb8934661921d28db450e82f4 3a2af9866bf948918c73e407ddf6fb0f ea06f12eb8934661921d28db450e82f4--3a2af9866bf948918c73e407ddf6fb0f 4876826ed9dd4ed083585bd17dc2dc38 3a2af9866bf948918c73e407ddf6fb0f--4876826ed9dd4ed083585bd17dc2dc38 ccc228f5a79740de979cafece7dc3906 4876826ed9dd4ed083585bd17dc2dc38--ccc228f5a79740de979cafece7dc3906 21865d58579543ef8c0f48f4c7f74bc3 ccc228f5a79740de979cafece7dc3906--21865d58579543ef8c0f48f4c7f74bc3 58a48c4ce8f7404b8c21d0e3039f7fd6 21865d58579543ef8c0f48f4c7f74bc3--58a48c4ce8f7404b8c21d0e3039f7fd6 c7a30ecf7ec74877ab08e0fcdf00f03b 58a48c4ce8f7404b8c21d0e3039f7fd6--c7a30ecf7ec74877ab08e0fcdf00f03b ea10e46d08854d6389909f9231233142 c7a30ecf7ec74877ab08e0fcdf00f03b--ea10e46d08854d6389909f9231233142 39552ec29dc2421488f2f0c216f87b76 ea10e46d08854d6389909f9231233142--39552ec29dc2421488f2f0c216f87b76 ca22ee6544964db49ae89317e74edb3a 39552ec29dc2421488f2f0c216f87b76--ca22ee6544964db49ae89317e74edb3a 0bb261a8cf2c4e53b80841f423fe258b ca22ee6544964db49ae89317e74edb3a--0bb261a8cf2c4e53b80841f423fe258b 4152bace3dda4931847d8d00c430fb33 RX(b00) 0bb261a8cf2c4e53b80841f423fe258b--4152bace3dda4931847d8d00c430fb33 75ad6fcea40e4a13b7e5eaf36da9d222 4152bace3dda4931847d8d00c430fb33--75ad6fcea40e4a13b7e5eaf36da9d222 6ec6671013834587807fc415ce0de63b 75ad6fcea40e4a13b7e5eaf36da9d222--6ec6671013834587807fc415ce0de63b 84da643c9d2142809ef79924fbf9bebc 6ec6671013834587807fc415ce0de63b--84da643c9d2142809ef79924fbf9bebc f8b11d6843944cb6b625ba324bea5430 84da643c9d2142809ef79924fbf9bebc--f8b11d6843944cb6b625ba324bea5430 1c692b36e37e448a955f250212637697 f8b11d6843944cb6b625ba324bea5430--1c692b36e37e448a955f250212637697 5ad61ae796e8459e9afc94f7df87e096 1c692b36e37e448a955f250212637697--5ad61ae796e8459e9afc94f7df87e096 bec6cd58132946c0897bd9796a079060 5ad61ae796e8459e9afc94f7df87e096--bec6cd58132946c0897bd9796a079060 4bc64290d07a40419d13976c5da25ef6 bec6cd58132946c0897bd9796a079060--4bc64290d07a40419d13976c5da25ef6 f03100b56ae640fa9f26ae7230d0deda 4bc64290d07a40419d13976c5da25ef6--f03100b56ae640fa9f26ae7230d0deda 9b3490b284d64a4489563cbc4f0b98f0 f03100b56ae640fa9f26ae7230d0deda--9b3490b284d64a4489563cbc4f0b98f0 51e9b30e0c1a44cab4cd8edb3c71cb8b 9b3490b284d64a4489563cbc4f0b98f0--51e9b30e0c1a44cab4cd8edb3c71cb8b 5d07e41fecad4dac99a33a116d5d0866 51e9b30e0c1a44cab4cd8edb3c71cb8b--5d07e41fecad4dac99a33a116d5d0866 70ae536d61a247768640163b384a932c 5d07e41fecad4dac99a33a116d5d0866--70ae536d61a247768640163b384a932c ab505dc899cb445490d0ac128a45fc40 70ae536d61a247768640163b384a932c--ab505dc899cb445490d0ac128a45fc40 8b369e86d2d648f79a029fccb68db10d ab505dc899cb445490d0ac128a45fc40--8b369e86d2d648f79a029fccb68db10d 6e5e250c5fe247a4a121b19fe28616b2 8b369e86d2d648f79a029fccb68db10d--6e5e250c5fe247a4a121b19fe28616b2 7ac39b543de749d8b6266e1e65392049 6e5e250c5fe247a4a121b19fe28616b2--7ac39b543de749d8b6266e1e65392049 57019ce0d7c44d7387b0503d99132d5b 7ac39b543de749d8b6266e1e65392049--57019ce0d7c44d7387b0503d99132d5b da8ff20fe2034f7581da0987a60b3bf6 57019ce0d7c44d7387b0503d99132d5b--da8ff20fe2034f7581da0987a60b3bf6 84adcc3efed3469abd86e032e1ffbb95 da8ff20fe2034f7581da0987a60b3bf6--84adcc3efed3469abd86e032e1ffbb95 41249b0e91f24071b52cc4f97d6e5cce 84adcc3efed3469abd86e032e1ffbb95--41249b0e91f24071b52cc4f97d6e5cce 520513530feb431f8509dd77779089e6 41249b0e91f24071b52cc4f97d6e5cce--520513530feb431f8509dd77779089e6 579aa104317c46afb61dcdb7e4d1b994 520513530feb431f8509dd77779089e6--579aa104317c46afb61dcdb7e4d1b994 a5e1ccc5c47446928cc236a878aa18eb 579aa104317c46afb61dcdb7e4d1b994--a5e1ccc5c47446928cc236a878aa18eb ff3f9067842d48b4b66eda1084e0a542 a5e1ccc5c47446928cc236a878aa18eb--ff3f9067842d48b4b66eda1084e0a542 98bee9e95f1945c6bd65e4ddae3910f2 ff3f9067842d48b4b66eda1084e0a542--98bee9e95f1945c6bd65e4ddae3910f2 b204bc487f1f4942a962f49ba4cf8194 98bee9e95f1945c6bd65e4ddae3910f2--b204bc487f1f4942a962f49ba4cf8194 a5a612a140b44d4cbf040916f65536ad b204bc487f1f4942a962f49ba4cf8194--a5a612a140b44d4cbf040916f65536ad 47edb78c509244bebc8a077361e444e0 a5a612a140b44d4cbf040916f65536ad--47edb78c509244bebc8a077361e444e0 705f6395bf9f48fd89a91fff66e35594 47edb78c509244bebc8a077361e444e0--705f6395bf9f48fd89a91fff66e35594 71f1f9ad0062412cae52111044fe3ce5 705f6395bf9f48fd89a91fff66e35594--71f1f9ad0062412cae52111044fe3ce5 f90d717dbed445e581ea2069ea661d40 71f1f9ad0062412cae52111044fe3ce5--f90d717dbed445e581ea2069ea661d40 b26409c51e64491cac67b3b41c17a749 f90d717dbed445e581ea2069ea661d40--b26409c51e64491cac67b3b41c17a749 a5ab3aa06e4c4216973b8fadbb2e8cfb b26409c51e64491cac67b3b41c17a749--a5ab3aa06e4c4216973b8fadbb2e8cfb bef02f3d1e0f4506b46085fca7126114 a5ab3aa06e4c4216973b8fadbb2e8cfb--bef02f3d1e0f4506b46085fca7126114 8513066ab5784cbe99ec6d74ff525228 bef02f3d1e0f4506b46085fca7126114--8513066ab5784cbe99ec6d74ff525228 39855c6b96bc4aee904a825198e27fcf 8513066ab5784cbe99ec6d74ff525228--39855c6b96bc4aee904a825198e27fcf a594ae4809a8424b93924d8d9ab832d6 39855c6b96bc4aee904a825198e27fcf--a594ae4809a8424b93924d8d9ab832d6 9954c3f4aba64ba3940e4c43ce0c3d2e a594ae4809a8424b93924d8d9ab832d6--9954c3f4aba64ba3940e4c43ce0c3d2e 604b5a98b1224894b83b45fda55d6b37 9954c3f4aba64ba3940e4c43ce0c3d2e--604b5a98b1224894b83b45fda55d6b37 9e10fe6ed2334b61978b2742daa94164 604b5a98b1224894b83b45fda55d6b37--9e10fe6ed2334b61978b2742daa94164 de7a2edb6d0a44158790ac7ac346f905 9e10fe6ed2334b61978b2742daa94164--de7a2edb6d0a44158790ac7ac346f905 08f0e78ee0bb4ad3b25388c5241333a5 de7a2edb6d0a44158790ac7ac346f905--08f0e78ee0bb4ad3b25388c5241333a5 a4f4ba50e24e49a29a00f7b0e3575815 08f0e78ee0bb4ad3b25388c5241333a5--a4f4ba50e24e49a29a00f7b0e3575815 1b108b7ff08e4d78bec738f7fb29996d a4f4ba50e24e49a29a00f7b0e3575815--1b108b7ff08e4d78bec738f7fb29996d 3598c0b8ff0940fabb035ded2c98745f 1b108b7ff08e4d78bec738f7fb29996d--3598c0b8ff0940fabb035ded2c98745f 08df2fbbf6524c9db4e0f2ed9a2d0dec 3598c0b8ff0940fabb035ded2c98745f--08df2fbbf6524c9db4e0f2ed9a2d0dec 712820744bcc4b8dbac186ab63bdd008 RX(b10) 08df2fbbf6524c9db4e0f2ed9a2d0dec--712820744bcc4b8dbac186ab63bdd008 ffa99e5e0c4348e0ac358c425cc8984e 712820744bcc4b8dbac186ab63bdd008--ffa99e5e0c4348e0ac358c425cc8984e cc7b9ac63fb848998f230d92f8eea35b 0a4c620b26334cfdbc42ec343c3fe187 X 2a725f96e813448899c1269405c471bd--0a4c620b26334cfdbc42ec343c3fe187 ad2322c8bed34705827d5ef7386cde02 2 0a4c620b26334cfdbc42ec343c3fe187--0f78d014664d4272a486fd4ec001cca7 9f3568a170df4f26bb4bfbd16f194974 0a4c620b26334cfdbc42ec343c3fe187--9f3568a170df4f26bb4bfbd16f194974 89f0018ef0034659bc4e93fa865ece77 9f3568a170df4f26bb4bfbd16f194974--89f0018ef0034659bc4e93fa865ece77 ae54186c278f42899cbc27b63764b9c4 89f0018ef0034659bc4e93fa865ece77--ae54186c278f42899cbc27b63764b9c4 ace2b79a5d8048a48935b3aefc3ac07d ae54186c278f42899cbc27b63764b9c4--ace2b79a5d8048a48935b3aefc3ac07d 62c5311bf5cd4f6a94877f5125c72585 ace2b79a5d8048a48935b3aefc3ac07d--62c5311bf5cd4f6a94877f5125c72585 3bd37cbc75564061a772b764c0201dbf 62c5311bf5cd4f6a94877f5125c72585--3bd37cbc75564061a772b764c0201dbf 8c87653c29474bedafa11a313a202ef9 3bd37cbc75564061a772b764c0201dbf--8c87653c29474bedafa11a313a202ef9 a4ff40d640ff4261b82e054726022dbb 8c87653c29474bedafa11a313a202ef9--a4ff40d640ff4261b82e054726022dbb 1594bd2f7a2d4807b9dffae214e7919c a4ff40d640ff4261b82e054726022dbb--1594bd2f7a2d4807b9dffae214e7919c d717deb4feb34253a5408a7643d01bdd 1594bd2f7a2d4807b9dffae214e7919c--d717deb4feb34253a5408a7643d01bdd e605511599724aa8943729780b497942 d717deb4feb34253a5408a7643d01bdd--e605511599724aa8943729780b497942 d26d927503384c3eab1183809260c38a e605511599724aa8943729780b497942--d26d927503384c3eab1183809260c38a 03b0500261ed4a0593539dfae87046ec d26d927503384c3eab1183809260c38a--03b0500261ed4a0593539dfae87046ec dc265af3d5e643cc926fe7785256fe31 X 03b0500261ed4a0593539dfae87046ec--dc265af3d5e643cc926fe7785256fe31 dc265af3d5e643cc926fe7785256fe31--a07f2c9fd82e419f9a157c2c57ea07d5 b5609b693bb246e0b904ee0b1d009d32 dc265af3d5e643cc926fe7785256fe31--b5609b693bb246e0b904ee0b1d009d32 a8663732d2474814beb87bfffa6d47a7 b5609b693bb246e0b904ee0b1d009d32--a8663732d2474814beb87bfffa6d47a7 9cbb2d8a31df410a95268d6a546eda79 a8663732d2474814beb87bfffa6d47a7--9cbb2d8a31df410a95268d6a546eda79 668bfbfe0c664026ae8f1d86fb906c69 9cbb2d8a31df410a95268d6a546eda79--668bfbfe0c664026ae8f1d86fb906c69 778b61f2641e49599850f614e4dea98b 668bfbfe0c664026ae8f1d86fb906c69--778b61f2641e49599850f614e4dea98b 2ae6469ad28c4825a9c382b706532588 778b61f2641e49599850f614e4dea98b--2ae6469ad28c4825a9c382b706532588 1bb37026f86b45d39fbb5548dc00a4cd 2ae6469ad28c4825a9c382b706532588--1bb37026f86b45d39fbb5548dc00a4cd 3ed1fe34e19e4f46a4f1d54e109be46f 1bb37026f86b45d39fbb5548dc00a4cd--3ed1fe34e19e4f46a4f1d54e109be46f 1d064af51e5542c99642f8d667800836 3ed1fe34e19e4f46a4f1d54e109be46f--1d064af51e5542c99642f8d667800836 b2420e8989b94004ac707cee53d4c283 1d064af51e5542c99642f8d667800836--b2420e8989b94004ac707cee53d4c283 b87cd84e86344b6a8634306b9f551763 b2420e8989b94004ac707cee53d4c283--b87cd84e86344b6a8634306b9f551763 50846d1b3ece43baa4005ee9dbf21b0a b87cd84e86344b6a8634306b9f551763--50846d1b3ece43baa4005ee9dbf21b0a d6e1d518f997440cbf6f919ccc77f069 50846d1b3ece43baa4005ee9dbf21b0a--d6e1d518f997440cbf6f919ccc77f069 94a2e907eac5447694016125c4ba22eb d6e1d518f997440cbf6f919ccc77f069--94a2e907eac5447694016125c4ba22eb 308422e7acad4ea5ab9868df95ea029a 94a2e907eac5447694016125c4ba22eb--308422e7acad4ea5ab9868df95ea029a 30b82bfc59c34f81b362c26609d7739e 308422e7acad4ea5ab9868df95ea029a--30b82bfc59c34f81b362c26609d7739e fe8f07dd4bca458ca3380fdfb749b75b 30b82bfc59c34f81b362c26609d7739e--fe8f07dd4bca458ca3380fdfb749b75b 4e136aded65a4a0dabf4370889279e40 fe8f07dd4bca458ca3380fdfb749b75b--4e136aded65a4a0dabf4370889279e40 f1863e66db9547079ee0a188c7ff1f42 4e136aded65a4a0dabf4370889279e40--f1863e66db9547079ee0a188c7ff1f42 c9aa7098484c4a3c8c2ebb4e70d97e04 f1863e66db9547079ee0a188c7ff1f42--c9aa7098484c4a3c8c2ebb4e70d97e04 dce3236e4b174fa2baff127c175fec06 c9aa7098484c4a3c8c2ebb4e70d97e04--dce3236e4b174fa2baff127c175fec06 84fdbe983f644da9861191901429e359 dce3236e4b174fa2baff127c175fec06--84fdbe983f644da9861191901429e359 05c02f3b82c145dc9d392665f5a4002a 84fdbe983f644da9861191901429e359--05c02f3b82c145dc9d392665f5a4002a 5da88c49e3d44f558a99f79ef87015fa 05c02f3b82c145dc9d392665f5a4002a--5da88c49e3d44f558a99f79ef87015fa 960d87ff0ccc4b17861c4dc619fd0a92 5da88c49e3d44f558a99f79ef87015fa--960d87ff0ccc4b17861c4dc619fd0a92 32f4ad251a15451a864db1ec0e94ca65 960d87ff0ccc4b17861c4dc619fd0a92--32f4ad251a15451a864db1ec0e94ca65 d1c3b39bd02145649f17a86b5b481bd9 32f4ad251a15451a864db1ec0e94ca65--d1c3b39bd02145649f17a86b5b481bd9 e0ab8b3ab0ad4c6f82c1082a2220455e d1c3b39bd02145649f17a86b5b481bd9--e0ab8b3ab0ad4c6f82c1082a2220455e e28ec7283a9242db9d4926ca48523409 e0ab8b3ab0ad4c6f82c1082a2220455e--e28ec7283a9242db9d4926ca48523409 0e1dea753b194bcd8e12d12ef036adad e28ec7283a9242db9d4926ca48523409--0e1dea753b194bcd8e12d12ef036adad f3bf3a318d0a477b9804092fac0c9c05 0e1dea753b194bcd8e12d12ef036adad--f3bf3a318d0a477b9804092fac0c9c05 145338b38e484e16bd643d68a959acb2 f3bf3a318d0a477b9804092fac0c9c05--145338b38e484e16bd643d68a959acb2 8e96f3b6226c4682ab951a0b391a1a33 RX(b01) 145338b38e484e16bd643d68a959acb2--8e96f3b6226c4682ab951a0b391a1a33 449604b13d084bab8f77ba4cae0e6705 X 8e96f3b6226c4682ab951a0b391a1a33--449604b13d084bab8f77ba4cae0e6705 449604b13d084bab8f77ba4cae0e6705--75ad6fcea40e4a13b7e5eaf36da9d222 6a9754e5ac6b4edeb6734ae9b72b626e 449604b13d084bab8f77ba4cae0e6705--6a9754e5ac6b4edeb6734ae9b72b626e 349ec69ce8d3461c84509b23c3501513 6a9754e5ac6b4edeb6734ae9b72b626e--349ec69ce8d3461c84509b23c3501513 908ecbef56af4d1fbcfa33945871cb3a 349ec69ce8d3461c84509b23c3501513--908ecbef56af4d1fbcfa33945871cb3a b8ba1b03599341b0bff5943b9940d2b7 908ecbef56af4d1fbcfa33945871cb3a--b8ba1b03599341b0bff5943b9940d2b7 39ab34c6b4c14bebb9580ef96c584225 b8ba1b03599341b0bff5943b9940d2b7--39ab34c6b4c14bebb9580ef96c584225 fe44955a4abe4e03a0e142d3b6dc8d4b 39ab34c6b4c14bebb9580ef96c584225--fe44955a4abe4e03a0e142d3b6dc8d4b 7ad8760e0713448eb8f01049779e4b3d fe44955a4abe4e03a0e142d3b6dc8d4b--7ad8760e0713448eb8f01049779e4b3d 0c3342add710478c865a57b6b9d8a4fe 7ad8760e0713448eb8f01049779e4b3d--0c3342add710478c865a57b6b9d8a4fe 994a8e1f917c41158bf4bca7d93dabc8 0c3342add710478c865a57b6b9d8a4fe--994a8e1f917c41158bf4bca7d93dabc8 03f5b9afbdd94aa194f55ec0ed242424 994a8e1f917c41158bf4bca7d93dabc8--03f5b9afbdd94aa194f55ec0ed242424 6c18643ac9ac4f9486aae81ebc1a73cd 03f5b9afbdd94aa194f55ec0ed242424--6c18643ac9ac4f9486aae81ebc1a73cd bb7ec4b296e1436c910d784915d5598f 6c18643ac9ac4f9486aae81ebc1a73cd--bb7ec4b296e1436c910d784915d5598f 62d85b7cee7c4da088d790681ae9bd09 bb7ec4b296e1436c910d784915d5598f--62d85b7cee7c4da088d790681ae9bd09 44d759831c244625b2c71fe36ad189e7 X 62d85b7cee7c4da088d790681ae9bd09--44d759831c244625b2c71fe36ad189e7 44d759831c244625b2c71fe36ad189e7--8b369e86d2d648f79a029fccb68db10d f20c0cc7a5de43f58b571e813584d609 44d759831c244625b2c71fe36ad189e7--f20c0cc7a5de43f58b571e813584d609 8e6aa0f9e7bb4791bc654355ec2958ab f20c0cc7a5de43f58b571e813584d609--8e6aa0f9e7bb4791bc654355ec2958ab 95ac294b58564549ae5f2322214eb224 8e6aa0f9e7bb4791bc654355ec2958ab--95ac294b58564549ae5f2322214eb224 91a411e30df44dbfa0ca4062cf123a60 95ac294b58564549ae5f2322214eb224--91a411e30df44dbfa0ca4062cf123a60 ed44f7b7f4da4365a026093d9ce17fb2 91a411e30df44dbfa0ca4062cf123a60--ed44f7b7f4da4365a026093d9ce17fb2 93c540969fc4473bb75e95cb78f329d6 ed44f7b7f4da4365a026093d9ce17fb2--93c540969fc4473bb75e95cb78f329d6 3e65af88ef474f1ca545f4cd076c0b5f 93c540969fc4473bb75e95cb78f329d6--3e65af88ef474f1ca545f4cd076c0b5f f266b2af2d344747b8a76047f2f719a8 3e65af88ef474f1ca545f4cd076c0b5f--f266b2af2d344747b8a76047f2f719a8 b9c9c8c55ad7430b88b319b4a89e0557 f266b2af2d344747b8a76047f2f719a8--b9c9c8c55ad7430b88b319b4a89e0557 63d75ed7b1844a00a11e083fdce63b59 b9c9c8c55ad7430b88b319b4a89e0557--63d75ed7b1844a00a11e083fdce63b59 9ebd39cd33f448c8b5b59f3fb877c10e 63d75ed7b1844a00a11e083fdce63b59--9ebd39cd33f448c8b5b59f3fb877c10e 26f25b9c31f644d38a4cd1f4d4227926 9ebd39cd33f448c8b5b59f3fb877c10e--26f25b9c31f644d38a4cd1f4d4227926 5d5333037e444e97b83308627ddbabaf 26f25b9c31f644d38a4cd1f4d4227926--5d5333037e444e97b83308627ddbabaf 311641efe8664aa88276c6d682f30e23 5d5333037e444e97b83308627ddbabaf--311641efe8664aa88276c6d682f30e23 4f58fd9d7e8348ccbd312bdeaaa898b9 311641efe8664aa88276c6d682f30e23--4f58fd9d7e8348ccbd312bdeaaa898b9 149a1c1b2e104998bc4794f92af908f3 4f58fd9d7e8348ccbd312bdeaaa898b9--149a1c1b2e104998bc4794f92af908f3 ec743b24fd1a4200a6db5fcd2c4183a7 149a1c1b2e104998bc4794f92af908f3--ec743b24fd1a4200a6db5fcd2c4183a7 6c0ed3dbcacc44c194aa4ac24d5edb0b ec743b24fd1a4200a6db5fcd2c4183a7--6c0ed3dbcacc44c194aa4ac24d5edb0b e387071ae41c4a69a860fa8b57fa80be 6c0ed3dbcacc44c194aa4ac24d5edb0b--e387071ae41c4a69a860fa8b57fa80be 55c89498b2c54942bda4756301788a29 e387071ae41c4a69a860fa8b57fa80be--55c89498b2c54942bda4756301788a29 67647dcff1aa45048554b03d934e36aa 55c89498b2c54942bda4756301788a29--67647dcff1aa45048554b03d934e36aa 6d4282ac665d405288e55a1dfdb367a9 67647dcff1aa45048554b03d934e36aa--6d4282ac665d405288e55a1dfdb367a9 480722ab030343759276224612a9dfea 6d4282ac665d405288e55a1dfdb367a9--480722ab030343759276224612a9dfea dd387c0338e04e3fbf06b9c995753bec 480722ab030343759276224612a9dfea--dd387c0338e04e3fbf06b9c995753bec 0ced654cbacb4935873dddd9e1e6e540 dd387c0338e04e3fbf06b9c995753bec--0ced654cbacb4935873dddd9e1e6e540 88c8eacba3aa45e6a54d99579312fbcb 0ced654cbacb4935873dddd9e1e6e540--88c8eacba3aa45e6a54d99579312fbcb 33d551a93c84458caa54e619c5ee48ec 88c8eacba3aa45e6a54d99579312fbcb--33d551a93c84458caa54e619c5ee48ec 88a78196ce9d490ebd12048f70832517 33d551a93c84458caa54e619c5ee48ec--88a78196ce9d490ebd12048f70832517 c4b68a034efd403385f157dd876b90d1 88a78196ce9d490ebd12048f70832517--c4b68a034efd403385f157dd876b90d1 7fe08661b9c54cf489db335bfe8f36ea c4b68a034efd403385f157dd876b90d1--7fe08661b9c54cf489db335bfe8f36ea 2bb71a5612fa4b738e87671d667ba3a0 7fe08661b9c54cf489db335bfe8f36ea--2bb71a5612fa4b738e87671d667ba3a0 742b625f8f5440df969676c3f5bb5c4a 2bb71a5612fa4b738e87671d667ba3a0--742b625f8f5440df969676c3f5bb5c4a 588524bb61014e64a871092e8f15387d RX(b11) 742b625f8f5440df969676c3f5bb5c4a--588524bb61014e64a871092e8f15387d 588524bb61014e64a871092e8f15387d--cc7b9ac63fb848998f230d92f8eea35b 6a898dab06de4ca1acd2639a8cb576f5 b903fc0140d44f51a2a5e6908130eb14 ad2322c8bed34705827d5ef7386cde02--b903fc0140d44f51a2a5e6908130eb14 9b47580fa7014be39a605724ac328ee2 3 3f9c4c6920334b719578b26df67e6ee0 X b903fc0140d44f51a2a5e6908130eb14--3f9c4c6920334b719578b26df67e6ee0 3f9c4c6920334b719578b26df67e6ee0--9f3568a170df4f26bb4bfbd16f194974 068587b334cc415a9c7efa7a9a91c042 3f9c4c6920334b719578b26df67e6ee0--068587b334cc415a9c7efa7a9a91c042 66d3b1450c494501b67b6a71952ebbb0 068587b334cc415a9c7efa7a9a91c042--66d3b1450c494501b67b6a71952ebbb0 409e7696c7b744cabbafb1f89086bed4 66d3b1450c494501b67b6a71952ebbb0--409e7696c7b744cabbafb1f89086bed4 55928715e51041dfb6e4194135161a7a 409e7696c7b744cabbafb1f89086bed4--55928715e51041dfb6e4194135161a7a 2e61b8087baa4872a3682e40b2020641 55928715e51041dfb6e4194135161a7a--2e61b8087baa4872a3682e40b2020641 98660fa6cf08446aacc04a65dca84061 2e61b8087baa4872a3682e40b2020641--98660fa6cf08446aacc04a65dca84061 f44105bf435f49afb58a205340ce6b8c 98660fa6cf08446aacc04a65dca84061--f44105bf435f49afb58a205340ce6b8c 3eb56cf1476a4641932f3a7fc12a1597 f44105bf435f49afb58a205340ce6b8c--3eb56cf1476a4641932f3a7fc12a1597 c7d329ef3afe439c90f96efb174ee436 3eb56cf1476a4641932f3a7fc12a1597--c7d329ef3afe439c90f96efb174ee436 111dd65f66204940911660dc602881ec c7d329ef3afe439c90f96efb174ee436--111dd65f66204940911660dc602881ec f6ffee8c3e23458d9ca88a8553bb4c52 111dd65f66204940911660dc602881ec--f6ffee8c3e23458d9ca88a8553bb4c52 4d2446955e7d435194e3d817c5e80e1e X f6ffee8c3e23458d9ca88a8553bb4c52--4d2446955e7d435194e3d817c5e80e1e 4d2446955e7d435194e3d817c5e80e1e--03b0500261ed4a0593539dfae87046ec 9dd376970e404100ac05a10cc4f29201 4d2446955e7d435194e3d817c5e80e1e--9dd376970e404100ac05a10cc4f29201 611de78ac55e45c9ac863cd3af2e86da X 9dd376970e404100ac05a10cc4f29201--611de78ac55e45c9ac863cd3af2e86da 611de78ac55e45c9ac863cd3af2e86da--b5609b693bb246e0b904ee0b1d009d32 7588b49547db443586c1979c042549db RZ(-1.0*g0) 611de78ac55e45c9ac863cd3af2e86da--7588b49547db443586c1979c042549db fa2f5f74e06c4ff09a6a7b4d2f3e0e79 X 7588b49547db443586c1979c042549db--fa2f5f74e06c4ff09a6a7b4d2f3e0e79 fa2f5f74e06c4ff09a6a7b4d2f3e0e79--9cbb2d8a31df410a95268d6a546eda79 19da4ffd82674adfaea1e117a470f31a X fa2f5f74e06c4ff09a6a7b4d2f3e0e79--19da4ffd82674adfaea1e117a470f31a 19da4ffd82674adfaea1e117a470f31a--668bfbfe0c664026ae8f1d86fb906c69 824c0b3cefe34b85848fc78b209674b8 19da4ffd82674adfaea1e117a470f31a--824c0b3cefe34b85848fc78b209674b8 14c30196392145e5a322d10c35023619 824c0b3cefe34b85848fc78b209674b8--14c30196392145e5a322d10c35023619 44332812801d4b62a6e3ff18110aff2e 14c30196392145e5a322d10c35023619--44332812801d4b62a6e3ff18110aff2e 75a6ecdd4005478da9b4e5cd130cb580 X 44332812801d4b62a6e3ff18110aff2e--75a6ecdd4005478da9b4e5cd130cb580 75a6ecdd4005478da9b4e5cd130cb580--3ed1fe34e19e4f46a4f1d54e109be46f 16fce06b10ad4018b0ce313d31f2ee7c X 75a6ecdd4005478da9b4e5cd130cb580--16fce06b10ad4018b0ce313d31f2ee7c 16fce06b10ad4018b0ce313d31f2ee7c--1d064af51e5542c99642f8d667800836 8c2afc334ae140d8a3435245b863ea36 16fce06b10ad4018b0ce313d31f2ee7c--8c2afc334ae140d8a3435245b863ea36 347a5fce95794d1989c1ced11a3a9224 8c2afc334ae140d8a3435245b863ea36--347a5fce95794d1989c1ced11a3a9224 c1bfe30a988a49bea6bd562c551d7945 347a5fce95794d1989c1ced11a3a9224--c1bfe30a988a49bea6bd562c551d7945 03b8164fcff34f2b9f949bcd3d11d00a c1bfe30a988a49bea6bd562c551d7945--03b8164fcff34f2b9f949bcd3d11d00a 257f1d81078b4a73b7a1d65ef2dc3c5c 03b8164fcff34f2b9f949bcd3d11d00a--257f1d81078b4a73b7a1d65ef2dc3c5c 80acb4cd3c6c4ec78b5b7d76d25cd236 257f1d81078b4a73b7a1d65ef2dc3c5c--80acb4cd3c6c4ec78b5b7d76d25cd236 a958bbccfc324f8bbf6b1d649c112aa7 80acb4cd3c6c4ec78b5b7d76d25cd236--a958bbccfc324f8bbf6b1d649c112aa7 2e6292b62d764cb6ae1205d5d9dafdf3 a958bbccfc324f8bbf6b1d649c112aa7--2e6292b62d764cb6ae1205d5d9dafdf3 a5eaef763ba4472ab2707a9588e49546 2e6292b62d764cb6ae1205d5d9dafdf3--a5eaef763ba4472ab2707a9588e49546 c741e07ad5ca4ce3952b6d465f69c538 X a5eaef763ba4472ab2707a9588e49546--c741e07ad5ca4ce3952b6d465f69c538 c741e07ad5ca4ce3952b6d465f69c538--f1863e66db9547079ee0a188c7ff1f42 0d865d2112454b0e97859330398bf3ee X c741e07ad5ca4ce3952b6d465f69c538--0d865d2112454b0e97859330398bf3ee 0d865d2112454b0e97859330398bf3ee--c9aa7098484c4a3c8c2ebb4e70d97e04 494b8e7672684bb5b2ad6a99cc5486d5 0d865d2112454b0e97859330398bf3ee--494b8e7672684bb5b2ad6a99cc5486d5 bc25b295f95c4d7ebbd6544659392b1d 494b8e7672684bb5b2ad6a99cc5486d5--bc25b295f95c4d7ebbd6544659392b1d d06916b925c94d5facd28418796b758a bc25b295f95c4d7ebbd6544659392b1d--d06916b925c94d5facd28418796b758a b5da5407b3e14904bc1006bca34a8d59 d06916b925c94d5facd28418796b758a--b5da5407b3e14904bc1006bca34a8d59 0e624044ca99410d859e9f2708ce275c b5da5407b3e14904bc1006bca34a8d59--0e624044ca99410d859e9f2708ce275c 6c7e58975018455789c440e0ea3ff6c3 0e624044ca99410d859e9f2708ce275c--6c7e58975018455789c440e0ea3ff6c3 48b2a4153eba477090e43d4fd5d03953 6c7e58975018455789c440e0ea3ff6c3--48b2a4153eba477090e43d4fd5d03953 507705993c1a4ec39d257c05228cc0e1 48b2a4153eba477090e43d4fd5d03953--507705993c1a4ec39d257c05228cc0e1 c0db0598e23b4ca081308420eb0a4cbc 507705993c1a4ec39d257c05228cc0e1--c0db0598e23b4ca081308420eb0a4cbc dab6af86b89e41159f7d36bca916da16 c0db0598e23b4ca081308420eb0a4cbc--dab6af86b89e41159f7d36bca916da16 04473738e81043b88bf2ae4df2e6b131 dab6af86b89e41159f7d36bca916da16--04473738e81043b88bf2ae4df2e6b131 d7502f59413342c2a1eca9a76204bde1 X 04473738e81043b88bf2ae4df2e6b131--d7502f59413342c2a1eca9a76204bde1 d7502f59413342c2a1eca9a76204bde1--145338b38e484e16bd643d68a959acb2 5714e866801d470c803318bc41913ed0 RX(b02) d7502f59413342c2a1eca9a76204bde1--5714e866801d470c803318bc41913ed0 61ea3cbe13094958a76925254b606532 5714e866801d470c803318bc41913ed0--61ea3cbe13094958a76925254b606532 75bcda80bc84482a9f4ab21cd620faf6 X 61ea3cbe13094958a76925254b606532--75bcda80bc84482a9f4ab21cd620faf6 75bcda80bc84482a9f4ab21cd620faf6--6a9754e5ac6b4edeb6734ae9b72b626e 29dcceab55aa499aac501491752dcbcf 75bcda80bc84482a9f4ab21cd620faf6--29dcceab55aa499aac501491752dcbcf 8a9d4a9ec3584ad78c8df2449a3cfe40 29dcceab55aa499aac501491752dcbcf--8a9d4a9ec3584ad78c8df2449a3cfe40 2e0e6e4795b846c696cc4279fd02f84f 8a9d4a9ec3584ad78c8df2449a3cfe40--2e0e6e4795b846c696cc4279fd02f84f 513a6580e48745a49727b29f67131cb3 2e0e6e4795b846c696cc4279fd02f84f--513a6580e48745a49727b29f67131cb3 4e4b59618e1544c295b331a01906ac4c 513a6580e48745a49727b29f67131cb3--4e4b59618e1544c295b331a01906ac4c 050a15734ec04b86b803f2c13145860e 4e4b59618e1544c295b331a01906ac4c--050a15734ec04b86b803f2c13145860e c68cfe3d49e54d52821115462fb9b93f 050a15734ec04b86b803f2c13145860e--c68cfe3d49e54d52821115462fb9b93f 3b11355b3e1945acbf104080bd734087 c68cfe3d49e54d52821115462fb9b93f--3b11355b3e1945acbf104080bd734087 444da2bafa6a4af2978779cf2ce7b7af 3b11355b3e1945acbf104080bd734087--444da2bafa6a4af2978779cf2ce7b7af dc64a9c003f04114b934338a50a2c998 444da2bafa6a4af2978779cf2ce7b7af--dc64a9c003f04114b934338a50a2c998 f58c636b270b4008807e5f907251746e dc64a9c003f04114b934338a50a2c998--f58c636b270b4008807e5f907251746e b0c603c20b204a7581253b48a3d02fd8 X f58c636b270b4008807e5f907251746e--b0c603c20b204a7581253b48a3d02fd8 b0c603c20b204a7581253b48a3d02fd8--62d85b7cee7c4da088d790681ae9bd09 3c7c1df00a0345469bbbe4df99df2424 b0c603c20b204a7581253b48a3d02fd8--3c7c1df00a0345469bbbe4df99df2424 683a96a156514760837b1f12a1cdeb96 X 3c7c1df00a0345469bbbe4df99df2424--683a96a156514760837b1f12a1cdeb96 683a96a156514760837b1f12a1cdeb96--f20c0cc7a5de43f58b571e813584d609 a2d57aa44dc54afda147fa0155486b04 RZ(-1.0*g1) 683a96a156514760837b1f12a1cdeb96--a2d57aa44dc54afda147fa0155486b04 9a231d54c56e4badb5d1374a5db47321 X a2d57aa44dc54afda147fa0155486b04--9a231d54c56e4badb5d1374a5db47321 9a231d54c56e4badb5d1374a5db47321--95ac294b58564549ae5f2322214eb224 edd6c0c5035c4de69697a23842c58d02 X 9a231d54c56e4badb5d1374a5db47321--edd6c0c5035c4de69697a23842c58d02 edd6c0c5035c4de69697a23842c58d02--91a411e30df44dbfa0ca4062cf123a60 c168942ded70410483a4c5aca2f14759 edd6c0c5035c4de69697a23842c58d02--c168942ded70410483a4c5aca2f14759 cecea846b5db4d21881e79187e9f48c6 c168942ded70410483a4c5aca2f14759--cecea846b5db4d21881e79187e9f48c6 efc2d62b485a40078216bf27a09c7d5d cecea846b5db4d21881e79187e9f48c6--efc2d62b485a40078216bf27a09c7d5d 91f6267d108a45558d2b2a9a9ddf2a52 X efc2d62b485a40078216bf27a09c7d5d--91f6267d108a45558d2b2a9a9ddf2a52 91f6267d108a45558d2b2a9a9ddf2a52--f266b2af2d344747b8a76047f2f719a8 8c6bd1349be44688aaeb187278d70542 X 91f6267d108a45558d2b2a9a9ddf2a52--8c6bd1349be44688aaeb187278d70542 8c6bd1349be44688aaeb187278d70542--b9c9c8c55ad7430b88b319b4a89e0557 f557756ccde04df88e8722095f8a15a0 8c6bd1349be44688aaeb187278d70542--f557756ccde04df88e8722095f8a15a0 081f7d64330b4076b2487834ffa9bd74 f557756ccde04df88e8722095f8a15a0--081f7d64330b4076b2487834ffa9bd74 c4a3e451aea34e988c0e480078400817 081f7d64330b4076b2487834ffa9bd74--c4a3e451aea34e988c0e480078400817 a4dd22c85820422b87d97efa6caa452e c4a3e451aea34e988c0e480078400817--a4dd22c85820422b87d97efa6caa452e 7ce909f976a64a28ab03dae4641a8c9a a4dd22c85820422b87d97efa6caa452e--7ce909f976a64a28ab03dae4641a8c9a 621e8b3843294e6ab18da0ffd1b89a44 7ce909f976a64a28ab03dae4641a8c9a--621e8b3843294e6ab18da0ffd1b89a44 591f553794914ed9ad15659c147f358c 621e8b3843294e6ab18da0ffd1b89a44--591f553794914ed9ad15659c147f358c 8f4d60d9424b466c8ca50273cd56e7ce 591f553794914ed9ad15659c147f358c--8f4d60d9424b466c8ca50273cd56e7ce 94a36c15b6464abf9cbf2ff69794f70b 8f4d60d9424b466c8ca50273cd56e7ce--94a36c15b6464abf9cbf2ff69794f70b 0daaafaa7ceb4869adc3ac825c302a55 X 94a36c15b6464abf9cbf2ff69794f70b--0daaafaa7ceb4869adc3ac825c302a55 0daaafaa7ceb4869adc3ac825c302a55--e387071ae41c4a69a860fa8b57fa80be 8166cce84ddc46d3b0c16ffe2797744a X 0daaafaa7ceb4869adc3ac825c302a55--8166cce84ddc46d3b0c16ffe2797744a 8166cce84ddc46d3b0c16ffe2797744a--55c89498b2c54942bda4756301788a29 5cf820c4c1ae4d8ab163985357b92717 8166cce84ddc46d3b0c16ffe2797744a--5cf820c4c1ae4d8ab163985357b92717 c17abb5e74494c0897b80fce6d201a2e 5cf820c4c1ae4d8ab163985357b92717--c17abb5e74494c0897b80fce6d201a2e 597bba4f35b243edaec319a8f7f114a4 c17abb5e74494c0897b80fce6d201a2e--597bba4f35b243edaec319a8f7f114a4 ac73a5fec8ab4cc4853245f53a10a919 597bba4f35b243edaec319a8f7f114a4--ac73a5fec8ab4cc4853245f53a10a919 b971b35f185a467d98ca8724232ce08b ac73a5fec8ab4cc4853245f53a10a919--b971b35f185a467d98ca8724232ce08b e684869794bd429a94177de409393044 b971b35f185a467d98ca8724232ce08b--e684869794bd429a94177de409393044 02c2ce522c564279971dbc31a41f45df e684869794bd429a94177de409393044--02c2ce522c564279971dbc31a41f45df 1e447c25c58e4ce3b59d35e75317e775 02c2ce522c564279971dbc31a41f45df--1e447c25c58e4ce3b59d35e75317e775 f7d8f886415249539077799b4dae7911 1e447c25c58e4ce3b59d35e75317e775--f7d8f886415249539077799b4dae7911 52413f0bd6a0458cb5efcd9420da48cd f7d8f886415249539077799b4dae7911--52413f0bd6a0458cb5efcd9420da48cd a3ab88b395664dce86e4d7427419e847 52413f0bd6a0458cb5efcd9420da48cd--a3ab88b395664dce86e4d7427419e847 49ad1634dc4140dc9442ed0d93a874a0 X a3ab88b395664dce86e4d7427419e847--49ad1634dc4140dc9442ed0d93a874a0 49ad1634dc4140dc9442ed0d93a874a0--742b625f8f5440df969676c3f5bb5c4a 0713083c25a343f2825e34fe4a47cc91 RX(b12) 49ad1634dc4140dc9442ed0d93a874a0--0713083c25a343f2825e34fe4a47cc91 0713083c25a343f2825e34fe4a47cc91--6a898dab06de4ca1acd2639a8cb576f5 04dcd4819e8c4591989eaed0c2188721 166e9755ffd2440791c78a34077dfaae 9b47580fa7014be39a605724ac328ee2--166e9755ffd2440791c78a34077dfaae db5acf6fd9294e3bae79376d9df0d137 4 e0259c733cde4494b27662a46f05afad 166e9755ffd2440791c78a34077dfaae--e0259c733cde4494b27662a46f05afad 36bbd752f7a94b52a0f6cc1d4d09e8fb X e0259c733cde4494b27662a46f05afad--36bbd752f7a94b52a0f6cc1d4d09e8fb 36bbd752f7a94b52a0f6cc1d4d09e8fb--068587b334cc415a9c7efa7a9a91c042 5675fab2c78e4a738a01f57f3f586525 36bbd752f7a94b52a0f6cc1d4d09e8fb--5675fab2c78e4a738a01f57f3f586525 c5a2f5f0f6f54ae8adfe033ff9768945 5675fab2c78e4a738a01f57f3f586525--c5a2f5f0f6f54ae8adfe033ff9768945 ee4bc540cd914ed5a8be352ea27b82c0 c5a2f5f0f6f54ae8adfe033ff9768945--ee4bc540cd914ed5a8be352ea27b82c0 f5ff568277aa464ea8335e8d1b3a10fc ee4bc540cd914ed5a8be352ea27b82c0--f5ff568277aa464ea8335e8d1b3a10fc 7db4a4fe8a0a4cd5926c630721521c4c f5ff568277aa464ea8335e8d1b3a10fc--7db4a4fe8a0a4cd5926c630721521c4c 312ba8d7f01041089e93c8a447f7bb4c 7db4a4fe8a0a4cd5926c630721521c4c--312ba8d7f01041089e93c8a447f7bb4c 9109c068ee6d409ea2ed295c564efd2d 312ba8d7f01041089e93c8a447f7bb4c--9109c068ee6d409ea2ed295c564efd2d 35781597d040462898c7fa42f0d17dd7 9109c068ee6d409ea2ed295c564efd2d--35781597d040462898c7fa42f0d17dd7 4863c5aa659b45cba121fbc7e58f3b68 35781597d040462898c7fa42f0d17dd7--4863c5aa659b45cba121fbc7e58f3b68 f23b322002e94966989c39b58ac05e0f X 4863c5aa659b45cba121fbc7e58f3b68--f23b322002e94966989c39b58ac05e0f f23b322002e94966989c39b58ac05e0f--f6ffee8c3e23458d9ca88a8553bb4c52 fdb22d7d496749c2a62af429dc6905c7 f23b322002e94966989c39b58ac05e0f--fdb22d7d496749c2a62af429dc6905c7 e0ac77db9be8469c912285fc93deb07b fdb22d7d496749c2a62af429dc6905c7--e0ac77db9be8469c912285fc93deb07b 85bef725664443d68791f4f87845726d e0ac77db9be8469c912285fc93deb07b--85bef725664443d68791f4f87845726d 11b2a5ede54049e9bd3ab3df79a5871e 85bef725664443d68791f4f87845726d--11b2a5ede54049e9bd3ab3df79a5871e a7e3d8f10e724a2db32a36116844e6dc 11b2a5ede54049e9bd3ab3df79a5871e--a7e3d8f10e724a2db32a36116844e6dc f9147a3cfba649d2a2ee7f5977c06695 a7e3d8f10e724a2db32a36116844e6dc--f9147a3cfba649d2a2ee7f5977c06695 584f881335464249838b535b725e7655 X f9147a3cfba649d2a2ee7f5977c06695--584f881335464249838b535b725e7655 584f881335464249838b535b725e7655--824c0b3cefe34b85848fc78b209674b8 3328b336180740bfbfebef0423fbe65f RZ(-1.0*g0) 584f881335464249838b535b725e7655--3328b336180740bfbfebef0423fbe65f e293e803eaae4deb999f47fa9b971989 X 3328b336180740bfbfebef0423fbe65f--e293e803eaae4deb999f47fa9b971989 e293e803eaae4deb999f47fa9b971989--44332812801d4b62a6e3ff18110aff2e 336764daa4c340be9e8f6a804cf0b03f e293e803eaae4deb999f47fa9b971989--336764daa4c340be9e8f6a804cf0b03f f27c5685cc5741a4a7d86acf163a9dda 336764daa4c340be9e8f6a804cf0b03f--f27c5685cc5741a4a7d86acf163a9dda 2b61539e54e8449e93ce5e73007eb396 X f27c5685cc5741a4a7d86acf163a9dda--2b61539e54e8449e93ce5e73007eb396 2b61539e54e8449e93ce5e73007eb396--8c2afc334ae140d8a3435245b863ea36 49b0f58bd85846c294c2b0beae95fc61 2b61539e54e8449e93ce5e73007eb396--49b0f58bd85846c294c2b0beae95fc61 3eabf164b2d24327bc170996456d75df 49b0f58bd85846c294c2b0beae95fc61--3eabf164b2d24327bc170996456d75df 1d6f8c199abf4a08bd34340410907b72 3eabf164b2d24327bc170996456d75df--1d6f8c199abf4a08bd34340410907b72 7572224b615148149b6ab001d0164199 1d6f8c199abf4a08bd34340410907b72--7572224b615148149b6ab001d0164199 a74f1a5483df4383bb3163116560d617 7572224b615148149b6ab001d0164199--a74f1a5483df4383bb3163116560d617 e3c7b52cba764a738877d60d24a9f329 a74f1a5483df4383bb3163116560d617--e3c7b52cba764a738877d60d24a9f329 8a55e9541ac94a72a5f33cb111bb208f e3c7b52cba764a738877d60d24a9f329--8a55e9541ac94a72a5f33cb111bb208f f8ed0de254e34995b06230f9728a64af X 8a55e9541ac94a72a5f33cb111bb208f--f8ed0de254e34995b06230f9728a64af f8ed0de254e34995b06230f9728a64af--a5eaef763ba4472ab2707a9588e49546 b5201079c80a4c0f914b2154d0b7eeec f8ed0de254e34995b06230f9728a64af--b5201079c80a4c0f914b2154d0b7eeec 56168d667241488d939642b2e8083275 b5201079c80a4c0f914b2154d0b7eeec--56168d667241488d939642b2e8083275 3995b81078964b178a16c60cac620772 X 56168d667241488d939642b2e8083275--3995b81078964b178a16c60cac620772 3995b81078964b178a16c60cac620772--494b8e7672684bb5b2ad6a99cc5486d5 c10922f5f6bc43eabf36dc6c1abcbda5 3995b81078964b178a16c60cac620772--c10922f5f6bc43eabf36dc6c1abcbda5 aabdca4b4c3a46f8b12051c84994e3ee c10922f5f6bc43eabf36dc6c1abcbda5--aabdca4b4c3a46f8b12051c84994e3ee 695a7ea72eee4c3199a63f531cd3130b aabdca4b4c3a46f8b12051c84994e3ee--695a7ea72eee4c3199a63f531cd3130b 304114b085e24c7aaff0ca468872216a 695a7ea72eee4c3199a63f531cd3130b--304114b085e24c7aaff0ca468872216a a1070cfc14af4542bc79482527612eb7 304114b085e24c7aaff0ca468872216a--a1070cfc14af4542bc79482527612eb7 8527d0a2f60045f4b01b96d030dc5ba8 a1070cfc14af4542bc79482527612eb7--8527d0a2f60045f4b01b96d030dc5ba8 a36ece44259d4f6c84b1c3c42868bdbb 8527d0a2f60045f4b01b96d030dc5ba8--a36ece44259d4f6c84b1c3c42868bdbb 2c8829828afd4e28b7d5ef51bce72da7 a36ece44259d4f6c84b1c3c42868bdbb--2c8829828afd4e28b7d5ef51bce72da7 514b0fb91be84aaebb45fb08d8be3d68 2c8829828afd4e28b7d5ef51bce72da7--514b0fb91be84aaebb45fb08d8be3d68 f2a01ff67b044d73861a06d697ea1268 X 514b0fb91be84aaebb45fb08d8be3d68--f2a01ff67b044d73861a06d697ea1268 f2a01ff67b044d73861a06d697ea1268--04473738e81043b88bf2ae4df2e6b131 8ee1749da88b446a8ae79c28fb4e427c f2a01ff67b044d73861a06d697ea1268--8ee1749da88b446a8ae79c28fb4e427c 01b3eeb15c0b4db687479767767044c3 RX(b03) 8ee1749da88b446a8ae79c28fb4e427c--01b3eeb15c0b4db687479767767044c3 9d66260681c94493a78b06c8d71dc9f1 01b3eeb15c0b4db687479767767044c3--9d66260681c94493a78b06c8d71dc9f1 c0602248f3fe415d896022c0095acb30 9d66260681c94493a78b06c8d71dc9f1--c0602248f3fe415d896022c0095acb30 6b2cef5f3b0e478592661fd9d75c20b3 X c0602248f3fe415d896022c0095acb30--6b2cef5f3b0e478592661fd9d75c20b3 6b2cef5f3b0e478592661fd9d75c20b3--29dcceab55aa499aac501491752dcbcf 2148f9c2b52843a7abb3630c4936d453 6b2cef5f3b0e478592661fd9d75c20b3--2148f9c2b52843a7abb3630c4936d453 d5a85e487aec4abcbef4e244dcf62626 2148f9c2b52843a7abb3630c4936d453--d5a85e487aec4abcbef4e244dcf62626 2d8c506a031949e9930ee0c0d7d09466 d5a85e487aec4abcbef4e244dcf62626--2d8c506a031949e9930ee0c0d7d09466 1701cd53e9d54fcaa79390e16d83e0af 2d8c506a031949e9930ee0c0d7d09466--1701cd53e9d54fcaa79390e16d83e0af c49fddd1494540c58fdf1d16332bb369 1701cd53e9d54fcaa79390e16d83e0af--c49fddd1494540c58fdf1d16332bb369 5b2b30da12a74a9ca0a05611e52de38e c49fddd1494540c58fdf1d16332bb369--5b2b30da12a74a9ca0a05611e52de38e 3de0858f62c04a00ae576369cc07502a 5b2b30da12a74a9ca0a05611e52de38e--3de0858f62c04a00ae576369cc07502a da205977b73049eaadf3dfc0a8234c16 3de0858f62c04a00ae576369cc07502a--da205977b73049eaadf3dfc0a8234c16 8ac47ad244bd46279f5e8eab749b6b4e da205977b73049eaadf3dfc0a8234c16--8ac47ad244bd46279f5e8eab749b6b4e 1c7fd64ca46748aab62b23e1aab447ef X 8ac47ad244bd46279f5e8eab749b6b4e--1c7fd64ca46748aab62b23e1aab447ef 1c7fd64ca46748aab62b23e1aab447ef--f58c636b270b4008807e5f907251746e c2e1f4830b2b47d28b7356d546bfd84e 1c7fd64ca46748aab62b23e1aab447ef--c2e1f4830b2b47d28b7356d546bfd84e 68ca023d93d642b2acf3a71090e26583 c2e1f4830b2b47d28b7356d546bfd84e--68ca023d93d642b2acf3a71090e26583 0b2bf6fbf37241b88ecd53eaa5dd5a36 68ca023d93d642b2acf3a71090e26583--0b2bf6fbf37241b88ecd53eaa5dd5a36 7bc1bc48cc8b4855bcc35725bf7717f1 0b2bf6fbf37241b88ecd53eaa5dd5a36--7bc1bc48cc8b4855bcc35725bf7717f1 bb611067174c4062bbe93750f1845372 7bc1bc48cc8b4855bcc35725bf7717f1--bb611067174c4062bbe93750f1845372 e56dc479eb304334a079665b3bd4d54e bb611067174c4062bbe93750f1845372--e56dc479eb304334a079665b3bd4d54e 8b2e168121d7426cb9110d9bdeba9795 X e56dc479eb304334a079665b3bd4d54e--8b2e168121d7426cb9110d9bdeba9795 8b2e168121d7426cb9110d9bdeba9795--c168942ded70410483a4c5aca2f14759 db9830003e444cc099701966d67a33fc RZ(-1.0*g1) 8b2e168121d7426cb9110d9bdeba9795--db9830003e444cc099701966d67a33fc 49e5eed8cee84d3eba3852d867347244 X db9830003e444cc099701966d67a33fc--49e5eed8cee84d3eba3852d867347244 49e5eed8cee84d3eba3852d867347244--efc2d62b485a40078216bf27a09c7d5d 8f129b307f0643f981cb7c14f6f7d7ca 49e5eed8cee84d3eba3852d867347244--8f129b307f0643f981cb7c14f6f7d7ca 21871116dab64d999783006d2f2fc265 8f129b307f0643f981cb7c14f6f7d7ca--21871116dab64d999783006d2f2fc265 3e4d5afbdb8242e5afd226e5f1133965 X 21871116dab64d999783006d2f2fc265--3e4d5afbdb8242e5afd226e5f1133965 3e4d5afbdb8242e5afd226e5f1133965--f557756ccde04df88e8722095f8a15a0 56ca2673aea7401098bf86c76f11a35c 3e4d5afbdb8242e5afd226e5f1133965--56ca2673aea7401098bf86c76f11a35c c061dcc299414d74b434c70c200b3eb2 56ca2673aea7401098bf86c76f11a35c--c061dcc299414d74b434c70c200b3eb2 4454745787854fe9b4d4cbac60e8a296 c061dcc299414d74b434c70c200b3eb2--4454745787854fe9b4d4cbac60e8a296 dc9edde12bf042e1bc614f273576d576 4454745787854fe9b4d4cbac60e8a296--dc9edde12bf042e1bc614f273576d576 94dc35c6e0fd4a1b9bc870d2132be36c dc9edde12bf042e1bc614f273576d576--94dc35c6e0fd4a1b9bc870d2132be36c 1b7e91dad78a4887bf4fe3645685bb42 94dc35c6e0fd4a1b9bc870d2132be36c--1b7e91dad78a4887bf4fe3645685bb42 a8bc4b7a38904000ad9bd9efde985cce 1b7e91dad78a4887bf4fe3645685bb42--a8bc4b7a38904000ad9bd9efde985cce fddc5067eba54c4098c96671bea6535e X a8bc4b7a38904000ad9bd9efde985cce--fddc5067eba54c4098c96671bea6535e fddc5067eba54c4098c96671bea6535e--94a36c15b6464abf9cbf2ff69794f70b 7255d82ae06e4705adda02b0594a6835 fddc5067eba54c4098c96671bea6535e--7255d82ae06e4705adda02b0594a6835 00c18a0e0e934e94bd3dbc15f5eea866 7255d82ae06e4705adda02b0594a6835--00c18a0e0e934e94bd3dbc15f5eea866 1e2949080ded4e13a4c032221b9b247b X 00c18a0e0e934e94bd3dbc15f5eea866--1e2949080ded4e13a4c032221b9b247b 1e2949080ded4e13a4c032221b9b247b--5cf820c4c1ae4d8ab163985357b92717 f88d1bf551614175828e36ceac98d022 1e2949080ded4e13a4c032221b9b247b--f88d1bf551614175828e36ceac98d022 a4288760bf4943b6b5ecd2911aacc362 f88d1bf551614175828e36ceac98d022--a4288760bf4943b6b5ecd2911aacc362 ae65fdf46b5d49d29a270052694f99f4 a4288760bf4943b6b5ecd2911aacc362--ae65fdf46b5d49d29a270052694f99f4 a9e8a37400c947e593294611065c0095 ae65fdf46b5d49d29a270052694f99f4--a9e8a37400c947e593294611065c0095 38457d2c7b634471a2fd630c099b5d31 a9e8a37400c947e593294611065c0095--38457d2c7b634471a2fd630c099b5d31 ec6b0848b9f64480b68f8ec5562adb5b 38457d2c7b634471a2fd630c099b5d31--ec6b0848b9f64480b68f8ec5562adb5b f7644bd171814113ad6a0ce05ead7853 ec6b0848b9f64480b68f8ec5562adb5b--f7644bd171814113ad6a0ce05ead7853 36a9b384a6b34078914d5cb295ebbd5b f7644bd171814113ad6a0ce05ead7853--36a9b384a6b34078914d5cb295ebbd5b 3b21f35d1779490f94407f9c656895ec 36a9b384a6b34078914d5cb295ebbd5b--3b21f35d1779490f94407f9c656895ec c44b29fe4bd6413098e8b5aedd799aba X 3b21f35d1779490f94407f9c656895ec--c44b29fe4bd6413098e8b5aedd799aba c44b29fe4bd6413098e8b5aedd799aba--a3ab88b395664dce86e4d7427419e847 53c0f874e8eb44848730be75c8a4e964 c44b29fe4bd6413098e8b5aedd799aba--53c0f874e8eb44848730be75c8a4e964 13285f8eda244de894e4b8e8a1cc92c0 RX(b13) 53c0f874e8eb44848730be75c8a4e964--13285f8eda244de894e4b8e8a1cc92c0 13285f8eda244de894e4b8e8a1cc92c0--04dcd4819e8c4591989eaed0c2188721 88e04b858a544a1494beb501d177b5fa 5b23280526ca4d8e9e27e140c3b5031f db5acf6fd9294e3bae79376d9df0d137--5b23280526ca4d8e9e27e140c3b5031f 9d46efb74aa44c699fc7d417d82f836e 5 600cc6c3917a41f680baf3c234a36094 5b23280526ca4d8e9e27e140c3b5031f--600cc6c3917a41f680baf3c234a36094 b50bde597e3a48edbbffcae4d578c75b 600cc6c3917a41f680baf3c234a36094--b50bde597e3a48edbbffcae4d578c75b 4435ffb0903f4b7e8e31f2df20b13092 X b50bde597e3a48edbbffcae4d578c75b--4435ffb0903f4b7e8e31f2df20b13092 4435ffb0903f4b7e8e31f2df20b13092--5675fab2c78e4a738a01f57f3f586525 2024b0cf784942b481f4b8a832b178ea 4435ffb0903f4b7e8e31f2df20b13092--2024b0cf784942b481f4b8a832b178ea 6f940b834beb4facbbb04c191d70bd9e 2024b0cf784942b481f4b8a832b178ea--6f940b834beb4facbbb04c191d70bd9e fe8412eac97441fdbdb23a9b562d097f 6f940b834beb4facbbb04c191d70bd9e--fe8412eac97441fdbdb23a9b562d097f 101540654ef34f289a0100699a8a8976 fe8412eac97441fdbdb23a9b562d097f--101540654ef34f289a0100699a8a8976 794a3c502be840b0b31ed88915175b82 101540654ef34f289a0100699a8a8976--794a3c502be840b0b31ed88915175b82 8806f71c5fc64075a892eb02682eb698 794a3c502be840b0b31ed88915175b82--8806f71c5fc64075a892eb02682eb698 9afcd43c3b644728945b866c5555764a 8806f71c5fc64075a892eb02682eb698--9afcd43c3b644728945b866c5555764a ff7a5f46bc3343e8b8e1e1d9390b20c2 X 9afcd43c3b644728945b866c5555764a--ff7a5f46bc3343e8b8e1e1d9390b20c2 ff7a5f46bc3343e8b8e1e1d9390b20c2--4863c5aa659b45cba121fbc7e58f3b68 b3e4fbc3c96946aaba495c07774e0c9d ff7a5f46bc3343e8b8e1e1d9390b20c2--b3e4fbc3c96946aaba495c07774e0c9d 7cffb85cf8de4d889c26fc0f8d287331 b3e4fbc3c96946aaba495c07774e0c9d--7cffb85cf8de4d889c26fc0f8d287331 08774db30a084be798021091443a554a 7cffb85cf8de4d889c26fc0f8d287331--08774db30a084be798021091443a554a 1d41a43097ab41f6b61ad2e5507d0083 08774db30a084be798021091443a554a--1d41a43097ab41f6b61ad2e5507d0083 20b7cc7390544cd9970a15eed57fa7b9 1d41a43097ab41f6b61ad2e5507d0083--20b7cc7390544cd9970a15eed57fa7b9 db8a9dedf53145a7af4d36de1aa89ff2 20b7cc7390544cd9970a15eed57fa7b9--db8a9dedf53145a7af4d36de1aa89ff2 943cf92339ad4176ac2077560e88fb32 db8a9dedf53145a7af4d36de1aa89ff2--943cf92339ad4176ac2077560e88fb32 516bf06992764e3dbd907cd6aed628f5 943cf92339ad4176ac2077560e88fb32--516bf06992764e3dbd907cd6aed628f5 e793ad576c3b49ac88ee0aab6bc8b940 516bf06992764e3dbd907cd6aed628f5--e793ad576c3b49ac88ee0aab6bc8b940 3e0b6125aeaa4487bd23041acb8b8fd3 e793ad576c3b49ac88ee0aab6bc8b940--3e0b6125aeaa4487bd23041acb8b8fd3 b89212923ae94b7ca7154d9cd59ca332 3e0b6125aeaa4487bd23041acb8b8fd3--b89212923ae94b7ca7154d9cd59ca332 df942d2e7f89429ba248f0fd94d88fbf b89212923ae94b7ca7154d9cd59ca332--df942d2e7f89429ba248f0fd94d88fbf 2198b304cf9941afb15d6723b63705c1 df942d2e7f89429ba248f0fd94d88fbf--2198b304cf9941afb15d6723b63705c1 d9ce43b51a5e42aaa542065d1d5daf7e X 2198b304cf9941afb15d6723b63705c1--d9ce43b51a5e42aaa542065d1d5daf7e d9ce43b51a5e42aaa542065d1d5daf7e--49b0f58bd85846c294c2b0beae95fc61 ee31c58d51094e7ba5f12f4651e8424d d9ce43b51a5e42aaa542065d1d5daf7e--ee31c58d51094e7ba5f12f4651e8424d cb162b5ab4254937a5e27a90d36d0415 ee31c58d51094e7ba5f12f4651e8424d--cb162b5ab4254937a5e27a90d36d0415 13afa6540452463ca0c8092bb849cc98 cb162b5ab4254937a5e27a90d36d0415--13afa6540452463ca0c8092bb849cc98 24c0f7673abe407796a55a8003dd04de 13afa6540452463ca0c8092bb849cc98--24c0f7673abe407796a55a8003dd04de e08b0de347634e85b0ba17161ce7ebaa 24c0f7673abe407796a55a8003dd04de--e08b0de347634e85b0ba17161ce7ebaa e2ee7b165cbe4edeb47ba88013abb78c X e08b0de347634e85b0ba17161ce7ebaa--e2ee7b165cbe4edeb47ba88013abb78c e2ee7b165cbe4edeb47ba88013abb78c--8a55e9541ac94a72a5f33cb111bb208f 92b21dcb84e94b62834345b9bc12227e e2ee7b165cbe4edeb47ba88013abb78c--92b21dcb84e94b62834345b9bc12227e 585e2dc8eeaf4acdac6f226fc0d9839c 92b21dcb84e94b62834345b9bc12227e--585e2dc8eeaf4acdac6f226fc0d9839c 5311b6c77c2e4c00933e2ccde6c1b95a 585e2dc8eeaf4acdac6f226fc0d9839c--5311b6c77c2e4c00933e2ccde6c1b95a b34bac4135044d32b6c581810b73bbbf 5311b6c77c2e4c00933e2ccde6c1b95a--b34bac4135044d32b6c581810b73bbbf dac9553af72549859262204a8fcc4485 X b34bac4135044d32b6c581810b73bbbf--dac9553af72549859262204a8fcc4485 dac9553af72549859262204a8fcc4485--c10922f5f6bc43eabf36dc6c1abcbda5 c1953c04cf94489991a1c27385a1bc67 dac9553af72549859262204a8fcc4485--c1953c04cf94489991a1c27385a1bc67 62ab03a13b874d47bad179cb432b3ac3 c1953c04cf94489991a1c27385a1bc67--62ab03a13b874d47bad179cb432b3ac3 7663e539c62c4a6d9f9a4d350753a8f1 62ab03a13b874d47bad179cb432b3ac3--7663e539c62c4a6d9f9a4d350753a8f1 b02698d3d0f540dca63898ed2d11db7d 7663e539c62c4a6d9f9a4d350753a8f1--b02698d3d0f540dca63898ed2d11db7d e000246aae764bd0a55ed85134f160f0 b02698d3d0f540dca63898ed2d11db7d--e000246aae764bd0a55ed85134f160f0 da35c75ab6d84dc7b1dd1758ee69095c e000246aae764bd0a55ed85134f160f0--da35c75ab6d84dc7b1dd1758ee69095c 3e06e2661287496084010b15ca491ec3 da35c75ab6d84dc7b1dd1758ee69095c--3e06e2661287496084010b15ca491ec3 8ff416a9ded04f7ab960bb295584e4a1 X 3e06e2661287496084010b15ca491ec3--8ff416a9ded04f7ab960bb295584e4a1 8ff416a9ded04f7ab960bb295584e4a1--514b0fb91be84aaebb45fb08d8be3d68 2e76e42b6f9e4d29ac13f3a8f722669f 8ff416a9ded04f7ab960bb295584e4a1--2e76e42b6f9e4d29ac13f3a8f722669f ea24af73091741b1b5dc2844b2f8303d 2e76e42b6f9e4d29ac13f3a8f722669f--ea24af73091741b1b5dc2844b2f8303d faa303f306ff4ef08963c75958d5e6ae RX(b04) ea24af73091741b1b5dc2844b2f8303d--faa303f306ff4ef08963c75958d5e6ae d01b6bc683af4293995a1e9e70443ad0 faa303f306ff4ef08963c75958d5e6ae--d01b6bc683af4293995a1e9e70443ad0 7507a99f1e6e4867ac260a127d80da25 d01b6bc683af4293995a1e9e70443ad0--7507a99f1e6e4867ac260a127d80da25 df8f98af027745e6be0ac7b17b138cbb 7507a99f1e6e4867ac260a127d80da25--df8f98af027745e6be0ac7b17b138cbb 8ca3f034c7c34991a20fc9906f875e51 X df8f98af027745e6be0ac7b17b138cbb--8ca3f034c7c34991a20fc9906f875e51 8ca3f034c7c34991a20fc9906f875e51--2148f9c2b52843a7abb3630c4936d453 4116d1ab9d3e4b6e9dbf84afa73ac97c 8ca3f034c7c34991a20fc9906f875e51--4116d1ab9d3e4b6e9dbf84afa73ac97c 79f02954bee74610822455b8af417f8a 4116d1ab9d3e4b6e9dbf84afa73ac97c--79f02954bee74610822455b8af417f8a 62462e314b044439a0c4276b1424a2a9 79f02954bee74610822455b8af417f8a--62462e314b044439a0c4276b1424a2a9 c16fd1f613e141f2a52a9246c8c56615 62462e314b044439a0c4276b1424a2a9--c16fd1f613e141f2a52a9246c8c56615 5d00e23624d9416aa517d54b7a890917 c16fd1f613e141f2a52a9246c8c56615--5d00e23624d9416aa517d54b7a890917 3a3f41923507443d8b40b1b62e00a515 5d00e23624d9416aa517d54b7a890917--3a3f41923507443d8b40b1b62e00a515 83a417bf4f0a4de4b6e4c809503dcbd1 3a3f41923507443d8b40b1b62e00a515--83a417bf4f0a4de4b6e4c809503dcbd1 b34dc710f37344f095824e74860eaec4 X 83a417bf4f0a4de4b6e4c809503dcbd1--b34dc710f37344f095824e74860eaec4 b34dc710f37344f095824e74860eaec4--8ac47ad244bd46279f5e8eab749b6b4e afab104e0df84d98ac221e768fd52ac9 b34dc710f37344f095824e74860eaec4--afab104e0df84d98ac221e768fd52ac9 e3873662cb2a4319aab2541b28ad0d42 afab104e0df84d98ac221e768fd52ac9--e3873662cb2a4319aab2541b28ad0d42 98c64062467948e0ae2b1ebc6dcdc337 e3873662cb2a4319aab2541b28ad0d42--98c64062467948e0ae2b1ebc6dcdc337 755d842b821d480d8c56ab8d0e59e665 98c64062467948e0ae2b1ebc6dcdc337--755d842b821d480d8c56ab8d0e59e665 7aeda4780132453eaedcf8d556a89679 755d842b821d480d8c56ab8d0e59e665--7aeda4780132453eaedcf8d556a89679 142f1a4a80e244c5ba34387bdcf93e1d 7aeda4780132453eaedcf8d556a89679--142f1a4a80e244c5ba34387bdcf93e1d 54cc9efbc91a4e2ca046edebba26817b 142f1a4a80e244c5ba34387bdcf93e1d--54cc9efbc91a4e2ca046edebba26817b c03925f88c614b1097ff8db5efd5e39c 54cc9efbc91a4e2ca046edebba26817b--c03925f88c614b1097ff8db5efd5e39c bbe9e386d5e84786a88899435475aaeb c03925f88c614b1097ff8db5efd5e39c--bbe9e386d5e84786a88899435475aaeb e99492cd8af1412d94a52f962f317a11 bbe9e386d5e84786a88899435475aaeb--e99492cd8af1412d94a52f962f317a11 bb2498a51b354198bbbb6b5e088e8117 e99492cd8af1412d94a52f962f317a11--bb2498a51b354198bbbb6b5e088e8117 51e11ca396a24b9fb15aeb7484b03622 bb2498a51b354198bbbb6b5e088e8117--51e11ca396a24b9fb15aeb7484b03622 42021345471a48d0b1830ef5dcd33a87 51e11ca396a24b9fb15aeb7484b03622--42021345471a48d0b1830ef5dcd33a87 2a0e8958bdff4e9b9bcd4ada5ebd9f2b X 42021345471a48d0b1830ef5dcd33a87--2a0e8958bdff4e9b9bcd4ada5ebd9f2b 2a0e8958bdff4e9b9bcd4ada5ebd9f2b--56ca2673aea7401098bf86c76f11a35c c19e758ba0e94da4b4a8edc21a80bf5a 2a0e8958bdff4e9b9bcd4ada5ebd9f2b--c19e758ba0e94da4b4a8edc21a80bf5a 6275b9bf2c8f4704b3b0239ba2dc33b4 c19e758ba0e94da4b4a8edc21a80bf5a--6275b9bf2c8f4704b3b0239ba2dc33b4 eb57ebc9bb744b6bac0ca0486be9fc89 6275b9bf2c8f4704b3b0239ba2dc33b4--eb57ebc9bb744b6bac0ca0486be9fc89 ac5666bbf14945639b5a791177d2d75b eb57ebc9bb744b6bac0ca0486be9fc89--ac5666bbf14945639b5a791177d2d75b b5dc81302d334e918510aa4ce26115ab ac5666bbf14945639b5a791177d2d75b--b5dc81302d334e918510aa4ce26115ab 5710f545513c4bc2ac67235c4bf99367 X b5dc81302d334e918510aa4ce26115ab--5710f545513c4bc2ac67235c4bf99367 5710f545513c4bc2ac67235c4bf99367--a8bc4b7a38904000ad9bd9efde985cce fcbdc82696684692a250dc6e7895efdf 5710f545513c4bc2ac67235c4bf99367--fcbdc82696684692a250dc6e7895efdf 9f97f7c1c9b24e55bdb27123f5e74c24 fcbdc82696684692a250dc6e7895efdf--9f97f7c1c9b24e55bdb27123f5e74c24 b76d05a867e047a2b2db999e836a00e0 9f97f7c1c9b24e55bdb27123f5e74c24--b76d05a867e047a2b2db999e836a00e0 a160921950fd4b5398879a28ad4ac409 b76d05a867e047a2b2db999e836a00e0--a160921950fd4b5398879a28ad4ac409 ff65b23c20d547fe85f2d5e99e366d28 X a160921950fd4b5398879a28ad4ac409--ff65b23c20d547fe85f2d5e99e366d28 ff65b23c20d547fe85f2d5e99e366d28--f88d1bf551614175828e36ceac98d022 c3179270c868491cbb4759d0008390f5 ff65b23c20d547fe85f2d5e99e366d28--c3179270c868491cbb4759d0008390f5 cc5d82cb2b7b47ffbd3fb8ac1f0f45ca c3179270c868491cbb4759d0008390f5--cc5d82cb2b7b47ffbd3fb8ac1f0f45ca 96d1788ca88345049787689765e110d5 cc5d82cb2b7b47ffbd3fb8ac1f0f45ca--96d1788ca88345049787689765e110d5 1eb80bd458f647c3b4312f20c7fcd0aa 96d1788ca88345049787689765e110d5--1eb80bd458f647c3b4312f20c7fcd0aa 486e9d9ad05847fe8f497777db39a8a2 1eb80bd458f647c3b4312f20c7fcd0aa--486e9d9ad05847fe8f497777db39a8a2 ba688c127dfe4cff9aa9c3dc35c28f32 486e9d9ad05847fe8f497777db39a8a2--ba688c127dfe4cff9aa9c3dc35c28f32 d50cfd42f566468a9871e52860846fcc ba688c127dfe4cff9aa9c3dc35c28f32--d50cfd42f566468a9871e52860846fcc dc51b46cc2b843c5bf42bcfbafd83bde X d50cfd42f566468a9871e52860846fcc--dc51b46cc2b843c5bf42bcfbafd83bde dc51b46cc2b843c5bf42bcfbafd83bde--3b21f35d1779490f94407f9c656895ec 1d35653a1507446fb5a07455e46c0ce7 dc51b46cc2b843c5bf42bcfbafd83bde--1d35653a1507446fb5a07455e46c0ce7 fb0c144aa1e6417094d2ec1c21fc551f 1d35653a1507446fb5a07455e46c0ce7--fb0c144aa1e6417094d2ec1c21fc551f 863cc8c6e6ee4593b1624df915b99fec RX(b14) fb0c144aa1e6417094d2ec1c21fc551f--863cc8c6e6ee4593b1624df915b99fec 863cc8c6e6ee4593b1624df915b99fec--88e04b858a544a1494beb501d177b5fa 14ef95c8156a4c42bae997956a0143dc 56048f0000364293b29a873bf22d704b 9d46efb74aa44c699fc7d417d82f836e--56048f0000364293b29a873bf22d704b 075106a9b62445a5a02bbba2b9c6d0d6 6 3a89c06d4d774d8aa6d277cbae236454 56048f0000364293b29a873bf22d704b--3a89c06d4d774d8aa6d277cbae236454 e65c181968c640f7b3316ddcf3ab63a4 3a89c06d4d774d8aa6d277cbae236454--e65c181968c640f7b3316ddcf3ab63a4 ab864de69bc44c198dfbced56de0db13 e65c181968c640f7b3316ddcf3ab63a4--ab864de69bc44c198dfbced56de0db13 99d109194b824a4b8303a0a6328f614f X ab864de69bc44c198dfbced56de0db13--99d109194b824a4b8303a0a6328f614f 99d109194b824a4b8303a0a6328f614f--2024b0cf784942b481f4b8a832b178ea 802b8492de634446839f08369f73485a 99d109194b824a4b8303a0a6328f614f--802b8492de634446839f08369f73485a c8bf9343a20a49fc87f3994985a39880 802b8492de634446839f08369f73485a--c8bf9343a20a49fc87f3994985a39880 d62efb63eb854c74833532ab4c708305 c8bf9343a20a49fc87f3994985a39880--d62efb63eb854c74833532ab4c708305 14cdee5d563047758c4f0e2d5fa3fe08 d62efb63eb854c74833532ab4c708305--14cdee5d563047758c4f0e2d5fa3fe08 9486fea4751a4caaa34d343e1ab03647 14cdee5d563047758c4f0e2d5fa3fe08--9486fea4751a4caaa34d343e1ab03647 65126eaeca39499a97b028db9a3482e0 X 9486fea4751a4caaa34d343e1ab03647--65126eaeca39499a97b028db9a3482e0 65126eaeca39499a97b028db9a3482e0--9afcd43c3b644728945b866c5555764a 550683fd681a4dcdb802bfe822d0fce1 65126eaeca39499a97b028db9a3482e0--550683fd681a4dcdb802bfe822d0fce1 3ae511cd77e242e1915c2007404e9969 550683fd681a4dcdb802bfe822d0fce1--3ae511cd77e242e1915c2007404e9969 b4443a37df5b40588eee7379f4725bde 3ae511cd77e242e1915c2007404e9969--b4443a37df5b40588eee7379f4725bde 3801e419492d4e58b5724d8ec0e2b24f b4443a37df5b40588eee7379f4725bde--3801e419492d4e58b5724d8ec0e2b24f 035b355d092848db807111781ee70dfe 3801e419492d4e58b5724d8ec0e2b24f--035b355d092848db807111781ee70dfe 9ac3bc665ece4f3a96bee535b079abf5 035b355d092848db807111781ee70dfe--9ac3bc665ece4f3a96bee535b079abf5 4d414dbab8c148b98426c92cec20cdb6 9ac3bc665ece4f3a96bee535b079abf5--4d414dbab8c148b98426c92cec20cdb6 f6c0a5ec28f04bc28de49e9b2449f4af 4d414dbab8c148b98426c92cec20cdb6--f6c0a5ec28f04bc28de49e9b2449f4af e98055570b8747e9a404bc48151e16ba f6c0a5ec28f04bc28de49e9b2449f4af--e98055570b8747e9a404bc48151e16ba 3e2a5eb8a0d940ff90d319e3341dfae5 e98055570b8747e9a404bc48151e16ba--3e2a5eb8a0d940ff90d319e3341dfae5 17b9d4291df94636a847da34c30bc264 3e2a5eb8a0d940ff90d319e3341dfae5--17b9d4291df94636a847da34c30bc264 1eb064e1274f4144b4c2463b3b03630a 17b9d4291df94636a847da34c30bc264--1eb064e1274f4144b4c2463b3b03630a b1ab80640fdf43359ce0b988a893acb2 1eb064e1274f4144b4c2463b3b03630a--b1ab80640fdf43359ce0b988a893acb2 1ac639ea439f48149e200920508c8678 b1ab80640fdf43359ce0b988a893acb2--1ac639ea439f48149e200920508c8678 3b52b4e108b5454abaefcd938b45c1d4 1ac639ea439f48149e200920508c8678--3b52b4e108b5454abaefcd938b45c1d4 c2345c35d1364eaab8551974bee6229f X 3b52b4e108b5454abaefcd938b45c1d4--c2345c35d1364eaab8551974bee6229f c2345c35d1364eaab8551974bee6229f--ee31c58d51094e7ba5f12f4651e8424d 33b7e121153240838619019e6524cfc6 c2345c35d1364eaab8551974bee6229f--33b7e121153240838619019e6524cfc6 668986aa8a3346fd9823e54c3efa6e5d 33b7e121153240838619019e6524cfc6--668986aa8a3346fd9823e54c3efa6e5d c9255a2a41604c1c80fc6b7b417cd9b0 668986aa8a3346fd9823e54c3efa6e5d--c9255a2a41604c1c80fc6b7b417cd9b0 97f46c60cb4e4bf6ba691dc7c9e57a91 X c9255a2a41604c1c80fc6b7b417cd9b0--97f46c60cb4e4bf6ba691dc7c9e57a91 97f46c60cb4e4bf6ba691dc7c9e57a91--e08b0de347634e85b0ba17161ce7ebaa 3172c362307c43e9aa5d4da4a42273fc 97f46c60cb4e4bf6ba691dc7c9e57a91--3172c362307c43e9aa5d4da4a42273fc f6bbef5f52144851bcde38f5b8849c72 3172c362307c43e9aa5d4da4a42273fc--f6bbef5f52144851bcde38f5b8849c72 ba27b601580d45808a5191fd074122c7 f6bbef5f52144851bcde38f5b8849c72--ba27b601580d45808a5191fd074122c7 084f7024156249b083c6e22ba03d4a25 ba27b601580d45808a5191fd074122c7--084f7024156249b083c6e22ba03d4a25 4da64bf6883a470d94c6e61b581360d6 084f7024156249b083c6e22ba03d4a25--4da64bf6883a470d94c6e61b581360d6 79ff6409a99f46489845de45e497d25e 4da64bf6883a470d94c6e61b581360d6--79ff6409a99f46489845de45e497d25e 40ee719d536f4e74a30d331c2e062cff X 79ff6409a99f46489845de45e497d25e--40ee719d536f4e74a30d331c2e062cff 40ee719d536f4e74a30d331c2e062cff--c1953c04cf94489991a1c27385a1bc67 d5e4dfdb9998430885004efa94438cff 40ee719d536f4e74a30d331c2e062cff--d5e4dfdb9998430885004efa94438cff e19d149017414cc3bf25785930c94ee6 d5e4dfdb9998430885004efa94438cff--e19d149017414cc3bf25785930c94ee6 71a96861e6364d8d924ff412bbd01818 e19d149017414cc3bf25785930c94ee6--71a96861e6364d8d924ff412bbd01818 3617bd3afc9f418fa6ccbd87a3d9b1bd 71a96861e6364d8d924ff412bbd01818--3617bd3afc9f418fa6ccbd87a3d9b1bd a25e99f574004b35af60992bb74d6be2 3617bd3afc9f418fa6ccbd87a3d9b1bd--a25e99f574004b35af60992bb74d6be2 017e89078d664b7dbf855016868314ed X a25e99f574004b35af60992bb74d6be2--017e89078d664b7dbf855016868314ed 017e89078d664b7dbf855016868314ed--3e06e2661287496084010b15ca491ec3 c4c546be1efc4ef097727276ca305344 017e89078d664b7dbf855016868314ed--c4c546be1efc4ef097727276ca305344 554cf1b96ada45718f4a04b88d13f3f7 c4c546be1efc4ef097727276ca305344--554cf1b96ada45718f4a04b88d13f3f7 c3f0b74987034738bafd12cdc69970cb 554cf1b96ada45718f4a04b88d13f3f7--c3f0b74987034738bafd12cdc69970cb bfa265703ef54ae8a0a5acfb5920ace5 RX(b05) c3f0b74987034738bafd12cdc69970cb--bfa265703ef54ae8a0a5acfb5920ace5 78b1070794a2441cba3b7e80f0b21182 bfa265703ef54ae8a0a5acfb5920ace5--78b1070794a2441cba3b7e80f0b21182 45155f2acac84cf69193ce6dc2b94a84 78b1070794a2441cba3b7e80f0b21182--45155f2acac84cf69193ce6dc2b94a84 bf6e8bb2811845dd80919b54faa27b97 45155f2acac84cf69193ce6dc2b94a84--bf6e8bb2811845dd80919b54faa27b97 77cc3a82d4274e83961182c4d79256b4 bf6e8bb2811845dd80919b54faa27b97--77cc3a82d4274e83961182c4d79256b4 6b8b5c6e725a480da630cfca2bcf2d28 X 77cc3a82d4274e83961182c4d79256b4--6b8b5c6e725a480da630cfca2bcf2d28 6b8b5c6e725a480da630cfca2bcf2d28--4116d1ab9d3e4b6e9dbf84afa73ac97c 3a6c895773e04d82bd01a099d19e30ed 6b8b5c6e725a480da630cfca2bcf2d28--3a6c895773e04d82bd01a099d19e30ed fa0e55e52e824cada62e8ef2703c87d0 3a6c895773e04d82bd01a099d19e30ed--fa0e55e52e824cada62e8ef2703c87d0 4117e76ab19343e3818b5696428810d1 fa0e55e52e824cada62e8ef2703c87d0--4117e76ab19343e3818b5696428810d1 1775a4ceadc04b768df6ccc8ac865b83 4117e76ab19343e3818b5696428810d1--1775a4ceadc04b768df6ccc8ac865b83 bae6b6c36af84e31952f737be674c0e8 1775a4ceadc04b768df6ccc8ac865b83--bae6b6c36af84e31952f737be674c0e8 dd09450953a946178cd7e515d0fe1d73 X bae6b6c36af84e31952f737be674c0e8--dd09450953a946178cd7e515d0fe1d73 dd09450953a946178cd7e515d0fe1d73--83a417bf4f0a4de4b6e4c809503dcbd1 e979cc9df2bc48e38ebb87fa47ed86a9 dd09450953a946178cd7e515d0fe1d73--e979cc9df2bc48e38ebb87fa47ed86a9 c1fd755002664c2cab4e58c3a732da7f e979cc9df2bc48e38ebb87fa47ed86a9--c1fd755002664c2cab4e58c3a732da7f d2993be21ee047938a3e6017818f4f81 c1fd755002664c2cab4e58c3a732da7f--d2993be21ee047938a3e6017818f4f81 d34a72cffa264d7299d94baf05351d8b d2993be21ee047938a3e6017818f4f81--d34a72cffa264d7299d94baf05351d8b 8d1724d4415c4d99bf9acea07d244eb1 d34a72cffa264d7299d94baf05351d8b--8d1724d4415c4d99bf9acea07d244eb1 7e8de0d7d05b49bc99f6170acda221d8 8d1724d4415c4d99bf9acea07d244eb1--7e8de0d7d05b49bc99f6170acda221d8 fde1f14fb24840928eed4903469f732a 7e8de0d7d05b49bc99f6170acda221d8--fde1f14fb24840928eed4903469f732a 3fe1418d71de49d5ba0b931cabf3588b fde1f14fb24840928eed4903469f732a--3fe1418d71de49d5ba0b931cabf3588b 9fd3be7722b848c197bc7c58f948c940 3fe1418d71de49d5ba0b931cabf3588b--9fd3be7722b848c197bc7c58f948c940 a9fb4c654e74494b826027d507aac76b 9fd3be7722b848c197bc7c58f948c940--a9fb4c654e74494b826027d507aac76b cbc88a00323e4200a67fe1ba38125b13 a9fb4c654e74494b826027d507aac76b--cbc88a00323e4200a67fe1ba38125b13 bc1c07a9e3f9428194b21e1a90d1bc08 cbc88a00323e4200a67fe1ba38125b13--bc1c07a9e3f9428194b21e1a90d1bc08 a1b67c2443b44726ba6afc09082e7052 bc1c07a9e3f9428194b21e1a90d1bc08--a1b67c2443b44726ba6afc09082e7052 ef05c4bf380540538b4a7424ca369e96 a1b67c2443b44726ba6afc09082e7052--ef05c4bf380540538b4a7424ca369e96 76973f1b63bf40199cc50211580da364 ef05c4bf380540538b4a7424ca369e96--76973f1b63bf40199cc50211580da364 d543838aa5a0419f9b46339d9da8e58b X 76973f1b63bf40199cc50211580da364--d543838aa5a0419f9b46339d9da8e58b d543838aa5a0419f9b46339d9da8e58b--c19e758ba0e94da4b4a8edc21a80bf5a 232b3e845b7c4d578be2b842592132fd d543838aa5a0419f9b46339d9da8e58b--232b3e845b7c4d578be2b842592132fd 5c43c581c4764ff5aa864463bf565820 232b3e845b7c4d578be2b842592132fd--5c43c581c4764ff5aa864463bf565820 69616508d519435ca18f3f3be589642b 5c43c581c4764ff5aa864463bf565820--69616508d519435ca18f3f3be589642b 3e7cf87051804ecea19c9f90b81e6250 X 69616508d519435ca18f3f3be589642b--3e7cf87051804ecea19c9f90b81e6250 3e7cf87051804ecea19c9f90b81e6250--b5dc81302d334e918510aa4ce26115ab 542b71f5bd4647d794ed81191fe66d2b 3e7cf87051804ecea19c9f90b81e6250--542b71f5bd4647d794ed81191fe66d2b 15ba3a61017f46678c99ed7413085c57 542b71f5bd4647d794ed81191fe66d2b--15ba3a61017f46678c99ed7413085c57 18e229917bc449d799129447d85324a8 15ba3a61017f46678c99ed7413085c57--18e229917bc449d799129447d85324a8 bde489452d6d4ea396306d4635bd390b 18e229917bc449d799129447d85324a8--bde489452d6d4ea396306d4635bd390b 4b9f4bbdd8764c279b54eaa741e4ab20 bde489452d6d4ea396306d4635bd390b--4b9f4bbdd8764c279b54eaa741e4ab20 0458c08081d34b4ca31d0239f5d63c93 4b9f4bbdd8764c279b54eaa741e4ab20--0458c08081d34b4ca31d0239f5d63c93 39105e810e5442cd8e90a32e51e8d0b1 X 0458c08081d34b4ca31d0239f5d63c93--39105e810e5442cd8e90a32e51e8d0b1 39105e810e5442cd8e90a32e51e8d0b1--c3179270c868491cbb4759d0008390f5 fc9bbddc3e7d46c5b5647d20a57f7392 39105e810e5442cd8e90a32e51e8d0b1--fc9bbddc3e7d46c5b5647d20a57f7392 11cee592dd994c3bb0f1785be879ff2b fc9bbddc3e7d46c5b5647d20a57f7392--11cee592dd994c3bb0f1785be879ff2b eb9a5eaa15f64aebbf851aa05174c178 11cee592dd994c3bb0f1785be879ff2b--eb9a5eaa15f64aebbf851aa05174c178 84aea385b9de4012b40dc9679974b98e eb9a5eaa15f64aebbf851aa05174c178--84aea385b9de4012b40dc9679974b98e c7b6e120f854414a814e349962ba591e 84aea385b9de4012b40dc9679974b98e--c7b6e120f854414a814e349962ba591e 641e1eb15af247fda138034cfb88d0d8 X c7b6e120f854414a814e349962ba591e--641e1eb15af247fda138034cfb88d0d8 641e1eb15af247fda138034cfb88d0d8--d50cfd42f566468a9871e52860846fcc 9422a9f7769141a59f9efa111ed86008 641e1eb15af247fda138034cfb88d0d8--9422a9f7769141a59f9efa111ed86008 103df8b99b2847e9a0bb00c73f20bcd4 9422a9f7769141a59f9efa111ed86008--103df8b99b2847e9a0bb00c73f20bcd4 4e91a0ba9ab744018bc56621186144ef 103df8b99b2847e9a0bb00c73f20bcd4--4e91a0ba9ab744018bc56621186144ef 14a5ef020991489db488da97ef0f28fb RX(b15) 4e91a0ba9ab744018bc56621186144ef--14a5ef020991489db488da97ef0f28fb 14a5ef020991489db488da97ef0f28fb--14ef95c8156a4c42bae997956a0143dc e3baa7494a6e446ea2a70413dcc2d91d 748c9b9e09d04f85a2646d639200d8f6 075106a9b62445a5a02bbba2b9c6d0d6--748c9b9e09d04f85a2646d639200d8f6 ffab22f7d5e5439688843070ca43df94 7 db8261a77d2b4177892b8fd3235176bd 748c9b9e09d04f85a2646d639200d8f6--db8261a77d2b4177892b8fd3235176bd f394d42fadbc4b3189e01e8f13ee9516 db8261a77d2b4177892b8fd3235176bd--f394d42fadbc4b3189e01e8f13ee9516 a41e1385e1e94a74ab945e316d7f5f32 f394d42fadbc4b3189e01e8f13ee9516--a41e1385e1e94a74ab945e316d7f5f32 fc91c5a5bcd048b890e387fcb757d580 a41e1385e1e94a74ab945e316d7f5f32--fc91c5a5bcd048b890e387fcb757d580 0c302689626541c3a8de55f5c18009f9 X fc91c5a5bcd048b890e387fcb757d580--0c302689626541c3a8de55f5c18009f9 0c302689626541c3a8de55f5c18009f9--802b8492de634446839f08369f73485a 3c831677fd8347d0938b737127d84390 0c302689626541c3a8de55f5c18009f9--3c831677fd8347d0938b737127d84390 78adf1b5346543e081e4d241f32422c2 3c831677fd8347d0938b737127d84390--78adf1b5346543e081e4d241f32422c2 0cee9c41bbbe470e8b65802e7780118a 78adf1b5346543e081e4d241f32422c2--0cee9c41bbbe470e8b65802e7780118a bede5566910046dfa086cc2ea4176d7a X 0cee9c41bbbe470e8b65802e7780118a--bede5566910046dfa086cc2ea4176d7a bede5566910046dfa086cc2ea4176d7a--9486fea4751a4caaa34d343e1ab03647 0c7398358ad7425bb111fecbfe756d06 bede5566910046dfa086cc2ea4176d7a--0c7398358ad7425bb111fecbfe756d06 29560fde62dd4d8cba7d465e331550aa 0c7398358ad7425bb111fecbfe756d06--29560fde62dd4d8cba7d465e331550aa f9c582d6ac78477c8ec7624833e60184 29560fde62dd4d8cba7d465e331550aa--f9c582d6ac78477c8ec7624833e60184 147a2942b9334145ae62c2fbd8adbb47 f9c582d6ac78477c8ec7624833e60184--147a2942b9334145ae62c2fbd8adbb47 3f329fd9eac441cc98b266a3bfa1b8d3 147a2942b9334145ae62c2fbd8adbb47--3f329fd9eac441cc98b266a3bfa1b8d3 979cd862c59f4e889d5c2f37f57700df 3f329fd9eac441cc98b266a3bfa1b8d3--979cd862c59f4e889d5c2f37f57700df f33f74baf75f4adaa96c0b5b15a6a1d9 979cd862c59f4e889d5c2f37f57700df--f33f74baf75f4adaa96c0b5b15a6a1d9 7360929c77c94f89b2c072131a907363 f33f74baf75f4adaa96c0b5b15a6a1d9--7360929c77c94f89b2c072131a907363 7e2a8488d8ad4310870eaf4f248b193f 7360929c77c94f89b2c072131a907363--7e2a8488d8ad4310870eaf4f248b193f cd544abaa85441b2a655a1e5717ef6b4 7e2a8488d8ad4310870eaf4f248b193f--cd544abaa85441b2a655a1e5717ef6b4 77314a4d031b47a58d8590c9c3cf73f4 cd544abaa85441b2a655a1e5717ef6b4--77314a4d031b47a58d8590c9c3cf73f4 afb08d9be65d465dbc677255ac6650c8 77314a4d031b47a58d8590c9c3cf73f4--afb08d9be65d465dbc677255ac6650c8 9f4ff2d82dbc498a8c5c529c9c1c0c96 afb08d9be65d465dbc677255ac6650c8--9f4ff2d82dbc498a8c5c529c9c1c0c96 e75bf2931641469db323eedb416e5513 9f4ff2d82dbc498a8c5c529c9c1c0c96--e75bf2931641469db323eedb416e5513 b745481f3fc942209dec696d05ed2577 e75bf2931641469db323eedb416e5513--b745481f3fc942209dec696d05ed2577 24b7ed32dbfb4daf926b2b38384639a4 b745481f3fc942209dec696d05ed2577--24b7ed32dbfb4daf926b2b38384639a4 435e9b50297041b9a004763cefe8dba1 24b7ed32dbfb4daf926b2b38384639a4--435e9b50297041b9a004763cefe8dba1 179965374e5c4d5fa1c65614cd3d6c01 X 435e9b50297041b9a004763cefe8dba1--179965374e5c4d5fa1c65614cd3d6c01 179965374e5c4d5fa1c65614cd3d6c01--33b7e121153240838619019e6524cfc6 4d2b7a4d67bc49db911afe9a727d254d RZ(-1.0*g0) 179965374e5c4d5fa1c65614cd3d6c01--4d2b7a4d67bc49db911afe9a727d254d 7144102fdca04c84a75ae43d6ee24d23 X 4d2b7a4d67bc49db911afe9a727d254d--7144102fdca04c84a75ae43d6ee24d23 7144102fdca04c84a75ae43d6ee24d23--c9255a2a41604c1c80fc6b7b417cd9b0 5aef157ccfa44189948c1a2ee6f2ab32 7144102fdca04c84a75ae43d6ee24d23--5aef157ccfa44189948c1a2ee6f2ab32 301a3ef967714c2b8f66dd12ada0b08f 5aef157ccfa44189948c1a2ee6f2ab32--301a3ef967714c2b8f66dd12ada0b08f 7a17105dc9e44f1094e70899bfe6c051 301a3ef967714c2b8f66dd12ada0b08f--7a17105dc9e44f1094e70899bfe6c051 cac460aeb7a6427c8492cb4cec0fb79f 7a17105dc9e44f1094e70899bfe6c051--cac460aeb7a6427c8492cb4cec0fb79f 0f591382f07d435c97675b91ffd0ed0f cac460aeb7a6427c8492cb4cec0fb79f--0f591382f07d435c97675b91ffd0ed0f 92c5bdf7422e4a2fae43caa6d955eb40 0f591382f07d435c97675b91ffd0ed0f--92c5bdf7422e4a2fae43caa6d955eb40 e44df18be9c549a2ad13ac2f302558c9 92c5bdf7422e4a2fae43caa6d955eb40--e44df18be9c549a2ad13ac2f302558c9 2e9dd609f298492ea847450742f09766 e44df18be9c549a2ad13ac2f302558c9--2e9dd609f298492ea847450742f09766 d9b08d57919446e29fbf3efb1bc5b663 X 2e9dd609f298492ea847450742f09766--d9b08d57919446e29fbf3efb1bc5b663 d9b08d57919446e29fbf3efb1bc5b663--d5e4dfdb9998430885004efa94438cff 57516a8795a147bfb55d94e99bae43ec d9b08d57919446e29fbf3efb1bc5b663--57516a8795a147bfb55d94e99bae43ec e9970da6d6e0421aab59d483b6215ea4 57516a8795a147bfb55d94e99bae43ec--e9970da6d6e0421aab59d483b6215ea4 53f292febb8b444a97d8e6808b9c42c4 e9970da6d6e0421aab59d483b6215ea4--53f292febb8b444a97d8e6808b9c42c4 2f86b610971b4b89837e8439f6c6e053 X 53f292febb8b444a97d8e6808b9c42c4--2f86b610971b4b89837e8439f6c6e053 2f86b610971b4b89837e8439f6c6e053--a25e99f574004b35af60992bb74d6be2 e193e08b03484e4c8cba490907c9b129 2f86b610971b4b89837e8439f6c6e053--e193e08b03484e4c8cba490907c9b129 79754f95a6f84686845c2fddd8af89e8 e193e08b03484e4c8cba490907c9b129--79754f95a6f84686845c2fddd8af89e8 65f751e4b20b481b8b8cf3f4a83ff9ec 79754f95a6f84686845c2fddd8af89e8--65f751e4b20b481b8b8cf3f4a83ff9ec aa0c51eacc50406396f59fbcf43671ea 65f751e4b20b481b8b8cf3f4a83ff9ec--aa0c51eacc50406396f59fbcf43671ea 5c7bba2eff374cdaa1bdc02cd8dc7e70 RX(b06) aa0c51eacc50406396f59fbcf43671ea--5c7bba2eff374cdaa1bdc02cd8dc7e70 76a5dea28a3c429cb99a4627dbb84ef4 5c7bba2eff374cdaa1bdc02cd8dc7e70--76a5dea28a3c429cb99a4627dbb84ef4 14cab314701c4993a30bbbf3712f189b 76a5dea28a3c429cb99a4627dbb84ef4--14cab314701c4993a30bbbf3712f189b 544520b1f8504ae7b0af9c97377a9fc0 14cab314701c4993a30bbbf3712f189b--544520b1f8504ae7b0af9c97377a9fc0 74d71a88f00942f396b4bc3ed4204ec8 544520b1f8504ae7b0af9c97377a9fc0--74d71a88f00942f396b4bc3ed4204ec8 6f0d6602c7ef4dcea302c33e2c67f716 74d71a88f00942f396b4bc3ed4204ec8--6f0d6602c7ef4dcea302c33e2c67f716 d80d8cac69424b02b3900b7a555ff97d X 6f0d6602c7ef4dcea302c33e2c67f716--d80d8cac69424b02b3900b7a555ff97d d80d8cac69424b02b3900b7a555ff97d--3a6c895773e04d82bd01a099d19e30ed 16054c93dd144472bd839d199665af5e d80d8cac69424b02b3900b7a555ff97d--16054c93dd144472bd839d199665af5e db2a3b4b301c41aeb002d6ab6cfa6a89 16054c93dd144472bd839d199665af5e--db2a3b4b301c41aeb002d6ab6cfa6a89 e8014702f28646c3b3ce35dbb4dbd955 db2a3b4b301c41aeb002d6ab6cfa6a89--e8014702f28646c3b3ce35dbb4dbd955 5eae0e89e92b437fa07f5087955ec971 X e8014702f28646c3b3ce35dbb4dbd955--5eae0e89e92b437fa07f5087955ec971 5eae0e89e92b437fa07f5087955ec971--bae6b6c36af84e31952f737be674c0e8 4306a48523b94ba49891076864f0fdff 5eae0e89e92b437fa07f5087955ec971--4306a48523b94ba49891076864f0fdff 51c85df0157244ac9dced1bfd3440fdd 4306a48523b94ba49891076864f0fdff--51c85df0157244ac9dced1bfd3440fdd 5fccd2e76dac470993626a349566197e 51c85df0157244ac9dced1bfd3440fdd--5fccd2e76dac470993626a349566197e b20bfe11534b4197be708a1d7e69cd91 5fccd2e76dac470993626a349566197e--b20bfe11534b4197be708a1d7e69cd91 f60073f6966e4f55b3568eee012b6bef b20bfe11534b4197be708a1d7e69cd91--f60073f6966e4f55b3568eee012b6bef c1edd83ca2324006a45a9d1299149848 f60073f6966e4f55b3568eee012b6bef--c1edd83ca2324006a45a9d1299149848 19baa290b9514ca5abfc5c2200221663 c1edd83ca2324006a45a9d1299149848--19baa290b9514ca5abfc5c2200221663 64b97f4879e941e28fa4f664fbc2022a 19baa290b9514ca5abfc5c2200221663--64b97f4879e941e28fa4f664fbc2022a 710fc87cc2384b739bc69f3ae4f04e29 64b97f4879e941e28fa4f664fbc2022a--710fc87cc2384b739bc69f3ae4f04e29 108491dbd2a64c7aa81b2985f4532ff3 710fc87cc2384b739bc69f3ae4f04e29--108491dbd2a64c7aa81b2985f4532ff3 b3240c45d9324059a645cb5e5172ad69 108491dbd2a64c7aa81b2985f4532ff3--b3240c45d9324059a645cb5e5172ad69 8c7f521fe62b4efe8862aebcbae4f04d b3240c45d9324059a645cb5e5172ad69--8c7f521fe62b4efe8862aebcbae4f04d 79bb2d60f5294c28af392ddea85ed583 8c7f521fe62b4efe8862aebcbae4f04d--79bb2d60f5294c28af392ddea85ed583 be254a2cb87244b29c2bc41c102ddc9a 79bb2d60f5294c28af392ddea85ed583--be254a2cb87244b29c2bc41c102ddc9a 5ff84e1fd4b943be86a99929ea5979e9 be254a2cb87244b29c2bc41c102ddc9a--5ff84e1fd4b943be86a99929ea5979e9 3ae1929cffcd494baac1e0ef2ca3d37e 5ff84e1fd4b943be86a99929ea5979e9--3ae1929cffcd494baac1e0ef2ca3d37e 608ac6b898c94d51af7882fabcbfa748 3ae1929cffcd494baac1e0ef2ca3d37e--608ac6b898c94d51af7882fabcbfa748 48307ef595ec4cb29cb7ddd47186f225 X 608ac6b898c94d51af7882fabcbfa748--48307ef595ec4cb29cb7ddd47186f225 48307ef595ec4cb29cb7ddd47186f225--232b3e845b7c4d578be2b842592132fd 692798ce716244eeb101ebadedbd78df RZ(-1.0*g1) 48307ef595ec4cb29cb7ddd47186f225--692798ce716244eeb101ebadedbd78df 693fdd05c55249aa94caba0c44d73e29 X 692798ce716244eeb101ebadedbd78df--693fdd05c55249aa94caba0c44d73e29 693fdd05c55249aa94caba0c44d73e29--69616508d519435ca18f3f3be589642b bec3a0ced39d4dc5b2454e671f289682 693fdd05c55249aa94caba0c44d73e29--bec3a0ced39d4dc5b2454e671f289682 3060d88ce41a495886a11c928ecd499c bec3a0ced39d4dc5b2454e671f289682--3060d88ce41a495886a11c928ecd499c 9197d861bfbd4230b0cf6b934e044c47 3060d88ce41a495886a11c928ecd499c--9197d861bfbd4230b0cf6b934e044c47 9df5c8aa5f4840ad8f611303ca2b761a 9197d861bfbd4230b0cf6b934e044c47--9df5c8aa5f4840ad8f611303ca2b761a 30613275d14c41b090f13a5c9d08e121 9df5c8aa5f4840ad8f611303ca2b761a--30613275d14c41b090f13a5c9d08e121 318555b0aa9a44a6a10abff7adc9bcf4 30613275d14c41b090f13a5c9d08e121--318555b0aa9a44a6a10abff7adc9bcf4 af941730609d49b9b75f6aaa6fb0b6c7 318555b0aa9a44a6a10abff7adc9bcf4--af941730609d49b9b75f6aaa6fb0b6c7 f672a6eac03e498ca4a26d32e8447ecc af941730609d49b9b75f6aaa6fb0b6c7--f672a6eac03e498ca4a26d32e8447ecc 214771170fa444b1a4634ca79111578d X f672a6eac03e498ca4a26d32e8447ecc--214771170fa444b1a4634ca79111578d 214771170fa444b1a4634ca79111578d--fc9bbddc3e7d46c5b5647d20a57f7392 99a92c37222d44fa81f391845e23c2bb 214771170fa444b1a4634ca79111578d--99a92c37222d44fa81f391845e23c2bb f0840be962b544f5ad697496b85955e3 99a92c37222d44fa81f391845e23c2bb--f0840be962b544f5ad697496b85955e3 78fea358ec144d3ca8b24d302f1adebc f0840be962b544f5ad697496b85955e3--78fea358ec144d3ca8b24d302f1adebc 0c7721a39e694c12adb5fad9f4e63848 X 78fea358ec144d3ca8b24d302f1adebc--0c7721a39e694c12adb5fad9f4e63848 0c7721a39e694c12adb5fad9f4e63848--c7b6e120f854414a814e349962ba591e ab56aa4a7e5d4a90889e6fdd1cf1fb15 0c7721a39e694c12adb5fad9f4e63848--ab56aa4a7e5d4a90889e6fdd1cf1fb15 aef812c13d0349b8b8a700a05844a681 ab56aa4a7e5d4a90889e6fdd1cf1fb15--aef812c13d0349b8b8a700a05844a681 89f03846d1ef4070b74a650a1b82ee92 aef812c13d0349b8b8a700a05844a681--89f03846d1ef4070b74a650a1b82ee92 7e13e1ccc2744632b48310a926c4a7d7 89f03846d1ef4070b74a650a1b82ee92--7e13e1ccc2744632b48310a926c4a7d7 f342a3103f7c430c821af9f45550e43d RX(b16) 7e13e1ccc2744632b48310a926c4a7d7--f342a3103f7c430c821af9f45550e43d f342a3103f7c430c821af9f45550e43d--e3baa7494a6e446ea2a70413dcc2d91d fda88e21d1104740bbc5d7a8ba4a4851 775e0de99a9b4f788ce83598b1f2485f ffab22f7d5e5439688843070ca43df94--775e0de99a9b4f788ce83598b1f2485f f8900350ea23438cbd9062ee8e4770b6 775e0de99a9b4f788ce83598b1f2485f--f8900350ea23438cbd9062ee8e4770b6 d722cf7ab3b84e528ed7f4a14ea201e2 f8900350ea23438cbd9062ee8e4770b6--d722cf7ab3b84e528ed7f4a14ea201e2 602760e6ccaf479f8bf69991f3c5e170 d722cf7ab3b84e528ed7f4a14ea201e2--602760e6ccaf479f8bf69991f3c5e170 574c40176754441e98eea05af0b2b6d6 602760e6ccaf479f8bf69991f3c5e170--574c40176754441e98eea05af0b2b6d6 e9a9dead8ebe4d6aaf0ce886494e312f 574c40176754441e98eea05af0b2b6d6--e9a9dead8ebe4d6aaf0ce886494e312f 61624423d0b4467cbb0da90fa3abcf91 X e9a9dead8ebe4d6aaf0ce886494e312f--61624423d0b4467cbb0da90fa3abcf91 61624423d0b4467cbb0da90fa3abcf91--3c831677fd8347d0938b737127d84390 2ba6097396b74adfa858f6e05972a7a6 RZ(1.0*g0) 61624423d0b4467cbb0da90fa3abcf91--2ba6097396b74adfa858f6e05972a7a6 755453f16cd1405eb593dc92c6e0ea32 X 2ba6097396b74adfa858f6e05972a7a6--755453f16cd1405eb593dc92c6e0ea32 755453f16cd1405eb593dc92c6e0ea32--0cee9c41bbbe470e8b65802e7780118a 0bfbf6f5b6994c1484496fbc29c2043c 755453f16cd1405eb593dc92c6e0ea32--0bfbf6f5b6994c1484496fbc29c2043c 2c6b4b3dcb1b4a559e4466b1b2143c9f 0bfbf6f5b6994c1484496fbc29c2043c--2c6b4b3dcb1b4a559e4466b1b2143c9f c72465e7a80b4bf480a1d60ca5bc1b6d 2c6b4b3dcb1b4a559e4466b1b2143c9f--c72465e7a80b4bf480a1d60ca5bc1b6d ed5119e1822e4bc19c3a47660bf63755 c72465e7a80b4bf480a1d60ca5bc1b6d--ed5119e1822e4bc19c3a47660bf63755 33602474f5e4426b9e2974a0b832591c ed5119e1822e4bc19c3a47660bf63755--33602474f5e4426b9e2974a0b832591c 56bdb16a4cc84173a4fc5ea7effb34a6 33602474f5e4426b9e2974a0b832591c--56bdb16a4cc84173a4fc5ea7effb34a6 fb52d73669d94823a45411cdd128d605 56bdb16a4cc84173a4fc5ea7effb34a6--fb52d73669d94823a45411cdd128d605 25a52e27cf0f43acb26b4180d821714e fb52d73669d94823a45411cdd128d605--25a52e27cf0f43acb26b4180d821714e 17fd409694794a8fb0442d77ab990e34 25a52e27cf0f43acb26b4180d821714e--17fd409694794a8fb0442d77ab990e34 ea6fe820b6474deab8cb04477582602a 17fd409694794a8fb0442d77ab990e34--ea6fe820b6474deab8cb04477582602a f9c29e864c6a49c48a8fae2c0268d949 ea6fe820b6474deab8cb04477582602a--f9c29e864c6a49c48a8fae2c0268d949 a26ec177ebc2413499739532e30b26d6 f9c29e864c6a49c48a8fae2c0268d949--a26ec177ebc2413499739532e30b26d6 5576b88703a3417c978d068cd36310ce a26ec177ebc2413499739532e30b26d6--5576b88703a3417c978d068cd36310ce dc4fdca9ed8e44248ec49236daeb33b8 5576b88703a3417c978d068cd36310ce--dc4fdca9ed8e44248ec49236daeb33b8 c776dd09b19a4919940f48d4dcbbee12 dc4fdca9ed8e44248ec49236daeb33b8--c776dd09b19a4919940f48d4dcbbee12 fb6dd29bd42a4443a1cf051f2427682f c776dd09b19a4919940f48d4dcbbee12--fb6dd29bd42a4443a1cf051f2427682f 1f5180668fd4448e954369196c1d39e2 fb6dd29bd42a4443a1cf051f2427682f--1f5180668fd4448e954369196c1d39e2 f937e8f6929c45468ecdfe9b55a8aa4f 1f5180668fd4448e954369196c1d39e2--f937e8f6929c45468ecdfe9b55a8aa4f df53ea0afef547278fcbbef29f2a7e48 f937e8f6929c45468ecdfe9b55a8aa4f--df53ea0afef547278fcbbef29f2a7e48 22bde20b87e24c9c8dce692feea4536f df53ea0afef547278fcbbef29f2a7e48--22bde20b87e24c9c8dce692feea4536f f9eab26bf9bc4eddb7e06544733eeb00 22bde20b87e24c9c8dce692feea4536f--f9eab26bf9bc4eddb7e06544733eeb00 2294a523a7a74d4d81dc4666761b8489 f9eab26bf9bc4eddb7e06544733eeb00--2294a523a7a74d4d81dc4666761b8489 923ec6a7e56f4c09a77f591677c63ad3 2294a523a7a74d4d81dc4666761b8489--923ec6a7e56f4c09a77f591677c63ad3 db63f36de0324b6da6a140ea39baccab 923ec6a7e56f4c09a77f591677c63ad3--db63f36de0324b6da6a140ea39baccab 34c55d750eb44dc58c98584c92fc791c db63f36de0324b6da6a140ea39baccab--34c55d750eb44dc58c98584c92fc791c 4e550af343494fb7bd081d2d9d79a2f9 34c55d750eb44dc58c98584c92fc791c--4e550af343494fb7bd081d2d9d79a2f9 209a914675ff45b5b74d8a84bdaea40a 4e550af343494fb7bd081d2d9d79a2f9--209a914675ff45b5b74d8a84bdaea40a af0f7a6a391647f8b0c666e5b1d108df 209a914675ff45b5b74d8a84bdaea40a--af0f7a6a391647f8b0c666e5b1d108df c301ba5b9a3b4a2881e68dd875a7a7fa af0f7a6a391647f8b0c666e5b1d108df--c301ba5b9a3b4a2881e68dd875a7a7fa c847dbbb1ac54fbf9fd3df9e1a41d9f3 c301ba5b9a3b4a2881e68dd875a7a7fa--c847dbbb1ac54fbf9fd3df9e1a41d9f3 be73c433b9c445f18c604cae99e0a07f X c847dbbb1ac54fbf9fd3df9e1a41d9f3--be73c433b9c445f18c604cae99e0a07f be73c433b9c445f18c604cae99e0a07f--57516a8795a147bfb55d94e99bae43ec 60d9b73e3d82481eabff290a4feb950d RZ(-1.0*g0) be73c433b9c445f18c604cae99e0a07f--60d9b73e3d82481eabff290a4feb950d b02fcb6d970446b9b17b639b8b745061 X 60d9b73e3d82481eabff290a4feb950d--b02fcb6d970446b9b17b639b8b745061 b02fcb6d970446b9b17b639b8b745061--53f292febb8b444a97d8e6808b9c42c4 4e11526f47994800abf92bd5ee1f0d16 b02fcb6d970446b9b17b639b8b745061--4e11526f47994800abf92bd5ee1f0d16 8ef728b91a7f415ea730131aeb7fd2e0 4e11526f47994800abf92bd5ee1f0d16--8ef728b91a7f415ea730131aeb7fd2e0 e9c0c93ca2de437b86c54811f27f2654 8ef728b91a7f415ea730131aeb7fd2e0--e9c0c93ca2de437b86c54811f27f2654 20f4491fc2d64a4e8e1c42110049091a e9c0c93ca2de437b86c54811f27f2654--20f4491fc2d64a4e8e1c42110049091a 21074d79879646a78048f768b7783281 20f4491fc2d64a4e8e1c42110049091a--21074d79879646a78048f768b7783281 2bb05e3067a14f1e96d183fc2d352c79 RX(b07) 21074d79879646a78048f768b7783281--2bb05e3067a14f1e96d183fc2d352c79 a7eb6cdaa9ec48f7885e6ff167dfc8f8 2bb05e3067a14f1e96d183fc2d352c79--a7eb6cdaa9ec48f7885e6ff167dfc8f8 11da7f96ccbe45d896911bfd386c6d4a a7eb6cdaa9ec48f7885e6ff167dfc8f8--11da7f96ccbe45d896911bfd386c6d4a fd7d726c663948868e37a6ea13adf1c8 11da7f96ccbe45d896911bfd386c6d4a--fd7d726c663948868e37a6ea13adf1c8 78173e8c4be14f8da5d38395fadcf1cd fd7d726c663948868e37a6ea13adf1c8--78173e8c4be14f8da5d38395fadcf1cd 83cf45b9823349b19b605658270628b8 78173e8c4be14f8da5d38395fadcf1cd--83cf45b9823349b19b605658270628b8 ba5b8519ba304754b66b09e7f9939281 83cf45b9823349b19b605658270628b8--ba5b8519ba304754b66b09e7f9939281 34d27706a2c54d1e95a8d20fb129f826 X ba5b8519ba304754b66b09e7f9939281--34d27706a2c54d1e95a8d20fb129f826 34d27706a2c54d1e95a8d20fb129f826--16054c93dd144472bd839d199665af5e d669fcbd03b04f22aa8d41d4234529c2 RZ(1.0*g1) 34d27706a2c54d1e95a8d20fb129f826--d669fcbd03b04f22aa8d41d4234529c2 e106ee11e3794e7ab03822786a2904c9 X d669fcbd03b04f22aa8d41d4234529c2--e106ee11e3794e7ab03822786a2904c9 e106ee11e3794e7ab03822786a2904c9--e8014702f28646c3b3ce35dbb4dbd955 6e7c64177ca746aaa1bf2726da928d4d e106ee11e3794e7ab03822786a2904c9--6e7c64177ca746aaa1bf2726da928d4d cba56140e8674d50ade4aebc8e69c80c 6e7c64177ca746aaa1bf2726da928d4d--cba56140e8674d50ade4aebc8e69c80c 35ac052055504e1299b7638a11340ca8 cba56140e8674d50ade4aebc8e69c80c--35ac052055504e1299b7638a11340ca8 6a90ffd99b0f45a7b511f9e65dd630d7 35ac052055504e1299b7638a11340ca8--6a90ffd99b0f45a7b511f9e65dd630d7 ae82bc1a60f84b5a901c55cb192eee76 6a90ffd99b0f45a7b511f9e65dd630d7--ae82bc1a60f84b5a901c55cb192eee76 90d5c2a110264365a7d66f62b8b101e0 ae82bc1a60f84b5a901c55cb192eee76--90d5c2a110264365a7d66f62b8b101e0 2960c4507c434bd1b4433d91d3b5797c 90d5c2a110264365a7d66f62b8b101e0--2960c4507c434bd1b4433d91d3b5797c 9e707a85b3bf40cd862b76b096df8ecf 2960c4507c434bd1b4433d91d3b5797c--9e707a85b3bf40cd862b76b096df8ecf 71df9442dc9645e0aa3f8adb772890e2 9e707a85b3bf40cd862b76b096df8ecf--71df9442dc9645e0aa3f8adb772890e2 01ae47db880049529dcaec292adfd091 71df9442dc9645e0aa3f8adb772890e2--01ae47db880049529dcaec292adfd091 de7496d5f4734278bea38d175d8286b9 01ae47db880049529dcaec292adfd091--de7496d5f4734278bea38d175d8286b9 158945874e0d49c493e25234b2588c14 de7496d5f4734278bea38d175d8286b9--158945874e0d49c493e25234b2588c14 d68a99e401c348389d33ec876804f14c 158945874e0d49c493e25234b2588c14--d68a99e401c348389d33ec876804f14c 080b69f2532c449f89954a8a40d2ceff d68a99e401c348389d33ec876804f14c--080b69f2532c449f89954a8a40d2ceff 006c395a1b644684b06db94050d99d33 080b69f2532c449f89954a8a40d2ceff--006c395a1b644684b06db94050d99d33 11e1f02b9122485b837e936b5a5c86bb 006c395a1b644684b06db94050d99d33--11e1f02b9122485b837e936b5a5c86bb 515fac44850044a194496a37c32c81d2 11e1f02b9122485b837e936b5a5c86bb--515fac44850044a194496a37c32c81d2 7834791357dd4f61be05a5641df9fd82 515fac44850044a194496a37c32c81d2--7834791357dd4f61be05a5641df9fd82 6f2c9f3f284c463fb08fcaa5c0e04ecb 7834791357dd4f61be05a5641df9fd82--6f2c9f3f284c463fb08fcaa5c0e04ecb 7a743f4446134884921a1a6dc371b4f4 6f2c9f3f284c463fb08fcaa5c0e04ecb--7a743f4446134884921a1a6dc371b4f4 a7fa56a734514190a8e64f3b65ba4471 7a743f4446134884921a1a6dc371b4f4--a7fa56a734514190a8e64f3b65ba4471 7baa1bd8e47544188b557f82508ba1e3 a7fa56a734514190a8e64f3b65ba4471--7baa1bd8e47544188b557f82508ba1e3 aef2297bda0e4cfcb5193c088da3a0ed 7baa1bd8e47544188b557f82508ba1e3--aef2297bda0e4cfcb5193c088da3a0ed a5ad37623cea49ad9a067307f47daa54 aef2297bda0e4cfcb5193c088da3a0ed--a5ad37623cea49ad9a067307f47daa54 f08b04a823c64d18a7b5938bf0a5435d a5ad37623cea49ad9a067307f47daa54--f08b04a823c64d18a7b5938bf0a5435d 8b76d9384d8645c48aeabb0d9313455e f08b04a823c64d18a7b5938bf0a5435d--8b76d9384d8645c48aeabb0d9313455e 67387ade97b4489abe8cc984e82b79fe 8b76d9384d8645c48aeabb0d9313455e--67387ade97b4489abe8cc984e82b79fe 6f78729468c547a5978e31a6f8ecf61f 67387ade97b4489abe8cc984e82b79fe--6f78729468c547a5978e31a6f8ecf61f 09268c24111b4603ad7e621c2b952fd9 6f78729468c547a5978e31a6f8ecf61f--09268c24111b4603ad7e621c2b952fd9 9370d664e24e421a815884e1f76a7e41 09268c24111b4603ad7e621c2b952fd9--9370d664e24e421a815884e1f76a7e41 552af11bf67c4a799be7da3a4545e5a6 X 9370d664e24e421a815884e1f76a7e41--552af11bf67c4a799be7da3a4545e5a6 552af11bf67c4a799be7da3a4545e5a6--99a92c37222d44fa81f391845e23c2bb 9ee70324eefb4090830a3d5668faadd8 RZ(-1.0*g1) 552af11bf67c4a799be7da3a4545e5a6--9ee70324eefb4090830a3d5668faadd8 fae559acbc824fb4a47e4ad525f45e23 X 9ee70324eefb4090830a3d5668faadd8--fae559acbc824fb4a47e4ad525f45e23 fae559acbc824fb4a47e4ad525f45e23--78fea358ec144d3ca8b24d302f1adebc 7e3353a181304521aa36ba4595ebef58 fae559acbc824fb4a47e4ad525f45e23--7e3353a181304521aa36ba4595ebef58 84c56fecae8745f0982f09ffe3487e7e 7e3353a181304521aa36ba4595ebef58--84c56fecae8745f0982f09ffe3487e7e 88c9393c68504c3cba05b3bb137128d8 84c56fecae8745f0982f09ffe3487e7e--88c9393c68504c3cba05b3bb137128d8 c8af10cfaaed4c3caab99fde0a4f6fd2 88c9393c68504c3cba05b3bb137128d8--c8af10cfaaed4c3caab99fde0a4f6fd2 0d7b80d263a64fd680f7bf8c9efbc9f5 c8af10cfaaed4c3caab99fde0a4f6fd2--0d7b80d263a64fd680f7bf8c9efbc9f5 7bdb1df115314c05bb6f1e55d5c6e25b RX(b17) 0d7b80d263a64fd680f7bf8c9efbc9f5--7bdb1df115314c05bb6f1e55d5c6e25b 7bdb1df115314c05bb6f1e55d5c6e25b--fda88e21d1104740bbc5d7a8ba4a4851"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\ntorch.manual_seed(seed)\ndef loss_function(_model: QuantumModel):\nexpval_ops = _model.expectation().squeeze()\n# this corresponds to the MaxCut cost by definition\n# with negative sign in front to perform maximization\nexpval = 0.0\nfor val in expval_ops:\nexpval += 0.5 * (1 - val)\nreturn -1.0 * expval\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n# train the model\nn_epochs = 100\nlr = 1.0\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_function(model)\nloss.backward()\noptimizer.step()\nif (i+1) % (n_epochs // 10) == 0:\nprint(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -1.043459130268472\nMaxCut cost at iteration 10: 3.985378083531456\nMaxCut cost at iteration 20: 3.9996375164696967\nMaxCut cost at iteration 30: 3.999296050945324\nMaxCut cost at iteration 40: 3.999321293374523\nMaxCut cost at iteration 50: 3.9996697236616856\nMaxCut cost at iteration 60: 3.999888017053253\nMaxCut cost at iteration 70: 3.999966654936591\nMaxCut cost at iteration 80: 3.9999904558460018\nMaxCut cost at iteration 90: 3.9999972991936743\nMaxCut cost at iteration 100: 3.999999238191352\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\ncolors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\nlabels[node] = \"A\" if int(b) == 0 else \"B\"\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 00111111  2023-11-21T16:26:30.354733 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\ndef qcl_training_data(\ndomain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\nstart, end = domain\nx_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\ny_rand = torch.sin(x_rand)\nreturn x_rand, y_rand\nx, y = qcl_training_data()\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\nn_qubits = 4\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n[0.1315],\n[0.2424],\n[0.1552],\n[0.1592],\n[0.2063],\n[0.1899],\n[0.2208],\n[0.2472],\n[0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\nfor i in range(n_epochs):\noptimizer.zero_grad()\n# given a `n_batch` number of input points and a `n_observables`\n# number of input observables to measure, the QNN returns\n# an output of the following shape: [n_batch x n_observables]\n# given that there is only one observable, a squeeze is applied to get\n# a 1-dimensional tensor\nloss = mse_loss(model(values=x_train).squeeze(), y_train)\nloss.backward()\noptimizer.step()\nif (i+1) % 20 == 0:\nprint(f\"Epoch {i+1} - Loss: {loss.item()}\")\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\ny_pred = model({\"phi\": x_test})\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-11-21T16:26:34.508163 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\nn_qubits = 3\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_560fdcaa518b44b69ff2686e5a383f94 Constant Chebyshev FM cluster_ee38e7324d9e48a89106a1a11fa1c961 Constant Fourier FM dfcd51f0a1384bceb7050adcb776c0c9 0 1e15088aa0634057ad9a815b1cf1d32d RX(phi) dfcd51f0a1384bceb7050adcb776c0c9--1e15088aa0634057ad9a815b1cf1d32d 381cf647db964651977841701604a8ee 1 c09a311f004e48b0890dc4513724d927 RX(acos(phi)) 1e15088aa0634057ad9a815b1cf1d32d--c09a311f004e48b0890dc4513724d927 421ad099bf164ddfa79e7b0d9c458ccf c09a311f004e48b0890dc4513724d927--421ad099bf164ddfa79e7b0d9c458ccf 44037b38ca23434194791b0fc0dff401 20af4925dcbd46449a1e5b1aaffc5c76 RX(phi) 381cf647db964651977841701604a8ee--20af4925dcbd46449a1e5b1aaffc5c76 8a1675af178f44e38f5e252584e86701 2 db608663615447fcbc365866d9f2cad0 RX(acos(phi)) 20af4925dcbd46449a1e5b1aaffc5c76--db608663615447fcbc365866d9f2cad0 db608663615447fcbc365866d9f2cad0--44037b38ca23434194791b0fc0dff401 40f53adfa8334f9f956b1b68a0812fa2 ff0e8d929d6a4447859c106901541b30 RX(phi) 8a1675af178f44e38f5e252584e86701--ff0e8d929d6a4447859c106901541b30 b9a4b781515d450a84746102ad8e34be RX(acos(phi)) ff0e8d929d6a4447859c106901541b30--b9a4b781515d450a84746102ad8e34be b9a4b781515d450a84746102ad8e34be--40f53adfa8334f9f956b1b68a0812fa2 <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\nn_qubits = 3\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n# Creating a custom sub-class of Function\nclass custom_func(Function):\n@classmethod\ndef eval(cls, x):\nreturn asin(x) + x**2\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_func)\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_e4129ff547814d4fae8c846f8f8107ec Constant custom_func FM cluster_7765e244eff747c5a358b51864573c4a Constant asin FM 3504c4192fee4170b9a5fdf1d08b00ad 0 8879e07d0b9748fcb14652484ad8ffc8 RX(asin(phi)) 3504c4192fee4170b9a5fdf1d08b00ad--8879e07d0b9748fcb14652484ad8ffc8 e6827434b5754aa8adfd80e0473791b2 1 0df0e6e1520746f9aeaffd43f7996e45 RX(phi**2 + asin(phi)) 8879e07d0b9748fcb14652484ad8ffc8--0df0e6e1520746f9aeaffd43f7996e45 4b9e3a3dbc0242ab83db0425b7da5460 0df0e6e1520746f9aeaffd43f7996e45--4b9e3a3dbc0242ab83db0425b7da5460 4d4708ce869f41108fd117ba95db85f0 50e9eae26075484d9a652f5a7fa8e72c RX(asin(phi)) e6827434b5754aa8adfd80e0473791b2--50e9eae26075484d9a652f5a7fa8e72c 2936cc323bfe4a49abd158d87c480ff6 2 917f44a2edb24dbd8fa2f2705d31078e RX(phi**2 + asin(phi)) 50e9eae26075484d9a652f5a7fa8e72c--917f44a2edb24dbd8fa2f2705d31078e 917f44a2edb24dbd8fa2f2705d31078e--4d4708ce869f41108fd117ba95db85f0 8bccf4ca923e4d4aad279ef2df51b79d bc5a44861bf34fb999118b842060c365 RX(asin(phi)) 2936cc323bfe4a49abd158d87c480ff6--bc5a44861bf34fb999118b842060c365 82da01a7ebfb4b4ca9949f98b70a02cf RX(phi**2 + asin(phi)) bc5a44861bf34fb999118b842060c365--82da01a7ebfb4b4ca9949f98b70a02cf 82da01a7ebfb4b4ca9949f98b70a02cf--8bccf4ca923e4d4aad279ef2df51b79d <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\nn_qubits = 5\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_bca62dbcd66948a7802bb8cd3124a2a0 Exponential Fourier FM cluster_88f3e3ed5dd64bd9834dd7d32a89239f Constant Fourier FM cluster_02c892bbc48d4396a89aff6eec542b15 Tower Fourier FM 2acd3739032b441699eb9448aa633952 0 c277b3c40907452fa654ef33bd2cd9b6 RX(phi) 2acd3739032b441699eb9448aa633952--c277b3c40907452fa654ef33bd2cd9b6 8db5a4903f364acda23e4a2f5f46aad7 1 2b569fb3999f442f955ad2e8a4cd28d4 RX(1.0*phi) c277b3c40907452fa654ef33bd2cd9b6--2b569fb3999f442f955ad2e8a4cd28d4 f1cbab8e4b14422d9c3d5bea6eed864f RX(1.0*phi) 2b569fb3999f442f955ad2e8a4cd28d4--f1cbab8e4b14422d9c3d5bea6eed864f b20dd3da204048ef96a825aff5744c0c f1cbab8e4b14422d9c3d5bea6eed864f--b20dd3da204048ef96a825aff5744c0c 3158582b0eee47c58c404975ac18ce8e dbab37856ac14cc8a0235193edc3d215 RX(phi) 8db5a4903f364acda23e4a2f5f46aad7--dbab37856ac14cc8a0235193edc3d215 441e39e205fb4fa0a943532fe5d8cdac 2 ceee16f96d7649128d101d6c3293dfaa RX(2.0*phi) dbab37856ac14cc8a0235193edc3d215--ceee16f96d7649128d101d6c3293dfaa bc2ff3ae8d744e15aebc4b80e966ab05 RX(2.0*phi) ceee16f96d7649128d101d6c3293dfaa--bc2ff3ae8d744e15aebc4b80e966ab05 bc2ff3ae8d744e15aebc4b80e966ab05--3158582b0eee47c58c404975ac18ce8e 4086edbe8472477589d653bc684bece9 befd91ea770c46f993b3c1ace89da1d9 RX(phi) 441e39e205fb4fa0a943532fe5d8cdac--befd91ea770c46f993b3c1ace89da1d9 c94809115adc43ba848edece17c116bf 3 38acf6e13b854eb6b7f841ff88d8a921 RX(3.0*phi) befd91ea770c46f993b3c1ace89da1d9--38acf6e13b854eb6b7f841ff88d8a921 bfb5b8122ad0448a86fe9c7e1e421a22 RX(4.0*phi) 38acf6e13b854eb6b7f841ff88d8a921--bfb5b8122ad0448a86fe9c7e1e421a22 bfb5b8122ad0448a86fe9c7e1e421a22--4086edbe8472477589d653bc684bece9 c35eaa6cd4ae43b3b257a386177815c1 e4781caa8c004aec8cfa38df9c984c7b RX(phi) c94809115adc43ba848edece17c116bf--e4781caa8c004aec8cfa38df9c984c7b 7f0b85dfacb048288a8245e76142df84 4 c43b6155351346489b10741196b66a44 RX(4.0*phi) e4781caa8c004aec8cfa38df9c984c7b--c43b6155351346489b10741196b66a44 90a2447e0acb4dbe8f557999b0c7d8c1 RX(8.0*phi) c43b6155351346489b10741196b66a44--90a2447e0acb4dbe8f557999b0c7d8c1 90a2447e0acb4dbe8f557999b0c7d8c1--c35eaa6cd4ae43b3b257a386177815c1 38eb9e774fcb4c3b98f7ec48ddea1cd7 703f61e5f6824b559f7f09524f8782be RX(phi) 7f0b85dfacb048288a8245e76142df84--703f61e5f6824b559f7f09524f8782be bbb9a5f3b33c4a6490a2fbad84af3d28 RX(5.0*phi) 703f61e5f6824b559f7f09524f8782be--bbb9a5f3b33c4a6490a2fbad84af3d28 f8c4435a90cb44b7b37b0b42f6b6812a RX(16.0*phi) bbb9a5f3b33c4a6490a2fbad84af3d28--f8c4435a90cb44b7b37b0b42f6b6812a f8c4435a90cb44b7b37b0b42f6b6812a--38eb9e774fcb4c3b98f7ec48ddea1cd7 <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\ndef custom_scaling(i: int) -&gt; int | float:\n\"\"\"Sqrt(i+1)\"\"\"\nreturn (i+1) ** (0.5)\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 9da57c4ca55d49fca98857be9c63728b 0 e4de81714d374b0886bcfe8c60e003f0 RX(1.0*acos(phi)) 9da57c4ca55d49fca98857be9c63728b--e4de81714d374b0886bcfe8c60e003f0 fe5ef0e7daa74473ab258865dc02341f 1 10b747cc84ee40eeb86773971162e9dd e4de81714d374b0886bcfe8c60e003f0--10b747cc84ee40eeb86773971162e9dd d7640d9241df40409e553caa5985a66b 287bd9f90b5543cd8900f2db5cea4b36 RX(1.414*acos(phi)) fe5ef0e7daa74473ab258865dc02341f--287bd9f90b5543cd8900f2db5cea4b36 10c0db2f14564992b6c7b0e6c43ec746 2 287bd9f90b5543cd8900f2db5cea4b36--d7640d9241df40409e553caa5985a66b fc8515ae4a794a1da8b6a4365da1ea30 fb2f179c96b945f395ab184bd170fc8d RX(1.732*acos(phi)) 10c0db2f14564992b6c7b0e6c43ec746--fb2f179c96b945f395ab184bd170fc8d 57efd7b6ee784302b80a099c38173111 3 fb2f179c96b945f395ab184bd170fc8d--fc8515ae4a794a1da8b6a4365da1ea30 daeedf6496a84933ae2ee115d4f80a9b 7709bf7eda2f4e0cab94afd41c1ddd66 RX(2.0*acos(phi)) 57efd7b6ee784302b80a099c38173111--7709bf7eda2f4e0cab94afd41c1ddd66 8afb2b354782431f9fdf2c819a3d8a3a 4 7709bf7eda2f4e0cab94afd41c1ddd66--daeedf6496a84933ae2ee115d4f80a9b 762f833bfd7e4e33a0c77eddb11accc1 b6cee5423e2c4bcbad0f984dca9985fb RX(2.236*acos(phi)) 8afb2b354782431f9fdf2c819a3d8a3a--b6cee5423e2c4bcbad0f984dca9985fb b6cee5423e2c4bcbad0f984dca9985fb--762f833bfd7e4e33a0c77eddb11accc1 <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\nn_qubits = 5\n# Custom scaling function\nfm_full = feature_map(\nn_qubits = n_qubits,\nsupport = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\nparam = \"x\", # Change the name of the parameter\nop = RY, # Change the rotation gate between RX, RY, RZ or PHASE\nfm_type = BasisSet.CHEBYSHEV,\nreupload_scaling = ReuploadScaling.EXP,\nfeature_range = (-1.0, 2.0), # Range from which the input data comes from\ntarget_range = (1.0, 3.0), # Range the encoder assumes as the natural range\nmultiplier = 5.0 # Extra multiplier, which can also be a Parameter\n)\n</code></pre> %3 b9ab2fdc07bf4a9496cfc504594986ae 0 cf22c9dd916a4626b693d03be65db981 RY(80.0*acos(0.667*x + 1.667)) b9ab2fdc07bf4a9496cfc504594986ae--cf22c9dd916a4626b693d03be65db981 b5d2896bec7c41989df7c74090330433 1 e4700aab671b443ba7ec83f308395658 cf22c9dd916a4626b693d03be65db981--e4700aab671b443ba7ec83f308395658 2d24d77f46f447bbacf655f7d52d1f34 444dccdd8b5a464a88d522d7c7bdbb0b RY(40.0*acos(0.667*x + 1.667)) b5d2896bec7c41989df7c74090330433--444dccdd8b5a464a88d522d7c7bdbb0b c762123a383548e08873387c08592c2d 2 444dccdd8b5a464a88d522d7c7bdbb0b--2d24d77f46f447bbacf655f7d52d1f34 84d405dda4834864b80e4df6cd3bdb94 ff16c36eeb3b410a814aaf5217ea9c6d RY(20.0*acos(0.667*x + 1.667)) c762123a383548e08873387c08592c2d--ff16c36eeb3b410a814aaf5217ea9c6d 2fa6b9c06cb242f0ba7043998839d7f8 3 ff16c36eeb3b410a814aaf5217ea9c6d--84d405dda4834864b80e4df6cd3bdb94 43a45ab77e2648128f660e68a04682ec eadf47a809e942eeb7fb3a9a354b62fd RY(10.0*acos(0.667*x + 1.667)) 2fa6b9c06cb242f0ba7043998839d7f8--eadf47a809e942eeb7fb3a9a354b62fd 2562f7605b4f4fbbb33d9ce241357224 4 eadf47a809e942eeb7fb3a9a354b62fd--43a45ab77e2648128f660e68a04682ec 5ededdae4cb84db58511f50530618859 683837353c5242f0ac26e1e0cbed9fb7 RY(5.0*acos(0.667*x + 1.667)) 2562f7605b4f4fbbb33d9ce241357224--683837353c5242f0ac26e1e0cbed9fb7 683837353c5242f0ac26e1e0cbed9fb7--5ededdae4cb84db58511f50530618859"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\nn_qubits = 3\ndepth = 2\nansatz = hea(n_qubits, depth)\n</code></pre> %3 e18a779dfb7945f4a954427fc049717a 0 49e20cc4130d4a6fb222e528f949b105 RX(theta\u2080) e18a779dfb7945f4a954427fc049717a--49e20cc4130d4a6fb222e528f949b105 1d5e436311614e14a342726bc975eca6 1 f581ccf56bd04011b5fa62ee6a81b467 RY(theta\u2083) 49e20cc4130d4a6fb222e528f949b105--f581ccf56bd04011b5fa62ee6a81b467 96dde83dd450439aa3d640ccbcfd40ec RX(theta\u2086) f581ccf56bd04011b5fa62ee6a81b467--96dde83dd450439aa3d640ccbcfd40ec 027cf7cda82041fd8f7e8f24481e85b6 96dde83dd450439aa3d640ccbcfd40ec--027cf7cda82041fd8f7e8f24481e85b6 7f4fe8240a1241cabc218c133cb08654 027cf7cda82041fd8f7e8f24481e85b6--7f4fe8240a1241cabc218c133cb08654 d68a5e60c4d841a48da83084c694c308 RX(theta\u2089) 7f4fe8240a1241cabc218c133cb08654--d68a5e60c4d841a48da83084c694c308 8d7f00ae9b1845628c5e60012002dce7 RY(theta\u2081\u2082) d68a5e60c4d841a48da83084c694c308--8d7f00ae9b1845628c5e60012002dce7 e2ae62a7abc34392b035afef0d6897cd RX(theta\u2081\u2085) 8d7f00ae9b1845628c5e60012002dce7--e2ae62a7abc34392b035afef0d6897cd 03cf400eb9174a5a8f705fdcd2518af7 e2ae62a7abc34392b035afef0d6897cd--03cf400eb9174a5a8f705fdcd2518af7 b26829db669643a0a784e84a159066e7 03cf400eb9174a5a8f705fdcd2518af7--b26829db669643a0a784e84a159066e7 e7c122cdf8a544e39f6a573b9162f9d4 b26829db669643a0a784e84a159066e7--e7c122cdf8a544e39f6a573b9162f9d4 98fd2aff15b0463a830558e75b4bd09a 9ed12228a97a4224962249d77dd91da5 RX(theta\u2081) 1d5e436311614e14a342726bc975eca6--9ed12228a97a4224962249d77dd91da5 505111d3a9fd43aeb7199ccd17700605 2 ad07bcb6961543919871d5e80a225a0d RY(theta\u2084) 9ed12228a97a4224962249d77dd91da5--ad07bcb6961543919871d5e80a225a0d fad06356608d442381b775a33d0e6157 RX(theta\u2087) ad07bcb6961543919871d5e80a225a0d--fad06356608d442381b775a33d0e6157 a2379b5b8b7447b29270e2c72d800b89 X fad06356608d442381b775a33d0e6157--a2379b5b8b7447b29270e2c72d800b89 a2379b5b8b7447b29270e2c72d800b89--027cf7cda82041fd8f7e8f24481e85b6 0d69c159be944fff8307419a8e536fb2 a2379b5b8b7447b29270e2c72d800b89--0d69c159be944fff8307419a8e536fb2 b7c4cfb550334e6fa60599b3718daa3b RX(theta\u2081\u2080) 0d69c159be944fff8307419a8e536fb2--b7c4cfb550334e6fa60599b3718daa3b 961758b7665d47c0aad943e8e8fa6e6c RY(theta\u2081\u2083) b7c4cfb550334e6fa60599b3718daa3b--961758b7665d47c0aad943e8e8fa6e6c 12f159e61052428888820b6b2faeb692 RX(theta\u2081\u2086) 961758b7665d47c0aad943e8e8fa6e6c--12f159e61052428888820b6b2faeb692 df3139cc26f54be3966d5e9e8a696b29 X 12f159e61052428888820b6b2faeb692--df3139cc26f54be3966d5e9e8a696b29 df3139cc26f54be3966d5e9e8a696b29--03cf400eb9174a5a8f705fdcd2518af7 1c3b0ede5263436cb80dcb882d4f34d4 df3139cc26f54be3966d5e9e8a696b29--1c3b0ede5263436cb80dcb882d4f34d4 1c3b0ede5263436cb80dcb882d4f34d4--98fd2aff15b0463a830558e75b4bd09a ed69979d977e4a9499461c3bb4792af7 fa95f6323c6049888fc2f507b6142886 RX(theta\u2082) 505111d3a9fd43aeb7199ccd17700605--fa95f6323c6049888fc2f507b6142886 a77c8467ec3c4237845858c9f5089517 RY(theta\u2085) fa95f6323c6049888fc2f507b6142886--a77c8467ec3c4237845858c9f5089517 f06379f822074c7797e902d5ea98a9c4 RX(theta\u2088) a77c8467ec3c4237845858c9f5089517--f06379f822074c7797e902d5ea98a9c4 5e5d17c18c5c4f23ad30d56a8c7f9688 f06379f822074c7797e902d5ea98a9c4--5e5d17c18c5c4f23ad30d56a8c7f9688 1aaccef6ea154d07ba2a58472a911819 X 5e5d17c18c5c4f23ad30d56a8c7f9688--1aaccef6ea154d07ba2a58472a911819 1aaccef6ea154d07ba2a58472a911819--0d69c159be944fff8307419a8e536fb2 27afe9185ad5454a9c8b98469cebea34 RX(theta\u2081\u2081) 1aaccef6ea154d07ba2a58472a911819--27afe9185ad5454a9c8b98469cebea34 cb70b519f2d64992a68f01291b86832c RY(theta\u2081\u2084) 27afe9185ad5454a9c8b98469cebea34--cb70b519f2d64992a68f01291b86832c 01415c75d0cf40a7a75e51c990b0cb9d RX(theta\u2081\u2087) cb70b519f2d64992a68f01291b86832c--01415c75d0cf40a7a75e51c990b0cb9d 28da948c21e647e696b7c8eaea4386cd 01415c75d0cf40a7a75e51c990b0cb9d--28da948c21e647e696b7c8eaea4386cd f3380ed633874d369ff78c4a61af07c2 X 28da948c21e647e696b7c8eaea4386cd--f3380ed633874d369ff78c4a61af07c2 f3380ed633874d369ff78c4a61af07c2--1c3b0ede5263436cb80dcb882d4f34d4 f3380ed633874d369ff78c4a61af07c2--ed69979d977e4a9499461c3bb4792af7 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=\"phi\",\noperations=[RX, RY, RX],\nentangler=CPHASE\n)\n</code></pre> %3 70fd6ac4c2be4e409b5c0e690841d32d 0 ed2e1d1443d948c2af4bd8e99b524774 RX(phi\u2080) 70fd6ac4c2be4e409b5c0e690841d32d--ed2e1d1443d948c2af4bd8e99b524774 8ccb94a09274482e9719889cb333f055 1 d682c75485a74ef6a6f76149d280d9fa RY(phi\u2083) ed2e1d1443d948c2af4bd8e99b524774--d682c75485a74ef6a6f76149d280d9fa 53a001cac69548899d2e0e61c8b940d8 RX(phi\u2086) d682c75485a74ef6a6f76149d280d9fa--53a001cac69548899d2e0e61c8b940d8 9e287bea793f424bbb784359993221f5 53a001cac69548899d2e0e61c8b940d8--9e287bea793f424bbb784359993221f5 f21571ebb02d473f82d9508e310fa620 9e287bea793f424bbb784359993221f5--f21571ebb02d473f82d9508e310fa620 3b48c1946bbb4956a337276d633f6c64 RX(phi\u2089) f21571ebb02d473f82d9508e310fa620--3b48c1946bbb4956a337276d633f6c64 61109d793ed9487a90b096184dea6d5b RY(phi\u2081\u2082) 3b48c1946bbb4956a337276d633f6c64--61109d793ed9487a90b096184dea6d5b f446462bc85f4835a45249b767adabb5 RX(phi\u2081\u2085) 61109d793ed9487a90b096184dea6d5b--f446462bc85f4835a45249b767adabb5 4bf94db7ebd64046832cbe0d2eaaaaf3 f446462bc85f4835a45249b767adabb5--4bf94db7ebd64046832cbe0d2eaaaaf3 e86eb488714b433ab8c98ad4378ffda2 4bf94db7ebd64046832cbe0d2eaaaaf3--e86eb488714b433ab8c98ad4378ffda2 89174edfe4564a4f8c3dd18b55ff36c0 e86eb488714b433ab8c98ad4378ffda2--89174edfe4564a4f8c3dd18b55ff36c0 0e93d82b48f84dc6a474b6dd4e0cc9ba 6edba4c589f84d919a20d01dae83b589 RX(phi\u2081) 8ccb94a09274482e9719889cb333f055--6edba4c589f84d919a20d01dae83b589 d4a0588a6c4e480b816432f10aa6d1a2 2 535ad55c5e40405fbbc43256768961d5 RY(phi\u2084) 6edba4c589f84d919a20d01dae83b589--535ad55c5e40405fbbc43256768961d5 74f4c267e9a540e0b1d61b5a377ae8b8 RX(phi\u2087) 535ad55c5e40405fbbc43256768961d5--74f4c267e9a540e0b1d61b5a377ae8b8 0cac6095565d4031a379f07a1fbffba4 PHASE(phi_ent\u2080) 74f4c267e9a540e0b1d61b5a377ae8b8--0cac6095565d4031a379f07a1fbffba4 0cac6095565d4031a379f07a1fbffba4--9e287bea793f424bbb784359993221f5 8fa295042097421cbcb838840e8d7e3d 0cac6095565d4031a379f07a1fbffba4--8fa295042097421cbcb838840e8d7e3d c121304fa57e42d6a74005fe442e8d1a RX(phi\u2081\u2080) 8fa295042097421cbcb838840e8d7e3d--c121304fa57e42d6a74005fe442e8d1a 1a2248453f6342efbe2a8490be705c73 RY(phi\u2081\u2083) c121304fa57e42d6a74005fe442e8d1a--1a2248453f6342efbe2a8490be705c73 1b42eb2cfe5547369ed60afc9a68d6df RX(phi\u2081\u2086) 1a2248453f6342efbe2a8490be705c73--1b42eb2cfe5547369ed60afc9a68d6df b9c30f7452dd496884e1910d5fdabcd2 PHASE(phi_ent\u2082) 1b42eb2cfe5547369ed60afc9a68d6df--b9c30f7452dd496884e1910d5fdabcd2 b9c30f7452dd496884e1910d5fdabcd2--4bf94db7ebd64046832cbe0d2eaaaaf3 1d47b96a468d48f3ab79880f80323490 b9c30f7452dd496884e1910d5fdabcd2--1d47b96a468d48f3ab79880f80323490 1d47b96a468d48f3ab79880f80323490--0e93d82b48f84dc6a474b6dd4e0cc9ba c00ecb99c4ac4f0ca19031d88088e67c 5ac6a501163e43c1ab78b08810761738 RX(phi\u2082) d4a0588a6c4e480b816432f10aa6d1a2--5ac6a501163e43c1ab78b08810761738 1330d3d64838439cb488143241f67d87 RY(phi\u2085) 5ac6a501163e43c1ab78b08810761738--1330d3d64838439cb488143241f67d87 c7a7f0526d48448d99e74c7fc996474b RX(phi\u2088) 1330d3d64838439cb488143241f67d87--c7a7f0526d48448d99e74c7fc996474b 92c41165063f42128c7159e01d6fafe8 c7a7f0526d48448d99e74c7fc996474b--92c41165063f42128c7159e01d6fafe8 c1ade26c9bf14bab9859f6d11b05efe4 PHASE(phi_ent\u2081) 92c41165063f42128c7159e01d6fafe8--c1ade26c9bf14bab9859f6d11b05efe4 c1ade26c9bf14bab9859f6d11b05efe4--8fa295042097421cbcb838840e8d7e3d f2a860d6571e468fbd3daa71786d7400 RX(phi\u2081\u2081) c1ade26c9bf14bab9859f6d11b05efe4--f2a860d6571e468fbd3daa71786d7400 ae4d96d53fec44638aa321346f34485d RY(phi\u2081\u2084) f2a860d6571e468fbd3daa71786d7400--ae4d96d53fec44638aa321346f34485d 3113adc8254441a886e4066c8e740347 RX(phi\u2081\u2087) ae4d96d53fec44638aa321346f34485d--3113adc8254441a886e4066c8e740347 11fca3a827594846853ae1d025eb6d75 3113adc8254441a886e4066c8e740347--11fca3a827594846853ae1d025eb6d75 345c757e838d446fa4cadb4ffb226914 PHASE(phi_ent\u2083) 11fca3a827594846853ae1d025eb6d75--345c757e838d446fa4cadb4ffb226914 345c757e838d446fa4cadb4ffb226914--1d47b96a468d48f3ab79880f80323490 345c757e838d446fa4cadb4ffb226914--c00ecb99c4ac4f0ca19031d88088e67c <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\nansatz = hea(\nn_qubits,\ndepth=depth,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_29a01a5e1ec14d10a0500529e9571e8f cluster_0e5ef7873aab4016b46b2a356e26f46c bd0af01394604951b6637e2fe8a5d380 0 d58f516f4687439898e61b13cb4dd761 RX(theta\u2080) bd0af01394604951b6637e2fe8a5d380--d58f516f4687439898e61b13cb4dd761 6bc88b1808b24c4bb278b63d68bb88d6 1 7e9656e2af0a43588d3779e7fa9e8fe1 RY(theta\u2083) d58f516f4687439898e61b13cb4dd761--7e9656e2af0a43588d3779e7fa9e8fe1 24502f83fa474284ac4a7185d8213bf8 RX(theta\u2086) 7e9656e2af0a43588d3779e7fa9e8fe1--24502f83fa474284ac4a7185d8213bf8 62c3399bd30b430c8ca935be0d6aeaf0 HamEvo 24502f83fa474284ac4a7185d8213bf8--62c3399bd30b430c8ca935be0d6aeaf0 4f538a477e484e118839c00352b0dd5a RX(theta\u2089) 62c3399bd30b430c8ca935be0d6aeaf0--4f538a477e484e118839c00352b0dd5a 09b7a3b2a01343189a01681cad9570a2 RY(theta\u2081\u2082) 4f538a477e484e118839c00352b0dd5a--09b7a3b2a01343189a01681cad9570a2 db9940c1cc2844e492ea6cbc37f542df RX(theta\u2081\u2085) 09b7a3b2a01343189a01681cad9570a2--db9940c1cc2844e492ea6cbc37f542df 42f20c6d1f844306b436bc9d58b6e0f0 HamEvo db9940c1cc2844e492ea6cbc37f542df--42f20c6d1f844306b436bc9d58b6e0f0 7fd08a16c8b94aefad917dcbf4e6bcde 42f20c6d1f844306b436bc9d58b6e0f0--7fd08a16c8b94aefad917dcbf4e6bcde 2f78de97556041069d0c53ed8f0cb4b1 6d9b84b6e1c04173a888c4fdaf059bcc RX(theta\u2081) 6bc88b1808b24c4bb278b63d68bb88d6--6d9b84b6e1c04173a888c4fdaf059bcc 703d2de54d104743be8555ed887e1a29 2 53b7f4d65c0c4415808d36c3b64e5e0a RY(theta\u2084) 6d9b84b6e1c04173a888c4fdaf059bcc--53b7f4d65c0c4415808d36c3b64e5e0a ce8a4752935f4202a029599be8c97ad2 RX(theta\u2087) 53b7f4d65c0c4415808d36c3b64e5e0a--ce8a4752935f4202a029599be8c97ad2 05bd69703b1245ea96d6f433af15ba77 t = theta_t\u2080 ce8a4752935f4202a029599be8c97ad2--05bd69703b1245ea96d6f433af15ba77 7a0f149a25384565b555dd40f846a1ae RX(theta\u2081\u2080) 05bd69703b1245ea96d6f433af15ba77--7a0f149a25384565b555dd40f846a1ae c1cbe34442594ca79211bc267acd5427 RY(theta\u2081\u2083) 7a0f149a25384565b555dd40f846a1ae--c1cbe34442594ca79211bc267acd5427 9c3d75f13d6e4433a817d6003d10a2c2 RX(theta\u2081\u2086) c1cbe34442594ca79211bc267acd5427--9c3d75f13d6e4433a817d6003d10a2c2 612433d0cf3e41abb44b00689f215f01 t = theta_t\u2081 9c3d75f13d6e4433a817d6003d10a2c2--612433d0cf3e41abb44b00689f215f01 612433d0cf3e41abb44b00689f215f01--2f78de97556041069d0c53ed8f0cb4b1 607f23650f9845219bc6b4a594f892f8 373fc5af2d3b4caba5743d806bb4ab6a RX(theta\u2082) 703d2de54d104743be8555ed887e1a29--373fc5af2d3b4caba5743d806bb4ab6a 501176588f1d4f9584a4de99f9163221 RY(theta\u2085) 373fc5af2d3b4caba5743d806bb4ab6a--501176588f1d4f9584a4de99f9163221 00e783dff1a04635883c6777e7c1c0c6 RX(theta\u2088) 501176588f1d4f9584a4de99f9163221--00e783dff1a04635883c6777e7c1c0c6 c31fb9dc67834678b85bacad6ff844ec 00e783dff1a04635883c6777e7c1c0c6--c31fb9dc67834678b85bacad6ff844ec d9568b7d679d4bf08b69afabe29041f8 RX(theta\u2081\u2081) c31fb9dc67834678b85bacad6ff844ec--d9568b7d679d4bf08b69afabe29041f8 9cf5ecf8bf1940e7a1d1464e815ed457 RY(theta\u2081\u2084) d9568b7d679d4bf08b69afabe29041f8--9cf5ecf8bf1940e7a1d1464e815ed457 3ad8e84922f3408ebf3fcd9cb9c7fe31 RX(theta\u2081\u2087) 9cf5ecf8bf1940e7a1d1464e815ed457--3ad8e84922f3408ebf3fcd9cb9c7fe31 4a512fc56b654443873a1b2580497484 3ad8e84922f3408ebf3fcd9cb9c7fe31--4a512fc56b654443873a1b2580497484 4a512fc56b654443873a1b2580497484--607f23650f9845219bc6b4a594f892f8 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\nentangler = hamiltonian_factory(\nregister,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"e\",\ndetuning_strength=\"n\"\n)\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\nansatz = hea(\nn_qubits=register.n_qubits,\ndepth=depth,\noperations=[RX, RY, RX],\nentangler=entangler,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_154f61770c8a48e1aaf7a17abbe7c4f4 cluster_0e26af3d2b8540a6841a05260e6ff693 cd91906f091a48d78bf95645bc235763 0 0f8ba48680b1472cbe9a744590368ff1 RX(theta\u2080) cd91906f091a48d78bf95645bc235763--0f8ba48680b1472cbe9a744590368ff1 064161d69cda4af28e826d633076a0f0 1 8d1ce07c88bb411ca2ab34923f6cd156 RY(theta\u2086) 0f8ba48680b1472cbe9a744590368ff1--8d1ce07c88bb411ca2ab34923f6cd156 4ab07139f8bc428d9468cc4e04191429 RX(theta\u2081\u2082) 8d1ce07c88bb411ca2ab34923f6cd156--4ab07139f8bc428d9468cc4e04191429 a4f0168bc85e4e2997230561b2fc8554 4ab07139f8bc428d9468cc4e04191429--a4f0168bc85e4e2997230561b2fc8554 07c786389a404902abef44289f4ac02e RX(theta\u2081\u2088) a4f0168bc85e4e2997230561b2fc8554--07c786389a404902abef44289f4ac02e 6b5f1a43a5dc4ae488374131c1b58df7 RY(theta\u2082\u2084) 07c786389a404902abef44289f4ac02e--6b5f1a43a5dc4ae488374131c1b58df7 29ee591a6ad844fba5ae033d80e687fe RX(theta\u2083\u2080) 6b5f1a43a5dc4ae488374131c1b58df7--29ee591a6ad844fba5ae033d80e687fe 1b2f79211636495a8734db6046efaf0f 29ee591a6ad844fba5ae033d80e687fe--1b2f79211636495a8734db6046efaf0f 2fe734544feb4d0ebab3032ce5937b26 1b2f79211636495a8734db6046efaf0f--2fe734544feb4d0ebab3032ce5937b26 c68480d3bd7f4345b841fa9a5f1d0b6d 234edc6c48944458899ec52ed4e911ee RX(theta\u2081) 064161d69cda4af28e826d633076a0f0--234edc6c48944458899ec52ed4e911ee b3af3c62bb4c4f61b67a80b0c1276eca 2 bcaf6ffc55784b89b752c347c5ee181d RY(theta\u2087) 234edc6c48944458899ec52ed4e911ee--bcaf6ffc55784b89b752c347c5ee181d 0a12fca6d0ad41098c2067eefde9ba8b RX(theta\u2081\u2083) bcaf6ffc55784b89b752c347c5ee181d--0a12fca6d0ad41098c2067eefde9ba8b 3091d8fa06da41bca9d9b39df82dd05a 0a12fca6d0ad41098c2067eefde9ba8b--3091d8fa06da41bca9d9b39df82dd05a e8abc88b8dba41c498071aca9571579b RX(theta\u2081\u2089) 3091d8fa06da41bca9d9b39df82dd05a--e8abc88b8dba41c498071aca9571579b f38c83d9a1ad4af2b7a3e7ed69189665 RY(theta\u2082\u2085) e8abc88b8dba41c498071aca9571579b--f38c83d9a1ad4af2b7a3e7ed69189665 5b03f8fc29744a809a98c4f3f6c869c4 RX(theta\u2083\u2081) f38c83d9a1ad4af2b7a3e7ed69189665--5b03f8fc29744a809a98c4f3f6c869c4 f7aecbe40c63436f9642f07f9dcabd38 5b03f8fc29744a809a98c4f3f6c869c4--f7aecbe40c63436f9642f07f9dcabd38 f7aecbe40c63436f9642f07f9dcabd38--c68480d3bd7f4345b841fa9a5f1d0b6d 0e1dc6e1d6ed4294a11046cdabeb68d1 e4ea7a8ec5c84687ad6bdfce234729b2 RX(theta\u2082) b3af3c62bb4c4f61b67a80b0c1276eca--e4ea7a8ec5c84687ad6bdfce234729b2 c9632205b82541e885d68ef167a11833 3 a288f8262671486a875a8679546996b2 RY(theta\u2088) e4ea7a8ec5c84687ad6bdfce234729b2--a288f8262671486a875a8679546996b2 c188a9d437364edf9f3db930def52a0e RX(theta\u2081\u2084) a288f8262671486a875a8679546996b2--c188a9d437364edf9f3db930def52a0e 45194000535142549a4a01c507af7b90 HamEvo c188a9d437364edf9f3db930def52a0e--45194000535142549a4a01c507af7b90 e5a17055a06343eab8f3cfe28f0ca2ec RX(theta\u2082\u2080) 45194000535142549a4a01c507af7b90--e5a17055a06343eab8f3cfe28f0ca2ec 7bc856fb6bf64a2b8d4b8e281fce77ab RY(theta\u2082\u2086) e5a17055a06343eab8f3cfe28f0ca2ec--7bc856fb6bf64a2b8d4b8e281fce77ab 4ca4d00f6fc842b58ce0a9e830a55ca9 RX(theta\u2083\u2082) 7bc856fb6bf64a2b8d4b8e281fce77ab--4ca4d00f6fc842b58ce0a9e830a55ca9 72daa4e7a693402c92167cda3156a84a HamEvo 4ca4d00f6fc842b58ce0a9e830a55ca9--72daa4e7a693402c92167cda3156a84a 72daa4e7a693402c92167cda3156a84a--0e1dc6e1d6ed4294a11046cdabeb68d1 360a7c7a46884096b5ac14bb5a4a2cba 89c9662e7b8e492abc1f701101b8a95c RX(theta\u2083) c9632205b82541e885d68ef167a11833--89c9662e7b8e492abc1f701101b8a95c a935643fd4804b96bc9d13fd4f86ecea 4 ddf5e8d33f234bbc9c41ffdcc00c1e05 RY(theta\u2089) 89c9662e7b8e492abc1f701101b8a95c--ddf5e8d33f234bbc9c41ffdcc00c1e05 661c0bb015b543d4a27abee2c2147289 RX(theta\u2081\u2085) ddf5e8d33f234bbc9c41ffdcc00c1e05--661c0bb015b543d4a27abee2c2147289 e5d6efc2b40a4c1d9ad8af331648bc94 t = theta_t\u2080 661c0bb015b543d4a27abee2c2147289--e5d6efc2b40a4c1d9ad8af331648bc94 30d18e609efc452ebb521cde737400ff RX(theta\u2082\u2081) e5d6efc2b40a4c1d9ad8af331648bc94--30d18e609efc452ebb521cde737400ff c6154f26183943e89908f836c5392182 RY(theta\u2082\u2087) 30d18e609efc452ebb521cde737400ff--c6154f26183943e89908f836c5392182 c4cdec70094e443e905988577d77b48c RX(theta\u2083\u2083) c6154f26183943e89908f836c5392182--c4cdec70094e443e905988577d77b48c 2369eb372d3942da9fe068d60261e026 t = theta_t\u2081 c4cdec70094e443e905988577d77b48c--2369eb372d3942da9fe068d60261e026 2369eb372d3942da9fe068d60261e026--360a7c7a46884096b5ac14bb5a4a2cba 4a4f54c73eb54c2695d4af8df048692c 019f0e9fb5ba4f5c88c6fde53efd85bf RX(theta\u2084) a935643fd4804b96bc9d13fd4f86ecea--019f0e9fb5ba4f5c88c6fde53efd85bf 034706b3d5714e83909f9b6607a9cdcd 5 d2c12f7191ce48169c4b8b21c2e35eed RY(theta\u2081\u2080) 019f0e9fb5ba4f5c88c6fde53efd85bf--d2c12f7191ce48169c4b8b21c2e35eed 341fb6cc17f34da4a753c20880c9abf0 RX(theta\u2081\u2086) d2c12f7191ce48169c4b8b21c2e35eed--341fb6cc17f34da4a753c20880c9abf0 488a8cf7ed7e4f7196f829c652683a4b 341fb6cc17f34da4a753c20880c9abf0--488a8cf7ed7e4f7196f829c652683a4b da4fca7d85b64b0a8a850e0626b84fe2 RX(theta\u2082\u2082) 488a8cf7ed7e4f7196f829c652683a4b--da4fca7d85b64b0a8a850e0626b84fe2 168bcfc2b510480894c59fc2640b0108 RY(theta\u2082\u2088) da4fca7d85b64b0a8a850e0626b84fe2--168bcfc2b510480894c59fc2640b0108 f8cef4db72bf434885098810466747d4 RX(theta\u2083\u2084) 168bcfc2b510480894c59fc2640b0108--f8cef4db72bf434885098810466747d4 4360acf72fac4060a3ee09acfa16c780 f8cef4db72bf434885098810466747d4--4360acf72fac4060a3ee09acfa16c780 4360acf72fac4060a3ee09acfa16c780--4a4f54c73eb54c2695d4af8df048692c c2e4bc01a5c44c15bbd809f5bbf52637 94057662fc0f45bdb738a6a155438ed0 RX(theta\u2085) 034706b3d5714e83909f9b6607a9cdcd--94057662fc0f45bdb738a6a155438ed0 c79446687d3145fb9ccff9759d686655 RY(theta\u2081\u2081) 94057662fc0f45bdb738a6a155438ed0--c79446687d3145fb9ccff9759d686655 8c0aeb2eb422435b844c94d3c9662ade RX(theta\u2081\u2087) c79446687d3145fb9ccff9759d686655--8c0aeb2eb422435b844c94d3c9662ade b3305f0597ff4b0398754c93ba61bb9f 8c0aeb2eb422435b844c94d3c9662ade--b3305f0597ff4b0398754c93ba61bb9f 55760031fade46a7a49e0cc0e9d4eefa RX(theta\u2082\u2083) b3305f0597ff4b0398754c93ba61bb9f--55760031fade46a7a49e0cc0e9d4eefa 46fd9b9f3fd34b46bc4174d13b5c1a90 RY(theta\u2082\u2089) 55760031fade46a7a49e0cc0e9d4eefa--46fd9b9f3fd34b46bc4174d13b5c1a90 e45b6db1e090495b875dad462ebe6e9b RX(theta\u2083\u2085) 46fd9b9f3fd34b46bc4174d13b5c1a90--e45b6db1e090495b875dad462ebe6e9b f83f324ae5124067863e3bd95dbcdbe4 e45b6db1e090495b875dad462ebe6e9b--f83f324ae5124067863e3bd95dbcdbe4 f83f324ae5124067863e3bd95dbcdbe4--c2e4bc01a5c44c15bbd809f5bbf52637"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\nn_qubits = 3\ndepth = 2\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_68033c257ddd4a969a5d72af6f76dd86 BPMA-1 cluster_e52003727f5341b69220e9cf8204f61e BPMA-0 c8ff9caf07e2467d9b1291179973f2b8 0 b1055231daf7497db3a9fcddc5effa70 RX(alpha\u2080\u2080) c8ff9caf07e2467d9b1291179973f2b8--b1055231daf7497db3a9fcddc5effa70 f770d33252374b109a9b0674b851982f 1 e539e5e2b8874b179752a154ace8102b RY(alpha\u2080\u2083) b1055231daf7497db3a9fcddc5effa70--e539e5e2b8874b179752a154ace8102b 170fcc5acdf64204a5c2d1f21219d9cf e539e5e2b8874b179752a154ace8102b--170fcc5acdf64204a5c2d1f21219d9cf ae96d8daf53b43f69ea5ade98d8fe2e0 170fcc5acdf64204a5c2d1f21219d9cf--ae96d8daf53b43f69ea5ade98d8fe2e0 c631bf0509da490ca7304b91f0f40207 RX(gamma\u2080\u2080) ae96d8daf53b43f69ea5ade98d8fe2e0--c631bf0509da490ca7304b91f0f40207 f6a23da541bb4e5eb7fbaf7d92da9fd5 c631bf0509da490ca7304b91f0f40207--f6a23da541bb4e5eb7fbaf7d92da9fd5 4916b2c7969046ea80162c72afd99313 f6a23da541bb4e5eb7fbaf7d92da9fd5--4916b2c7969046ea80162c72afd99313 27942f4ecabe4e86ba1df1543577f3fa RY(beta\u2080\u2083) 4916b2c7969046ea80162c72afd99313--27942f4ecabe4e86ba1df1543577f3fa 7b5957dd99e9455f8db607bad5015012 RX(beta\u2080\u2080) 27942f4ecabe4e86ba1df1543577f3fa--7b5957dd99e9455f8db607bad5015012 2104705da9c644fd8d06831343300024 RX(alpha\u2081\u2080) 7b5957dd99e9455f8db607bad5015012--2104705da9c644fd8d06831343300024 55dddc02317944a3aa03539b4fb5ab1a RY(alpha\u2081\u2083) 2104705da9c644fd8d06831343300024--55dddc02317944a3aa03539b4fb5ab1a 862ec2f6aad542f19df2db8ea85d89e5 55dddc02317944a3aa03539b4fb5ab1a--862ec2f6aad542f19df2db8ea85d89e5 16743c3d5fcc422db1402bdc4585c1fb 862ec2f6aad542f19df2db8ea85d89e5--16743c3d5fcc422db1402bdc4585c1fb 0fd7d0ed2b104fe69f008fa929da0eb4 RX(gamma\u2081\u2080) 16743c3d5fcc422db1402bdc4585c1fb--0fd7d0ed2b104fe69f008fa929da0eb4 45212a95ef004015ad525a8bb3cb25a3 0fd7d0ed2b104fe69f008fa929da0eb4--45212a95ef004015ad525a8bb3cb25a3 0a05b64925764c91a931e91706e6ae7a 45212a95ef004015ad525a8bb3cb25a3--0a05b64925764c91a931e91706e6ae7a 20d5c94647714302b87cc717a202229d RY(beta\u2081\u2083) 0a05b64925764c91a931e91706e6ae7a--20d5c94647714302b87cc717a202229d 52f318b7894f48adaeb0359d7cc64b13 RX(beta\u2081\u2080) 20d5c94647714302b87cc717a202229d--52f318b7894f48adaeb0359d7cc64b13 959bf4b57b9a49e08b6075387dcda261 52f318b7894f48adaeb0359d7cc64b13--959bf4b57b9a49e08b6075387dcda261 d2691dc015f448beb1ca153abf5d3f87 b1d691273353483fa62635d440b002cf RX(alpha\u2080\u2081) f770d33252374b109a9b0674b851982f--b1d691273353483fa62635d440b002cf 228041b0b4a845fdaaa4771c2c8a1b6c 2 cf128507d3d0442cb968e56b55dd9a0b RY(alpha\u2080\u2084) b1d691273353483fa62635d440b002cf--cf128507d3d0442cb968e56b55dd9a0b a47c7183f651402a8293553f433f160e X cf128507d3d0442cb968e56b55dd9a0b--a47c7183f651402a8293553f433f160e a47c7183f651402a8293553f433f160e--170fcc5acdf64204a5c2d1f21219d9cf 700b7ee6e08845c2883242ccee8d88b8 a47c7183f651402a8293553f433f160e--700b7ee6e08845c2883242ccee8d88b8 c29be40d5163493ca1adf487c99b7b6f RX(gamma\u2080\u2081) 700b7ee6e08845c2883242ccee8d88b8--c29be40d5163493ca1adf487c99b7b6f 58004363282a47998bd6c04b6a047d83 c29be40d5163493ca1adf487c99b7b6f--58004363282a47998bd6c04b6a047d83 877e1fbd6ce343b1b32542c07c02463a X 58004363282a47998bd6c04b6a047d83--877e1fbd6ce343b1b32542c07c02463a 877e1fbd6ce343b1b32542c07c02463a--4916b2c7969046ea80162c72afd99313 758aed3334c2441f953c2c2437d07fe8 RY(beta\u2080\u2084) 877e1fbd6ce343b1b32542c07c02463a--758aed3334c2441f953c2c2437d07fe8 37a410bb3e174f5382ab10ea185017e8 RX(beta\u2080\u2081) 758aed3334c2441f953c2c2437d07fe8--37a410bb3e174f5382ab10ea185017e8 c3bab8c116044a3fa7f8820ecc9e6c8e RX(alpha\u2081\u2081) 37a410bb3e174f5382ab10ea185017e8--c3bab8c116044a3fa7f8820ecc9e6c8e 874b3aece2ab4a59ace69194bfe9a770 RY(alpha\u2081\u2084) c3bab8c116044a3fa7f8820ecc9e6c8e--874b3aece2ab4a59ace69194bfe9a770 0687f7f205a3487f8b669856f24dfe3f X 874b3aece2ab4a59ace69194bfe9a770--0687f7f205a3487f8b669856f24dfe3f 0687f7f205a3487f8b669856f24dfe3f--862ec2f6aad542f19df2db8ea85d89e5 d41f0c76ea684a02969744c63db73247 0687f7f205a3487f8b669856f24dfe3f--d41f0c76ea684a02969744c63db73247 3518fa81e5ea4ec7baf7cb8b2c0caacd RX(gamma\u2081\u2081) d41f0c76ea684a02969744c63db73247--3518fa81e5ea4ec7baf7cb8b2c0caacd 9c3b243ce1e64208981d441c6ae6ee13 3518fa81e5ea4ec7baf7cb8b2c0caacd--9c3b243ce1e64208981d441c6ae6ee13 a538034962214e028a29b2b62f623a46 X 9c3b243ce1e64208981d441c6ae6ee13--a538034962214e028a29b2b62f623a46 a538034962214e028a29b2b62f623a46--0a05b64925764c91a931e91706e6ae7a 900add26039a4dc19eaf64b77281d03f RY(beta\u2081\u2084) a538034962214e028a29b2b62f623a46--900add26039a4dc19eaf64b77281d03f 07f3c1178f834b1da5e80878a3f62efb RX(beta\u2081\u2081) 900add26039a4dc19eaf64b77281d03f--07f3c1178f834b1da5e80878a3f62efb 07f3c1178f834b1da5e80878a3f62efb--d2691dc015f448beb1ca153abf5d3f87 1074eff867ad4384be3a2417b10d7035 c99710d2ba3d4dbb861ee59eaef2ff10 RX(alpha\u2080\u2082) 228041b0b4a845fdaaa4771c2c8a1b6c--c99710d2ba3d4dbb861ee59eaef2ff10 51269b98c5b34f6e801c949f51fe904a RY(alpha\u2080\u2085) c99710d2ba3d4dbb861ee59eaef2ff10--51269b98c5b34f6e801c949f51fe904a 189b68bc68884a958a4a13b278e02647 51269b98c5b34f6e801c949f51fe904a--189b68bc68884a958a4a13b278e02647 6ae45bf5eedb43b9bca6193e97d98381 X 189b68bc68884a958a4a13b278e02647--6ae45bf5eedb43b9bca6193e97d98381 6ae45bf5eedb43b9bca6193e97d98381--700b7ee6e08845c2883242ccee8d88b8 08c46593e75d49a09da8dd2d6cdd8a14 RX(gamma\u2080\u2082) 6ae45bf5eedb43b9bca6193e97d98381--08c46593e75d49a09da8dd2d6cdd8a14 7c1725b036434f41a4646f6943dea682 X 08c46593e75d49a09da8dd2d6cdd8a14--7c1725b036434f41a4646f6943dea682 7c1725b036434f41a4646f6943dea682--58004363282a47998bd6c04b6a047d83 f1067b18cd984efbb1fde43a199b620f 7c1725b036434f41a4646f6943dea682--f1067b18cd984efbb1fde43a199b620f 00a2e5c5c8454141b032c32cc94b5cb2 RY(beta\u2080\u2085) f1067b18cd984efbb1fde43a199b620f--00a2e5c5c8454141b032c32cc94b5cb2 04e043a913924046b59333fb434a78fe RX(beta\u2080\u2082) 00a2e5c5c8454141b032c32cc94b5cb2--04e043a913924046b59333fb434a78fe 156937f63f784bb49d98f10e72f78585 RX(alpha\u2081\u2082) 04e043a913924046b59333fb434a78fe--156937f63f784bb49d98f10e72f78585 4344890d155946f095d87efb321a720c RY(alpha\u2081\u2085) 156937f63f784bb49d98f10e72f78585--4344890d155946f095d87efb321a720c fe8f8f812c4e42d39599ef2bfae6fdf9 4344890d155946f095d87efb321a720c--fe8f8f812c4e42d39599ef2bfae6fdf9 860e4c4cf4a64a1cad4e37f2a7c7a6a5 X fe8f8f812c4e42d39599ef2bfae6fdf9--860e4c4cf4a64a1cad4e37f2a7c7a6a5 860e4c4cf4a64a1cad4e37f2a7c7a6a5--d41f0c76ea684a02969744c63db73247 f2ee23807b1e49cc9f7a70e2ffff4d43 RX(gamma\u2081\u2082) 860e4c4cf4a64a1cad4e37f2a7c7a6a5--f2ee23807b1e49cc9f7a70e2ffff4d43 29b0244bc6f5466ca02d292a240e3d3b X f2ee23807b1e49cc9f7a70e2ffff4d43--29b0244bc6f5466ca02d292a240e3d3b 29b0244bc6f5466ca02d292a240e3d3b--9c3b243ce1e64208981d441c6ae6ee13 952c89df2f9e4956a6b9877282b2df89 29b0244bc6f5466ca02d292a240e3d3b--952c89df2f9e4956a6b9877282b2df89 607d92b6f7e84deb9928bd7662a6fa8a RY(beta\u2081\u2085) 952c89df2f9e4956a6b9877282b2df89--607d92b6f7e84deb9928bd7662a6fa8a cc6a3b376eda4384946df487f7073ac7 RX(beta\u2081\u2082) 607d92b6f7e84deb9928bd7662a6fa8a--cc6a3b376eda4384946df487f7073ac7 cc6a3b376eda4384946df487f7073ac7--1074eff867ad4384be3a2417b10d7035"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>This section introduces the various measurement protocols.</p>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>This section introduces mitigation protocols.</p>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'00': 50, '10': 50})]\nnoisy = [Counter({'00': 46, '10': 42, '01': 6, '11': 6})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[1.0026]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9704]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\nRX(0, 3 * x),\nRX(0, x),\nRZ(1, sympy.exp(y)),\nRX(0, 3.14),\nRZ(1, \"theta\")\n)\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\ncircuit = QuantumCircuit(2, block)\nobservable = Z(0)\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n# Compute expectation.\nexp = model.expectation(values)\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1,2)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n\u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 KronBlock(1,2)\n\u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': e01ef19f-f557-47f7-bb6c-47d11f0bbadc, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': a4ee8e6c-e74f-409b-8e84-5d73c1abf446, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 49552f26-1f16-4f01-9f5a-e7230d87d4d0, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 7ada3d66-45fe-450f-b517-d286142d0baa, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 0767d192-a5e9-4fd4-b7c0-e97b9ac4021c, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 5257b0c9-4036-4c62-a342-ae3ee3cff003, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 009a3b9a-c52b-4d7a-964c-ef65eca8ebbb, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 096df521-f5e2-4344-a7ca-2696f600389e, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': a14f5048-f86c-4e18-8c86-f1ca19e617e0, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 38bbb09e-85cb-482a-9723-d13636fdda13, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 0a76b0e0-8853-4047-b1aa-c41adaf159ae, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n# Contains fixed parameters and variational (from the HEA)\nconv.params\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\ntheta_7: tensor([0.9841], requires_grad=True)\ntheta_6: tensor([0.7025], requires_grad=True)\ntheta_8: tensor([0.8725], requires_grad=True)\ntheta_2: tensor([0.8550], requires_grad=True)\ntheta_5: tensor([0.1050], requires_grad=True)\ntheta_4: tensor([0.7986], requires_grad=True)\ntheta_3: tensor([0.9275], requires_grad=True)\ntheta_0: tensor([0.1505], requires_grad=True)\ntheta_1: tensor([0.0848], requires_grad=True)\n}\nembedded = {\ne01ef19f-f557-47f7-bb6c-47d11f0bbadc: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\na4ee8e6c-e74f-409b-8e84-5d73c1abf446: tensor([2., 2.])\n49552f26-1f16-4f01-9f5a-e7230d87d4d0: tensor([0.1505], grad_fn=&lt;ViewBackward0&gt;)\n7ada3d66-45fe-450f-b517-d286142d0baa: tensor([0.0848], grad_fn=&lt;ViewBackward0&gt;)\n0767d192-a5e9-4fd4-b7c0-e97b9ac4021c: tensor([0.8550], grad_fn=&lt;ViewBackward0&gt;)\n5257b0c9-4036-4c62-a342-ae3ee3cff003: tensor([0.9275], grad_fn=&lt;ViewBackward0&gt;)\n009a3b9a-c52b-4d7a-964c-ef65eca8ebbb: tensor([0.7986], grad_fn=&lt;ViewBackward0&gt;)\n096df521-f5e2-4344-a7ca-2696f600389e: tensor([0.1050], grad_fn=&lt;ViewBackward0&gt;)\na14f5048-f86c-4e18-8c86-f1ca19e617e0: tensor([0.7025], grad_fn=&lt;ViewBackward0&gt;)\n38bbb09e-85cb-482a-9723-d13636fdda13: tensor([0.9841], grad_fn=&lt;ViewBackward0&gt;)\n0a76b0e0-8853-4047-b1aa-c41adaf159ae: tensor([0.8725], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\ntheta_7: tensor([0.9841], grad_fn=&lt;ViewBackward0&gt;)\n3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\ntheta_8: tensor([0.8725], grad_fn=&lt;ViewBackward0&gt;)\ntheta_6: tensor([0.7025], grad_fn=&lt;ViewBackward0&gt;)\ny: tensor([2., 2.])\ntheta_2: tensor([0.8550], grad_fn=&lt;ViewBackward0&gt;)\ntheta_5: tensor([0.1050], grad_fn=&lt;ViewBackward0&gt;)\ntheta_4: tensor([0.7986], grad_fn=&lt;ViewBackward0&gt;)\ntheta_3: tensor([0.9275], grad_fn=&lt;ViewBackward0&gt;)\ntheta_0: tensor([0.1505], grad_fn=&lt;ViewBackward0&gt;)\ntheta_1: tensor([0.0848], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.1347-0.2025j, -0.2260-0.1742j,  0.3257+0.0072j,  0.0132+0.2774j,\n-0.2720-0.3532j, -0.4356+0.2895j,  0.3382+0.0606j, -0.0314+0.2912j],\n[ 0.1347-0.2025j, -0.2260-0.1742j,  0.3257+0.0072j,  0.0132+0.2774j,\n-0.2720-0.3532j, -0.4356+0.2895j,  0.3382+0.0606j, -0.0314+0.2912j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'001': 194, '000': 157, '110': 121, '010': 121, '101': 113, '011': 102, '100': 100, '111': 92})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nq0 : -Rx(e01ef19f-f557-47f7-bb6c-47d11f0bbadc)-C----------------------------------------Rx(49552f26-1f16-4f01-9f5a-e7230d87d4d0)-Ry(5257b0c9-4036-4c62-a342-ae3ee3cff003)-Rx(a14f5048-f86c-4e18-8c86-f1ca19e617e0)-C---\n|                                                                                                                                                                   |   q1 : -Rz(a4ee8e6c-e74f-409b-8e84-5d73c1abf446)-X----------------------------------------Rx(7ada3d66-45fe-450f-b517-d286142d0baa)-Ry(009a3b9a-c52b-4d7a-964c-ef65eca8ebbb)-Rx(38bbb09e-85cb-482a-9723-d13636fdda13)-X-C-\n| q2 : -Rx(0767d192-a5e9-4fd4-b7c0-e97b9ac4021c)-Ry(096df521-f5e2-4344-a7ca-2696f600389e)-Rx(0a76b0e0-8853-4047-b1aa-c41adaf159ae)-------------------------------------------------------------------------------------X-\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nUnassigned parameters: [009a3b9a-c52b-4d7a-964c-ef65eca8ebbb, 0767d192-a5e9-4fd4-b7c0-e97b9ac4021c, 096df521-f5e2-4344-a7ca-2696f600389e, 0a76b0e0-8853-4047-b1aa-c41adaf159ae, 38bbb09e-85cb-482a-9723-d13636fdda13, 49552f26-1f16-4f01-9f5a-e7230d87d4d0, 5257b0c9-4036-4c62-a342-ae3ee3cff003, 7ada3d66-45fe-450f-b517-d286142d0baa, a14f5048-f86c-4e18-8c86-f1ca19e617e0, a4ee8e6c-e74f-409b-8e84-5d73c1abf446, e01ef19f-f557-47f7-bb6c-47d11f0bbadc].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\nq0 : -Rx(0.55)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.15)-DEPO(0.1)-Ry(0.93)-DEPO(0.1)-Rx(0.70)-DEPO(0.1)-C-DEPO(0.1)-------------\n|                                                                           |                       q1 : -Rz(0.03)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.08)-DEPO(0.1)-Ry(0.80)-DEPO(0.1)-Rx(0.98)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n|           q2 : -Rx(0.85)-DEPO(0.1)-Ry(0.10)-DEPO(0.1)-Rx(0.87)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 bbbaf10295a542f6bc4cb7d8120fb6b8 0 2017aae9049c47f0bb50fc538e87f6ff X bbbaf10295a542f6bc4cb7d8120fb6b8--2017aae9049c47f0bb50fc538e87f6ff 42f05504a4e94c30a2d5b0ef23e364ab 1 61014342fa6e4c788ca18f553d1c3527 2017aae9049c47f0bb50fc538e87f6ff--61014342fa6e4c788ca18f553d1c3527 f801b0e285fe48e284896759dcbfca6a 218557e1682d4ab0ad279a0bdf6eb7bc Y 42f05504a4e94c30a2d5b0ef23e364ab--218557e1682d4ab0ad279a0bdf6eb7bc 218557e1682d4ab0ad279a0bdf6eb7bc--f801b0e285fe48e284896759dcbfca6a </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 af6d4544ced94d709558ca64165def11 0 79dc509820564454af4b7b25a161ccdb RX(0.5) af6d4544ced94d709558ca64165def11--79dc509820564454af4b7b25a161ccdb 6109b0d6aaab412aa8d243b0d900a002 79dc509820564454af4b7b25a161ccdb--6109b0d6aaab412aa8d243b0d900a002 <pre><code>from qadence import CNOT\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 ac0d2ffd19e54b6fbce39b7f040c910b 0 073e90eaa16e45d0aa6f5fa3d5d1e05e ac0d2ffd19e54b6fbce39b7f040c910b--073e90eaa16e45d0aa6f5fa3d5d1e05e 05a8f662671b4c7982492f24b2741b08 1 a058a12510944d6f8b55ea141cd8a976 073e90eaa16e45d0aa6f5fa3d5d1e05e--a058a12510944d6f8b55ea141cd8a976 1c028c27293b41588c5d01d8c09d2d68 671bb9e5385e469c8da4a67026c74a6f X 05a8f662671b4c7982492f24b2741b08--671bb9e5385e469c8da4a67026c74a6f 671bb9e5385e469c8da4a67026c74a6f--073e90eaa16e45d0aa6f5fa3d5d1e05e 671bb9e5385e469c8da4a67026c74a6f--1c028c27293b41588c5d01d8c09d2d68 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 b20c18f4b1834702922e19f7a9f06002 0 47e5af7c463f47d9b28b70fabde98199 X b20c18f4b1834702922e19f7a9f06002--47e5af7c463f47d9b28b70fabde98199 4d44be3b87a9450ca672f9687ce72480 X 47e5af7c463f47d9b28b70fabde98199--4d44be3b87a9450ca672f9687ce72480 db1c1c20020f47a7b38972fe2104474b 4d44be3b87a9450ca672f9687ce72480--db1c1c20020f47a7b38972fe2104474b <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 676fc009a721497c8309721006293b0a 0 5ab1524f78564f6dbd6ea349bfe1ee6c X 676fc009a721497c8309721006293b0a--5ab1524f78564f6dbd6ea349bfe1ee6c e4d3339346784c158c1b554685c3195b 1 73de1be255834f54958c9be9948d6d9a 5ab1524f78564f6dbd6ea349bfe1ee6c--73de1be255834f54958c9be9948d6d9a b6a78ebe8ead43a1b05647c2d7a703be 73de1be255834f54958c9be9948d6d9a--b6a78ebe8ead43a1b05647c2d7a703be c0bd9926378f4b58ba5aeac1b4bd17e3 bc7bfc61fa8a41c597667314c1af4844 e4d3339346784c158c1b554685c3195b--bc7bfc61fa8a41c597667314c1af4844 f7641a41f5ab4fd5a4855f0ef52c8944 X bc7bfc61fa8a41c597667314c1af4844--f7641a41f5ab4fd5a4855f0ef52c8944 f7641a41f5ab4fd5a4855f0ef52c8944--c0bd9926378f4b58ba5aeac1b4bd17e3 </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 255822f46b3345eb8388b9c063d1561f 0 8d555a8bbf674da493f3ab321b775312 X 255822f46b3345eb8388b9c063d1561f--8d555a8bbf674da493f3ab321b775312 25cd7767dfd243af9a86d40551b466e3 1 a6baa04146094ede87763845cd799bbd 8d555a8bbf674da493f3ab321b775312--a6baa04146094ede87763845cd799bbd a0b9954446be45c7a5a0c0115dc4fd78 c1762deb402b4db58ecfb049e45a89f6 X 25cd7767dfd243af9a86d40551b466e3--c1762deb402b4db58ecfb049e45a89f6 c1762deb402b4db58ecfb049e45a89f6--a0b9954446be45c7a5a0c0115dc4fd78 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n[ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_d0ca4f4dacb24ba2b01043e216a13f82 subblock cluster_812d2fc29ee64fd4b72c47ef15cc0475 subblock d21c33bdc1df4c3f930a1986fabc60cf 0 6c220884b79d4a2c93baf93ca0a5a634 X d21c33bdc1df4c3f930a1986fabc60cf--6c220884b79d4a2c93baf93ca0a5a634 f1990727edfe4207a063b4e3795e1b1c 1 30076970d47449819f2717156f26708e X 6c220884b79d4a2c93baf93ca0a5a634--30076970d47449819f2717156f26708e 69da517133fd41e1bf41206c9bca58d3 30076970d47449819f2717156f26708e--69da517133fd41e1bf41206c9bca58d3 ed262f98b4ae4479abfdaa4005971da3 11714677c79f4d438a067bd152657f69 Y f1990727edfe4207a063b4e3795e1b1c--11714677c79f4d438a067bd152657f69 c9dd3c6bb7394a82926c57356f8b53a1 2 c606da8e91d74426ac1ae9824fae2d6d Y 11714677c79f4d438a067bd152657f69--c606da8e91d74426ac1ae9824fae2d6d c606da8e91d74426ac1ae9824fae2d6d--ed262f98b4ae4479abfdaa4005971da3 96c5336b705e4e54b57287f6e5778e2c be19ccde8e9b477d91f634f64dda1e6a c9dd3c6bb7394a82926c57356f8b53a1--be19ccde8e9b477d91f634f64dda1e6a f946763842234ce5bd49c33e35b7db06 3 3ed00239452847bf936def72bac8ab74 be19ccde8e9b477d91f634f64dda1e6a--3ed00239452847bf936def72bac8ab74 3ed00239452847bf936def72bac8ab74--96c5336b705e4e54b57287f6e5778e2c 86f740061ccb42b2bcb00154ebd9ef54 fb8046be05cf488c9af610f7bc1a656f f946763842234ce5bd49c33e35b7db06--fb8046be05cf488c9af610f7bc1a656f a66002772f2c40efaf0450659c1b884f 4 40e25bc884644059b49eeed1d22d2193 fb8046be05cf488c9af610f7bc1a656f--40e25bc884644059b49eeed1d22d2193 40e25bc884644059b49eeed1d22d2193--86f740061ccb42b2bcb00154ebd9ef54 6ad54d9561224a90bd50d2b6035966fa 2e937b5aeb40426daaca171135d8e0e5 X a66002772f2c40efaf0450659c1b884f--2e937b5aeb40426daaca171135d8e0e5 2e937b5aeb40426daaca171135d8e0e5--fb8046be05cf488c9af610f7bc1a656f d36e8382e75544f3b07e123109e9d3fb X 2e937b5aeb40426daaca171135d8e0e5--d36e8382e75544f3b07e123109e9d3fb d36e8382e75544f3b07e123109e9d3fb--40e25bc884644059b49eeed1d22d2193 d36e8382e75544f3b07e123109e9d3fb--6ad54d9561224a90bd50d2b6035966fa"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\nn_qubits = 2\nblock = chain(H(0), H(1))\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'11': 257, '10': 254, '00': 251, '01': 238})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'110': 30, '100': 28, '010': 22, '000': 20})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\nn_qubits = 3\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\nhamilt = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=[0.5, 0.2, 0.1],\ndetuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\nzz_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=zz_terms,\ndetuning_strength=z_terms\n)\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(1)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(2)\n\u2514\u2500\u2500 [mul: -1.00000000000000] \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\nreg = Register.square(qubits_side=2)\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Custom Hamiltonian coefficients can also be added to the register beforehand using the <code>\"strength\"</code> key.</p> <pre><code>reg = Register.square(qubits_side = 2)\nfor i, edge in enumerate(reg.edges):\nreg.edges[edge][\"strength\"] = (0.5 * i) ** 2\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.0] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.250] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 2.250] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Alternatively, if the register already stores interaction or detuning strengths, it is possible to override them in the Hamiltonian creation by using <code>force_update = True</code>.</p>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments:</p> <pre><code>n_qubits = 3\nnn_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"c\",\ndetuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(1)\n\u2514\u2500\u2500 N(2)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\ntensor([[2.5000e-01, 1.8747e-33],\n[1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\ntensor([[ 2.5000e-01, -3.3307e-16],\n[-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\ntensor([[ 0.2624, -0.0138],\n[ 0.0116,  0.0006]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9974+0.0000j, 0.0000-0.0725j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\nblock = RX(0, FeatureParameter(\"phi\"))\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n[0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8777+0.0000j, 0.0000-0.4793j],\n[0.9664+0.0000j, 0.0000-0.2571j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\nblock = chain(\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.8728+0.0000j, 0.2312+0.0000j, 0.0000-0.4155j, 0.0000-0.1101j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\nblock = chain(\nkron(\nRX(0, phi/theta),\nRY(1, theta*2),\nRZ(2, sympy.cos(phi)),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi + theta),\nRY(1, theta**2),\nRZ(2, sympy.cos(phi)),\n),\nchain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_99bbdfa7b6a146228d2d5a7dd28c3d65 [* 2] cluster_08aac9d9f7734c778efb1b098786d7fe Rotations 775f3e3cb3bc4151a95fe36f6c10b74d 0 7d0a4955cbbe46438a8ddb51e2ca75c8 RX(phi/theta) 775f3e3cb3bc4151a95fe36f6c10b74d--7d0a4955cbbe46438a8ddb51e2ca75c8 50ebd86fd4b94f37ba71b555d76aa1b7 1 5621c91a94984267a5e25e4b5e04e4d6 RX(phi) 7d0a4955cbbe46438a8ddb51e2ca75c8--5621c91a94984267a5e25e4b5e04e4d6 ecb9576f39ab4b2f9ffb6342018f3361 RX(phi) 5621c91a94984267a5e25e4b5e04e4d6--ecb9576f39ab4b2f9ffb6342018f3361 a3da8d012f7c4bd2883b224abb9a7808 RX(phi + theta) ecb9576f39ab4b2f9ffb6342018f3361--a3da8d012f7c4bd2883b224abb9a7808 278e4dfbcd4e486fb3f633a848c8f076 a3da8d012f7c4bd2883b224abb9a7808--278e4dfbcd4e486fb3f633a848c8f076 5560dcffa3ec4b60882a9bf3a248f80d 278e4dfbcd4e486fb3f633a848c8f076--5560dcffa3ec4b60882a9bf3a248f80d 3f06a0a731ee44bd99ed9eaea812ea83 Z 5560dcffa3ec4b60882a9bf3a248f80d--3f06a0a731ee44bd99ed9eaea812ea83 eaf61dbb766643bbb17da5a164ed7010 3f06a0a731ee44bd99ed9eaea812ea83--eaf61dbb766643bbb17da5a164ed7010 379567128ba442a187f4649479e9a255 3275d7531364417e97bf125a85ebe205 RY(2*theta) 50ebd86fd4b94f37ba71b555d76aa1b7--3275d7531364417e97bf125a85ebe205 9aa38b04278347fca375d7ed926851de 2 9dcf68f7e9a347959ebd89ab4310fdf5 RY(theta) 3275d7531364417e97bf125a85ebe205--9dcf68f7e9a347959ebd89ab4310fdf5 08f4ecc00d5349f7bab4b30f55be4717 RY(theta) 9dcf68f7e9a347959ebd89ab4310fdf5--08f4ecc00d5349f7bab4b30f55be4717 b1d946175bce49fcbd753bf83e5eb0b1 RY(theta**2) 08f4ecc00d5349f7bab4b30f55be4717--b1d946175bce49fcbd753bf83e5eb0b1 6c1a39c53e324c8d8594e5fbdced49b3 X b1d946175bce49fcbd753bf83e5eb0b1--6c1a39c53e324c8d8594e5fbdced49b3 6c1a39c53e324c8d8594e5fbdced49b3--278e4dfbcd4e486fb3f633a848c8f076 445fbc5991df43b8b2c6a6539d43ffbe 6c1a39c53e324c8d8594e5fbdced49b3--445fbc5991df43b8b2c6a6539d43ffbe a9e314c4b7d64d828572e11b9b1161fa Z 445fbc5991df43b8b2c6a6539d43ffbe--a9e314c4b7d64d828572e11b9b1161fa a9e314c4b7d64d828572e11b9b1161fa--379567128ba442a187f4649479e9a255 4f26bc79be524574861b60e2c6bf77c7 53a29cf9c59b49328b210ad1af3ab0b9 RZ(cos(phi)) 9aa38b04278347fca375d7ed926851de--53a29cf9c59b49328b210ad1af3ab0b9 5133477aba35435f92608adf10b6cd23 RZ(phi) 53a29cf9c59b49328b210ad1af3ab0b9--5133477aba35435f92608adf10b6cd23 d841c4fb957a4fd38f8a8b5db900c72a RZ(phi) 5133477aba35435f92608adf10b6cd23--d841c4fb957a4fd38f8a8b5db900c72a ae71c376989f4fe9b356d46cfd1f59ad RZ(cos(phi)) d841c4fb957a4fd38f8a8b5db900c72a--ae71c376989f4fe9b356d46cfd1f59ad 0d3104be8e88466e8295073bd7ec611f ae71c376989f4fe9b356d46cfd1f59ad--0d3104be8e88466e8295073bd7ec611f 3bd8f954fa3144d9bdb53c9298c1b056 X 0d3104be8e88466e8295073bd7ec611f--3bd8f954fa3144d9bdb53c9298c1b056 3bd8f954fa3144d9bdb53c9298c1b056--445fbc5991df43b8b2c6a6539d43ffbe 1abb6bb303fc4c42a5b8f3467fdffdda Z 3bd8f954fa3144d9bdb53c9298c1b056--1abb6bb303fc4c42a5b8f3467fdffdda 1abb6bb303fc4c42a5b8f3467fdffdda--4f26bc79be524574861b60e2c6bf77c7 <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\nblock = chain(\nkron(RX(0, theta), RY(1, theta)),\nkron(RX(0, phi), RY(1, phi)),\n)\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.4176]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.7455+0.0000j, 0.4356+0.0000j, 0.0000-0.4356j, 0.0000-0.2545j],\n[0.6912+0.0000j, 0.4620+0.0000j, 0.0000-0.4620j, 0.0000-0.3088j],\n[0.9451+0.0000j, 0.2277+0.0000j, 0.0000-0.2277j, 0.0000-0.0549j]],\ngrad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\nn_qubits = 4\ndepth = 2\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 d214759bab6c4de191ed16126111cc10 0 56813477e0204b61a16d4f113930795c RX(theta\u2080) d214759bab6c4de191ed16126111cc10--56813477e0204b61a16d4f113930795c fca2166b9b2b4a2fb67b4b41e0a1e264 1 05a3403987f14b1593363f676f496e13 RY(theta\u2084) 56813477e0204b61a16d4f113930795c--05a3403987f14b1593363f676f496e13 3745ac9025b84f21be8c6077c106ad70 RX(theta\u2088) 05a3403987f14b1593363f676f496e13--3745ac9025b84f21be8c6077c106ad70 df7c88c1a4994a218819b3f9753db1df 3745ac9025b84f21be8c6077c106ad70--df7c88c1a4994a218819b3f9753db1df 769a4143e9454bd9a75af557d0bc65be df7c88c1a4994a218819b3f9753db1df--769a4143e9454bd9a75af557d0bc65be a8a033f779c14daeb58a210760eaa3c6 RX(theta\u2081\u2082) 769a4143e9454bd9a75af557d0bc65be--a8a033f779c14daeb58a210760eaa3c6 6addc22bd6a943c3a1b51a09419734fb RY(theta\u2081\u2086) a8a033f779c14daeb58a210760eaa3c6--6addc22bd6a943c3a1b51a09419734fb 0b755ea06713475f92c70afb86ee2417 RX(theta\u2082\u2080) 6addc22bd6a943c3a1b51a09419734fb--0b755ea06713475f92c70afb86ee2417 8ebdbcf9e684455ca661020e7f41662d 0b755ea06713475f92c70afb86ee2417--8ebdbcf9e684455ca661020e7f41662d 276ea01e42b548ba80a7f6994323f320 8ebdbcf9e684455ca661020e7f41662d--276ea01e42b548ba80a7f6994323f320 21f339b41a754a9e97db063a025924f5 276ea01e42b548ba80a7f6994323f320--21f339b41a754a9e97db063a025924f5 0ca7a05c073b422384e62703005dbe27 3fd6940527064e7cbe63e97a7ac3f75c RX(theta\u2081) fca2166b9b2b4a2fb67b4b41e0a1e264--3fd6940527064e7cbe63e97a7ac3f75c 6a68a637bfb94637805a3fd3d4c6bce0 2 846947f4937741e7848773733f65b92e RY(theta\u2085) 3fd6940527064e7cbe63e97a7ac3f75c--846947f4937741e7848773733f65b92e f2192acc4c7446949dd432415d41b34e RX(theta\u2089) 846947f4937741e7848773733f65b92e--f2192acc4c7446949dd432415d41b34e e10e7ec4618643468015f36ef3e09967 X f2192acc4c7446949dd432415d41b34e--e10e7ec4618643468015f36ef3e09967 e10e7ec4618643468015f36ef3e09967--df7c88c1a4994a218819b3f9753db1df 8e948f73a7a3483b8a710b5372237ae5 e10e7ec4618643468015f36ef3e09967--8e948f73a7a3483b8a710b5372237ae5 620e563208614b46bfea7249ab9106d2 RX(theta\u2081\u2083) 8e948f73a7a3483b8a710b5372237ae5--620e563208614b46bfea7249ab9106d2 c08e6c5a48ea40138c42055a73681349 RY(theta\u2081\u2087) 620e563208614b46bfea7249ab9106d2--c08e6c5a48ea40138c42055a73681349 464580efd2a64b0a80527b18f7945637 RX(theta\u2082\u2081) c08e6c5a48ea40138c42055a73681349--464580efd2a64b0a80527b18f7945637 438ce34327af458195c46868f83ae420 X 464580efd2a64b0a80527b18f7945637--438ce34327af458195c46868f83ae420 438ce34327af458195c46868f83ae420--8ebdbcf9e684455ca661020e7f41662d 00e48ab7b5094019b9c8a6d563a8b0b8 438ce34327af458195c46868f83ae420--00e48ab7b5094019b9c8a6d563a8b0b8 00e48ab7b5094019b9c8a6d563a8b0b8--0ca7a05c073b422384e62703005dbe27 465cee3f5ba5432695427ddc15795bde c14ed8449d924363881997b00f30ea1b RX(theta\u2082) 6a68a637bfb94637805a3fd3d4c6bce0--c14ed8449d924363881997b00f30ea1b 12c5021210f04ed49dc0b7b628df99b2 3 75d52281a09e40b984d1721a30ff1faf RY(theta\u2086) c14ed8449d924363881997b00f30ea1b--75d52281a09e40b984d1721a30ff1faf e01fa4b3ceff4de293b0a8c575ad02ff RX(theta\u2081\u2080) 75d52281a09e40b984d1721a30ff1faf--e01fa4b3ceff4de293b0a8c575ad02ff d487b74b08934d659dfc76e639e247b4 e01fa4b3ceff4de293b0a8c575ad02ff--d487b74b08934d659dfc76e639e247b4 08d62011052945078f17b7e27696d1fd X d487b74b08934d659dfc76e639e247b4--08d62011052945078f17b7e27696d1fd 08d62011052945078f17b7e27696d1fd--8e948f73a7a3483b8a710b5372237ae5 b380c797700548d488608265baa93c60 RX(theta\u2081\u2084) 08d62011052945078f17b7e27696d1fd--b380c797700548d488608265baa93c60 82e8431b07514fba98a0193807b8e047 RY(theta\u2081\u2088) b380c797700548d488608265baa93c60--82e8431b07514fba98a0193807b8e047 fc052f1802f142d1a3e6b6bae5b9d88d RX(theta\u2082\u2082) 82e8431b07514fba98a0193807b8e047--fc052f1802f142d1a3e6b6bae5b9d88d ad1a4efefaf748ef97b078af9b05e313 fc052f1802f142d1a3e6b6bae5b9d88d--ad1a4efefaf748ef97b078af9b05e313 fa57eafea484493cb46e45a3dd25a89f X ad1a4efefaf748ef97b078af9b05e313--fa57eafea484493cb46e45a3dd25a89f fa57eafea484493cb46e45a3dd25a89f--00e48ab7b5094019b9c8a6d563a8b0b8 fa57eafea484493cb46e45a3dd25a89f--465cee3f5ba5432695427ddc15795bde f00cbead27fd4adcb74f916a91161141 e3405c6e1b994141b376d85c13bb8c99 RX(theta\u2083) 12c5021210f04ed49dc0b7b628df99b2--e3405c6e1b994141b376d85c13bb8c99 d7d50baadead47acbd00ba1f2abcd5d0 RY(theta\u2087) e3405c6e1b994141b376d85c13bb8c99--d7d50baadead47acbd00ba1f2abcd5d0 ed907c6acc044b97a9fe9c2c82b50451 RX(theta\u2081\u2081) d7d50baadead47acbd00ba1f2abcd5d0--ed907c6acc044b97a9fe9c2c82b50451 b1fae8ce89f7462587c605ceb42ff64d X ed907c6acc044b97a9fe9c2c82b50451--b1fae8ce89f7462587c605ceb42ff64d b1fae8ce89f7462587c605ceb42ff64d--d487b74b08934d659dfc76e639e247b4 d9e380874add4a88887e84a298a606aa b1fae8ce89f7462587c605ceb42ff64d--d9e380874add4a88887e84a298a606aa a86bac58be7a4fafbcc91b78e99ef64a RX(theta\u2081\u2085) d9e380874add4a88887e84a298a606aa--a86bac58be7a4fafbcc91b78e99ef64a 4439767d12b44f2182b92878667ed06a RY(theta\u2081\u2089) a86bac58be7a4fafbcc91b78e99ef64a--4439767d12b44f2182b92878667ed06a 0df8d6b80cc241e8a70d2476687fea9e RX(theta\u2082\u2083) 4439767d12b44f2182b92878667ed06a--0df8d6b80cc241e8a70d2476687fea9e c7b2daad9a5f4c1e8b973d2d66c20c4a X 0df8d6b80cc241e8a70d2476687fea9e--c7b2daad9a5f4c1e8b973d2d66c20c4a c7b2daad9a5f4c1e8b973d2d66c20c4a--ad1a4efefaf748ef97b078af9b05e313 77c50898f46342e7afcda17f32f9fbe5 c7b2daad9a5f4c1e8b973d2d66c20c4a--77c50898f46342e7afcda17f32f9fbe5 77c50898f46342e7afcda17f32f9fbe5--f00cbead27fd4adcb74f916a91161141 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_845259bda6064ff48d6804e7e8f18c75 HEA cluster_3123b6b4121546b8b8561e16425d9805 HEA 04f1bbc1743d4adebab227a7df0c5c50 0 29055866c3d04a4da09d25104ba059ed RX(theta\u2080) 04f1bbc1743d4adebab227a7df0c5c50--29055866c3d04a4da09d25104ba059ed e45218487e544cba92c511104acb49aa 1 2e42c33844e243b2b7d4fa870d71a795 RY(theta\u2084) 29055866c3d04a4da09d25104ba059ed--2e42c33844e243b2b7d4fa870d71a795 6ff65be4386c40dfbc414584e86bf59d RX(theta\u2088) 2e42c33844e243b2b7d4fa870d71a795--6ff65be4386c40dfbc414584e86bf59d 43e919f291e043afbb0d0680eac1176a 6ff65be4386c40dfbc414584e86bf59d--43e919f291e043afbb0d0680eac1176a c30ded9a91694b918e3212285038c9e7 43e919f291e043afbb0d0680eac1176a--c30ded9a91694b918e3212285038c9e7 7d660caceb6946ec9924ba8961638c99 RX(theta\u2081\u2082) c30ded9a91694b918e3212285038c9e7--7d660caceb6946ec9924ba8961638c99 4d6cce01699f49d6b963ae260d4eab69 RY(theta\u2081\u2086) 7d660caceb6946ec9924ba8961638c99--4d6cce01699f49d6b963ae260d4eab69 3fce4d5b14554245b2a724eab9c9e257 RX(theta\u2082\u2080) 4d6cce01699f49d6b963ae260d4eab69--3fce4d5b14554245b2a724eab9c9e257 3dea7ac1b6ac418fa7b2f6258adddf4d 3fce4d5b14554245b2a724eab9c9e257--3dea7ac1b6ac418fa7b2f6258adddf4d c3cf4d178d424a11a1b764af7fd48c29 3dea7ac1b6ac418fa7b2f6258adddf4d--c3cf4d178d424a11a1b764af7fd48c29 73000cac9ef14f2ebcb74cbb0dee2500 RX(theta\u2080) c3cf4d178d424a11a1b764af7fd48c29--73000cac9ef14f2ebcb74cbb0dee2500 79ab8f3dfe6f434eab39721c41f42bf6 RY(theta\u2084) 73000cac9ef14f2ebcb74cbb0dee2500--79ab8f3dfe6f434eab39721c41f42bf6 eb05cc87ac5d40a0b8f33f099b43b43c RX(theta\u2088) 79ab8f3dfe6f434eab39721c41f42bf6--eb05cc87ac5d40a0b8f33f099b43b43c c52a200dcbf74449addcc97811ece2d5 eb05cc87ac5d40a0b8f33f099b43b43c--c52a200dcbf74449addcc97811ece2d5 0edad8865d6c43d7ab40a8f0149deae0 c52a200dcbf74449addcc97811ece2d5--0edad8865d6c43d7ab40a8f0149deae0 5a38a03164e34d8db2763e8e830efcfa RX(theta\u2081\u2082) 0edad8865d6c43d7ab40a8f0149deae0--5a38a03164e34d8db2763e8e830efcfa 1c253c6d5bb1400d8bff4a2cde4bc770 RY(theta\u2081\u2086) 5a38a03164e34d8db2763e8e830efcfa--1c253c6d5bb1400d8bff4a2cde4bc770 c50add91e8944f72a614ef486f111e23 RX(theta\u2082\u2080) 1c253c6d5bb1400d8bff4a2cde4bc770--c50add91e8944f72a614ef486f111e23 2282b5fe147f4c2180faf6c23edaeb9d c50add91e8944f72a614ef486f111e23--2282b5fe147f4c2180faf6c23edaeb9d 7fe65c55b0494a11bf72e2f85fe18dac 2282b5fe147f4c2180faf6c23edaeb9d--7fe65c55b0494a11bf72e2f85fe18dac 9d29bd88aabe42bea888496191ba2268 7fe65c55b0494a11bf72e2f85fe18dac--9d29bd88aabe42bea888496191ba2268 3f151acbdb1846cd89e933d8876ebf34 dc294e4c5d7346eab3b530bfc8672a52 RX(theta\u2081) e45218487e544cba92c511104acb49aa--dc294e4c5d7346eab3b530bfc8672a52 e36366ba610647b7b3f1553a28f3eb09 2 5434ab37eeba45138dabfdc848eceb27 RY(theta\u2085) dc294e4c5d7346eab3b530bfc8672a52--5434ab37eeba45138dabfdc848eceb27 960d9e995a53499a8a7b5d2f993c4de6 RX(theta\u2089) 5434ab37eeba45138dabfdc848eceb27--960d9e995a53499a8a7b5d2f993c4de6 b2fc8b26d6ac414da537c0d5e7b02869 X 960d9e995a53499a8a7b5d2f993c4de6--b2fc8b26d6ac414da537c0d5e7b02869 b2fc8b26d6ac414da537c0d5e7b02869--43e919f291e043afbb0d0680eac1176a a253e9c67440495fbb4057089f3256e8 b2fc8b26d6ac414da537c0d5e7b02869--a253e9c67440495fbb4057089f3256e8 ee14a8d7283e4f9dade4c176ecd73790 RX(theta\u2081\u2083) a253e9c67440495fbb4057089f3256e8--ee14a8d7283e4f9dade4c176ecd73790 2a91f8fe34804b8ca6a32f76f95f601c RY(theta\u2081\u2087) ee14a8d7283e4f9dade4c176ecd73790--2a91f8fe34804b8ca6a32f76f95f601c b5e24870c5c14762b9d39c3871c7c805 RX(theta\u2082\u2081) 2a91f8fe34804b8ca6a32f76f95f601c--b5e24870c5c14762b9d39c3871c7c805 24a52c25ec724a449e8ae7a5dc928664 X b5e24870c5c14762b9d39c3871c7c805--24a52c25ec724a449e8ae7a5dc928664 24a52c25ec724a449e8ae7a5dc928664--3dea7ac1b6ac418fa7b2f6258adddf4d ea75d78ffb19460893a952829b841f7e 24a52c25ec724a449e8ae7a5dc928664--ea75d78ffb19460893a952829b841f7e 27c7cfded54c49b1a8d25ae4ba1a00ae RX(theta\u2081) ea75d78ffb19460893a952829b841f7e--27c7cfded54c49b1a8d25ae4ba1a00ae 813eed0acd9f4ad8ad6629e21c09e0f0 RY(theta\u2085) 27c7cfded54c49b1a8d25ae4ba1a00ae--813eed0acd9f4ad8ad6629e21c09e0f0 c680a271d7d843d882c289a9711f4c3c RX(theta\u2089) 813eed0acd9f4ad8ad6629e21c09e0f0--c680a271d7d843d882c289a9711f4c3c 39ab5b299d384182bb089215b989c581 X c680a271d7d843d882c289a9711f4c3c--39ab5b299d384182bb089215b989c581 39ab5b299d384182bb089215b989c581--c52a200dcbf74449addcc97811ece2d5 1637aaea13fe41efa7aa1210354be52a 39ab5b299d384182bb089215b989c581--1637aaea13fe41efa7aa1210354be52a f14422ac94f048b081ea8dc193a69c76 RX(theta\u2081\u2083) 1637aaea13fe41efa7aa1210354be52a--f14422ac94f048b081ea8dc193a69c76 70ca449d45cc4e7391f66171068d8d2e RY(theta\u2081\u2087) f14422ac94f048b081ea8dc193a69c76--70ca449d45cc4e7391f66171068d8d2e 3c0c4114d81447758a05752ad3a32511 RX(theta\u2082\u2081) 70ca449d45cc4e7391f66171068d8d2e--3c0c4114d81447758a05752ad3a32511 0039561e5e46488da69db1e395aae25f X 3c0c4114d81447758a05752ad3a32511--0039561e5e46488da69db1e395aae25f 0039561e5e46488da69db1e395aae25f--2282b5fe147f4c2180faf6c23edaeb9d 7103960c862640938e5994d3f6697fbe 0039561e5e46488da69db1e395aae25f--7103960c862640938e5994d3f6697fbe 7103960c862640938e5994d3f6697fbe--3f151acbdb1846cd89e933d8876ebf34 054a2717c468498b93378e853147617d d6fc3033a382491082250ad4f80c4788 RX(theta\u2082) e36366ba610647b7b3f1553a28f3eb09--d6fc3033a382491082250ad4f80c4788 7c5939bf8ec149ee8194dbc1b4de10ac 3 0141da5233ae4636947260e7a6bcbfc1 RY(theta\u2086) d6fc3033a382491082250ad4f80c4788--0141da5233ae4636947260e7a6bcbfc1 7d6d87386c9e45a8bfaa740dc3bc247c RX(theta\u2081\u2080) 0141da5233ae4636947260e7a6bcbfc1--7d6d87386c9e45a8bfaa740dc3bc247c d5910c284081425cb3f7bfe4a0676258 7d6d87386c9e45a8bfaa740dc3bc247c--d5910c284081425cb3f7bfe4a0676258 07b7e44b41c84a9b93a611120744fc7e X d5910c284081425cb3f7bfe4a0676258--07b7e44b41c84a9b93a611120744fc7e 07b7e44b41c84a9b93a611120744fc7e--a253e9c67440495fbb4057089f3256e8 6c0b4f5441a74cd981d0c93b71ec8846 RX(theta\u2081\u2084) 07b7e44b41c84a9b93a611120744fc7e--6c0b4f5441a74cd981d0c93b71ec8846 06f8ac34cd284c7583ae9ccbee6719f3 RY(theta\u2081\u2088) 6c0b4f5441a74cd981d0c93b71ec8846--06f8ac34cd284c7583ae9ccbee6719f3 38fe9436d9134ee8a27dcc04d4fb3364 RX(theta\u2082\u2082) 06f8ac34cd284c7583ae9ccbee6719f3--38fe9436d9134ee8a27dcc04d4fb3364 ff70d34b751f4e72a52afdb4c3669fe5 38fe9436d9134ee8a27dcc04d4fb3364--ff70d34b751f4e72a52afdb4c3669fe5 3c23220f406f44c9a3535f7b9bcf2037 X ff70d34b751f4e72a52afdb4c3669fe5--3c23220f406f44c9a3535f7b9bcf2037 3c23220f406f44c9a3535f7b9bcf2037--ea75d78ffb19460893a952829b841f7e 1e8f4ad4a8714fd78112ffdba1db220a RX(theta\u2082) 3c23220f406f44c9a3535f7b9bcf2037--1e8f4ad4a8714fd78112ffdba1db220a f21fdb411a1042c5bea6bcb489743709 RY(theta\u2086) 1e8f4ad4a8714fd78112ffdba1db220a--f21fdb411a1042c5bea6bcb489743709 3fa81841aec14fd3a4a5786ab2757a06 RX(theta\u2081\u2080) f21fdb411a1042c5bea6bcb489743709--3fa81841aec14fd3a4a5786ab2757a06 cefcc5d981e5430bab11fb1ab5ce79b4 3fa81841aec14fd3a4a5786ab2757a06--cefcc5d981e5430bab11fb1ab5ce79b4 6505c394bc50418d91c266b30d35c53c X cefcc5d981e5430bab11fb1ab5ce79b4--6505c394bc50418d91c266b30d35c53c 6505c394bc50418d91c266b30d35c53c--1637aaea13fe41efa7aa1210354be52a 3d3da1c11dbe47389409043b54dc216f RX(theta\u2081\u2084) 6505c394bc50418d91c266b30d35c53c--3d3da1c11dbe47389409043b54dc216f 6e3ac85627854b9bbe95d75765c76874 RY(theta\u2081\u2088) 3d3da1c11dbe47389409043b54dc216f--6e3ac85627854b9bbe95d75765c76874 709afc515d9c423fb4d10597f0e35259 RX(theta\u2082\u2082) 6e3ac85627854b9bbe95d75765c76874--709afc515d9c423fb4d10597f0e35259 fa6f5acd06c54ae6b17a01bf75bff845 709afc515d9c423fb4d10597f0e35259--fa6f5acd06c54ae6b17a01bf75bff845 b15a43cacf4341a0a1bd6f6f08aa2453 X fa6f5acd06c54ae6b17a01bf75bff845--b15a43cacf4341a0a1bd6f6f08aa2453 b15a43cacf4341a0a1bd6f6f08aa2453--7103960c862640938e5994d3f6697fbe b15a43cacf4341a0a1bd6f6f08aa2453--054a2717c468498b93378e853147617d c400b2524f42401fae831d2296679d9f 358c07400aaa4d85908f428cb31f55e1 RX(theta\u2083) 7c5939bf8ec149ee8194dbc1b4de10ac--358c07400aaa4d85908f428cb31f55e1 79167e9724f043e7a92696448355bfba RY(theta\u2087) 358c07400aaa4d85908f428cb31f55e1--79167e9724f043e7a92696448355bfba d37129e819324d639b16457b5f5a5f74 RX(theta\u2081\u2081) 79167e9724f043e7a92696448355bfba--d37129e819324d639b16457b5f5a5f74 0103d093fe61465fa563c26d11b7e46e X d37129e819324d639b16457b5f5a5f74--0103d093fe61465fa563c26d11b7e46e 0103d093fe61465fa563c26d11b7e46e--d5910c284081425cb3f7bfe4a0676258 9a869006a5b04f4c9695c9394a152c9b 0103d093fe61465fa563c26d11b7e46e--9a869006a5b04f4c9695c9394a152c9b 935127bf9a2b4e91b5a56b9f23be4ed3 RX(theta\u2081\u2085) 9a869006a5b04f4c9695c9394a152c9b--935127bf9a2b4e91b5a56b9f23be4ed3 107c28a23c824366819e552e70b19161 RY(theta\u2081\u2089) 935127bf9a2b4e91b5a56b9f23be4ed3--107c28a23c824366819e552e70b19161 151b9fa472dc4262b79774b655b00634 RX(theta\u2082\u2083) 107c28a23c824366819e552e70b19161--151b9fa472dc4262b79774b655b00634 2c14c2457ebb404c97629d6602e2baf8 X 151b9fa472dc4262b79774b655b00634--2c14c2457ebb404c97629d6602e2baf8 2c14c2457ebb404c97629d6602e2baf8--ff70d34b751f4e72a52afdb4c3669fe5 426aa0f0ce6b411b8c86d55b18fc3bdb 2c14c2457ebb404c97629d6602e2baf8--426aa0f0ce6b411b8c86d55b18fc3bdb dc0f060b9cfd42c8b72ce4192162d2d5 RX(theta\u2083) 426aa0f0ce6b411b8c86d55b18fc3bdb--dc0f060b9cfd42c8b72ce4192162d2d5 6753303a41214cc686b306b42a5cd3ac RY(theta\u2087) dc0f060b9cfd42c8b72ce4192162d2d5--6753303a41214cc686b306b42a5cd3ac 37a1ca6e67174df080db65ec214bcb4b RX(theta\u2081\u2081) 6753303a41214cc686b306b42a5cd3ac--37a1ca6e67174df080db65ec214bcb4b c3dbe44ed0e7498a9c5eaf6207d12a32 X 37a1ca6e67174df080db65ec214bcb4b--c3dbe44ed0e7498a9c5eaf6207d12a32 c3dbe44ed0e7498a9c5eaf6207d12a32--cefcc5d981e5430bab11fb1ab5ce79b4 70cced3cfa9c436ea89b9be0c86b71bb c3dbe44ed0e7498a9c5eaf6207d12a32--70cced3cfa9c436ea89b9be0c86b71bb ee234c203e584d18a9dff92b53fe4f1e RX(theta\u2081\u2085) 70cced3cfa9c436ea89b9be0c86b71bb--ee234c203e584d18a9dff92b53fe4f1e 67f635cefac8422aaec7d9b6562d3aa7 RY(theta\u2081\u2089) ee234c203e584d18a9dff92b53fe4f1e--67f635cefac8422aaec7d9b6562d3aa7 ff1991b5f2ea4dea8f4af8bc43109320 RX(theta\u2082\u2083) 67f635cefac8422aaec7d9b6562d3aa7--ff1991b5f2ea4dea8f4af8bc43109320 6d36ee18785147eabba3082db508fcf8 X ff1991b5f2ea4dea8f4af8bc43109320--6d36ee18785147eabba3082db508fcf8 6d36ee18785147eabba3082db508fcf8--fa6f5acd06c54ae6b17a01bf75bff845 b4c234895c184b7daba61b803598c558 6d36ee18785147eabba3082db508fcf8--b4c234895c184b7daba61b803598c558 b4c234895c184b7daba61b803598c558--c400b2524f42401fae831d2296679d9f </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_826984297b934e4bab0e33b4e1816b1c HEA cluster_d8d1623e60d14913b9a3b95f8e9ce9ec HEA 3f1b285a55c3455ea6e85c7694f2d079 0 ae34925a920946589dfb60a67245f38c RX(p1\u2080) 3f1b285a55c3455ea6e85c7694f2d079--ae34925a920946589dfb60a67245f38c a7b0b8d79d43430895403f50a3df4f83 1 db642af5564a46b7a31c904901a232e4 RY(p1\u2084) ae34925a920946589dfb60a67245f38c--db642af5564a46b7a31c904901a232e4 845d3ff9840d454983cad12fa5b1f650 RX(p1\u2088) db642af5564a46b7a31c904901a232e4--845d3ff9840d454983cad12fa5b1f650 729efda83a6d4401a4cf839c738c6e32 845d3ff9840d454983cad12fa5b1f650--729efda83a6d4401a4cf839c738c6e32 9eafef5167da418db648fc36e3ae571b 729efda83a6d4401a4cf839c738c6e32--9eafef5167da418db648fc36e3ae571b e56c708139494fb9b825e7b37aedeadc RX(p1\u2081\u2082) 9eafef5167da418db648fc36e3ae571b--e56c708139494fb9b825e7b37aedeadc c83345e992d541ec967e60bd8b6afb22 RY(p1\u2081\u2086) e56c708139494fb9b825e7b37aedeadc--c83345e992d541ec967e60bd8b6afb22 711c95a525554683a8c9eafff5eace1b RX(p1\u2082\u2080) c83345e992d541ec967e60bd8b6afb22--711c95a525554683a8c9eafff5eace1b 3801bc3fece24ed88fee45b6e527e508 711c95a525554683a8c9eafff5eace1b--3801bc3fece24ed88fee45b6e527e508 9b355d2d8a784569a0bcf2710d56b92a 3801bc3fece24ed88fee45b6e527e508--9b355d2d8a784569a0bcf2710d56b92a 4191b9be222d4c73afaf3b6fe53d1bcb RX(p2\u2080) 9b355d2d8a784569a0bcf2710d56b92a--4191b9be222d4c73afaf3b6fe53d1bcb 756fea91d0df4bc8ac7a1ab61cd8eef9 RY(p2\u2084) 4191b9be222d4c73afaf3b6fe53d1bcb--756fea91d0df4bc8ac7a1ab61cd8eef9 67806026b49d460797e28cb05691cd80 RX(p2\u2088) 756fea91d0df4bc8ac7a1ab61cd8eef9--67806026b49d460797e28cb05691cd80 b7c50d31dd7a4f54be6e36a83790cdde 67806026b49d460797e28cb05691cd80--b7c50d31dd7a4f54be6e36a83790cdde 5367bc2908d14b459b5aa0f9e3592afd b7c50d31dd7a4f54be6e36a83790cdde--5367bc2908d14b459b5aa0f9e3592afd c37b64aaed51453ab3f1da7b5bf8e81a RX(p2\u2081\u2082) 5367bc2908d14b459b5aa0f9e3592afd--c37b64aaed51453ab3f1da7b5bf8e81a 826ac0b946ee46f49b2b9c2f998dfd79 RY(p2\u2081\u2086) c37b64aaed51453ab3f1da7b5bf8e81a--826ac0b946ee46f49b2b9c2f998dfd79 0a0aa339cb4e4b4697277fe353787a75 RX(p2\u2082\u2080) 826ac0b946ee46f49b2b9c2f998dfd79--0a0aa339cb4e4b4697277fe353787a75 431b5219513f48eb9bc471825678cf65 0a0aa339cb4e4b4697277fe353787a75--431b5219513f48eb9bc471825678cf65 a1ce1859992147298a14405ff081c751 431b5219513f48eb9bc471825678cf65--a1ce1859992147298a14405ff081c751 534899b4149b4b65a23bb4f5cff28ace a1ce1859992147298a14405ff081c751--534899b4149b4b65a23bb4f5cff28ace 3ab8979d6d004f2b9107673f2f7d8843 40bedc602e964efd84d93c4ea4adbb65 RX(p1\u2081) a7b0b8d79d43430895403f50a3df4f83--40bedc602e964efd84d93c4ea4adbb65 700ecd5724254d76b9721a3fd8890ce1 2 e7f27c9c5591416d953dae4eeacc092b RY(p1\u2085) 40bedc602e964efd84d93c4ea4adbb65--e7f27c9c5591416d953dae4eeacc092b c9f8eb02d3034e158b52e2a7c693c23f RX(p1\u2089) e7f27c9c5591416d953dae4eeacc092b--c9f8eb02d3034e158b52e2a7c693c23f 8f7c69567c7c4c9396f2a36a8c59f076 X c9f8eb02d3034e158b52e2a7c693c23f--8f7c69567c7c4c9396f2a36a8c59f076 8f7c69567c7c4c9396f2a36a8c59f076--729efda83a6d4401a4cf839c738c6e32 1b0f59fed3e3404087b07c41e554e44c 8f7c69567c7c4c9396f2a36a8c59f076--1b0f59fed3e3404087b07c41e554e44c 4a421208993a4b2bbe02c769a825bf77 RX(p1\u2081\u2083) 1b0f59fed3e3404087b07c41e554e44c--4a421208993a4b2bbe02c769a825bf77 188d906254c04b27bf87a3f364880049 RY(p1\u2081\u2087) 4a421208993a4b2bbe02c769a825bf77--188d906254c04b27bf87a3f364880049 6109731a793a45419c36c8a770a2f619 RX(p1\u2082\u2081) 188d906254c04b27bf87a3f364880049--6109731a793a45419c36c8a770a2f619 db008de2292d45139ebbc4e6ade411f4 X 6109731a793a45419c36c8a770a2f619--db008de2292d45139ebbc4e6ade411f4 db008de2292d45139ebbc4e6ade411f4--3801bc3fece24ed88fee45b6e527e508 4b797d05742943cba341dd5b96f842ad db008de2292d45139ebbc4e6ade411f4--4b797d05742943cba341dd5b96f842ad 1cc493f8a44e4c4c8c255ddebd5bb091 RX(p2\u2081) 4b797d05742943cba341dd5b96f842ad--1cc493f8a44e4c4c8c255ddebd5bb091 c2e83a19cedc45078901ed680f7c31de RY(p2\u2085) 1cc493f8a44e4c4c8c255ddebd5bb091--c2e83a19cedc45078901ed680f7c31de e4e4290944f64b51879488d794fac1c8 RX(p2\u2089) c2e83a19cedc45078901ed680f7c31de--e4e4290944f64b51879488d794fac1c8 9dbc598c37e447138da54a0c6e70d497 X e4e4290944f64b51879488d794fac1c8--9dbc598c37e447138da54a0c6e70d497 9dbc598c37e447138da54a0c6e70d497--b7c50d31dd7a4f54be6e36a83790cdde 04ecdb528857413c89180efe83c04aee 9dbc598c37e447138da54a0c6e70d497--04ecdb528857413c89180efe83c04aee ce4fb7cfed2048b2a2b7bdf7c60898ed RX(p2\u2081\u2083) 04ecdb528857413c89180efe83c04aee--ce4fb7cfed2048b2a2b7bdf7c60898ed 404c74181dc541f7a02a476526ea398b RY(p2\u2081\u2087) ce4fb7cfed2048b2a2b7bdf7c60898ed--404c74181dc541f7a02a476526ea398b a07fe77facee4489892eab25940939ed RX(p2\u2082\u2081) 404c74181dc541f7a02a476526ea398b--a07fe77facee4489892eab25940939ed a5961c9c09f94bf5aa3a089c2426b1a0 X a07fe77facee4489892eab25940939ed--a5961c9c09f94bf5aa3a089c2426b1a0 a5961c9c09f94bf5aa3a089c2426b1a0--431b5219513f48eb9bc471825678cf65 3d1039ca10c040bf85604b99696c6c5e a5961c9c09f94bf5aa3a089c2426b1a0--3d1039ca10c040bf85604b99696c6c5e 3d1039ca10c040bf85604b99696c6c5e--3ab8979d6d004f2b9107673f2f7d8843 860ffce8158b43fe88b35e07b4c0b005 6d69b63b507f4c65a368ef0334ae1dbd RX(p1\u2082) 700ecd5724254d76b9721a3fd8890ce1--6d69b63b507f4c65a368ef0334ae1dbd 327e3adb027d477bafd03d1c05a82f18 3 6789c7568234430db850c2bc0731b4fb RY(p1\u2086) 6d69b63b507f4c65a368ef0334ae1dbd--6789c7568234430db850c2bc0731b4fb bd5a731bba454032b6c7583f44561b04 RX(p1\u2081\u2080) 6789c7568234430db850c2bc0731b4fb--bd5a731bba454032b6c7583f44561b04 d32b3bfb76ba49b081c4bf29a3d78c2f bd5a731bba454032b6c7583f44561b04--d32b3bfb76ba49b081c4bf29a3d78c2f 7634d2892d5c42548c0c3dbeafd67b53 X d32b3bfb76ba49b081c4bf29a3d78c2f--7634d2892d5c42548c0c3dbeafd67b53 7634d2892d5c42548c0c3dbeafd67b53--1b0f59fed3e3404087b07c41e554e44c 240167f22f8440b39664b585d769dad0 RX(p1\u2081\u2084) 7634d2892d5c42548c0c3dbeafd67b53--240167f22f8440b39664b585d769dad0 52d6fb7b446b4a36a7f513e731fa6add RY(p1\u2081\u2088) 240167f22f8440b39664b585d769dad0--52d6fb7b446b4a36a7f513e731fa6add 330e7b14befa41d989be16c5b2e01bfb RX(p1\u2082\u2082) 52d6fb7b446b4a36a7f513e731fa6add--330e7b14befa41d989be16c5b2e01bfb 0afdfc9a168a4a86bc9f5066cd941fd8 330e7b14befa41d989be16c5b2e01bfb--0afdfc9a168a4a86bc9f5066cd941fd8 922bf0e94a6049fa8169e4dc51a453d3 X 0afdfc9a168a4a86bc9f5066cd941fd8--922bf0e94a6049fa8169e4dc51a453d3 922bf0e94a6049fa8169e4dc51a453d3--4b797d05742943cba341dd5b96f842ad f7f5943df4c14b8faf2011c912a189b1 RX(p2\u2082) 922bf0e94a6049fa8169e4dc51a453d3--f7f5943df4c14b8faf2011c912a189b1 f8d91a5b59df4726bf9163cf4a735638 RY(p2\u2086) f7f5943df4c14b8faf2011c912a189b1--f8d91a5b59df4726bf9163cf4a735638 49e81880809b4a7eaeff20ea7d373432 RX(p2\u2081\u2080) f8d91a5b59df4726bf9163cf4a735638--49e81880809b4a7eaeff20ea7d373432 4e6533596521480d99626a20215f89a5 49e81880809b4a7eaeff20ea7d373432--4e6533596521480d99626a20215f89a5 d4efbc01a6ff437a8af9121209501eea X 4e6533596521480d99626a20215f89a5--d4efbc01a6ff437a8af9121209501eea d4efbc01a6ff437a8af9121209501eea--04ecdb528857413c89180efe83c04aee 191dc81f3a5d4216bccae7c08726faeb RX(p2\u2081\u2084) d4efbc01a6ff437a8af9121209501eea--191dc81f3a5d4216bccae7c08726faeb 418909f0d1c9452a894aa71f79d4e489 RY(p2\u2081\u2088) 191dc81f3a5d4216bccae7c08726faeb--418909f0d1c9452a894aa71f79d4e489 a4dc5f7f6b844bb4845c85b3537f57c5 RX(p2\u2082\u2082) 418909f0d1c9452a894aa71f79d4e489--a4dc5f7f6b844bb4845c85b3537f57c5 0c3aee26700c45638834332edfcb35c4 a4dc5f7f6b844bb4845c85b3537f57c5--0c3aee26700c45638834332edfcb35c4 f65b0b1de96f4cfc84881a037a2237a9 X 0c3aee26700c45638834332edfcb35c4--f65b0b1de96f4cfc84881a037a2237a9 f65b0b1de96f4cfc84881a037a2237a9--3d1039ca10c040bf85604b99696c6c5e f65b0b1de96f4cfc84881a037a2237a9--860ffce8158b43fe88b35e07b4c0b005 8f53042945a94e18be0f09cd85904c0d a79230d518924a08a3bd33a67c25944d RX(p1\u2083) 327e3adb027d477bafd03d1c05a82f18--a79230d518924a08a3bd33a67c25944d c6501dbf6bae475399f6c9863b00a32c RY(p1\u2087) a79230d518924a08a3bd33a67c25944d--c6501dbf6bae475399f6c9863b00a32c 9370d5e59ebb4008a04f18b729577302 RX(p1\u2081\u2081) c6501dbf6bae475399f6c9863b00a32c--9370d5e59ebb4008a04f18b729577302 e58c7a4cfac3431898207ee9dc8dd719 X 9370d5e59ebb4008a04f18b729577302--e58c7a4cfac3431898207ee9dc8dd719 e58c7a4cfac3431898207ee9dc8dd719--d32b3bfb76ba49b081c4bf29a3d78c2f 95770df1701d45c7a144193fe7a51b04 e58c7a4cfac3431898207ee9dc8dd719--95770df1701d45c7a144193fe7a51b04 047f0071093940d2bc744a36124298cb RX(p1\u2081\u2085) 95770df1701d45c7a144193fe7a51b04--047f0071093940d2bc744a36124298cb dd2546cbc7fa479881247dcc410aa6d7 RY(p1\u2081\u2089) 047f0071093940d2bc744a36124298cb--dd2546cbc7fa479881247dcc410aa6d7 7690602144ee4aa98cfc529a859571d9 RX(p1\u2082\u2083) dd2546cbc7fa479881247dcc410aa6d7--7690602144ee4aa98cfc529a859571d9 26175596a04e436d935be321ed87581b X 7690602144ee4aa98cfc529a859571d9--26175596a04e436d935be321ed87581b 26175596a04e436d935be321ed87581b--0afdfc9a168a4a86bc9f5066cd941fd8 c998e1d19dc34c2080a0769beed2cdb0 26175596a04e436d935be321ed87581b--c998e1d19dc34c2080a0769beed2cdb0 3df4a145afbc42d9a8e8a7c6cf96781e RX(p2\u2083) c998e1d19dc34c2080a0769beed2cdb0--3df4a145afbc42d9a8e8a7c6cf96781e df2df968649444af84b3c2fd0faec61d RY(p2\u2087) 3df4a145afbc42d9a8e8a7c6cf96781e--df2df968649444af84b3c2fd0faec61d c7ec112de2df402095e71e47ee8899d5 RX(p2\u2081\u2081) df2df968649444af84b3c2fd0faec61d--c7ec112de2df402095e71e47ee8899d5 5def2c3a19f1483482b27efdfa6adb69 X c7ec112de2df402095e71e47ee8899d5--5def2c3a19f1483482b27efdfa6adb69 5def2c3a19f1483482b27efdfa6adb69--4e6533596521480d99626a20215f89a5 c4972266ea5e40579c3c7a472824c987 5def2c3a19f1483482b27efdfa6adb69--c4972266ea5e40579c3c7a472824c987 25763adf436f44f7a208198790bf8985 RX(p2\u2081\u2085) c4972266ea5e40579c3c7a472824c987--25763adf436f44f7a208198790bf8985 08d874ef805c4848af42b8f83ab1e411 RY(p2\u2081\u2089) 25763adf436f44f7a208198790bf8985--08d874ef805c4848af42b8f83ab1e411 c7d7a73353924dd29eac1dc039513613 RX(p2\u2082\u2083) 08d874ef805c4848af42b8f83ab1e411--c7d7a73353924dd29eac1dc039513613 66e47b17915c40c8878135614f4ed7d1 X c7d7a73353924dd29eac1dc039513613--66e47b17915c40c8878135614f4ed7d1 66e47b17915c40c8878135614f4ed7d1--0c3aee26700c45638834332edfcb35c4 510084a316b54a2da1747719dde6681f 66e47b17915c40c8878135614f4ed7d1--510084a316b54a2da1747719dde6681f 510084a316b54a2da1747719dde6681f--8f53042945a94e18be0f09cd85904c0d </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.8235])), ('theta_0', tensor([0.2038])), ('theta_1', tensor([0.7853])), ('theta_10', tensor([0.9408])), ('theta_11', tensor([0.4441])), ('theta_12', tensor([0.6926])), ('theta_13', tensor([0.3457])), ('theta_14', tensor([0.6128])), ('theta_15', tensor([0.6174])), ('theta_16', tensor([0.8657])), ('theta_17', tensor([0.8418])), ('theta_18', tensor([0.1063])), ('theta_19', tensor([0.6077])), ('theta_2', tensor([0.2668])), ('theta_20', tensor([0.8846])), ('theta_21', tensor([0.9668])), ('theta_22', tensor([0.2565])), ('theta_23', tensor([0.1043])), ('theta_3', tensor([0.5797])), ('theta_4', tensor([0.4227])), ('theta_5', tensor([0.6723])), ('theta_6', tensor([0.1476])), ('theta_7', tensor([0.6309])), ('theta_8', tensor([0.1834])), ('theta_9', tensor([0.8038]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.8225])), ('theta_0', tensor([0.2048])), ('theta_1', tensor([0.7863])), ('theta_10', tensor([0.9398])), ('theta_11', tensor([0.4451])), ('theta_12', tensor([0.6916])), ('theta_13', tensor([0.3467])), ('theta_14', tensor([0.6118])), ('theta_15', tensor([0.6184])), ('theta_16', tensor([0.8647])), ('theta_17', tensor([0.8408])), ('theta_18', tensor([0.1073])), ('theta_19', tensor([0.6067])), ('theta_2', tensor([0.2658])), ('theta_20', tensor([0.8836])), ('theta_21', tensor([0.9678])), ('theta_22', tensor([0.2555])), ('theta_23', tensor([0.1053])), ('theta_3', tensor([0.5787])), ('theta_4', tensor([0.4217])), ('theta_5', tensor([0.6713])), ('theta_6', tensor([0.1486])), ('theta_7', tensor([0.6319])), ('theta_8', tensor([0.1844])), ('theta_9', tensor([0.8028]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\nx = Parameter(\"x\")\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = QuantumCircuit(\n(operations): ModuleList(\n(0): QuantumCircuit(\n(operations): ModuleList(\n(0): RX(qubit_support=(0,))\n(1): RX(qubit_support=(1,))\n)\n)\n)\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 9.9905e-01+0.0000j,  0.0000e+00-0.0309j,  0.0000e+00-0.0309j,\n-9.5347e-04+0.0000j],\n[ 9.5148e-01+0.0000j,  0.0000e+00-0.2149j,  0.0000e+00-0.2149j,\n-4.8521e-02+0.0000j],\n[ 9.0139e-01+0.0000j,  0.0000e+00-0.2981j,  0.0000e+00-0.2981j,\n-9.8614e-02+0.0000j]])\nxs = [Counter({'00': 99, '10': 1}), Counter({'00': 84, '01': 8, '10': 8}), Counter({'00': 81, '10': 10, '01': 9})]\nex = tensor([[0.9981],\n[0.9030],\n[0.8028]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9981, 0.9981],\n[0.9030, 0.9030],\n[0.8028, 0.8028]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-11-21T16:26:36.385155 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\ngraph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\nreg = Register(graph)\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\nreg = Register.from_coordinates(\n[(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\nreg.draw(show=False)\n</code></pre> 2023-11-21T16:26:36.749443 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_edges</code> property for convencience:</p> <pre><code>print(reg.all_edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of Registers in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\nn_qubits = 4\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'01': 52, '00': 48})]\nSample in little endian = [Counter({'10': 51, '00': 49})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'10': 52, '00': 48})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nCNOT matrix in little endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\nOn PyQTorch = [Counter({'00': 87, '01': 13})]\nOn Braket = [Counter({'00': 87, '01': 13})]\nOn Pulser = [Counter({'00': 89, '01': 11})]\nSame wavefunction order:\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n# Check the normalization.\nassert is_normalized(state)\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\nstate = [0.58729291+0.j         0.        +0.04520839j 0.80572725+0.j\n0.        +0.06202294j]\nProduct state corresponding to bitstring '01':\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n# Let's now prepare a circuit.\nn_qubits = 4\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_a309924e874e4a51882a2a3c76cd3c62 Circuit block cluster_153faf85c16e47b98907d57b7e9cf033 Prep block 37749086c3624f6b8b88ef331da322d9 0 1bbcf20c30c54dc788b7e7ce1f36553f 37749086c3624f6b8b88ef331da322d9--1bbcf20c30c54dc788b7e7ce1f36553f 2c23699454ec481989b79fc60cfa3199 1 c0e193a641f548328ca6771f4698d7ea RX(theta\u2080) 1bbcf20c30c54dc788b7e7ce1f36553f--c0e193a641f548328ca6771f4698d7ea 27d4908deb5f403496c9fd37326eb2bb RY(theta\u2084) c0e193a641f548328ca6771f4698d7ea--27d4908deb5f403496c9fd37326eb2bb aaa0832408a14e7c8b2beb4ddbfe8e6d RX(theta\u2088) 27d4908deb5f403496c9fd37326eb2bb--aaa0832408a14e7c8b2beb4ddbfe8e6d 12bb8312f66d4bf082e762ed1250b8bb aaa0832408a14e7c8b2beb4ddbfe8e6d--12bb8312f66d4bf082e762ed1250b8bb c8761a5c38b44279a11a229b2f77795d 12bb8312f66d4bf082e762ed1250b8bb--c8761a5c38b44279a11a229b2f77795d a64d99e1e2dd48ff89d247321f0c55a5 RX(theta\u2081\u2082) c8761a5c38b44279a11a229b2f77795d--a64d99e1e2dd48ff89d247321f0c55a5 21a1a0280f1340dd9ea09e8b08c168e4 RY(theta\u2081\u2086) a64d99e1e2dd48ff89d247321f0c55a5--21a1a0280f1340dd9ea09e8b08c168e4 c711177803cf45488bfb7e4ea2658c58 RX(theta\u2082\u2080) 21a1a0280f1340dd9ea09e8b08c168e4--c711177803cf45488bfb7e4ea2658c58 9d560866f28a4a888c96325bbaaad82f c711177803cf45488bfb7e4ea2658c58--9d560866f28a4a888c96325bbaaad82f 3b94d68b194e497e84390e75773e8d89 9d560866f28a4a888c96325bbaaad82f--3b94d68b194e497e84390e75773e8d89 103075b3e92e4fabb860fdc8474bd52c 3b94d68b194e497e84390e75773e8d89--103075b3e92e4fabb860fdc8474bd52c 01cfcd17be50431c9995f8dc741210f4 5f225d2bf1ef4daba7220e1ee94e2c6c 2c23699454ec481989b79fc60cfa3199--5f225d2bf1ef4daba7220e1ee94e2c6c aa8b6e3636e143048d96c6885d5234d0 2 e59f8933a7514e27add0709f95ad37bb RX(theta\u2081) 5f225d2bf1ef4daba7220e1ee94e2c6c--e59f8933a7514e27add0709f95ad37bb eccf6a0e31084b468512864d7860817d RY(theta\u2085) e59f8933a7514e27add0709f95ad37bb--eccf6a0e31084b468512864d7860817d b0e40febbc2f4cc69b1045c5039e4857 RX(theta\u2089) eccf6a0e31084b468512864d7860817d--b0e40febbc2f4cc69b1045c5039e4857 1957443d32044ebcb7baae4beaad5520 X b0e40febbc2f4cc69b1045c5039e4857--1957443d32044ebcb7baae4beaad5520 1957443d32044ebcb7baae4beaad5520--12bb8312f66d4bf082e762ed1250b8bb 482aa206068d486f9439d313f28b545e 1957443d32044ebcb7baae4beaad5520--482aa206068d486f9439d313f28b545e acfb50a5a5214d678522bcee1a745163 RX(theta\u2081\u2083) 482aa206068d486f9439d313f28b545e--acfb50a5a5214d678522bcee1a745163 c1d2ca743fa847529dcb12f31d9bdcfd RY(theta\u2081\u2087) acfb50a5a5214d678522bcee1a745163--c1d2ca743fa847529dcb12f31d9bdcfd 1b9c7fb8abf249ad93fd741f4f52e8d2 RX(theta\u2082\u2081) c1d2ca743fa847529dcb12f31d9bdcfd--1b9c7fb8abf249ad93fd741f4f52e8d2 79f7eb61aac8421b9226764c1fad05b1 X 1b9c7fb8abf249ad93fd741f4f52e8d2--79f7eb61aac8421b9226764c1fad05b1 79f7eb61aac8421b9226764c1fad05b1--9d560866f28a4a888c96325bbaaad82f 282ac4a76711421babd30404f27252da 79f7eb61aac8421b9226764c1fad05b1--282ac4a76711421babd30404f27252da 282ac4a76711421babd30404f27252da--01cfcd17be50431c9995f8dc741210f4 0687b978f354459f9afb68d761bf41dc caaac81c892e49c8a8aa21d324427b6b aa8b6e3636e143048d96c6885d5234d0--caaac81c892e49c8a8aa21d324427b6b a6bc7d7b15c6416ebd0558d70b981332 3 613f65bad9ac45b0b6fc48cfbb5f998d RX(theta\u2082) caaac81c892e49c8a8aa21d324427b6b--613f65bad9ac45b0b6fc48cfbb5f998d 14b23220cd51499e833a1e885cc8f5bd RY(theta\u2086) 613f65bad9ac45b0b6fc48cfbb5f998d--14b23220cd51499e833a1e885cc8f5bd caa980504eb34d829846d8f9e1d38f9a RX(theta\u2081\u2080) 14b23220cd51499e833a1e885cc8f5bd--caa980504eb34d829846d8f9e1d38f9a 5096f8d50e1f40988bdc544a54d37ca3 caa980504eb34d829846d8f9e1d38f9a--5096f8d50e1f40988bdc544a54d37ca3 9a654c54775648188a946ba0fc9868cc X 5096f8d50e1f40988bdc544a54d37ca3--9a654c54775648188a946ba0fc9868cc 9a654c54775648188a946ba0fc9868cc--482aa206068d486f9439d313f28b545e 7950f071934340d08cc64283ae6a91bf RX(theta\u2081\u2084) 9a654c54775648188a946ba0fc9868cc--7950f071934340d08cc64283ae6a91bf 93e63d4990424f1c9b3db1135b3819cb RY(theta\u2081\u2088) 7950f071934340d08cc64283ae6a91bf--93e63d4990424f1c9b3db1135b3819cb 4d61d1ef333b4572b87bd143c29e91b4 RX(theta\u2082\u2082) 93e63d4990424f1c9b3db1135b3819cb--4d61d1ef333b4572b87bd143c29e91b4 7f73f20175f04b30afacc39f9336b9d6 4d61d1ef333b4572b87bd143c29e91b4--7f73f20175f04b30afacc39f9336b9d6 2e144c6b6d614781bbc98ee5c0d7036f X 7f73f20175f04b30afacc39f9336b9d6--2e144c6b6d614781bbc98ee5c0d7036f 2e144c6b6d614781bbc98ee5c0d7036f--282ac4a76711421babd30404f27252da 2e144c6b6d614781bbc98ee5c0d7036f--0687b978f354459f9afb68d761bf41dc a0ce6d818a084e88ac5aa822092fa93b 0706a99062d64115914d74742af5cdd2 X a6bc7d7b15c6416ebd0558d70b981332--0706a99062d64115914d74742af5cdd2 0d2688006a8443389014f32c639ad034 RX(theta\u2083) 0706a99062d64115914d74742af5cdd2--0d2688006a8443389014f32c639ad034 8569c30243244d728901a11043e01082 RY(theta\u2087) 0d2688006a8443389014f32c639ad034--8569c30243244d728901a11043e01082 fbae3d493b7241539c9003fa181e53e6 RX(theta\u2081\u2081) 8569c30243244d728901a11043e01082--fbae3d493b7241539c9003fa181e53e6 3da3cd6a706a4bf190342d67bf21078f X fbae3d493b7241539c9003fa181e53e6--3da3cd6a706a4bf190342d67bf21078f 3da3cd6a706a4bf190342d67bf21078f--5096f8d50e1f40988bdc544a54d37ca3 7d3d1a57b976455db859f799e1df4c79 3da3cd6a706a4bf190342d67bf21078f--7d3d1a57b976455db859f799e1df4c79 2453b3722b5e4deba2c0aafdec209902 RX(theta\u2081\u2085) 7d3d1a57b976455db859f799e1df4c79--2453b3722b5e4deba2c0aafdec209902 fc174861b71744aab7d994343493ca4e RY(theta\u2081\u2089) 2453b3722b5e4deba2c0aafdec209902--fc174861b71744aab7d994343493ca4e dedf12fb455d447eaeebcf3516179a2e RX(theta\u2082\u2083) fc174861b71744aab7d994343493ca4e--dedf12fb455d447eaeebcf3516179a2e de076c2e4b4f48b1a14b2a1df914ccf4 X dedf12fb455d447eaeebcf3516179a2e--de076c2e4b4f48b1a14b2a1df914ccf4 de076c2e4b4f48b1a14b2a1df914ccf4--7f73f20175f04b30afacc39f9336b9d6 010ff3bf92fb4a9ead8091d861f9ffc9 de076c2e4b4f48b1a14b2a1df914ccf4--010ff3bf92fb4a9ead8091d861f9ffc9 010ff3bf92fb4a9ead8091d861f9ffc9--a0ce6d818a084e88ac5aa822092fa93b  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\nn_qubits = 3\nbatch_size = 2\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = tensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j],\n[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j]])\nZero state = tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nRandom state = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = tensor([[-0.3367+0.1492j, -0.2387-0.4529j, -0.0397+0.1336j, -0.1125+0.5659j,\n-0.0703-0.0669j, -0.0778+0.2793j,  0.3534-0.1424j,  0.0682+0.0811j],\n[ 0.3436+0.2393j,  0.0505-0.0122j, -0.0484-0.1730j, -0.0440+0.2970j,\n0.3615+0.2362j,  0.2817-0.0456j,  0.2953+0.4642j, -0.2217+0.2824j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\nn_qubits = 3\nuniform_block = uniform_block(n_qubits)\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\nproduct_block = product_block(\"100\")\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 I(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\nn_qubits = 3\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}